# Comparing `tmp/stitch_n_split-0.1.1.tar.gz` & `tmp/stitch_n_split-0.1.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist\stitch_n_split-0.1.1.tar", last modified: Fri Oct  9 08:14:38 2020, max compression
+gzip compressed data, was "stitch_n_split-0.1.2.tar", last modified: Wed May 31 10:36:47 2023, max compression
```

## Comparing `stitch_n_split-0.1.1.tar` & `stitch_n_split-0.1.2.tar`

### file list

```diff
@@ -1,24 +1,25 @@
-drwxrwxrwx   0        0        0        0 2020-10-09 08:14:38.000000 stitch_n_split-0.1.1/
--rw-rw-rw-   0        0        0       19 2020-10-09 08:13:58.000000 stitch_n_split-0.1.1/CHANGES.txt
--rw-rw-rw-   0        0        0       78 2020-08-06 16:11:01.000000 stitch_n_split-0.1.1/MANIFEST.in
--rw-rw-rw-   0        0        0     9427 2020-10-09 08:14:38.000000 stitch_n_split-0.1.1/PKG-INFO
--rw-rw-rw-   0        0        0     7433 2020-10-09 08:13:29.000000 stitch_n_split-0.1.1/README.md
--rw-rw-rw-   0        0        0       86 2020-10-09 08:14:38.000000 stitch_n_split-0.1.1/setup.cfg
--rw-rw-rw-   0        0        0      875 2020-10-09 08:13:58.000000 stitch_n_split-0.1.1/setup.py
-drwxrwxrwx   0        0        0        0 2020-10-09 08:14:38.000000 stitch_n_split-0.1.1/stitch_n_split/
--rw-rw-rw-   0        0        0        0 2020-08-07 06:57:18.000000 stitch_n_split-0.1.1/stitch_n_split/__init__.py
--rw-rw-rw-   0        0        0     3433 2020-08-15 11:08:00.000000 stitch_n_split-0.1.1/stitch_n_split/geo_info.py
-drwxrwxrwx   0        0        0        0 2020-10-09 08:14:38.000000 stitch_n_split-0.1.1/stitch_n_split/split/
--rw-rw-rw-   0        0        0        0 2020-08-10 06:28:51.000000 stitch_n_split-0.1.1/stitch_n_split/split/__init__.py
--rw-rw-rw-   0        0        0     6476 2020-10-09 07:42:41.000000 stitch_n_split-0.1.1/stitch_n_split/split/images.py
--rw-rw-rw-   0        0        0    10244 2020-08-15 11:08:31.000000 stitch_n_split-0.1.1/stitch_n_split/split/mesh.py
-drwxrwxrwx   0        0        0        0 2020-10-09 08:14:38.000000 stitch_n_split-0.1.1/stitch_n_split/stitch/
--rw-rw-rw-   0        0        0        0 2020-08-10 06:29:26.000000 stitch_n_split-0.1.1/stitch_n_split/stitch/__init__.py
--rw-rw-rw-   0        0        0     3141 2020-10-09 07:42:41.000000 stitch_n_split-0.1.1/stitch_n_split/stitch/images.py
--rw-rw-rw-   0        0        0     1244 2020-08-10 12:29:01.000000 stitch_n_split-0.1.1/stitch_n_split/utility.py
-drwxrwxrwx   0        0        0        0 2020-10-09 08:14:38.000000 stitch_n_split-0.1.1/stitch_n_split.egg-info/
--rw-rw-rw-   0        0        0     9427 2020-10-09 08:14:38.000000 stitch_n_split-0.1.1/stitch_n_split.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0      480 2020-10-09 08:14:38.000000 stitch_n_split-0.1.1/stitch_n_split.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2020-10-09 08:14:38.000000 stitch_n_split-0.1.1/stitch_n_split.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       71 2020-10-09 08:14:38.000000 stitch_n_split-0.1.1/stitch_n_split.egg-info/requires.txt
--rw-rw-rw-   0        0        0       15 2020-10-09 08:14:38.000000 stitch_n_split-0.1.1/stitch_n_split.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 10:36:47.628136 stitch_n_split-0.1.2/
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/CHANGES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)       75 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     7747 2023-05-31 10:36:47.628136 stitch_n_split-0.1.2/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     7294 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)       79 2023-05-31 10:36:47.628136 stitch_n_split-0.1.2/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)      836 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 10:36:47.628136 stitch_n_split-0.1.2/stitch_n_split/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/stitch_n_split/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3329 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/stitch_n_split/geo_info.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 10:36:47.628136 stitch_n_split-0.1.2/stitch_n_split/split/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/stitch_n_split/split/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6292 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/stitch_n_split/split/images.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9943 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/stitch_n_split/split/mesh.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 10:36:47.628136 stitch_n_split-0.1.2/stitch_n_split/stitch/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/stitch_n_split/stitch/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3053 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/stitch_n_split/stitch/images.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1197 2023-05-31 10:36:30.000000 stitch_n_split-0.1.2/stitch_n_split/utility.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 10:36:47.628136 stitch_n_split-0.1.2/stitch_n_split.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     7747 2023-05-31 10:36:47.000000 stitch_n_split-0.1.2/stitch_n_split.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)      488 2023-05-31 10:36:47.000000 stitch_n_split-0.1.2/stitch_n_split.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-31 10:36:47.000000 stitch_n_split-0.1.2/stitch_n_split.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       63 2023-05-31 10:36:47.000000 stitch_n_split-0.1.2/stitch_n_split.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       15 2023-05-31 10:36:47.000000 stitch_n_split-0.1.2/stitch_n_split.egg-info/top_level.txt
```

### filetype from file(1)

```diff
@@ -1 +1 @@
-POSIX tar archive (GNU)
+POSIX tar archive
```

### Comparing `stitch_n_split-0.1.1/PKG-INFO` & `stitch_n_split-0.1.2/PKG-INFO`

 * *Files 21% similar despite different names*

```diff
@@ -1,590 +1,485 @@
 00000000: 4d65 7461 6461 7461 2d56 6572 7369 6f6e  Metadata-Version
-00000010: 3a20 322e 310d 0a4e 616d 653a 2073 7469  : 2.1..Name: sti
-00000020: 7463 685f 6e5f 7370 6c69 740d 0a56 6572  tch_n_split..Ver
-00000030: 7369 6f6e 3a20 302e 312e 310d 0a53 756d  sion: 0.1.1..Sum
-00000040: 6d61 7279 3a20 4c69 6272 6172 7920 666f  mary: Library fo
-00000050: 7220 7374 6974 6368 696e 6720 616e 6420  r stitching and 
-00000060: 7370 6c69 7469 6e67 0d0a 486f 6d65 2d70  spliting..Home-p
-00000070: 6167 653a 2055 4e4b 4e4f 574e 0d0a 4175  age: UNKNOWN..Au
-00000080: 7468 6f72 3a20 4675 7a61 696c 2050 616c  thor: Fuzail Pal
-00000090: 6e61 6b0d 0a41 7574 686f 722d 656d 6169  nak..Author-emai
-000000a0: 6c3a 2066 757a 6169 6c70 616c 6e61 6b40  l: fuzailpalnak@
-000000b0: 676d 6169 6c2e 636f 6d0d 0a4c 6963 656e  gmail.com..Licen
-000000c0: 7365 3a20 554e 4b4e 4f57 4e0d 0a44 6573  se: UNKNOWN..Des
-000000d0: 6372 6970 7469 6f6e 3a20 2320 7374 6974  cription: # stit
-000000e0: 6368 4e73 706c 6974 0d0a 2020 2020 2020  chNsplit..      
-000000f0: 2020 215b 4769 7448 7562 5d28 6874 7470    ![GitHub](http
-00000100: 733a 2f2f 696d 672e 7368 6965 6c64 732e  s://img.shields.
-00000110: 696f 2f67 6974 6875 622f 6c69 6365 6e73  io/github/licens
-00000120: 652f 6379 7068 6572 6963 732f 5368 6170  e/cypherics/Shap
-00000130: 654d 6572 6765 290d 0a20 2020 2020 2020  eMerge)..       
-00000140: 2021 5b50 7974 686f 6e5d 2868 7474 7073   ![Python](https
-00000150: 3a2f 2f69 6d67 2e73 6869 656c 6473 2e69  ://img.shields.i
-00000160: 6f2f 6261 6467 652f 7079 7468 6f6e 2d76  o/badge/python-v
-00000170: 332e 362b 2d62 6c75 652e 7376 6729 0d0a  3.6+-blue.svg)..
-00000180: 2020 2020 2020 2020 215b 436f 6e74 7269          ![Contri
-00000190: 6275 7469 6f6e 7320 7765 6c63 6f6d 655d  butions welcome]
-000001a0: 2868 7474 7073 3a2f 2f69 6d67 2e73 6869  (https://img.shi
-000001b0: 656c 6473 2e69 6f2f 6261 6467 652f 636f  elds.io/badge/co
-000001c0: 6e74 7269 6275 7469 6f6e 732d 7765 6c63  ntributions-welc
-000001d0: 6f6d 652d 6f72 616e 6765 2e73 7667 290d  ome-orange.svg).
-000001e0: 0a20 2020 2020 2020 200d 0a20 2020 2020  .        ..     
-000001f0: 2020 2041 2050 7974 686f 6e20 4c69 6272     A Python Libr
-00000200: 6172 7920 546f 2053 7469 7463 6820 416e  ary To Stitch An
-00000210: 6420 5370 6c69 7420 496d 6167 6573 2066  d Split Images f
-00000220: 6f72 2061 6e79 2064 696d 656e 7369 6f6e  or any dimension
-00000230: 2c20 636f 6d70 7574 696e 6720 6772 6964  , computing grid
-00000240: 2061 6e64 2077 696e 646f 7773 206f 7665   and windows ove
-00000250: 7220 7468 6520 7370 6563 6966 6965 6420  r the specified 
-00000260: 6469 6d65 6e73 696f 6e0d 0a20 2020 2020  dimension..     
-00000270: 2020 200d 0a20 2020 2020 2020 2023 2320     ..        ## 
-00000280: 496e 7374 616c 6c61 7469 6f6e 0d0a 2020  Installation..  
-00000290: 2020 2020 2020 2020 2020 0d0a 2020 2020            ..    
-000002a0: 2020 2020 2d20 496e 7374 616c 6c69 6e67      - Installing
-000002b0: 2072 6173 7465 7269 6f20 6465 7065 6e64   rasterio depend
-000002c0: 656e 6379 2075 7369 6e67 2063 6f6e 6461  ency using conda
-000002d0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000002e0: 2020 0d0a 2020 2020 2020 2020 2020 2020    ..            
-000002f0: 2020 2020 636f 6e64 6120 696e 7374 616c      conda instal
-00000300: 6c20 2d63 2063 6f6e 6461 2d66 6f72 6765  l -c conda-forge
-00000310: 2072 6173 7465 7269 6f0d 0a20 2020 2020   rasterio..     
-00000320: 2020 200d 0a20 2020 2020 2020 202d 2049     ..        - I
-00000330: 6e73 7461 6c6c 696e 6720 7261 7374 6572  nstalling raster
-00000340: 696f 2064 6570 656e 6465 6e63 7920 6672  io dependency fr
-00000350: 6f6d 205b 7069 705d 2868 7474 7073 3a2f  om [pip](https:/
-00000360: 2f72 6173 7465 7269 6f2e 7265 6164 7468  /rasterio.readth
-00000370: 6564 6f63 732e 696f 2f65 6e2f 6c61 7465  edocs.io/en/late
-00000380: 7374 2f69 6e73 7461 6c6c 6174 696f 6e2e  st/installation.
-00000390: 6874 6d6c 290d 0a20 2020 2020 2020 2020  html)..         
-000003a0: 2020 2020 2020 2020 0d0a 2020 2020 2020          ..      
-000003b0: 2020 2020 2020 2020 2020 2020 0d0a 2020              ..  
-000003c0: 2020 2020 2020 2020 2020 7069 7020 696e            pip in
-000003d0: 7374 616c 6c20 7374 6974 6368 5f6e 5f73  stall stitch_n_s
-000003e0: 706c 6974 0d0a 2020 2020 2020 2020 2020  plit..          
-000003f0: 2020 0d0a 2020 2020 2020 2020 2020 2020    ..            
-00000400: 0d0a 2020 2020 2020 2020 2323 2053 706c  ..        ## Spl
-00000410: 6974 0d0a 2020 2020 2020 2020 0d0a 2020  it..        ..  
-00000420: 2020 2020 2020 5370 6c69 7420 4f70 6572        Split Oper
-00000430: 6174 696f 6e20 6361 6e20 6265 2070 6572  ation can be per
-00000440: 666f 726d 6564 206f 6e20 7477 6f20 7365  formed on two se
-00000450: 7473 206f 6620 496d 6167 6572 792c 203c  ts of Imagery, <
-00000460: 623e 4765 6f20 5265 6665 7265 6e63 6564  b>Geo Referenced
-00000470: 3c2f 623e 2061 6e64 203c 623e 4e6f 6e20  </b> and <b>Non 
-00000480: 4765 6f20 5265 6665 7265 6e63 6564 3c2f  Geo Referenced</
-00000490: 623e 0d0a 2020 2020 2020 2020 5468 6520  b>..        The 
-000004a0: 5769 6e64 6f77 7320 666f 726d 6564 2066  Windows formed f
-000004b0: 6f72 2074 6865 2073 706c 6974 206f 7065  or the split ope
-000004c0: 7261 7469 6f6e 2061 7265 2061 646a 7573  ration are adjus
-000004d0: 7465 6420 6261 7365 6420 6f6e 2074 6865  ted based on the
-000004e0: 2073 706c 6974 5f73 697a 6520 616e 6420   split_size and 
-000004f0: 696d 675f 7369 7a65 2c20 7768 656e 6576  img_size, whenev
-00000500: 6572 200d 0a20 2020 2020 2020 203c 636f  er ..        <co
-00000510: 6465 3e69 6d67 5f73 697a 6525 7370 6c69  de>img_size%spli
-00000520: 745f 7369 7a65 2021 3d20 303c 2f63 6f64  t_size != 0</cod
-00000530: 653e 2069 7320 7472 7565 2c20 7468 6973  e> is true, this
-00000540: 2073 7567 6765 7374 7320 7468 6174 2074   suggests that t
-00000550: 6865 7265 2077 696c 6c20 6265 206f 7665  here will be ove
-00000560: 726c 6170 7069 6e67 2077 696e 646f 7773  rlapping windows
-00000570: 2e20 0d0a 2020 2020 2020 2020 4f76 6572  . ..        Over
-00000580: 6c61 7070 696e 6720 7769 6e64 6f77 7320  lapping windows 
-00000590: 6172 6520 6765 6e65 7261 7465 6420 6f6e  are generated on
-000005a0: 6c79 2077 6865 6e20 7265 7175 6972 6564  ly when required
-000005b0: 2e20 0d0a 2020 2020 2020 2020 0d0a 2020  . ..        ..  
-000005c0: 2020 2020 2020 3c74 6162 6c65 3e0d 0a20        <table>.. 
-000005d0: 2020 2020 2020 2020 203c 7472 3e0d 0a20           <tr>.. 
-000005e0: 2020 2020 2020 2020 2020 203c 7464 3e4f             <td>O
-000005f0: 7269 6769 6e61 6c20 496d 6167 653c 2f74  riginal Image</t
-00000600: 643e 0d0a 2020 2020 2020 2020 2020 2020  d>..            
-00000610: 203c 7464 3e49 6d61 6765 7320 4166 7465   <td>Images Afte
-00000620: 7220 5370 6c69 743c 2f74 643e 0d0a 2020  r Split</td>..  
-00000630: 2020 2020 2020 2020 3c2f 7472 3e0d 0a20          </tr>.. 
-00000640: 2020 2020 2020 2020 203c 7472 3e0d 0a20           <tr>.. 
-00000650: 2020 2020 2020 2020 2020 203c 7464 3e3c             <td><
-00000660: 696d 6720 7372 633d 2268 7474 7073 3a2f  img src="https:/
-00000670: 2f75 7365 722d 696d 6167 6573 2e67 6974  /user-images.git
-00000680: 6875 6275 7365 7263 6f6e 7465 6e74 2e63  hubusercontent.c
-00000690: 6f6d 2f32 3436 3635 3537 302f 3839 3738  om/24665570/8978
-000006a0: 3036 3239 2d37 3332 3536 6438 302d 6462  0629-73256d80-db
-000006b0: 3266 2d31 3165 612d 3964 6235 2d65 6535  2f-11ea-9db5-ee5
-000006c0: 3035 3733 6438 6336 642e 706e 6722 2077  0573d8c6d.png" w
-000006d0: 6964 7468 3d36 3030 2068 6569 6768 743d  idth=600 height=
-000006e0: 3230 303e 3c2f 7464 3e0d 0a20 2020 2020  200></td>..     
-000006f0: 2020 2020 2020 203c 7464 3e3c 696d 6720         <td><img 
-00000700: 7372 633d 2268 7474 7073 3a2f 2f75 7365  src="https://use
-00000710: 722d 696d 6167 6573 2e67 6974 6875 6275  r-images.githubu
-00000720: 7365 7263 6f6e 7465 6e74 2e63 6f6d 2f32  sercontent.com/2
-00000730: 3436 3635 3537 302f 3839 3738 3035 3534  4665570/89780554
-00000740: 2d34 3833 6231 3938 302d 6462 3266 2d31  -483b1980-db2f-1
-00000750: 3165 612d 3838 3330 2d64 3133 6337 3238  1ea-8830-d13c728
-00000760: 6561 6463 642e 706e 6722 2077 6964 7468  eadcd.png" width
-00000770: 3d32 3030 3020 6865 6967 6874 3d32 3030  =2000 height=200
-00000780: 3e3c 2f74 643e 0d0a 2020 2020 2020 2020  ></td>..        
-00000790: 2020 3c2f 7472 3e0d 0a20 2020 2020 2020    </tr>..       
-000007a0: 2020 3c2f 7461 626c 653e 0d0a 2020 2020    </table>..    
-000007b0: 2020 2020 200d 0a20 2020 2020 2020 202d       ..        -
-000007c0: 2023 2323 2323 2047 656f 2052 6566 6572   ##### Geo Refer
-000007d0: 656e 6365 640d 0a20 2020 2020 2020 2020  enced..         
-000007e0: 2020 2047 656f 5265 6665 7265 6e63 6564     GeoReferenced
-000007f0: 2049 6d61 6765 7279 2068 6176 6520 7265   Imagery have re
-00000800: 6665 7265 6e63 6520 636f 6f72 6469 6e61  ference coordina
-00000810: 7465 2069 6e66 6f72 6d61 7469 6f6e 2073  te information s
-00000820: 746f 7265 6420 696e 2074 6865 6d2e 0d0a  tored in them...
-00000830: 2020 2020 2020 2020 5468 6973 2069 7320          This is 
-00000840: 7461 6b65 6e20 696e 746f 2061 6363 6f75  taken into accou
-00000850: 6e74 2077 6869 6c65 2073 706c 6974 7469  nt while splitti
-00000860: 6e67 2067 656f 2072 6566 6572 656e 6365  ng geo reference
-00000870: 6420 696d 6167 6572 792c 2061 7373 6967  d imagery, assig
-00000880: 6e69 6e67 2063 6f72 7265 6374 2072 6566  ning correct ref
+00000010: 3a20 322e 310a 4e61 6d65 3a20 7374 6974  : 2.1.Name: stit
+00000020: 6368 5f6e 5f73 706c 6974 0a56 6572 7369  ch_n_split.Versi
+00000030: 6f6e 3a20 302e 312e 320a 5375 6d6d 6172  on: 0.1.2.Summar
+00000040: 793a 204c 6962 7261 7279 2066 6f72 2073  y: Library for s
+00000050: 7469 7463 6869 6e67 2061 6e64 2073 706c  titching and spl
+00000060: 6974 696e 670a 4175 7468 6f72 3a20 4675  iting.Author: Fu
+00000070: 7a61 696c 2050 616c 6e61 6b0a 4175 7468  zail Palnak.Auth
+00000080: 6f72 2d65 6d61 696c 3a20 6675 7a61 696c  or-email: fuzail
+00000090: 7061 6c6e 616b 4067 6d61 696c 2e63 6f6d  palnak@gmail.com
+000000a0: 0a4b 6579 776f 7264 733a 2047 4953 2052  .Keywords: GIS R
+000000b0: 6173 7465 7269 6f20 5374 6963 7468 2053  asterio Sticth S
+000000c0: 706c 6974 204d 6573 6820 4772 6964 2047  plit Mesh Grid G
+000000d0: 656f 2052 6566 6572 656e 6365 0a43 6c61  eo Reference.Cla
+000000e0: 7373 6966 6965 723a 2050 726f 6772 616d  ssifier: Program
+000000f0: 6d69 6e67 204c 616e 6775 6167 6520 3a3a  ming Language ::
+00000100: 2050 7974 686f 6e20 3a3a 2033 0a43 6c61   Python :: 3.Cla
+00000110: 7373 6966 6965 723a 204c 6963 656e 7365  ssifier: License
+00000120: 203a 3a20 4f53 4920 4170 7072 6f76 6564   :: OSI Approved
+00000130: 203a 3a20 4d49 5420 4c69 6365 6e73 650a   :: MIT License.
+00000140: 436c 6173 7369 6669 6572 3a20 4f70 6572  Classifier: Oper
+00000150: 6174 696e 6720 5379 7374 656d 203a 3a20  ating System :: 
+00000160: 4f53 2049 6e64 6570 656e 6465 6e74 0a52  OS Independent.R
+00000170: 6571 7569 7265 732d 5079 7468 6f6e 3a20  equires-Python: 
+00000180: 7e3d 332e 330a 4465 7363 7269 7074 696f  ~=3.3.Descriptio
+00000190: 6e2d 436f 6e74 656e 742d 5479 7065 3a20  n-Content-Type: 
+000001a0: 7465 7874 2f6d 6172 6b64 6f77 6e0a 4c69  text/markdown.Li
+000001b0: 6365 6e73 652d 4669 6c65 3a20 4c49 4345  cense-File: LICE
+000001c0: 4e53 450a 0a23 2073 7469 7463 684e 7370  NSE..# stitchNsp
+000001d0: 6c69 740a 215b 4769 7448 7562 5d28 6874  lit.![GitHub](ht
+000001e0: 7470 733a 2f2f 696d 672e 7368 6965 6c64  tps://img.shield
+000001f0: 732e 696f 2f67 6974 6875 622f 6c69 6365  s.io/github/lice
+00000200: 6e73 652f 6379 7068 6572 6963 732f 5368  nse/cypherics/Sh
+00000210: 6170 654d 6572 6765 290a 215b 5079 7468  apeMerge).![Pyth
+00000220: 6f6e 5d28 6874 7470 733a 2f2f 696d 672e  on](https://img.
+00000230: 7368 6965 6c64 732e 696f 2f62 6164 6765  shields.io/badge
+00000240: 2f70 7974 686f 6e2d 7633 2e36 2b2d 626c  /python-v3.6+-bl
+00000250: 7565 2e73 7667 290a 215b 436f 6e74 7269  ue.svg).![Contri
+00000260: 6275 7469 6f6e 7320 7765 6c63 6f6d 655d  butions welcome]
+00000270: 2868 7474 7073 3a2f 2f69 6d67 2e73 6869  (https://img.shi
+00000280: 656c 6473 2e69 6f2f 6261 6467 652f 636f  elds.io/badge/co
+00000290: 6e74 7269 6275 7469 6f6e 732d 7765 6c63  ntributions-welc
+000002a0: 6f6d 652d 6f72 616e 6765 2e73 7667 290a  ome-orange.svg).
+000002b0: 215b 446f 776e 6c6f 6164 735d 2868 7474  ![Downloads](htt
+000002c0: 7073 3a2f 2f70 6570 792e 7465 6368 2f62  ps://pepy.tech/b
+000002d0: 6164 6765 2f73 7469 7463 682d 6e2d 7370  adge/stitch-n-sp
+000002e0: 6c69 7429 0a0a 4120 5079 7468 6f6e 204c  lit)..A Python L
+000002f0: 6962 7261 7279 2054 6f20 5374 6974 6368  ibrary To Stitch
+00000300: 2041 6e64 2053 706c 6974 2049 6d61 6765   And Split Image
+00000310: 7320 666f 7220 616e 7920 6469 6d65 6e73  s for any dimens
+00000320: 696f 6e2c 2063 6f6d 7075 7469 6e67 2067  ion, computing g
+00000330: 7269 6420 616e 6420 7769 6e64 6f77 7320  rid and windows 
+00000340: 6f76 6572 2074 6865 2073 7065 6369 6669  over the specifi
+00000350: 6564 2064 696d 656e 7369 6f6e 0a0a 2323  ed dimension..##
+00000360: 2049 6e73 7461 6c6c 6174 696f 6e0a 0a20   Installation.. 
+00000370: 2020 2070 6970 2069 6e73 7461 6c6c 2073     pip install s
+00000380: 7469 7463 682d 6e2d 7370 6c69 740a 2020  titch-n-split.  
+00000390: 2020 0a20 2020 200a 2d20 496e 7374 616c    .    .- Instal
+000003a0: 6c69 6e67 2072 6173 7465 7269 6f20 6465  ling rasterio de
+000003b0: 7065 6e64 656e 6379 2075 7369 6e67 2063  pendency using c
+000003c0: 6f6e 6461 0a20 2020 2020 2020 200a 2020  onda.        .  
+000003d0: 2020 2020 2020 636f 6e64 6120 696e 7374        conda inst
+000003e0: 616c 6c20 2d63 2063 6f6e 6461 2d66 6f72  all -c conda-for
+000003f0: 6765 2072 6173 7465 7269 6f0a 0a2d 2049  ge rasterio..- I
+00000400: 6e73 7461 6c6c 696e 6720 7261 7374 6572  nstalling raster
+00000410: 696f 2064 6570 656e 6465 6e63 7920 6672  io dependency fr
+00000420: 6f6d 205b 7069 705d 2868 7474 7073 3a2f  om [pip](https:/
+00000430: 2f72 6173 7465 7269 6f2e 7265 6164 7468  /rasterio.readth
+00000440: 6564 6f63 732e 696f 2f65 6e2f 6c61 7465  edocs.io/en/late
+00000450: 7374 2f69 6e73 7461 6c6c 6174 696f 6e2e  st/installation.
+00000460: 6874 6d6c 290a 2020 2020 2020 2020 2020  html).          
+00000470: 2020 0a20 2020 200a 2323 2053 706c 6974    .    .## Split
+00000480: 0a0a 5370 6c69 7420 4f70 6572 6174 696f  ..Split Operatio
+00000490: 6e20 6361 6e20 6265 2070 6572 666f 726d  n can be perform
+000004a0: 6564 206f 6e20 7477 6f20 7365 7473 206f  ed on two sets o
+000004b0: 6620 496d 6167 6572 792c 203c 623e 4765  f Imagery, <b>Ge
+000004c0: 6f20 5265 6665 7265 6e63 6564 3c2f 623e  o Referenced</b>
+000004d0: 2061 6e64 203c 623e 4e6f 6e20 4765 6f20   and <b>Non Geo 
+000004e0: 5265 6665 7265 6e63 6564 3c2f 623e 0a54  Referenced</b>.T
+000004f0: 6865 2057 696e 646f 7773 2066 6f72 6d65  he Windows forme
+00000500: 6420 666f 7220 7468 6520 7370 6c69 7420  d for the split 
+00000510: 6f70 6572 6174 696f 6e20 6172 6520 6164  operation are ad
+00000520: 6a75 7374 6564 2062 6173 6564 206f 6e20  justed based on 
+00000530: 7468 6520 7370 6c69 745f 7369 7a65 2061  the split_size a
+00000540: 6e64 2069 6d67 5f73 697a 652c 2077 6865  nd img_size, whe
+00000550: 6e65 7665 7220 0a3c 636f 6465 3e69 6d67  never .<code>img
+00000560: 5f73 697a 6525 7370 6c69 745f 7369 7a65  _size%split_size
+00000570: 2021 3d20 303c 2f63 6f64 653e 2069 7320   != 0</code> is 
+00000580: 7472 7565 2c20 7468 6973 2073 7567 6765  true, this sugge
+00000590: 7374 7320 7468 6174 2074 6865 7265 2077  sts that there w
+000005a0: 696c 6c20 6265 206f 7665 726c 6170 7069  ill be overlappi
+000005b0: 6e67 2077 696e 646f 7773 2e20 0a4f 7665  ng windows. .Ove
+000005c0: 726c 6170 7069 6e67 2077 696e 646f 7773  rlapping windows
+000005d0: 2061 7265 2067 656e 6572 6174 6564 206f   are generated o
+000005e0: 6e6c 7920 7768 656e 2072 6571 7569 7265  nly when require
+000005f0: 642e 200a 0a3c 7461 626c 653e 0a20 203c  d. ..<table>.  <
+00000600: 7472 3e0a 2020 2020 3c74 643e 4f72 6967  tr>.    <td>Orig
+00000610: 696e 616c 2049 6d61 6765 3c2f 7464 3e0a  inal Image</td>.
+00000620: 2020 2020 203c 7464 3e49 6d61 6765 7320       <td>Images 
+00000630: 4166 7465 7220 5370 6c69 743c 2f74 643e  After Split</td>
+00000640: 0a20 203c 2f74 723e 0a20 203c 7472 3e0a  .  </tr>.  <tr>.
+00000650: 2020 2020 3c74 643e 3c69 6d67 2073 7263      <td><img src
+00000660: 3d22 6874 7470 733a 2f2f 7573 6572 2d69  ="https://user-i
+00000670: 6d61 6765 732e 6769 7468 7562 7573 6572  mages.githubuser
+00000680: 636f 6e74 656e 742e 636f 6d2f 3234 3636  content.com/2466
+00000690: 3535 3730 2f38 3937 3830 3632 392d 3733  5570/89780629-73
+000006a0: 3235 3664 3830 2d64 6232 662d 3131 6561  256d80-db2f-11ea
+000006b0: 2d39 6462 352d 6565 3530 3537 3364 3863  -9db5-ee50573d8c
+000006c0: 3664 2e70 6e67 2220 7769 6474 683d 3630  6d.png" width=60
+000006d0: 3020 6865 6967 6874 3d32 3030 3e3c 2f74  0 height=200></t
+000006e0: 643e 0a20 2020 203c 7464 3e3c 696d 6720  d>.    <td><img 
+000006f0: 7372 633d 2268 7474 7073 3a2f 2f75 7365  src="https://use
+00000700: 722d 696d 6167 6573 2e67 6974 6875 6275  r-images.githubu
+00000710: 7365 7263 6f6e 7465 6e74 2e63 6f6d 2f32  sercontent.com/2
+00000720: 3436 3635 3537 302f 3839 3738 3035 3534  4665570/89780554
+00000730: 2d34 3833 6231 3938 302d 6462 3266 2d31  -483b1980-db2f-1
+00000740: 3165 612d 3838 3330 2d64 3133 6337 3238  1ea-8830-d13c728
+00000750: 6561 6463 642e 706e 6722 2077 6964 7468  eadcd.png" width
+00000760: 3d32 3030 3020 6865 6967 6874 3d32 3030  =2000 height=200
+00000770: 3e3c 2f74 643e 0a20 203c 2f74 723e 0a20  ></td>.  </tr>. 
+00000780: 3c2f 7461 626c 653e 0a20 0a2d 2023 2323  </table>. .- ###
+00000790: 2323 2047 656f 2052 6566 6572 656e 6365  ## Geo Reference
+000007a0: 640a 2020 2020 4765 6f52 6566 6572 656e  d.    GeoReferen
+000007b0: 6365 6420 496d 6167 6572 7920 6861 7665  ced Imagery have
+000007c0: 2072 6566 6572 656e 6365 2063 6f6f 7264   reference coord
+000007d0: 696e 6174 6520 696e 666f 726d 6174 696f  inate informatio
+000007e0: 6e20 7374 6f72 6564 2069 6e20 7468 656d  n stored in them
+000007f0: 2e0a 5468 6973 2069 7320 7461 6b65 6e20  ..This is taken 
+00000800: 696e 746f 2061 6363 6f75 6e74 2077 6869  into account whi
+00000810: 6c65 2073 706c 6974 7469 6e67 2067 656f  le splitting geo
+00000820: 2072 6566 6572 656e 6365 6420 696d 6167   referenced imag
+00000830: 6572 792c 2061 7373 6967 6e69 6e67 2063  ery, assigning c
+00000840: 6f72 7265 6374 2072 6566 6572 656e 6365  orrect reference
+00000850: 2069 6e66 6f72 6d61 7469 6f6e 2074 6f20   information to 
+00000860: 7468 6520 6375 7420 696d 6167 6573 2c0a  the cut images,.
+00000870: 7468 7573 2070 7265 7365 7276 696e 6720  thus preserving 
+00000880: 7468 6520 6f76 6572 2061 6c6c 2072 6566  the over all ref
 00000890: 6572 656e 6365 2069 6e66 6f72 6d61 7469  erence informati
-000008a0: 6f6e 2074 6f20 7468 6520 6375 7420 696d  on to the cut im
-000008b0: 6167 6573 2c0d 0a20 2020 2020 2020 2074  ages,..        t
-000008c0: 6875 7320 7072 6573 6572 7669 6e67 2074  hus preserving t
-000008d0: 6865 206f 7665 7220 616c 6c20 7265 6665  he over all refe
-000008e0: 7265 6e63 6520 696e 666f 726d 6174 696f  rence informatio
-000008f0: 6e20 0d0a 2020 2020 2020 2020 2020 2020  n ..            
-00000900: 3e20 4765 6f20 5265 6665 7265 6e63 6520  > Geo Reference 
-00000910: 696d 6167 6572 7920 6d75 7374 2062 6520  imagery must be 
-00000920: 6f66 205b 7469 6666 5d28 6874 7470 733a  of [tiff](https:
-00000930: 2f2f 656e 2e77 696b 6970 6564 6961 2e6f  //en.wikipedia.o
-00000940: 7267 2f77 696b 692f 5449 4646 2920 666f  rg/wiki/TIFF) fo
-00000950: 726d 6174 2e0d 0a20 2020 2020 2020 200d  rmat...        .
-00000960: 0a20 2020 2020 2020 202d 2023 2323 2323  .        - #####
-00000970: 204e 6f6e 2047 656f 5265 6665 7265 6e63   Non GeoReferenc
-00000980: 6564 200d 0a20 2020 2020 2020 2020 2020  ed ..           
-00000990: 2046 6f72 204e 6f6e 2047 656f 5265 6665   For Non GeoRefe
-000009a0: 7265 6e63 6564 2074 6865 2073 706c 6974  renced the split
-000009b0: 2069 7320 7374 7261 6967 6874 2066 6f72   is straight for
-000009c0: 7761 7264 2c20 6974 2067 6574 7320 6372  ward, it gets cr
-000009d0: 6f70 7065 6420 696e 2074 6f20 7370 6563  opped in to spec
-000009e0: 6966 6965 6420 6469 6d65 6e73 696f 6e0d  ified dimension.
-000009f0: 0a20 2020 2020 2020 200d 0a20 2020 2020  .        ..     
-00000a00: 2020 202a 5f53 706c 6974 2045 6e74 6972     *_Split Entir
-00000a10: 6520 4469 7265 6374 6f72 795f 3a2a 0d0a  e Directory_:*..
-00000a20: 2020 2020 2020 2020 6060 6070 7974 686f          ```pytho
-00000a30: 6e0d 0a20 2020 2020 2020 2066 726f 6d20  n..        from 
-00000a40: 7374 6974 6368 5f6e 5f73 706c 6974 2e73  stitch_n_split.s
-00000a50: 706c 6974 2e69 6d61 6765 7320 696d 706f  plit.images impo
-00000a60: 7274 2053 706c 6974 4765 6f0d 0a20 2020  rt SplitGeo..   
-00000a70: 2020 2020 2073 706c 6974 203d 2053 706c       split = Spl
-00000a80: 6974 4765 6f28 7370 6c69 745f 7369 7a65  itGeo(split_size
-00000a90: 3d28 3132 342c 2032 3637 292c 2069 6d67  =(124, 267), img
-00000aa0: 5f73 697a 653d 2835 3132 2c20 3531 3229  _size=(512, 512)
-00000ab0: 290d 0a20 2020 2020 2020 2073 706c 6974  )..        split
-00000ac0: 2e70 6572 666f 726d 5f64 6972 6563 746f  .perform_directo
-00000ad0: 7279 5f73 706c 6974 2822 6469 725f 7061  ry_split("dir_pa
-00000ae0: 7468 2229 0d0a 2020 2020 2020 2020 6060  th")..        ``
-00000af0: 600d 0a20 2020 2020 2020 2050 6572 666f  `..        Perfo
-00000b00: 726d 696e 6720 5370 6c69 7420 6f76 6572  rming Split over
-00000b10: 2069 6e64 6976 6964 7561 6c20 696d 6167   individual imag
-00000b20: 6573 2063 616e 2062 6520 646f 6e65 2062  es can be done b
-00000b30: 7920 6163 6365 7373 696e 6720 7370 6c69  y accessing spli
-00000b40: 7420 6173 2061 6e20 6974 6572 6174 6f72  t as an iterator
-00000b50: 2e0d 0a20 2020 2020 2020 200d 0a20 2020  ...        ..   
-00000b60: 2020 2020 202a 5f53 706c 6974 2049 7465       *_Split Ite
-00000b70: 7261 746f 7220 7573 696e 6720 7769 6e64  rator using wind
-00000b80: 6f77 5f3a 2a0d 0a20 2020 2020 2020 2060  ow_:*..        `
-00000b90: 6060 7079 7468 6f6e 0d0a 2020 2020 2020  ``python..      
-00000ba0: 2020 6672 6f6d 2073 7469 7463 685f 6e5f    from stitch_n_
-00000bb0: 7370 6c69 742e 7370 6c69 742e 696d 6167  split.split.imag
-00000bc0: 6573 2069 6d70 6f72 7420 5370 6c69 7447  es import SplitG
-00000bd0: 656f 0d0a 2020 2020 2020 2020 6672 6f6d  eo..        from
-00000be0: 2073 7469 7463 685f 6e5f 7370 6c69 742e   stitch_n_split.
-00000bf0: 7574 696c 6974 7920 696d 706f 7274 206f  utility import o
-00000c00: 7065 6e5f 696d 6167 650d 0a20 2020 2020  pen_image..     
-00000c10: 2020 200d 0a20 2020 2020 2020 2073 706c     ..        spl
-00000c20: 6974 203d 2053 706c 6974 4765 6f28 7370  it = SplitGeo(sp
-00000c30: 6c69 745f 7369 7a65 3d28 3132 342c 2032  lit_size=(124, 2
-00000c40: 3637 292c 2069 6d67 5f73 697a 653d 2835  67), img_size=(5
-00000c50: 3132 2c20 3531 3229 290d 0a20 2020 2020  12, 512))..     
-00000c60: 2020 2069 6d61 6765 203d 206f 7065 6e5f     image = open_
-00000c70: 696d 6167 6528 2269 6d67 5f70 6174 6822  image("img_path"
-00000c80: 2c20 6973 5f67 656f 5f72 6566 6572 656e  , is_geo_referen
-00000c90: 6365 3d54 7275 6529 0d0a 2020 2020 2020  ce=True)..      
-00000ca0: 2020 666f 7220 7769 6e5f 6e75 6d62 6572    for win_number
-00000cb0: 2c20 7769 6e64 6f77 2069 6e20 7370 6c69  , window in spli
-00000cc0: 743a 0d0a 2020 2020 2020 2020 2020 2020  t:..            
-00000cd0: 7370 6c69 745f 696d 6167 6520 3d20 7370  split_image = sp
-00000ce0: 6c69 742e 7769 6e64 6f77 5f73 706c 6974  lit.window_split
-00000cf0: 2869 6d61 6765 2c20 7769 6e64 6f77 290d  (image, window).
-00000d00: 0a20 2020 2020 2020 2020 2020 2023 2070  .            # p
-00000d10: 6572 666f 726d 206f 7065 7261 7469 6f6e  erform operation
-00000d20: 202e 2e2e 2e0d 0a20 2020 2020 2020 2060   ......        `
-00000d30: 6060 0d0a 2020 2020 2020 2020 0d0a 2020  ``..        ..  
-00000d40: 2020 2020 2020 2323 2053 7469 7463 6820        ## Stitch 
-00000d50: 0d0a 2020 2020 2020 2020 0d0a 2020 2020  ..        ..    
-00000d60: 2020 2020 5768 696c 6520 5065 7266 6f72      While Perfor
-00000d70: 6d69 6e67 2053 7469 7463 6820 6966 2074  ming Stitch if t
-00000d80: 6865 7265 2061 7265 2061 6e79 206f 7665  here are any ove
-00000d90: 726c 6170 7069 6e67 2077 696e 646f 772c  rlapping window,
-00000da0: 2074 686f 7365 2077 696e 646f 7773 2061   those windows a
-00000db0: 7265 206d 6572 6765 6420 7365 616d 6c65  re merged seamle
-00000dc0: 7373 6c79 2c20 7769 7468 6f75 740d 0a20  ssly, without.. 
-00000dd0: 2020 2020 2020 2068 616d 7065 7269 6e67         hampering
-00000de0: 2074 6865 2070 6978 656c 2069 6e66 6f72   the pixel infor
-00000df0: 6d61 7469 6f6e 2061 6e64 2069 6d61 6765  mation and image
-00000e00: 2064 696d 656e 7369 6f6e 0d0a 2020 2020   dimension..    
-00000e10: 2020 2020 0d0a 2020 2020 2020 2020 4576      ..        Ev
-00000e20: 6572 7920 5370 6c69 7420 696d 6167 6520  ery Split image 
-00000e30: 6361 6e20 6265 2061 7373 6f63 6961 7465  can be associate
-00000e40: 6420 746f 2074 6865 206f 7269 6769 6e61  d to the origina
-00000e50: 6c20 696d 6167 6520 6279 2074 6865 202a  l image by the *
-00000e60: 7769 6e64 6f77 206e 756d 6265 722a 206f  window number* o
-00000e70: 7220 7468 6520 2a77 696e 646f 772a 2069  r the *window* i
-00000e80: 7473 656c 662e 0d0a 2020 2020 2020 2020  tself...        
-00000e90: 0d0a 2020 2020 2020 2020 2a5f 5573 696e  ..        *_Usin
-00000ea0: 6720 7374 6974 6368 4e73 706c 6974 2074  g stitchNsplit t
-00000eb0: 6f67 6574 6865 725f 3a2a 0d0a 2020 2020  ogether_:*..    
-00000ec0: 2020 2020 6060 6070 7974 686f 6e0d 0a20      ```python.. 
-00000ed0: 2020 2020 2020 2066 726f 6d20 7374 6974         from stit
-00000ee0: 6368 5f6e 5f73 706c 6974 2e73 7469 7463  ch_n_split.stitc
-00000ef0: 682e 696d 6167 6573 2069 6d70 6f72 7420  h.images import 
-00000f00: 5374 6974 6368 0d0a 2020 2020 2020 2020  Stitch..        
-00000f10: 6672 6f6d 2073 7469 7463 685f 6e5f 7370  from stitch_n_sp
-00000f20: 6c69 742e 7574 696c 6974 7920 696d 706f  lit.utility impo
-00000f30: 7274 2073 6176 655f 696d 6167 650d 0a20  rt save_image.. 
-00000f40: 2020 2020 2020 2066 726f 6d20 7374 6974         from stit
-00000f50: 6368 5f6e 5f73 706c 6974 2e73 706c 6974  ch_n_split.split
-00000f60: 2e69 6d61 6765 7320 696d 706f 7274 2053  .images import S
-00000f70: 706c 6974 4e6f 6e47 656f 0d0a 2020 2020  plitNonGeo..    
-00000f80: 2020 2020 6672 6f6d 2073 7469 7463 685f      from stitch_
-00000f90: 6e5f 7370 6c69 742e 7574 696c 6974 7920  n_split.utility 
-00000fa0: 696d 706f 7274 206f 7065 6e5f 696d 6167  import open_imag
-00000fb0: 650d 0a20 2020 2020 2020 2069 6d70 6f72  e..        impor
-00000fc0: 7420 6e75 6d70 7920 6173 206e 700d 0a20  t numpy as np.. 
-00000fd0: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-00000fe0: 2073 706c 6974 203d 2053 706c 6974 4e6f   split = SplitNo
-00000ff0: 6e47 656f 2873 706c 6974 5f73 697a 653d  nGeo(split_size=
-00001000: 2831 3234 2c20 3236 3729 2c20 696d 675f  (124, 267), img_
-00001010: 7369 7a65 3d28 3531 322c 2035 3132 2c20  size=(512, 512, 
-00001020: 3329 290d 0a20 2020 2020 2020 2069 6d61  3))..        ima
-00001030: 6765 203d 206f 7065 6e5f 696d 6167 6528  ge = open_image(
-00001040: 2269 6d67 5f70 6174 6822 290d 0a20 2020  "img_path")..   
-00001050: 2020 2020 2073 7469 7463 6865 645f 696d       stitched_im
-00001060: 6167 6520 3d20 6e70 2e7a 6572 6f73 2828  age = np.zeros((
-00001070: 3531 322c 2035 3132 2c20 3329 290d 0a20  512, 512, 3)).. 
-00001080: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-00001090: 2066 6f72 2077 696e 5f6e 756d 6265 722c   for win_number,
-000010a0: 2077 696e 646f 7720 696e 2073 706c 6974   window in split
-000010b0: 3a0d 0a20 2020 2020 2020 2020 2020 2073  :..            s
-000010c0: 706c 6974 5f69 6d61 6765 203d 2073 706c  plit_image = spl
-000010d0: 6974 2e77 696e 646f 775f 7370 6c69 7428  it.window_split(
-000010e0: 696d 6167 652c 2077 696e 5f6e 756d 6265  image, win_numbe
-000010f0: 7229 0d0a 2020 2020 2020 2020 2020 2020  r)..            
-00001100: 2320 7065 7266 6f72 6d20 6f70 6572 6174  # perform operat
-00001110: 696f 6e20 2e2e 2e2e 0d0a 2020 2020 2020  ion ......      
-00001120: 2020 2020 2020 7374 6974 6368 6564 5f69        stitched_i
-00001130: 6d61 6765 203d 2053 7469 7463 682e 7374  mage = Stitch.st
-00001140: 6974 6368 5f69 6d61 6765 2873 706c 6974  itch_image(split
-00001150: 5f69 6d61 6765 2c20 7374 6974 6368 6564  _image, stitched
-00001160: 5f69 6d61 6765 2c20 7769 6e64 6f77 290d  _image, window).
-00001170: 0a20 2020 2020 2020 2073 6176 655f 696d  .        save_im
-00001180: 6167 6528 2270 6174 685f 746f 5f73 6176  age("path_to_sav
-00001190: 6522 2c20 7374 6974 6368 6564 5f69 6d61  e", stitched_ima
-000011a0: 6765 290d 0a20 2020 2020 2020 2060 6060  ge)..        ```
-000011b0: 200d 0a20 2020 2020 2020 2020 200d 0a20   ..          .. 
-000011c0: 2020 2020 2020 2023 2320 4d65 7368 2043         ## Mesh C
-000011d0: 6f6d 7075 7469 6e67 0d0a 2020 2020 2020  omputing..      
-000011e0: 2020 0d0a 2020 2020 2020 2020 215b 7374    ..        ![st
-000011f0: 6974 6368 4e73 706c 6974 5d28 6874 7470  itchNsplit](http
-00001200: 733a 2f2f 7573 6572 2d69 6d61 6765 732e  s://user-images.
-00001210: 6769 7468 7562 7573 6572 636f 6e74 656e  githubuserconten
-00001220: 742e 636f 6d2f 3234 3636 3535 3730 2f38  t.com/24665570/8
-00001230: 3937 3739 3631 392d 3665 3566 6261 3030  9779619-6e5fba00
-00001240: 2d64 6232 642d 3131 6561 2d38 3730 352d  -db2d-11ea-8705-
-00001250: 6438 6261 3738 3166 3732 6561 2e67 6966  d8ba781f72ea.gif
-00001260: 290d 0a20 2020 2020 2020 200d 0a20 2020  )..        ..   
-00001270: 2020 2020 202d 2023 2323 2320 4f76 6572       - #### Over
-00001280: 4c61 7070 696e 6720 4772 6964 0d0a 2020  Lapping Grid..  
-00001290: 2020 2020 2020 2020 2020 0d0a 2020 2020            ..    
-000012a0: 2020 2020 2020 2020 5468 6520 6772 6964          The grid
-000012b0: 2063 7265 6174 696f 6e20 7072 6f63 6573   creation proces
-000012c0: 7320 6173 7375 6d65 7320 7468 6520 7072  s assumes the pr
-000012d0: 6f76 6964 6564 2067 7269 6420 7369 7a65  ovided grid size
-000012e0: 206d 6967 6874 206e 6f74 2062 6520 6576   might not be ev
-000012f0: 656e 6c79 2064 6973 7472 6962 7574 6564  enly distributed
-00001300: 206f 7665 7220 7468 6520 6d65 7368 2073   over the mesh s
-00001310: 697a 6520 616e 640d 0a20 2020 2020 2020  ize and..       
-00001320: 2020 2020 2077 6865 6e65 7665 7220 7375       whenever su
-00001330: 6368 2073 6974 7561 7469 6f6e 2061 7269  ch situation ari
-00001340: 7365 732c 2074 6865 2067 7269 6420 6164  ses, the grid ad
-00001350: 6a75 7374 7320 6974 7320 706f 7369 7469  justs its positi
-00001360: 6f6e 2077 6974 686f 7574 2063 6f6d 7072  on without compr
-00001370: 6f6d 6973 696e 6720 7468 6520 6772 6964  omising the grid
-00001380: 2073 697a 652c 2074 6875 7320 6765 6e65   size, thus gene
-00001390: 7261 7469 6e67 200d 0a20 2020 2020 2020  rating ..       
-000013a0: 2020 2020 206f 7665 726c 6170 7069 6e67       overlapping
-000013b0: 2067 7269 6420 696e 2074 6865 206d 6573   grid in the mes
-000013c0: 680d 0a20 2020 2020 2020 2020 2020 200d  h..            .
-000013d0: 0a20 2020 2020 2020 202d 2023 2323 2320  .        - #### 
-000013e0: 4e6f 6e4f 7665 726c 6170 7069 6e67 2047  NonOverlapping G
-000013f0: 7269 640d 0a20 2020 2020 2020 2020 2020  rid..           
-00001400: 200d 0a20 2020 2020 2020 2020 2020 204e   ..            N
-00001410: 6f20 6d61 7474 6572 2077 6861 7420 7468  o matter what th
-00001420: 6520 7072 6f76 6964 6564 2067 7269 6420  e provided grid 
-00001430: 7369 7a65 2c20 7468 6520 676f 616c 2069  size, the goal i
-00001440: 7320 746f 2066 696e 6420 6120 6772 6964  s to find a grid
-00001450: 2073 697a 6520 7768 6963 6820 6361 6e20   size which can 
-00001460: 6265 2065 7665 6e6c 7920 6469 7374 7269  be evenly distri
-00001470: 6275 7465 6420 6f76 6572 2074 6865 0d0a  buted over the..
-00001480: 2020 2020 2020 2020 2020 2020 7072 6f76              prov
-00001490: 6964 6564 206d 6573 6820 7369 7a65 2c20  ided mesh size, 
-000014a0: 6966 2074 6865 2070 726f 7669 6465 6420  if the provided 
-000014b0: 7369 7a65 7320 7072 6573 656e 7473 2074  sizes presents t
-000014c0: 6865 2070 6f73 7369 6269 6c69 7479 206f  he possibility o
-000014d0: 6620 6120 6f76 6572 6c61 7020 7468 656e  f a overlap then
-000014e0: 2074 6865 2073 697a 6520 6f66 2074 6865   the size of the
-000014f0: 200d 0a20 2020 2020 2020 2020 2020 2067   ..            g
-00001500: 7269 6420 6973 2061 646a 7573 7465 642c  rid is adjusted,
-00001510: 2074 6f20 7072 6f76 6964 6520 6e6f 6e20   to provide non 
-00001520: 6f76 6572 6c61 7070 696e 6720 6772 6964  overlapping grid
-00001530: 0d0a 2020 2020 2020 2020 2020 2020 0d0a  ..            ..
-00001540: 2020 2020 2020 2020 2020 2020 0d0a 2020              ..  
-00001550: 2020 2020 2020 3c74 6162 6c65 3e0d 0a20        <table>.. 
-00001560: 2020 2020 2020 2020 203c 7472 3e0d 0a20           <tr>.. 
-00001570: 2020 2020 2020 2020 2020 203c 7464 3e4d             <td>M
-00001580: 6573 6820 7769 7468 204f 7665 726c 6170  esh with Overlap
-00001590: 7069 6e67 2047 7269 643c 2f74 643e 0d0a  ping Grid</td>..
-000015a0: 2020 2020 2020 2020 2020 2020 203c 7464               <td
-000015b0: 3e4d 6573 6820 7769 7468 204e 6f6e 204f  >Mesh with Non O
-000015c0: 7665 726c 6170 7069 6e67 2047 7269 643c  verlapping Grid<
-000015d0: 2f74 643e 0d0a 2020 2020 2020 2020 2020  /td>..          
-000015e0: 3c2f 7472 3e0d 0a20 2020 2020 2020 2020  </tr>..         
-000015f0: 203c 7472 3e0d 0a20 2020 2020 2020 2020   <tr>..         
-00001600: 2020 203c 7464 3e3c 696d 6720 7372 633d     <td><img src=
-00001610: 2268 7474 7073 3a2f 2f75 7365 722d 696d  "https://user-im
-00001620: 6167 6573 2e67 6974 6875 6275 7365 7263  ages.githubuserc
-00001630: 6f6e 7465 6e74 2e63 6f6d 2f32 3436 3635  ontent.com/24665
-00001640: 3537 302f 3839 3737 3333 3131 2d34 3936  570/89773311-496
-00001650: 3534 6130 302d 6462 3231 2d31 3165 612d  54a00-db21-11ea-
-00001660: 3939 3535 2d66 3132 3330 6434 3332 3938  9955-f1230d43298
-00001670: 392e 706e 6722 2077 6964 7468 3d38 3132  9.png" width=812
-00001680: 2068 6569 6768 743d 3335 303e 3c2f 7464   height=350></td
-00001690: 3e0d 0a20 2020 2020 2020 2020 2020 203c  >..            <
-000016a0: 7464 3e3c 696d 6720 7372 633d 2268 7474  td><img src="htt
-000016b0: 7073 3a2f 2f75 7365 722d 696d 6167 6573  ps://user-images
-000016c0: 2e67 6974 6875 6275 7365 7263 6f6e 7465  .githubuserconte
-000016d0: 6e74 2e63 6f6d 2f32 3436 3635 3537 302f  nt.com/24665570/
-000016e0: 3839 3737 3336 3439 2d66 3861 3232 3130  89773649-f8a2210
-000016f0: 302d 6462 3231 2d31 3165 612d 3862 6363  0-db21-11ea-8bcc
-00001700: 2d64 6565 6234 3639 3339 6135 312e 706e  -deeb46939a51.pn
-00001710: 6722 2077 6964 7468 3d38 3132 2068 6569  g" width=812 hei
-00001720: 6768 743d 3335 303e 3c2f 7464 3e0d 0a20  ght=350></td>.. 
-00001730: 2020 2020 2020 2020 203c 2f74 723e 0d0a           </tr>..
-00001740: 2020 2020 2020 2020 203c 2f74 6162 6c65           </table
-00001750: 3e0d 0a20 2020 2020 2020 2020 0d0a 2020  >..         ..  
-00001760: 2020 2020 2020 205f 2a6d 6573 6820 7369         _*mesh si
-00001770: 7a65 203d 2028 3130 3030 302c 2031 3030  ze = (10000, 100
-00001780: 3030 292a 2c20 202a 6772 6964 2073 697a  00)*,  *grid siz
-00001790: 6520 3d20 2832 3538 372c 2033 3030 3029  e = (2587, 3000)
-000017a0: 2a20 7765 7265 2075 7365 6420 666f 7220  * were used for 
-000017b0: 6162 6f76 6520 6578 616d 706c 655f 0d0a  above example_..
-000017c0: 2020 2020 2020 2020 0d0a 2020 2020 2020          ..      
-000017d0: 2020 5468 6520 6e75 6d62 6572 206f 6620    The number of 
-000017e0: 6772 6964 2067 656e 6572 6174 6564 2069  grid generated i
-000017f0: 6e20 626f 7468 2063 6173 6573 2061 7265  n both cases are
-00001800: 2074 6865 2073 616d 652c 2074 6865 206f   the same, the o
-00001810: 6e6c 7920 6469 6666 6572 656e 6365 2069  nly difference i
-00001820: 732c 2074 6865 2069 6d61 6765 2069 6e20  s, the image in 
-00001830: 7468 6520 6c65 6674 2064 6f65 736e 2774  the left doesn't
-00001840: 2063 6f6d 7072 6f6d 6973 6573 2074 6865   compromises the
-00001850: 2067 7269 6420 7369 7a65 2077 6865 6e20   grid size when 
-00001860: 6974 2065 6e63 6f75 6e74 6572 730d 0a20  it encounters.. 
-00001870: 2020 2020 2020 2061 6e20 6f76 6572 6c61         an overla
-00001880: 702c 2077 6865 7265 2061 7320 7468 6520  p, where as the 
-00001890: 696d 6167 6520 6f6e 2074 6865 2072 6967  image on the rig
-000018a0: 6874 2061 646a 7573 7473 2069 7473 2067  ht adjusts its g
-000018b0: 7269 6420 7369 7a65 2074 6f20 3c63 6f64  rid size to <cod
-000018c0: 653e 6d65 7368 2073 697a 6520 2f2f 2028  e>mesh size // (
-000018d0: 6d65 7368 2073 697a 6520 2f20 6772 6964  mesh size / grid
-000018e0: 2073 697a 6529 3c2f 636f 6465 3e20 0d0a   size)</code> ..
-000018f0: 2020 2020 2020 2020 746f 2061 766f 6964          to avoid
-00001900: 2061 6e79 206f 7665 726c 6170 0d0a 2020   any overlap..  
-00001910: 2020 2020 2020 0d0a 2020 2020 2020 2020        ..        
-00001920: 0d0a 2020 2020 2020 2020 2323 2323 204d  ..        #### M
-00001930: 6573 6820 436f 6d70 7574 696e 6720 4672  esh Computing Fr
-00001940: 6f6d 2067 656f 2d72 6566 6572 656e 6365  om geo-reference
-00001950: 6420 696d 6167 650d 0a20 2020 2020 2020  d image..       
-00001960: 2054 6865 204f 6e65 206d 616e 6461 746f   The One mandato
-00001970: 7279 2050 6172 616d 6574 6572 2077 6869  ry Parameter whi
-00001980: 6c65 2063 6f6d 7075 7469 6e67 204d 6573  le computing Mes
-00001990: 6820 6973 2074 6865 2067 656f 2072 6566  h is the geo ref
-000019a0: 6572 656e 6369 6e67 2074 7261 6e73 666f  erencing transfo
-000019b0: 726d 6174 696f 6e20 6d61 7472 6978 2e0d  rmation matrix..
-000019c0: 0a20 2020 2020 2020 200d 0a20 2020 2020  .        ..     
-000019d0: 2020 202d 2057 6865 6e20 7468 6520 7369     - When the si
-000019e0: 7a65 206f 6620 7468 6520 6d65 7368 2061  ze of the mesh a
-000019f0: 6e64 2074 6865 2067 7269 6420 6172 6520  nd the grid are 
-00001a00: 7072 6f76 6964 6564 2069 6e20 7265 6775  provided in regu
-00001a10: 6c61 7220 6469 6d65 6e73 696f 6e2c 2074  lar dimension, t
-00001a20: 6865 6e20 7468 6520 706f 7369 7469 6f6e  hen the position
-00001a30: 2077 6865 7265 2074 6865 206d 6573 6820   where the mesh 
-00001a40: 6973 2074 6f20 6265 2064 7261 776e 2069  is to be drawn i
-00001a50: 730d 0a20 2020 2020 2020 2065 7874 7261  s..        extra
-00001a60: 6374 6564 2066 726f 6d20 7468 6520 6166  cted from the af
-00001a70: 6669 6e65 2074 7261 6e73 666f 726d 2061  fine transform a
-00001a80: 6e64 2063 6f6e 7665 7273 696f 6e20 6f66  nd conversion of
-00001a90: 2074 6865 2064 696d 656e 7369 6f6e 2074   the dimension t
-00001aa0: 6f20 7265 6665 7265 6e63 6520 636f 6f72  o reference coor
-00001ab0: 6469 6e61 7465 2073 7973 7465 6d20 6973  dinate system is
-00001ac0: 2064 6f6e 6520 7769 7468 2074 6865 2068   done with the h
-00001ad0: 656c 700d 0a20 2020 2020 2020 206f 6620  elp..        of 
-00001ae0: 7069 7865 6c20 7265 736f 6c75 7469 6f6e  pixel resolution
-00001af0: 2070 7265 7365 6e74 2069 6e20 6166 6669   present in affi
-00001b00: 6e65 2074 7261 6e73 666f 726d 0d0a 2020  ne transform..  
-00001b10: 2020 2020 2020 0d0a 2020 2020 2020 2020        ..        
-00001b20: 2020 2020 2020 2020 6d65 7368 203d 206d          mesh = m
-00001b30: 6573 685f 6672 6f6d 5f67 656f 5f74 7261  esh_from_geo_tra
-00001b40: 6e73 666f 726d 280d 0a20 2020 2020 2020  nsform(..       
-00001b50: 2020 2020 2020 2020 206d 6573 685f 7369           mesh_si
-00001b60: 7a65 3d28 772c 2068 292c 0d0a 2020 2020  ze=(w, h),..    
-00001b70: 2020 2020 2020 2020 2020 2020 7472 616e              tran
-00001b80: 7366 6f72 6d3d 7472 616e 7366 726f 6d61  sform=transfroma
-00001b90: 7469 6f6e 5f6d 6174 7269 782c 200d 0a20  tion_matrix, .. 
-00001ba0: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-00001bb0: 7269 645f 7369 7a65 3d28 772c 2068 290d  rid_size=(w, h).
-00001bc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001bd0: 2029 0d0a 2020 2020 2020 2020 0d0a 2020   )..        ..  
-00001be0: 2020 2020 2020 2020 2020 5f54 6869 7320            _This 
-00001bf0: 7769 6c6c 2067 656e 6572 6174 6520 6120  will generate a 
-00001c00: 2a4d 6573 682a 206f 6620 6469 6d65 6e73  *Mesh* of dimens
-00001c10: 696f 6e20 2a28 772c 2068 292a 2077 6869  ion *(w, h)* whi
-00001c20: 6368 2077 696c 6c20 6861 7665 202a 4772  ch will have *Gr
-00001c30: 6964 2a20 6f66 2064 696d 656e 7369 6f6e  id* of dimension
-00001c40: 202a 2877 2c20 6829 2a2c 200d 0a20 2020   *(w, h)*, ..   
-00001c50: 2020 2020 2077 6869 6368 2077 696c 6c20       which will 
-00001c60: 6265 2062 6f75 6e64 6564 2077 6974 6869  be bounded withi
-00001c70: 6e20 7468 6520 7265 6769 6f6e 202a 7472  n the region *tr
-00001c80: 616e 7366 6f72 6d20 2a20 286d 6573 685f  ansform * (mesh_
-00001c90: 7369 7a65 292a 5f0d 0a20 2020 2020 2020  size)*_..       
-00001ca0: 200d 0a20 2020 2020 2020 202d 2057 6865   ..        - Whe
-00001cb0: 6e20 7468 6520 626f 756e 6473 206f 6620  n the bounds of 
-00001cc0: 6d65 7368 2061 7265 2070 6173 7365 642c  mesh are passed,
-00001cd0: 2054 6865 2074 7261 6e73 666f 726d 6174   The transformat
-00001ce0: 696f 6e20 6d61 7472 6978 2066 6f72 2074  ion matrix for t
-00001cf0: 6865 206d 6573 6820 6861 7665 2074 6f20  he mesh have to 
-00001d00: 6265 2063 6f6e 7374 7275 6374 6564 2065  be constructed e
-00001d10: 7870 6c69 6369 746c 792c 2074 6865 2077  xplicitly, the w
-00001d20: 6964 7468 2061 6e64 0d0a 2020 2020 2020  idth and..      
-00001d30: 2020 6865 6967 6874 2061 7265 2063 6f6d    height are com
-00001d40: 7075 7465 6420 696e 7465 726e 616c 6c79  puted internally
-00001d50: 2066 726f 6d20 7468 6520 6769 7665 6e20   from the given 
-00001d60: 7472 616e 7366 6f72 6d61 7469 6f6e 0d0a  transformation..
-00001d70: 2020 2020 2020 2020 0d0a 2020 2020 2020          ..      
-00001d80: 2020 2020 2020 2020 2020 7472 616e 7366            transf
-00001d90: 726f 6d61 7469 6f6e 5f6d 6174 7269 7820  romation_matrix 
-00001da0: 3d20 6765 745f 6166 6669 6e65 5f74 7261  = get_affine_tra
-00001db0: 6e73 666f 726d 280d 0a20 2020 2020 2020  nsform(..       
-00001dc0: 2020 2020 2020 2020 206d 6573 685f 626f           mesh_bo
-00001dd0: 756e 6473 5b30 5d2c 0d0a 2020 2020 2020  unds[0],..      
-00001de0: 2020 2020 2020 2020 2020 6d65 7368 5f62            mesh_b
-00001df0: 6f75 6e64 735b 2d31 5d2c 0d0a 2020 2020  ounds[-1],..    
-00001e00: 2020 2020 2020 2020 2020 2020 2a67 6574              *get
-00001e10: 5f70 6978 656c 5f72 6573 6f6c 7574 696f  _pixel_resolutio
-00001e20: 6e28 696d 6167 652e 7472 616e 7366 6f72  n(image.transfor
-00001e30: 6d29 0d0a 2020 2020 2020 2020 2020 2020  m)..            
-00001e40: 2020 2020 2920 0d0a 2020 2020 2020 2020      ) ..        
-00001e50: 2020 2020 2020 2020 0d0a 2020 2020 2020          ..      
-00001e60: 2020 2020 2020 2020 2020 6d65 7368 203d            mesh =
-00001e70: 206d 6573 685f 6672 6f6d 5f67 656f 5f74   mesh_from_geo_t
-00001e80: 7261 6e73 666f 726d 280d 0a20 2020 2020  ransform(..     
-00001e90: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-00001ea0: 7269 645f 7369 7a65 3d28 772c 2068 292c  rid_size=(w, h),
-00001eb0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00001ec0: 2020 2020 2020 7472 616e 7366 6f72 6d3d        transform=
-00001ed0: 7472 616e 7366 726f 6d61 7469 6f6e 5f6d  transfromation_m
-00001ee0: 6174 7269 782c 0d0a 2020 2020 2020 2020  atrix,..        
-00001ef0: 2020 2020 2020 2020 2020 2020 6d65 7368              mesh
-00001f00: 5f62 6f75 6e64 733d 6d65 7368 5f62 6f75  _bounds=mesh_bou
-00001f10: 6e64 732c 0d0a 2020 2020 2020 2020 2020  nds,..          
-00001f20: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-00001f30: 200d 0a20 2020 2020 2020 2023 2320 4f75   ..        ## Ou
-00001f40: 7470 7574 0d0a 2020 2020 2020 2020 0d0a  tput..        ..
-00001f50: 2020 2020 2020 2020 4772 6964 2063 616e          Grid can
-00001f60: 2063 616e 2061 6363 6573 7365 6420 6279   can accessed by
-00001f70: 2074 6865 2065 7874 656e 7428 2920 6361   the extent() ca
-00001f80: 6c6c 2077 6869 6368 2069 7320 6120 4765  ll which is a Ge
-00001f90: 6e65 7261 746f 7220 666f 7220 7072 6f76  nerator for prov
-00001fa0: 6964 696e 6720 696e 6469 7669 6475 616c  iding individual
-00001fb0: 2067 7269 6420 616c 6f6e 6720 7769 7468   grid along with
-00001fc0: 2074 6865 2069 6e66 6f72 6d61 7469 6f6e   the information
-00001fd0: 2061 7373 6f63 6961 7465 6420 0d0a 2020   associated ..  
-00001fe0: 2020 2020 2020 7769 7468 2074 6865 2067        with the g
-00001ff0: 7269 640d 0a20 2020 2020 2020 200d 0a20  rid..        .. 
-00002000: 2020 2020 2020 2020 2020 206d 6573 685f             mesh_
-00002010: 6f76 6572 6c61 7020 3d20 6d65 7368 5f66  overlap = mesh_f
-00002020: 726f 6d5f 6765 6f5f 7472 616e 7366 6f72  rom_geo_transfor
-00002030: 6d28 6d65 7368 5f73 697a 653d 2831 3030  m(mesh_size=(100
-00002040: 3030 2c20 3130 3030 302c 2033 292c 2074  00, 10000, 3), t
-00002050: 7261 6e73 666f 726d 3d61 6666 696e 655f  ransform=affine_
-00002060: 7472 616e 7366 6f72 6d2c 0d0a 2020 2020  transform,..    
-00002070: 2020 2020 2020 2020 6772 6964 5f73 697a          grid_siz
-00002080: 653d 2832 3538 372c 2033 3030 302c 2033  e=(2587, 3000, 3
-00002090: 2929 0d0a 2020 2020 2020 2020 2020 2020  ))..            
-000020a0: 0d0a 2020 2020 2020 2020 2020 2020 666f  ..            fo
-000020b0: 7220 6772 6964 2069 6e20 6d65 7368 2e65  r grid in mesh.e
-000020c0: 7874 656e 7428 293a 0d0a 2020 2020 2020  xtent():..      
-000020d0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-000020e0: 6772 6964 290d 0a20 2020 2020 2020 2020  grid)..         
-000020f0: 2020 2020 2020 202e 2e2e 2e2e 0d0a 2020         .......  
-00002100: 2020 2020 2020 0d0a 2020 2020 2020 2020        ..        
-00002110: 4966 2074 6865 2063 6f6f 7264 696e 6174  If the coordinat
-00002120: 6520 7379 7374 656d 2061 7661 696c 6162  e system availab
-00002130: 6c65 2069 7320 6469 6666 6572 656e 7420  le is different 
-00002140: 7468 616e 2074 6865 206f 6e65 7320 6c69  than the ones li
-00002150: 7374 6564 205b 6865 7265 5d28 2357 6f72  sted [here](#Wor
-00002160: 6b69 6e67 2d43 6f6f 7264 696e 6174 652d  king-Coordinate-
-00002170: 5379 7374 656d 292c 2074 6865 6e20 7468  System), then th
-00002180: 6520 636f 6f72 6469 6e61 7465 206d 7573  e coordinate mus
-00002190: 7420 6265 2072 6570 726f 6a65 6374 6564  t be reprojected
-000021a0: 2062 6566 6f72 6520 0d0a 2020 2020 2020   before ..      
-000021b0: 2020 6d65 7368 2063 6f6d 7075 7461 7469    mesh computati
-000021c0: 6f6e 0d0a 2020 2020 2020 2020 2020 2020  on..            
-000021d0: 0d0a 2020 2020 2020 2020 2020 2020 7472  ..            tr
-000021e0: 616e 7366 6f72 6d3d 6765 6f5f 7472 616e  ansform=geo_tran
-000021f0: 7366 6f72 6d5f 746f 5f32 3631 3930 2877  sform_to_26190(w
-00002200: 2c20 682c 2061 7262 6974 7261 7279 5f69  , h, arbitrary_i
-00002210: 6d61 6765 5f63 6f6f 7264 696e 6174 655f  mage_coordinate_
-00002220: 7379 7374 656d 2e62 6f75 6e64 732c 0d0a  system.bounds,..
-00002230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002240: 2061 7262 6974 7261 7279 5f69 6d61 6765   arbitrary_image
-00002250: 5f63 6f6f 7264 696e 6174 655f 7379 7374  _coordinate_syst
-00002260: 656d 2e63 7273 292c 0d0a 2020 2020 2020  em.crs),..      
-00002270: 2020 0d0a 2020 2020 2020 2020 4966 2077    ..        If w
-00002280: 6964 7468 2061 6e64 2068 6569 6768 7420  idth and height 
-00002290: 6f66 2074 6865 2062 6f75 6e64 7320 6172  of the bounds ar
-000022a0: 6520 6e6f 7420 6b6e 6f77 6e2c 2074 6f20  e not known, to 
-000022b0: 6361 6c63 756c 6174 6520 6974 2c20 7573  calculate it, us
-000022c0: 650d 0a20 2020 2020 2020 200d 0a20 2020  e..        ..   
-000022d0: 2020 2020 2020 2020 2063 6f6d 7075 7465           compute
-000022e0: 5f64 696d 656e 7369 6f6e 2861 7262 6974  _dimension(arbit
-000022f0: 7261 7279 5f69 6d61 6765 5f63 6f6f 7264  rary_image_coord
-00002300: 696e 6174 655f 7379 7374 656d 2e62 6f75  inate_system.bou
-00002310: 6e64 732c 2070 6978 656c 5f72 6573 6f6c  nds, pixel_resol
-00002320: 7574 696f 6e29 0d0a 2020 2020 2020 2020  ution)..        
-00002330: 0d0a 2020 2020 2020 2020 2020 2020 0d0a  ..            ..
-00002340: 2020 2020 2020 2020 2323 2057 6f72 6b69          ## Worki
-00002350: 6e67 2043 6f6f 7264 696e 6174 6520 5379  ng Coordinate Sy
-00002360: 7374 656d 0d0a 2020 2020 2020 2020 312e  stem..        1.
-00002370: 2045 5053 473a 3236 3931 300d 0a20 2020   EPSG:26910..   
-00002380: 2020 2020 2032 2e20 4550 5347 3a32 3639       2. EPSG:269
-00002390: 3836 2020 2020 200d 0a20 2020 2020 2020  86     ..       
-000023a0: 200d 0a20 2020 2020 2020 200d 0a4b 6579   ..        ..Key
-000023b0: 776f 7264 733a 2047 4953 2052 6173 7465  words: GIS Raste
-000023c0: 7269 6f20 5374 6963 7468 2053 706c 6974  rio Sticth Split
-000023d0: 204d 6573 6820 4772 6964 2047 656f 2052   Mesh Grid Geo R
-000023e0: 6566 6572 656e 6365 0d0a 506c 6174 666f  eference..Platfo
-000023f0: 726d 3a20 554e 4b4e 4f57 4e0d 0a43 6c61  rm: UNKNOWN..Cla
-00002400: 7373 6966 6965 723a 2050 726f 6772 616d  ssifier: Program
-00002410: 6d69 6e67 204c 616e 6775 6167 6520 3a3a  ming Language ::
-00002420: 2050 7974 686f 6e20 3a3a 2033 0d0a 436c   Python :: 3..Cl
-00002430: 6173 7369 6669 6572 3a20 4c69 6365 6e73  assifier: Licens
-00002440: 6520 3a3a 204f 5349 2041 7070 726f 7665  e :: OSI Approve
-00002450: 6420 3a3a 204d 4954 204c 6963 656e 7365  d :: MIT License
-00002460: 0d0a 436c 6173 7369 6669 6572 3a20 4f70  ..Classifier: Op
-00002470: 6572 6174 696e 6720 5379 7374 656d 203a  erating System :
-00002480: 3a20 4f53 2049 6e64 6570 656e 6465 6e74  : OS Independent
-00002490: 0d0a 5265 7175 6972 6573 2d50 7974 686f  ..Requires-Pytho
-000024a0: 6e3a 207e 3d33 2e33 0d0a 4465 7363 7269  n: ~=3.3..Descri
-000024b0: 7074 696f 6e2d 436f 6e74 656e 742d 5479  ption-Content-Ty
-000024c0: 7065 3a20 7465 7874 2f6d 6172 6b64 6f77  pe: text/markdow
-000024d0: 6e0d 0a                                  n..
+000008a0: 6f6e 200a 2020 2020 3e20 4765 6f20 5265  on .    > Geo Re
+000008b0: 6665 7265 6e63 6520 696d 6167 6572 7920  ference imagery 
+000008c0: 6d75 7374 2062 6520 6f66 205b 7469 6666  must be of [tiff
+000008d0: 5d28 6874 7470 733a 2f2f 656e 2e77 696b  ](https://en.wik
+000008e0: 6970 6564 6961 2e6f 7267 2f77 696b 692f  ipedia.org/wiki/
+000008f0: 5449 4646 2920 666f 726d 6174 2e0a 0a2d  TIFF) format...-
+00000900: 2023 2323 2323 204e 6f6e 2047 656f 5265   ##### Non GeoRe
+00000910: 6665 7265 6e63 6564 200a 2020 2020 466f  ferenced .    Fo
+00000920: 7220 4e6f 6e20 4765 6f52 6566 6572 656e  r Non GeoReferen
+00000930: 6365 6420 7468 6520 7370 6c69 7420 6973  ced the split is
+00000940: 2073 7472 6169 6768 7420 666f 7277 6172   straight forwar
+00000950: 642c 2069 7420 6765 7473 2063 726f 7070  d, it gets cropp
+00000960: 6564 2069 6e20 746f 2073 7065 6369 6669  ed in to specifi
+00000970: 6564 2064 696d 656e 7369 6f6e 0a0a 2a5f  ed dimension..*_
+00000980: 5370 6c69 7420 456e 7469 7265 2044 6972  Split Entire Dir
+00000990: 6563 746f 7279 5f3a 2a0a 6060 6070 7974  ectory_:*.```pyt
+000009a0: 686f 6e0a 6672 6f6d 2073 7469 7463 685f  hon.from stitch_
+000009b0: 6e5f 7370 6c69 742e 7370 6c69 742e 696d  n_split.split.im
+000009c0: 6167 6573 2069 6d70 6f72 7420 5370 6c69  ages import Spli
+000009d0: 7447 656f 0a73 706c 6974 203d 2053 706c  tGeo.split = Spl
+000009e0: 6974 4765 6f28 7370 6c69 745f 7369 7a65  itGeo(split_size
+000009f0: 3d28 3132 342c 2032 3637 292c 2069 6d67  =(124, 267), img
+00000a00: 5f73 697a 653d 2835 3132 2c20 3531 3229  _size=(512, 512)
+00000a10: 290a 7370 6c69 742e 7065 7266 6f72 6d5f  ).split.perform_
+00000a20: 6469 7265 6374 6f72 795f 7370 6c69 7428  directory_split(
+00000a30: 2264 6972 5f70 6174 6822 290a 6060 600a  "dir_path").```.
+00000a40: 5065 7266 6f72 6d69 6e67 2053 706c 6974  Performing Split
+00000a50: 206f 7665 7220 696e 6469 7669 6475 616c   over individual
+00000a60: 2069 6d61 6765 7320 6361 6e20 6265 2064   images can be d
+00000a70: 6f6e 6520 6279 2061 6363 6573 7369 6e67  one by accessing
+00000a80: 2073 706c 6974 2061 7320 616e 2069 7465   split as an ite
+00000a90: 7261 746f 722e 0a0a 2a5f 5370 6c69 7420  rator...*_Split 
+00000aa0: 4974 6572 6174 6f72 2075 7369 6e67 2077  Iterator using w
+00000ab0: 696e 646f 775f 3a2a 0a60 6060 7079 7468  indow_:*.```pyth
+00000ac0: 6f6e 0a66 726f 6d20 7374 6974 6368 5f6e  on.from stitch_n
+00000ad0: 5f73 706c 6974 2e73 706c 6974 2e69 6d61  _split.split.ima
+00000ae0: 6765 7320 696d 706f 7274 2053 706c 6974  ges import Split
+00000af0: 4765 6f0a 6672 6f6d 2073 7469 7463 685f  Geo.from stitch_
+00000b00: 6e5f 7370 6c69 742e 7574 696c 6974 7920  n_split.utility 
+00000b10: 696d 706f 7274 206f 7065 6e5f 696d 6167  import open_imag
+00000b20: 650a 0a73 706c 6974 203d 2053 706c 6974  e..split = Split
+00000b30: 4765 6f28 7370 6c69 745f 7369 7a65 3d28  Geo(split_size=(
+00000b40: 3132 342c 2032 3637 292c 2069 6d67 5f73  124, 267), img_s
+00000b50: 697a 653d 2835 3132 2c20 3531 3229 290a  ize=(512, 512)).
+00000b60: 696d 6167 6520 3d20 6f70 656e 5f69 6d61  image = open_ima
+00000b70: 6765 2822 696d 675f 7061 7468 222c 2069  ge("img_path", i
+00000b80: 735f 6765 6f5f 7265 6665 7265 6e63 653d  s_geo_reference=
+00000b90: 5472 7565 290a 666f 7220 7769 6e5f 6e75  True).for win_nu
+00000ba0: 6d62 6572 2c20 7769 6e64 6f77 2069 6e20  mber, window in 
+00000bb0: 7370 6c69 743a 0a20 2020 2073 706c 6974  split:.    split
+00000bc0: 5f69 6d61 6765 203d 2073 706c 6974 2e77  _image = split.w
+00000bd0: 696e 646f 775f 7370 6c69 7428 696d 6167  indow_split(imag
+00000be0: 652c 2077 696e 646f 7729 0a20 2020 2023  e, window).    #
+00000bf0: 2070 6572 666f 726d 206f 7065 7261 7469   perform operati
+00000c00: 6f6e 202e 2e2e 2e0a 6060 600a 0a23 2320  on .....```..## 
+00000c10: 5374 6974 6368 200a 0a57 6869 6c65 2050  Stitch ..While P
+00000c20: 6572 666f 726d 696e 6720 5374 6974 6368  erforming Stitch
+00000c30: 2069 6620 7468 6572 6520 6172 6520 616e   if there are an
+00000c40: 7920 6f76 6572 6c61 7070 696e 6720 7769  y overlapping wi
+00000c50: 6e64 6f77 2c20 7468 6f73 6520 7769 6e64  ndow, those wind
+00000c60: 6f77 7320 6172 6520 6d65 7267 6564 2073  ows are merged s
+00000c70: 6561 6d6c 6573 736c 792c 2077 6974 686f  eamlessly, witho
+00000c80: 7574 0a68 616d 7065 7269 6e67 2074 6865  ut.hampering the
+00000c90: 2070 6978 656c 2069 6e66 6f72 6d61 7469   pixel informati
+00000ca0: 6f6e 2061 6e64 2069 6d61 6765 2064 696d  on and image dim
+00000cb0: 656e 7369 6f6e 0a0a 4576 6572 7920 5370  ension..Every Sp
+00000cc0: 6c69 7420 696d 6167 6520 6361 6e20 6265  lit image can be
+00000cd0: 2061 7373 6f63 6961 7465 6420 746f 2074   associated to t
+00000ce0: 6865 206f 7269 6769 6e61 6c20 696d 6167  he original imag
+00000cf0: 6520 6279 2074 6865 202a 7769 6e64 6f77  e by the *window
+00000d00: 206e 756d 6265 722a 206f 7220 7468 6520   number* or the 
+00000d10: 2a77 696e 646f 772a 2069 7473 656c 662e  *window* itself.
+00000d20: 0a0a 2a5f 5573 696e 6720 7374 6974 6368  ..*_Using stitch
+00000d30: 4e73 706c 6974 2074 6f67 6574 6865 725f  Nsplit together_
+00000d40: 3a2a 0a60 6060 7079 7468 6f6e 0a66 726f  :*.```python.fro
+00000d50: 6d20 7374 6974 6368 5f6e 5f73 706c 6974  m stitch_n_split
+00000d60: 2e73 7469 7463 682e 696d 6167 6573 2069  .stitch.images i
+00000d70: 6d70 6f72 7420 5374 6974 6368 0a66 726f  mport Stitch.fro
+00000d80: 6d20 7374 6974 6368 5f6e 5f73 706c 6974  m stitch_n_split
+00000d90: 2e75 7469 6c69 7479 2069 6d70 6f72 7420  .utility import 
+00000da0: 7361 7665 5f69 6d61 6765 0a66 726f 6d20  save_image.from 
+00000db0: 7374 6974 6368 5f6e 5f73 706c 6974 2e73  stitch_n_split.s
+00000dc0: 706c 6974 2e69 6d61 6765 7320 696d 706f  plit.images impo
+00000dd0: 7274 2053 706c 6974 4e6f 6e47 656f 0a66  rt SplitNonGeo.f
+00000de0: 726f 6d20 7374 6974 6368 5f6e 5f73 706c  rom stitch_n_spl
+00000df0: 6974 2e75 7469 6c69 7479 2069 6d70 6f72  it.utility impor
+00000e00: 7420 6f70 656e 5f69 6d61 6765 0a69 6d70  t open_image.imp
+00000e10: 6f72 7420 6e75 6d70 7920 6173 206e 700a  ort numpy as np.
+00000e20: 0a73 706c 6974 203d 2053 706c 6974 4e6f  .split = SplitNo
+00000e30: 6e47 656f 2873 706c 6974 5f73 697a 653d  nGeo(split_size=
+00000e40: 2831 3234 2c20 3236 3729 2c20 696d 675f  (124, 267), img_
+00000e50: 7369 7a65 3d28 3531 322c 2035 3132 2c20  size=(512, 512, 
+00000e60: 3329 290a 696d 6167 6520 3d20 6f70 656e  3)).image = open
+00000e70: 5f69 6d61 6765 2822 696d 675f 7061 7468  _image("img_path
+00000e80: 2229 0a73 7469 7463 6865 645f 696d 6167  ").stitched_imag
+00000e90: 6520 3d20 6e70 2e7a 6572 6f73 2828 3531  e = np.zeros((51
+00000ea0: 322c 2035 3132 2c20 3329 290a 0a66 6f72  2, 512, 3))..for
+00000eb0: 2077 696e 5f6e 756d 6265 722c 2077 696e   win_number, win
+00000ec0: 646f 7720 696e 2073 706c 6974 3a0a 2020  dow in split:.  
+00000ed0: 2020 7370 6c69 745f 696d 6167 6520 3d20    split_image = 
+00000ee0: 7370 6c69 742e 7769 6e64 6f77 5f73 706c  split.window_spl
+00000ef0: 6974 2869 6d61 6765 2c20 7769 6e5f 6e75  it(image, win_nu
+00000f00: 6d62 6572 290a 2020 2020 2320 7065 7266  mber).    # perf
+00000f10: 6f72 6d20 6f70 6572 6174 696f 6e20 2e2e  orm operation ..
+00000f20: 2e2e 0a20 2020 2073 7469 7463 6865 645f  ...    stitched_
+00000f30: 696d 6167 6520 3d20 5374 6974 6368 2e73  image = Stitch.s
+00000f40: 7469 7463 685f 696d 6167 6528 7370 6c69  titch_image(spli
+00000f50: 745f 696d 6167 652c 2073 7469 7463 6865  t_image, stitche
+00000f60: 645f 696d 6167 652c 2077 696e 646f 7729  d_image, window)
+00000f70: 0a73 6176 655f 696d 6167 6528 2270 6174  .save_image("pat
+00000f80: 685f 746f 5f73 6176 6522 2c20 7374 6974  h_to_save", stit
+00000f90: 6368 6564 5f69 6d61 6765 290a 6060 6020  ched_image).``` 
+00000fa0: 0a20 200a 2323 204d 6573 6820 436f 6d70  .  .## Mesh Comp
+00000fb0: 7574 696e 670a 0a21 5b73 7469 7463 684e  uting..![stitchN
+00000fc0: 7370 6c69 745d 2868 7474 7073 3a2f 2f75  split](https://u
+00000fd0: 7365 722d 696d 6167 6573 2e67 6974 6875  ser-images.githu
+00000fe0: 6275 7365 7263 6f6e 7465 6e74 2e63 6f6d  busercontent.com
+00000ff0: 2f32 3436 3635 3537 302f 3839 3737 3936  /24665570/897796
+00001000: 3139 2d36 6535 6662 6130 302d 6462 3264  19-6e5fba00-db2d
+00001010: 2d31 3165 612d 3837 3035 2d64 3862 6137  -11ea-8705-d8ba7
+00001020: 3831 6637 3265 612e 6769 6629 0a0a 2d20  81f72ea.gif)..- 
+00001030: 2323 2323 204f 7665 724c 6170 7069 6e67  #### OverLapping
+00001040: 2047 7269 640a 2020 2020 0a20 2020 2054   Grid.    .    T
+00001050: 6865 2067 7269 6420 6372 6561 7469 6f6e  he grid creation
+00001060: 2070 726f 6365 7373 2061 7373 756d 6573   process assumes
+00001070: 2074 6865 2070 726f 7669 6465 6420 6772   the provided gr
+00001080: 6964 2073 697a 6520 6d69 6768 7420 6e6f  id size might no
+00001090: 7420 6265 2065 7665 6e6c 7920 6469 7374  t be evenly dist
+000010a0: 7269 6275 7465 6420 6f76 6572 2074 6865  ributed over the
+000010b0: 206d 6573 6820 7369 7a65 2061 6e64 0a20   mesh size and. 
+000010c0: 2020 2077 6865 6e65 7665 7220 7375 6368     whenever such
+000010d0: 2073 6974 7561 7469 6f6e 2061 7269 7365   situation arise
+000010e0: 732c 2074 6865 2067 7269 6420 6164 6a75  s, the grid adju
+000010f0: 7374 7320 6974 7320 706f 7369 7469 6f6e  sts its position
+00001100: 2077 6974 686f 7574 2063 6f6d 7072 6f6d   without comprom
+00001110: 6973 696e 6720 7468 6520 6772 6964 2073  ising the grid s
+00001120: 697a 652c 2074 6875 7320 6765 6e65 7261  ize, thus genera
+00001130: 7469 6e67 200a 2020 2020 6f76 6572 6c61  ting .    overla
+00001140: 7070 696e 6720 6772 6964 2069 6e20 7468  pping grid in th
+00001150: 6520 6d65 7368 0a20 2020 200a 2d20 2323  e mesh.    .- ##
+00001160: 2323 204e 6f6e 4f76 6572 6c61 7070 696e  ## NonOverlappin
+00001170: 6720 4772 6964 0a20 2020 200a 2020 2020  g Grid.    .    
+00001180: 4e6f 206d 6174 7465 7220 7768 6174 2074  No matter what t
+00001190: 6865 2070 726f 7669 6465 6420 6772 6964  he provided grid
+000011a0: 2073 697a 652c 2074 6865 2067 6f61 6c20   size, the goal 
+000011b0: 6973 2074 6f20 6669 6e64 2061 2067 7269  is to find a gri
+000011c0: 6420 7369 7a65 2077 6869 6368 2063 616e  d size which can
+000011d0: 2062 6520 6576 656e 6c79 2064 6973 7472   be evenly distr
+000011e0: 6962 7574 6564 206f 7665 7220 7468 650a  ibuted over the.
+000011f0: 2020 2020 7072 6f76 6964 6564 206d 6573      provided mes
+00001200: 6820 7369 7a65 2c20 6966 2074 6865 2070  h size, if the p
+00001210: 726f 7669 6465 6420 7369 7a65 7320 7072  rovided sizes pr
+00001220: 6573 656e 7473 2074 6865 2070 6f73 7369  esents the possi
+00001230: 6269 6c69 7479 206f 6620 6120 6f76 6572  bility of a over
+00001240: 6c61 7020 7468 656e 2074 6865 2073 697a  lap then the siz
+00001250: 6520 6f66 2074 6865 200a 2020 2020 6772  e of the .    gr
+00001260: 6964 2069 7320 6164 6a75 7374 6564 2c20  id is adjusted, 
+00001270: 746f 2070 726f 7669 6465 206e 6f6e 206f  to provide non o
+00001280: 7665 726c 6170 7069 6e67 2067 7269 640a  verlapping grid.
+00001290: 2020 2020 0a20 2020 200a 3c74 6162 6c65      .    .<table
+000012a0: 3e0a 2020 3c74 723e 0a20 2020 203c 7464  >.  <tr>.    <td
+000012b0: 3e4d 6573 6820 7769 7468 204f 7665 726c  >Mesh with Overl
+000012c0: 6170 7069 6e67 2047 7269 643c 2f74 643e  apping Grid</td>
+000012d0: 0a20 2020 2020 3c74 643e 4d65 7368 2077  .     <td>Mesh w
+000012e0: 6974 6820 4e6f 6e20 4f76 6572 6c61 7070  ith Non Overlapp
+000012f0: 696e 6720 4772 6964 3c2f 7464 3e0a 2020  ing Grid</td>.  
+00001300: 3c2f 7472 3e0a 2020 3c74 723e 0a20 2020  </tr>.  <tr>.   
+00001310: 203c 7464 3e3c 696d 6720 7372 633d 2268   <td><img src="h
+00001320: 7474 7073 3a2f 2f75 7365 722d 696d 6167  ttps://user-imag
+00001330: 6573 2e67 6974 6875 6275 7365 7263 6f6e  es.githubusercon
+00001340: 7465 6e74 2e63 6f6d 2f32 3436 3635 3537  tent.com/2466557
+00001350: 302f 3839 3737 3333 3131 2d34 3936 3534  0/89773311-49654
+00001360: 6130 302d 6462 3231 2d31 3165 612d 3939  a00-db21-11ea-99
+00001370: 3535 2d66 3132 3330 6434 3332 3938 392e  55-f1230d432989.
+00001380: 706e 6722 2077 6964 7468 3d38 3132 2068  png" width=812 h
+00001390: 6569 6768 743d 3335 303e 3c2f 7464 3e0a  eight=350></td>.
+000013a0: 2020 2020 3c74 643e 3c69 6d67 2073 7263      <td><img src
+000013b0: 3d22 6874 7470 733a 2f2f 7573 6572 2d69  ="https://user-i
+000013c0: 6d61 6765 732e 6769 7468 7562 7573 6572  mages.githubuser
+000013d0: 636f 6e74 656e 742e 636f 6d2f 3234 3636  content.com/2466
+000013e0: 3535 3730 2f38 3937 3733 3634 392d 6638  5570/89773649-f8
+000013f0: 6132 3231 3030 2d64 6232 312d 3131 6561  a22100-db21-11ea
+00001400: 2d38 6263 632d 6465 6562 3436 3933 3961  -8bcc-deeb46939a
+00001410: 3531 2e70 6e67 2220 7769 6474 683d 3831  51.png" width=81
+00001420: 3220 6865 6967 6874 3d33 3530 3e3c 2f74  2 height=350></t
+00001430: 643e 0a20 203c 2f74 723e 0a20 3c2f 7461  d>.  </tr>. </ta
+00001440: 626c 653e 0a20 0a20 5f2a 6d65 7368 2073  ble>. . _*mesh s
+00001450: 697a 6520 3d20 2831 3030 3030 2c20 3130  ize = (10000, 10
+00001460: 3030 3029 2a2c 2020 2a67 7269 6420 7369  000)*,  *grid si
+00001470: 7a65 203d 2028 3235 3837 2c20 3330 3030  ze = (2587, 3000
+00001480: 292a 2077 6572 6520 7573 6564 2066 6f72  )* were used for
+00001490: 2061 626f 7665 2065 7861 6d70 6c65 5f0a   above example_.
+000014a0: 0a54 6865 206e 756d 6265 7220 6f66 2067  .The number of g
+000014b0: 7269 6420 6765 6e65 7261 7465 6420 696e  rid generated in
+000014c0: 2062 6f74 6820 6361 7365 7320 6172 6520   both cases are 
+000014d0: 7468 6520 7361 6d65 2c20 7468 6520 6f6e  the same, the on
+000014e0: 6c79 2064 6966 6665 7265 6e63 6520 6973  ly difference is
+000014f0: 2c20 7468 6520 696d 6167 6520 696e 2074  , the image in t
+00001500: 6865 206c 6566 7420 646f 6573 6e27 7420  he left doesn't 
+00001510: 636f 6d70 726f 6d69 7365 7320 7468 6520  compromises the 
+00001520: 6772 6964 2073 697a 6520 7768 656e 2069  grid size when i
+00001530: 7420 656e 636f 756e 7465 7273 0a61 6e20  t encounters.an 
+00001540: 6f76 6572 6c61 702c 2077 6865 7265 2061  overlap, where a
+00001550: 7320 7468 6520 696d 6167 6520 6f6e 2074  s the image on t
+00001560: 6865 2072 6967 6874 2061 646a 7573 7473  he right adjusts
+00001570: 2069 7473 2067 7269 6420 7369 7a65 2074   its grid size t
+00001580: 6f20 3c63 6f64 653e 6d65 7368 2073 697a  o <code>mesh siz
+00001590: 6520 2f2f 2028 6d65 7368 2073 697a 6520  e // (mesh size 
+000015a0: 2f20 6772 6964 2073 697a 6529 3c2f 636f  / grid size)</co
+000015b0: 6465 3e20 0a74 6f20 6176 6f69 6420 616e  de> .to avoid an
+000015c0: 7920 6f76 6572 6c61 700a 0a0a 2323 2323  y overlap...####
+000015d0: 204d 6573 6820 436f 6d70 7574 696e 6720   Mesh Computing 
+000015e0: 4672 6f6d 2067 656f 2d72 6566 6572 656e  From geo-referen
+000015f0: 6365 6420 696d 6167 650a 5468 6520 4f6e  ced image.The On
+00001600: 6520 6d61 6e64 6174 6f72 7920 5061 7261  e mandatory Para
+00001610: 6d65 7465 7220 7768 696c 6520 636f 6d70  meter while comp
+00001620: 7574 696e 6720 4d65 7368 2069 7320 7468  uting Mesh is th
+00001630: 6520 6765 6f20 7265 6665 7265 6e63 696e  e geo referencin
+00001640: 6720 7472 616e 7366 6f72 6d61 7469 6f6e  g transformation
+00001650: 206d 6174 7269 782e 0a0a 2d20 5768 656e   matrix...- When
+00001660: 2074 6865 2073 697a 6520 6f66 2074 6865   the size of the
+00001670: 206d 6573 6820 616e 6420 7468 6520 6772   mesh and the gr
+00001680: 6964 2061 7265 2070 726f 7669 6465 6420  id are provided 
+00001690: 696e 2072 6567 756c 6172 2064 696d 656e  in regular dimen
+000016a0: 7369 6f6e 2c20 7468 656e 2074 6865 2070  sion, then the p
+000016b0: 6f73 6974 696f 6e20 7768 6572 6520 7468  osition where th
+000016c0: 6520 6d65 7368 2069 7320 746f 2062 6520  e mesh is to be 
+000016d0: 6472 6177 6e20 6973 0a65 7874 7261 6374  drawn is.extract
+000016e0: 6564 2066 726f 6d20 7468 6520 6166 6669  ed from the affi
+000016f0: 6e65 2074 7261 6e73 666f 726d 2061 6e64  ne transform and
+00001700: 2063 6f6e 7665 7273 696f 6e20 6f66 2074   conversion of t
+00001710: 6865 2064 696d 656e 7369 6f6e 2074 6f20  he dimension to 
+00001720: 7265 6665 7265 6e63 6520 636f 6f72 6469  reference coordi
+00001730: 6e61 7465 2073 7973 7465 6d20 6973 2064  nate system is d
+00001740: 6f6e 6520 7769 7468 2074 6865 2068 656c  one with the hel
+00001750: 700a 6f66 2070 6978 656c 2072 6573 6f6c  p.of pixel resol
+00001760: 7574 696f 6e20 7072 6573 656e 7420 696e  ution present in
+00001770: 2061 6666 696e 6520 7472 616e 7366 6f72   affine transfor
+00001780: 6d0a 0a20 2020 2020 2020 206d 6573 6820  m..        mesh 
+00001790: 3d20 6d65 7368 5f66 726f 6d5f 6765 6f5f  = mesh_from_geo_
+000017a0: 7472 616e 7366 6f72 6d28 0a20 2020 2020  transform(.     
+000017b0: 2020 206d 6573 685f 7369 7a65 3d28 772c     mesh_size=(w,
+000017c0: 2068 292c 0a20 2020 2020 2020 2074 7261   h),.        tra
+000017d0: 6e73 666f 726d 3d74 7261 6e73 6672 6f6d  nsform=transfrom
+000017e0: 6174 696f 6e5f 6d61 7472 6978 2c20 0a20  ation_matrix, . 
+000017f0: 2020 2020 2020 2067 7269 645f 7369 7a65         grid_size
+00001800: 3d28 772c 2068 290a 2020 2020 2020 2020  =(w, h).        
+00001810: 290a 0a20 2020 205f 5468 6973 2077 696c  )..    _This wil
+00001820: 6c20 6765 6e65 7261 7465 2061 202a 4d65  l generate a *Me
+00001830: 7368 2a20 6f66 2064 696d 656e 7369 6f6e  sh* of dimension
+00001840: 202a 2877 2c20 6829 2a20 7768 6963 6820   *(w, h)* which 
+00001850: 7769 6c6c 2068 6176 6520 2a47 7269 642a  will have *Grid*
+00001860: 206f 6620 6469 6d65 6e73 696f 6e20 2a28   of dimension *(
+00001870: 772c 2068 292a 2c20 0a77 6869 6368 2077  w, h)*, .which w
+00001880: 696c 6c20 6265 2062 6f75 6e64 6564 2077  ill be bounded w
+00001890: 6974 6869 6e20 7468 6520 7265 6769 6f6e  ithin the region
+000018a0: 202a 7472 616e 7366 6f72 6d20 2a20 286d   *transform * (m
+000018b0: 6573 685f 7369 7a65 292a 5f0a 0a2d 2057  esh_size)*_..- W
+000018c0: 6865 6e20 7468 6520 626f 756e 6473 206f  hen the bounds o
+000018d0: 6620 6d65 7368 2061 7265 2070 6173 7365  f mesh are passe
+000018e0: 642c 2054 6865 2074 7261 6e73 666f 726d  d, The transform
+000018f0: 6174 696f 6e20 6d61 7472 6978 2066 6f72  ation matrix for
+00001900: 2074 6865 206d 6573 6820 6861 7665 2074   the mesh have t
+00001910: 6f20 6265 2063 6f6e 7374 7275 6374 6564  o be constructed
+00001920: 2065 7870 6c69 6369 746c 792c 2074 6865   explicitly, the
+00001930: 2077 6964 7468 2061 6e64 0a68 6569 6768   width and.heigh
+00001940: 7420 6172 6520 636f 6d70 7574 6564 2069  t are computed i
+00001950: 6e74 6572 6e61 6c6c 7920 6672 6f6d 2074  nternally from t
+00001960: 6865 2067 6976 656e 2074 7261 6e73 666f  he given transfo
+00001970: 726d 6174 696f 6e0a 0a20 2020 2020 2020  rmation..       
+00001980: 2074 7261 6e73 6672 6f6d 6174 696f 6e5f   transfromation_
+00001990: 6d61 7472 6978 203d 2067 6574 5f61 6666  matrix = get_aff
+000019a0: 696e 655f 7472 616e 7366 6f72 6d28 0a20  ine_transform(. 
+000019b0: 2020 2020 2020 206d 6573 685f 626f 756e         mesh_boun
+000019c0: 6473 5b30 5d2c 0a20 2020 2020 2020 206d  ds[0],.        m
+000019d0: 6573 685f 626f 756e 6473 5b2d 315d 2c0a  esh_bounds[-1],.
+000019e0: 2020 2020 2020 2020 2a67 6574 5f70 6978          *get_pix
+000019f0: 656c 5f72 6573 6f6c 7574 696f 6e28 696d  el_resolution(im
+00001a00: 6167 652e 7472 616e 7366 6f72 6d29 0a20  age.transform). 
+00001a10: 2020 2020 2020 2029 200a 2020 2020 2020         ) .      
+00001a20: 2020 0a20 2020 2020 2020 206d 6573 6820    .        mesh 
+00001a30: 3d20 6d65 7368 5f66 726f 6d5f 6765 6f5f  = mesh_from_geo_
+00001a40: 7472 616e 7366 6f72 6d28 0a20 2020 2020  transform(.     
+00001a50: 2020 2020 2020 2067 7269 645f 7369 7a65         grid_size
+00001a60: 3d28 772c 2068 292c 0a20 2020 2020 2020  =(w, h),.       
+00001a70: 2020 2020 2074 7261 6e73 666f 726d 3d74       transform=t
+00001a80: 7261 6e73 6672 6f6d 6174 696f 6e5f 6d61  ransfromation_ma
+00001a90: 7472 6978 2c0a 2020 2020 2020 2020 2020  trix,.          
+00001aa0: 2020 6d65 7368 5f62 6f75 6e64 733d 6d65    mesh_bounds=me
+00001ab0: 7368 5f62 6f75 6e64 732c 0a20 2020 2020  sh_bounds,.     
+00001ac0: 2020 2029 0a0a 2323 204f 7574 7075 740a     )..## Output.
+00001ad0: 0a47 7269 6420 6361 6e20 6361 6e20 6163  .Grid can can ac
+00001ae0: 6365 7373 6564 2062 7920 7468 6520 6578  cessed by the ex
+00001af0: 7465 6e74 2829 2063 616c 6c20 7768 6963  tent() call whic
+00001b00: 6820 6973 2061 2047 656e 6572 6174 6f72  h is a Generator
+00001b10: 2066 6f72 2070 726f 7669 6469 6e67 2069   for providing i
+00001b20: 6e64 6976 6964 7561 6c20 6772 6964 2061  ndividual grid a
+00001b30: 6c6f 6e67 2077 6974 6820 7468 6520 696e  long with the in
+00001b40: 666f 726d 6174 696f 6e20 6173 736f 6369  formation associ
+00001b50: 6174 6564 200a 7769 7468 2074 6865 2067  ated .with the g
+00001b60: 7269 640a 0a20 2020 206d 6573 685f 6f76  rid..    mesh_ov
+00001b70: 6572 6c61 7020 3d20 6d65 7368 5f66 726f  erlap = mesh_fro
+00001b80: 6d5f 6765 6f5f 7472 616e 7366 6f72 6d28  m_geo_transform(
+00001b90: 6d65 7368 5f73 697a 653d 2831 3030 3030  mesh_size=(10000
+00001ba0: 2c20 3130 3030 302c 2033 292c 2074 7261  , 10000, 3), tra
+00001bb0: 6e73 666f 726d 3d61 6666 696e 655f 7472  nsform=affine_tr
+00001bc0: 616e 7366 6f72 6d2c 0a20 2020 2067 7269  ansform,.    gri
+00001bd0: 645f 7369 7a65 3d28 3235 3837 2c20 3330  d_size=(2587, 30
+00001be0: 3030 2c20 3329 290a 2020 2020 0a20 2020  00, 3)).    .   
+00001bf0: 2066 6f72 2067 7269 6420 696e 206d 6573   for grid in mes
+00001c00: 682e 6578 7465 6e74 2829 3a0a 2020 2020  h.extent():.    
+00001c10: 2020 2020 7072 696e 7428 6772 6964 290a      print(grid).
+00001c20: 2020 2020 2020 2020 2e2e 2e2e 2e0a 0a49          .......I
+00001c30: 6620 7468 6520 636f 6f72 6469 6e61 7465  f the coordinate
+00001c40: 2073 7973 7465 6d20 6176 6169 6c61 626c   system availabl
+00001c50: 6520 6973 2064 6966 6665 7265 6e74 2074  e is different t
+00001c60: 6861 6e20 7468 6520 6f6e 6573 206c 6973  han the ones lis
+00001c70: 7465 6420 5b68 6572 655d 2823 576f 726b  ted [here](#Work
+00001c80: 696e 672d 436f 6f72 6469 6e61 7465 2d53  ing-Coordinate-S
+00001c90: 7973 7465 6d29 2c20 7468 656e 2074 6865  ystem), then the
+00001ca0: 2063 6f6f 7264 696e 6174 6520 6d75 7374   coordinate must
+00001cb0: 2062 6520 7265 7072 6f6a 6563 7465 6420   be reprojected 
+00001cc0: 6265 666f 7265 200a 6d65 7368 2063 6f6d  before .mesh com
+00001cd0: 7075 7461 7469 6f6e 0a20 2020 200a 2020  putation.    .  
+00001ce0: 2020 7472 616e 7366 6f72 6d3d 6765 6f5f    transform=geo_
+00001cf0: 7472 616e 7366 6f72 6d5f 746f 5f32 3631  transform_to_261
+00001d00: 3930 2877 2c20 682c 2061 7262 6974 7261  90(w, h, arbitra
+00001d10: 7279 5f69 6d61 6765 5f63 6f6f 7264 696e  ry_image_coordin
+00001d20: 6174 655f 7379 7374 656d 2e62 6f75 6e64  ate_system.bound
+00001d30: 732c 0a20 2020 2020 2020 2020 6172 6269  s,.         arbi
+00001d40: 7472 6172 795f 696d 6167 655f 636f 6f72  trary_image_coor
+00001d50: 6469 6e61 7465 5f73 7973 7465 6d2e 6372  dinate_system.cr
+00001d60: 7329 2c0a 0a49 6620 7769 6474 6820 616e  s),..If width an
+00001d70: 6420 6865 6967 6874 206f 6620 7468 6520  d height of the 
+00001d80: 626f 756e 6473 2061 7265 206e 6f74 206b  bounds are not k
+00001d90: 6e6f 776e 2c20 746f 2063 616c 6375 6c61  nown, to calcula
+00001da0: 7465 2069 742c 2075 7365 0a0a 2020 2020  te it, use..    
+00001db0: 636f 6d70 7574 655f 6469 6d65 6e73 696f  compute_dimensio
+00001dc0: 6e28 6172 6269 7472 6172 795f 696d 6167  n(arbitrary_imag
+00001dd0: 655f 636f 6f72 6469 6e61 7465 5f73 7973  e_coordinate_sys
+00001de0: 7465 6d2e 626f 756e 6473 2c20 7069 7865  tem.bounds, pixe
+00001df0: 6c5f 7265 736f 6c75 7469 6f6e 290a 0a20  l_resolution).. 
+00001e00: 2020 200a 2323 2057 6f72 6b69 6e67 2043     .## Working C
+00001e10: 6f6f 7264 696e 6174 6520 5379 7374 656d  oordinate System
+00001e20: 0a31 2e20 4550 5347 3a32 3639 3130 0a32  .1. EPSG:26910.2
+00001e30: 2e20 4550 5347 3a32 3639 3836 2020 2020  . EPSG:26986    
+00001e40: 200a 0a                                   ..
```

### Comparing `stitch_n_split-0.1.1/README.md` & `stitch_n_split-0.1.2/stitch_n_split.egg-info/PKG-INFO`

 * *Files 13% similar despite different names*

```diff
@@ -1,185 +1,200 @@
-# stitchNsplit
-![GitHub](https://img.shields.io/github/license/cypherics/ShapeMerge)
-![Python](https://img.shields.io/badge/python-v3.6+-blue.svg)
-![Contributions welcome](https://img.shields.io/badge/contributions-welcome-orange.svg)
-
-A Python Library To Stitch And Split Images for any dimension, computing grid and windows over the specified dimension
-
-## Installation
-    
-- Installing rasterio dependency using conda
-        
-        conda install -c conda-forge rasterio
-
-- Installing rasterio dependency from [pip](https://rasterio.readthedocs.io/en/latest/installation.html)
-         
-          
-    pip install stitch_n_split
-    
-    
-## Split
-
-Split Operation can be performed on two sets of Imagery, <b>Geo Referenced</b> and <b>Non Geo Referenced</b>
-The Windows formed for the split operation are adjusted based on the split_size and img_size, whenever 
-<code>img_size%split_size != 0</code> is true, this suggests that there will be overlapping windows. 
-Overlapping windows are generated only when required. 
-
-<table>
-  <tr>
-    <td>Original Image</td>
-     <td>Images After Split</td>
-  </tr>
-  <tr>
-    <td><img src="https://user-images.githubusercontent.com/24665570/89780629-73256d80-db2f-11ea-9db5-ee50573d8c6d.png" width=600 height=200></td>
-    <td><img src="https://user-images.githubusercontent.com/24665570/89780554-483b1980-db2f-11ea-8830-d13c728eadcd.png" width=2000 height=200></td>
-  </tr>
- </table>
- 
-- ##### Geo Referenced
-    GeoReferenced Imagery have reference coordinate information stored in them.
-This is taken into account while splitting geo referenced imagery, assigning correct reference information to the cut images,
-thus preserving the over all reference information 
-    > Geo Reference imagery must be of [tiff](https://en.wikipedia.org/wiki/TIFF) format.
-
-- ##### Non GeoReferenced 
-    For Non GeoReferenced the split is straight forward, it gets cropped in to specified dimension
-
-*_Split Entire Directory_:*
-```python
-from stitch_n_split.split.images import SplitGeo
-split = SplitGeo(split_size=(124, 267), img_size=(512, 512))
-split.perform_directory_split("dir_path")
-```
-Performing Split over individual images can be done by accessing split as an iterator.
-
-*_Split Iterator using window_:*
-```python
-from stitch_n_split.split.images import SplitGeo
-from stitch_n_split.utility import open_image
-
-split = SplitGeo(split_size=(124, 267), img_size=(512, 512))
-image = open_image("img_path", is_geo_reference=True)
-for win_number, window in split:
-    split_image = split.window_split(image, window)
-    # perform operation ....
-```
-
-## Stitch 
-
-While Performing Stitch if there are any overlapping window, those windows are merged seamlessly, without
-hampering the pixel information and image dimension
-
-Every Split image can be associated to the original image by the *window number* or the *window* itself.
-
-*_Using stitchNsplit together_:*
-```python
-from stitch_n_split.stitch.images import Stitch
-from stitch_n_split.utility import save_image
-from stitch_n_split.split.images import SplitNonGeo
-from stitch_n_split.utility import open_image
-import numpy as np
-
-split = SplitNonGeo(split_size=(124, 267), img_size=(512, 512, 3))
-image = open_image("img_path")
-stitched_image = np.zeros((512, 512, 3))
-
-for win_number, window in split:
-    split_image = split.window_split(image, win_number)
-    # perform operation ....
-    stitched_image = Stitch.stitch_image(split_image, stitched_image, window)
-save_image("path_to_save", stitched_image)
-``` 
-  
-## Mesh Computing
-
-![stitchNsplit](https://user-images.githubusercontent.com/24665570/89779619-6e5fba00-db2d-11ea-8705-d8ba781f72ea.gif)
-
-- #### OverLapping Grid
-    
-    The grid creation process assumes the provided grid size might not be evenly distributed over the mesh size and
-    whenever such situation arises, the grid adjusts its position without compromising the grid size, thus generating 
-    overlapping grid in the mesh
-    
-- #### NonOverlapping Grid
-    
-    No matter what the provided grid size, the goal is to find a grid size which can be evenly distributed over the
-    provided mesh size, if the provided sizes presents the possibility of a overlap then the size of the 
-    grid is adjusted, to provide non overlapping grid
-    
-    
-<table>
-  <tr>
-    <td>Mesh with Overlapping Grid</td>
-     <td>Mesh with Non Overlapping Grid</td>
-  </tr>
-  <tr>
-    <td><img src="https://user-images.githubusercontent.com/24665570/89773311-49654a00-db21-11ea-9955-f1230d432989.png" width=812 height=350></td>
-    <td><img src="https://user-images.githubusercontent.com/24665570/89773649-f8a22100-db21-11ea-8bcc-deeb46939a51.png" width=812 height=350></td>
-  </tr>
- </table>
- 
- _*mesh size = (10000, 10000)*,  *grid size = (2587, 3000)* were used for above example_
-
-The number of grid generated in both cases are the same, the only difference is, the image in the left doesn't compromises the grid size when it encounters
-an overlap, where as the image on the right adjusts its grid size to <code>mesh size // (mesh size / grid size)</code> 
-to avoid any overlap
-
-
-#### Mesh Computing From geo-referenced image
-The One mandatory Parameter while computing Mesh is the geo referencing transformation matrix.
-
-- When the size of the mesh and the grid are provided in regular dimension, then the position where the mesh is to be drawn is
-extracted from the affine transform and conversion of the dimension to reference coordinate system is done with the help
-of pixel resolution present in affine transform
-
-        mesh = mesh_from_geo_transform(
-        mesh_size=(w, h),
-        transform=transfromation_matrix, 
-        grid_size=(w, h)
-        )
-
-    _This will generate a *Mesh* of dimension *(w, h)* which will have *Grid* of dimension *(w, h)*, 
-which will be bounded within the region *transform * (mesh_size)*_
-
-- When the bounds of mesh are passed, The transformation matrix for the mesh have to be constructed explicitly, the width and
-height are computed internally from the given transformation
-
-        transfromation_matrix = get_affine_transform(
-        mesh_bounds[0],
-        mesh_bounds[-1],
-        *get_pixel_resolution(image.transform)
-        ) 
-        
-        mesh = mesh_from_geo_transform(
-            grid_size=(w, h),
-            transform=transfromation_matrix,
-            mesh_bounds=mesh_bounds,
-        )
-
-## Output
-
-Grid can can accessed by the extent() call which is a Generator for providing individual grid along with the information associated 
-with the grid
-
-    mesh_overlap = mesh_from_geo_transform(mesh_size=(10000, 10000, 3), transform=affine_transform,
-    grid_size=(2587, 3000, 3))
-    
-    for grid in mesh.extent():
-        print(grid)
-        .....
-
-If the coordinate system available is different than the ones listed [here](#Working-Coordinate-System), then the coordinate must be reprojected before 
-mesh computation
-    
-    transform=geo_transform_to_26190(w, h, arbitrary_image_coordinate_system.bounds,
-         arbitrary_image_coordinate_system.crs),
-
-If width and height of the bounds are not known, to calculate it, use
-
-    compute_dimension(arbitrary_image_coordinate_system.bounds, pixel_resolution)
-
-    
-## Working Coordinate System
-1. EPSG:26910
-2. EPSG:26986     
-
+Metadata-Version: 2.1
+Name: stitch-n-split
+Version: 0.1.2
+Summary: Library for stitching and spliting
+Author: Fuzail Palnak
+Author-email: fuzailpalnak@gmail.com
+Keywords: GIS Rasterio Sticth Split Mesh Grid Geo Reference
+Classifier: Programming Language :: Python :: 3
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Operating System :: OS Independent
+Requires-Python: ~=3.3
+Description-Content-Type: text/markdown
+License-File: LICENSE
+
+# stitchNsplit
+![GitHub](https://img.shields.io/github/license/cypherics/ShapeMerge)
+![Python](https://img.shields.io/badge/python-v3.6+-blue.svg)
+![Contributions welcome](https://img.shields.io/badge/contributions-welcome-orange.svg)
+![Downloads](https://pepy.tech/badge/stitch-n-split)
+
+A Python Library To Stitch And Split Images for any dimension, computing grid and windows over the specified dimension
+
+## Installation
+
+    pip install stitch-n-split
+    
+    
+- Installing rasterio dependency using conda
+        
+        conda install -c conda-forge rasterio
+
+- Installing rasterio dependency from [pip](https://rasterio.readthedocs.io/en/latest/installation.html)
+            
+    
+## Split
+
+Split Operation can be performed on two sets of Imagery, <b>Geo Referenced</b> and <b>Non Geo Referenced</b>
+The Windows formed for the split operation are adjusted based on the split_size and img_size, whenever 
+<code>img_size%split_size != 0</code> is true, this suggests that there will be overlapping windows. 
+Overlapping windows are generated only when required. 
+
+<table>
+  <tr>
+    <td>Original Image</td>
+     <td>Images After Split</td>
+  </tr>
+  <tr>
+    <td><img src="https://user-images.githubusercontent.com/24665570/89780629-73256d80-db2f-11ea-9db5-ee50573d8c6d.png" width=600 height=200></td>
+    <td><img src="https://user-images.githubusercontent.com/24665570/89780554-483b1980-db2f-11ea-8830-d13c728eadcd.png" width=2000 height=200></td>
+  </tr>
+ </table>
+ 
+- ##### Geo Referenced
+    GeoReferenced Imagery have reference coordinate information stored in them.
+This is taken into account while splitting geo referenced imagery, assigning correct reference information to the cut images,
+thus preserving the over all reference information 
+    > Geo Reference imagery must be of [tiff](https://en.wikipedia.org/wiki/TIFF) format.
+
+- ##### Non GeoReferenced 
+    For Non GeoReferenced the split is straight forward, it gets cropped in to specified dimension
+
+*_Split Entire Directory_:*
+```python
+from stitch_n_split.split.images import SplitGeo
+split = SplitGeo(split_size=(124, 267), img_size=(512, 512))
+split.perform_directory_split("dir_path")
+```
+Performing Split over individual images can be done by accessing split as an iterator.
+
+*_Split Iterator using window_:*
+```python
+from stitch_n_split.split.images import SplitGeo
+from stitch_n_split.utility import open_image
+
+split = SplitGeo(split_size=(124, 267), img_size=(512, 512))
+image = open_image("img_path", is_geo_reference=True)
+for win_number, window in split:
+    split_image = split.window_split(image, window)
+    # perform operation ....
+```
+
+## Stitch 
+
+While Performing Stitch if there are any overlapping window, those windows are merged seamlessly, without
+hampering the pixel information and image dimension
+
+Every Split image can be associated to the original image by the *window number* or the *window* itself.
+
+*_Using stitchNsplit together_:*
+```python
+from stitch_n_split.stitch.images import Stitch
+from stitch_n_split.utility import save_image
+from stitch_n_split.split.images import SplitNonGeo
+from stitch_n_split.utility import open_image
+import numpy as np
+
+split = SplitNonGeo(split_size=(124, 267), img_size=(512, 512, 3))
+image = open_image("img_path")
+stitched_image = np.zeros((512, 512, 3))
+
+for win_number, window in split:
+    split_image = split.window_split(image, win_number)
+    # perform operation ....
+    stitched_image = Stitch.stitch_image(split_image, stitched_image, window)
+save_image("path_to_save", stitched_image)
+``` 
+  
+## Mesh Computing
+
+![stitchNsplit](https://user-images.githubusercontent.com/24665570/89779619-6e5fba00-db2d-11ea-8705-d8ba781f72ea.gif)
+
+- #### OverLapping Grid
+    
+    The grid creation process assumes the provided grid size might not be evenly distributed over the mesh size and
+    whenever such situation arises, the grid adjusts its position without compromising the grid size, thus generating 
+    overlapping grid in the mesh
+    
+- #### NonOverlapping Grid
+    
+    No matter what the provided grid size, the goal is to find a grid size which can be evenly distributed over the
+    provided mesh size, if the provided sizes presents the possibility of a overlap then the size of the 
+    grid is adjusted, to provide non overlapping grid
+    
+    
+<table>
+  <tr>
+    <td>Mesh with Overlapping Grid</td>
+     <td>Mesh with Non Overlapping Grid</td>
+  </tr>
+  <tr>
+    <td><img src="https://user-images.githubusercontent.com/24665570/89773311-49654a00-db21-11ea-9955-f1230d432989.png" width=812 height=350></td>
+    <td><img src="https://user-images.githubusercontent.com/24665570/89773649-f8a22100-db21-11ea-8bcc-deeb46939a51.png" width=812 height=350></td>
+  </tr>
+ </table>
+ 
+ _*mesh size = (10000, 10000)*,  *grid size = (2587, 3000)* were used for above example_
+
+The number of grid generated in both cases are the same, the only difference is, the image in the left doesn't compromises the grid size when it encounters
+an overlap, where as the image on the right adjusts its grid size to <code>mesh size // (mesh size / grid size)</code> 
+to avoid any overlap
+
+
+#### Mesh Computing From geo-referenced image
+The One mandatory Parameter while computing Mesh is the geo referencing transformation matrix.
+
+- When the size of the mesh and the grid are provided in regular dimension, then the position where the mesh is to be drawn is
+extracted from the affine transform and conversion of the dimension to reference coordinate system is done with the help
+of pixel resolution present in affine transform
+
+        mesh = mesh_from_geo_transform(
+        mesh_size=(w, h),
+        transform=transfromation_matrix, 
+        grid_size=(w, h)
+        )
+
+    _This will generate a *Mesh* of dimension *(w, h)* which will have *Grid* of dimension *(w, h)*, 
+which will be bounded within the region *transform * (mesh_size)*_
+
+- When the bounds of mesh are passed, The transformation matrix for the mesh have to be constructed explicitly, the width and
+height are computed internally from the given transformation
+
+        transfromation_matrix = get_affine_transform(
+        mesh_bounds[0],
+        mesh_bounds[-1],
+        *get_pixel_resolution(image.transform)
+        ) 
+        
+        mesh = mesh_from_geo_transform(
+            grid_size=(w, h),
+            transform=transfromation_matrix,
+            mesh_bounds=mesh_bounds,
+        )
+
+## Output
+
+Grid can can accessed by the extent() call which is a Generator for providing individual grid along with the information associated 
+with the grid
+
+    mesh_overlap = mesh_from_geo_transform(mesh_size=(10000, 10000, 3), transform=affine_transform,
+    grid_size=(2587, 3000, 3))
+    
+    for grid in mesh.extent():
+        print(grid)
+        .....
+
+If the coordinate system available is different than the ones listed [here](#Working-Coordinate-System), then the coordinate must be reprojected before 
+mesh computation
+    
+    transform=geo_transform_to_26190(w, h, arbitrary_image_coordinate_system.bounds,
+         arbitrary_image_coordinate_system.crs),
+
+If width and height of the bounds are not known, to calculate it, use
+
+    compute_dimension(arbitrary_image_coordinate_system.bounds, pixel_resolution)
+
+    
+## Working Coordinate System
+1. EPSG:26910
+2. EPSG:26986     
+
```

### Comparing `stitch_n_split-0.1.1/stitch_n_split/geo_info.py` & `stitch_n_split-0.1.2/stitch_n_split/geo_info.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,104 +1,104 @@
-import numpy as np
-import math
-
-import rasterio
-from affine import Affine
-from rasterio.transform import rowcol
-
-from rasterio.warp import transform_bounds
-
-
-def get_window(extent: tuple, transform: Affine) -> (tuple, tuple):
-    row_start, col_start = rowcol(transform, extent[0], extent[-1], op=int)
-
-    row_stop, col_stop = rowcol(transform, extent[2], extent[1], op=int)
-
-    return (row_start, row_stop), (col_start, col_stop)
-
-
-def get_mesh_transform(width: int, height: int, transform: Affine) -> Affine:
-    bounds = compute_bounds(width, height, transform)
-    mesh_transform = get_affine_transform(
-        bounds[0], bounds[-1], *get_pixel_resolution(transform)
-    )
-    return mesh_transform
-
-
-def get_affine_transform(
-    min_x: float, max_y: float, pixel_width: float, pixel_height: float
-) -> Affine:
-    """
-
-    :param min_x:
-    :param max_y:
-    :param pixel_width: width of pixels in the units of its coordinate reference system
-    :param pixel_height: height of pixels in the units of its coordinate reference system
-    :return:
-    """
-    return Affine.translation(min_x, max_y) * Affine.scale(pixel_width, -pixel_height)
-
-
-def compute_bounds(width, height, transform):
-    """
-    Computes the bounds of w x h given the transform
-    :param width:
-    :param height:
-    :param transform:
-    :return: bounds for w x h , format bounds returned in (w, s, e, n)
-    """
-    bounds = rasterio.transform.array_bounds(height, width, transform)
-    return bounds
-
-
-def geo_transform_to_26190(width, height, bounds, crs) -> Affine:
-    west, south, east, north = transform_bounds(crs, {"init": "epsg:26910"}, *bounds)
-    return rasterio.transform.from_bounds(west, south, east, north, width, height)
-
-
-def re_project_crs_to_26190(bounds, from_crs) -> (float, float, float, float):
-    west, south, east, north = transform_bounds(
-        from_crs, {"init": "epsg:26910"}, *bounds
-    )
-    return west, south, east, north
-
-
-def re_project_from_26190(bounds, to_crs) -> (float, float, float, float):
-    west, south, east, north = transform_bounds({"init": "epsg:26910"}, to_crs, *bounds)
-    return west, south, east, north
-
-
-def get_pixel_resolution(transform: Affine) -> (float, float):
-    """
-    Pixel Resolution
-    :param transform:
-    :return: width and height of pixels in the units of its coordinate reference system extracted from
-    transformation of image
-    """
-    return transform[0], -transform[4]
-
-
-def compute_num_of_col_and_ros(grid_size: tuple, mesh_size: tuple):
-    """
-    num_col grids will fit in x direction
-    num_row grids will fit in Y direction
-
-    Computes How many Number of grids to draw
-    :return: number of grid in x direction, number of grid in y direction
-    """
-    num_col = int(np.ceil(mesh_size[0] / grid_size[0]))
-    num_row = int(np.ceil(mesh_size[1] / grid_size[1]))
-
-    return num_col, num_row
-
-
-def compute_dimension(bounds, pixel_resolution: tuple):
-    """
-
-    :param bounds:
-    :param pixel_resolution: width and height of pixels in the units of its coordinate reference system extracted from
-    transformation of image
-    :return:
-    """
-    output_width = int(math.ceil((bounds[2] - bounds[0]) / pixel_resolution[0]))
-    output_height = int(math.ceil((bounds[3] - bounds[1]) / pixel_resolution[1]))
-    return output_width, output_height
+import numpy as np
+import math
+
+import rasterio
+from affine import Affine
+from rasterio.transform import rowcol
+
+from rasterio.warp import transform_bounds
+
+
+def get_window(extent: tuple, transform: Affine) -> (tuple, tuple):
+    row_start, col_start = rowcol(transform, extent[0], extent[-1], op=int)
+
+    row_stop, col_stop = rowcol(transform, extent[2], extent[1], op=int)
+
+    return (row_start, row_stop), (col_start, col_stop)
+
+
+def get_mesh_transform(width: int, height: int, transform: Affine) -> Affine:
+    bounds = compute_bounds(width, height, transform)
+    mesh_transform = get_affine_transform(
+        bounds[0], bounds[-1], *get_pixel_resolution(transform)
+    )
+    return mesh_transform
+
+
+def get_affine_transform(
+    min_x: float, max_y: float, pixel_width: float, pixel_height: float
+) -> Affine:
+    """
+
+    :param min_x:
+    :param max_y:
+    :param pixel_width: width of pixels in the units of its coordinate reference system
+    :param pixel_height: height of pixels in the units of its coordinate reference system
+    :return:
+    """
+    return Affine.translation(min_x, max_y) * Affine.scale(pixel_width, -pixel_height)
+
+
+def compute_bounds(width, height, transform):
+    """
+    Computes the bounds of w x h given the transform
+    :param width:
+    :param height:
+    :param transform:
+    :return: bounds for w x h , format bounds returned in (w, s, e, n)
+    """
+    bounds = rasterio.transform.array_bounds(height, width, transform)
+    return bounds
+
+
+def geo_transform_to_26190(width, height, bounds, crs) -> Affine:
+    west, south, east, north = transform_bounds(crs, {"init": "epsg:26910"}, *bounds)
+    return rasterio.transform.from_bounds(west, south, east, north, width, height)
+
+
+def re_project_crs_to_26190(bounds, from_crs) -> (float, float, float, float):
+    west, south, east, north = transform_bounds(
+        from_crs, {"init": "epsg:26910"}, *bounds
+    )
+    return west, south, east, north
+
+
+def re_project_from_26190(bounds, to_crs) -> (float, float, float, float):
+    west, south, east, north = transform_bounds({"init": "epsg:26910"}, to_crs, *bounds)
+    return west, south, east, north
+
+
+def get_pixel_resolution(transform: Affine) -> (float, float):
+    """
+    Pixel Resolution
+    :param transform:
+    :return: width and height of pixels in the units of its coordinate reference system extracted from
+    transformation of image
+    """
+    return transform[0], -transform[4]
+
+
+def compute_num_of_col_and_ros(grid_size: tuple, mesh_size: tuple):
+    """
+    num_col grids will fit in x direction
+    num_row grids will fit in Y direction
+
+    Computes How many Number of grids to draw
+    :return: number of grid in x direction, number of grid in y direction
+    """
+    num_col = int(np.ceil(mesh_size[0] / grid_size[0]))
+    num_row = int(np.ceil(mesh_size[1] / grid_size[1]))
+
+    return num_col, num_row
+
+
+def compute_dimension(bounds, pixel_resolution: tuple):
+    """
+
+    :param bounds:
+    :param pixel_resolution: width and height of pixels in the units of its coordinate reference system extracted from
+    transformation of image
+    :return:
+    """
+    output_width = int(math.ceil((bounds[2] - bounds[0]) / pixel_resolution[0]))
+    output_height = int(math.ceil((bounds[3] - bounds[1]) / pixel_resolution[1]))
+    return output_width, output_height
```

### Comparing `stitch_n_split-0.1.1/stitch_n_split/split/images.py` & `stitch_n_split-0.1.2/stitch_n_split/split/images.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,184 +1,184 @@
-import os
-import numpy as np
-import time
-
-import rasterio
-
-from image_fragment.fragment import ImageFragment, Fragment
-from stitch_n_split.utility import make_save_dir, open_image, save_image, Printer
-
-
-class Split:
-    def __init__(self, split_size: tuple, img_size: tuple):
-        """
-
-        :param split_size: tuple(H x W X B), Size to split1 the Image in, typically smaller than img_size
-        :param img_size: tuple(H x W X B), Size on which split1 operation is to be performed
-        """
-        if split_size[0] > img_size[0] or split_size[1] > img_size[1]:
-            raise ValueError(
-                "Size to Split Can't Be Greater than Image, Given {},"
-                " Expected <= {}".format(split_size, (img_size[0], img_size[1]))
-            )
-        self.split_size = split_size
-        self.img_size = img_size
-
-        self.image_fragment = ImageFragment.image_fragment_3d(fragment_size=self.split_size, org_size=self.img_size)
-
-    def __len__(self):
-        return len(self.image_fragment.collection)
-
-    def __getitem__(self, index):
-        return index, self.image_fragment.collection[index]
-
-    def perform_directory_split(self, dir_path: str):
-        """
-
-        :param dir_path: dir path over which split1 is to be performed
-        :return:
-        """
-        raise NotImplementedError
-
-    def _split_image(self, image, image_save_path: str):
-        """
-
-        :param image:
-        :return:
-        """
-        raise NotImplementedError
-
-    def _extract_data(self, image, fragment: Fragment):
-        """
-
-        :param image:
-        :param fragment:
-        :return:
-        """
-        raise NotImplementedError
-
-    def window_split(self, image: np.ndarray, fragment: Fragment):
-        return self._extract_data(image, fragment)
-
-
-class SplitNonGeo(Split):
-    def __init__(self, split_size: tuple, img_size: tuple):
-        """
-
-        :param split_size: tuple(H x W), Size to split1 the Image in, typically smaller than img_size
-        :param img_size: tuple(H x W X 3), Size on which split1 operation is to be performed
-        """
-        super().__init__(split_size, img_size)
-
-    def perform_directory_split(self, dir_path: str):
-        """
-
-        :param dir_path: str
-        :return:
-        """
-        files = [file for file in os.listdir(dir_path)]
-        save_path = make_save_dir(
-            os.getcwd(), os.path.join("stitchNsplit_store", str(int(time.time())))
-        )
-        for iterator, file in enumerate(files):
-            file_path = os.path.join(dir_path, file)
-            Printer.print("Split In Progress {} / {}".format(iterator + 1, len(files)))
-            image = open_image(file_path)
-            w, h, b = image.shape
-            if b > 3:
-                raise ValueError(
-                    "For Non Geo Reference Imagery More than 3 band is not supported"
-                )
-            image_save_path = os.path.join(save_path, file)
-            self._split_image(image, image_save_path)
-
-    def _split_image(self, image: np.ndarray, image_save_path: str):
-        """
-
-        :param image:
-        :return:
-        """
-        for index, tiff_window in zip(
-            range(0, len(self.image_fragment.collection)), self.image_fragment.collection
-        ):
-            split_image = self._extract_data(image, tiff_window)
-            split_path = image_save_path.split(".")
-            save_path = "{}_{}.{}".format(split_path[0], index, split_path[-1])
-            save_image(save_path, split_image)
-
-    def _extract_data(self, image: np.ndarray, fragment: Fragment) -> np.ndarray:
-        """
-
-        :param image:
-        :param fragment:
-        :return:
-        """
-
-        return fragment.get_fragment_data(image)
-
-
-class SplitGeo(Split):
-    def __init__(self, split_size: tuple, img_size: tuple):
-        """
-
-        :param split_size: tuple(H x W), Size to split1 the Image in, typically smaller than img_size
-        :param img_size: tuple(H x W X 3), Size on which split1 operation is to be performed
-        """
-        super().__init__(split_size, img_size)
-
-    def perform_directory_split(self, dir_path: str):
-        """
-        The images in the directory must have .tif extention
-
-        :param dir_path: dir path over which split1 is to be performed
-        :return:
-        """
-        files = [file for file in os.listdir(dir_path)]
-        save_path = make_save_dir(
-            os.getcwd(), os.path.join("stitchNsplit_store", str(int(time.time())))
-        )
-        for iterator, file in enumerate(files):
-            Printer.print("Split In Progress {} / {}".format(iterator + 1, len(files)))
-
-            file_path = os.path.join(dir_path, file)
-
-            image = open_image(file_path, is_geo_reference=True)
-            image_save_path = os.path.join(save_path, file)
-            self._split_image(image, image_save_path)
-
-    def _split_image(self, image: rasterio.io.DatasetReader, image_save_path: str):
-        """
-
-        :param image: an image open via rasterio
-        :return:
-        """
-        for index, tiff_window in zip(
-            range(0, len(self.image_fragment.collection)), self.image_fragment.collection
-        ):
-            split_image, kwargs_split_image = self._extract_data(image, tiff_window)
-            split_path = image_save_path.split(".")
-            save_path = "{}_{}.{}".format(split_path[0], index, split_path[-1])
-            save_image(save_path, split_image, True, **kwargs_split_image)
-
-    def _extract_data(
-        self, image: rasterio.io.DatasetReader, fragment: Fragment
-    ) -> (np.ndarray, dict):
-        """
-        The operation of spiting the images and copying its geo reference is carried out using a sliding window
-        approach, where fragment specifies which part of the original image is to be processed
-
-        :param image:
-        :param fragment: the split1 size
-        :return:
-        """
-        split_image = image.read(window=fragment.position)
-
-        kwargs_split_image = image.meta.copy()
-        kwargs_split_image.update(
-            {
-                "height": self.split_size[0],
-                "width": self.split_size[1],
-                "transform": image.window_transform(fragment.position),
-            }
-        )
-
-        return split_image, kwargs_split_image
+import os
+import numpy as np
+import time
+
+import rasterio
+
+from image_fragment.fragment import ImageFragment, Fragment
+from stitch_n_split.utility import make_save_dir, open_image, save_image, Printer
+
+
+class Split:
+    def __init__(self, split_size: tuple, img_size: tuple):
+        """
+
+        :param split_size: tuple(H x W X B), Size to split1 the Image in, typically smaller than img_size
+        :param img_size: tuple(H x W X B), Size on which split1 operation is to be performed
+        """
+        if split_size[0] > img_size[0] or split_size[1] > img_size[1]:
+            raise ValueError(
+                "Size to Split Can't Be Greater than Image, Given {},"
+                " Expected <= {}".format(split_size, (img_size[0], img_size[1]))
+            )
+        self.split_size = split_size
+        self.img_size = img_size
+
+        self.image_fragment = ImageFragment.image_fragment_3d(fragment_size=self.split_size, org_size=self.img_size)
+
+    def __len__(self):
+        return len(self.image_fragment.collection)
+
+    def __getitem__(self, index):
+        return index, self.image_fragment.collection[index]
+
+    def perform_directory_split(self, dir_path: str):
+        """
+
+        :param dir_path: dir path over which split1 is to be performed
+        :return:
+        """
+        raise NotImplementedError
+
+    def _split_image(self, image, image_save_path: str):
+        """
+
+        :param image:
+        :return:
+        """
+        raise NotImplementedError
+
+    def _extract_data(self, image, fragment: Fragment):
+        """
+
+        :param image:
+        :param fragment:
+        :return:
+        """
+        raise NotImplementedError
+
+    def window_split(self, image: np.ndarray, fragment: Fragment):
+        return self._extract_data(image, fragment)
+
+
+class SplitNonGeo(Split):
+    def __init__(self, split_size: tuple, img_size: tuple):
+        """
+
+        :param split_size: tuple(H x W), Size to split1 the Image in, typically smaller than img_size
+        :param img_size: tuple(H x W X 3), Size on which split1 operation is to be performed
+        """
+        super().__init__(split_size, img_size)
+
+    def perform_directory_split(self, dir_path: str):
+        """
+
+        :param dir_path: str
+        :return:
+        """
+        files = [file for file in os.listdir(dir_path)]
+        save_path = make_save_dir(
+            os.getcwd(), os.path.join("stitchNsplit_store", str(int(time.time())))
+        )
+        for iterator, file in enumerate(files):
+            file_path = os.path.join(dir_path, file)
+            Printer.print("Split In Progress {} / {}".format(iterator + 1, len(files)))
+            image = open_image(file_path)
+            w, h, b = image.shape
+            if b > 3:
+                raise ValueError(
+                    "For Non Geo Reference Imagery More than 3 band is not supported"
+                )
+            image_save_path = os.path.join(save_path, file)
+            self._split_image(image, image_save_path)
+
+    def _split_image(self, image: np.ndarray, image_save_path: str):
+        """
+
+        :param image:
+        :return:
+        """
+        for index, tiff_window in zip(
+            range(0, len(self.image_fragment.collection)), self.image_fragment.collection
+        ):
+            split_image = self._extract_data(image, tiff_window)
+            split_path = image_save_path.split(".")
+            save_path = "{}_{}.{}".format(split_path[0], index, split_path[-1])
+            save_image(save_path, split_image)
+
+    def _extract_data(self, image: np.ndarray, fragment: Fragment) -> np.ndarray:
+        """
+
+        :param image:
+        :param fragment:
+        :return:
+        """
+
+        return fragment.get_fragment_data(image)
+
+
+class SplitGeo(Split):
+    def __init__(self, split_size: tuple, img_size: tuple):
+        """
+
+        :param split_size: tuple(H x W), Size to split1 the Image in, typically smaller than img_size
+        :param img_size: tuple(H x W X 3), Size on which split1 operation is to be performed
+        """
+        super().__init__(split_size, img_size)
+
+    def perform_directory_split(self, dir_path: str):
+        """
+        The images in the directory must have .tif extention
+
+        :param dir_path: dir path over which split1 is to be performed
+        :return:
+        """
+        files = [file for file in os.listdir(dir_path)]
+        save_path = make_save_dir(
+            os.getcwd(), os.path.join("stitchNsplit_store", str(int(time.time())))
+        )
+        for iterator, file in enumerate(files):
+            Printer.print("Split In Progress {} / {}".format(iterator + 1, len(files)))
+
+            file_path = os.path.join(dir_path, file)
+
+            image = open_image(file_path, is_geo_reference=True)
+            image_save_path = os.path.join(save_path, file)
+            self._split_image(image, image_save_path)
+
+    def _split_image(self, image: rasterio.io.DatasetReader, image_save_path: str):
+        """
+
+        :param image: an image open via rasterio
+        :return:
+        """
+        for index, tiff_window in zip(
+            range(0, len(self.image_fragment.collection)), self.image_fragment.collection
+        ):
+            split_image, kwargs_split_image = self._extract_data(image, tiff_window)
+            split_path = image_save_path.split(".")
+            save_path = "{}_{}.{}".format(split_path[0], index, split_path[-1])
+            save_image(save_path, split_image, True, **kwargs_split_image)
+
+    def _extract_data(
+        self, image: rasterio.io.DatasetReader, fragment: Fragment
+    ) -> (np.ndarray, dict):
+        """
+        The operation of spiting the images and copying its geo reference is carried out using a sliding window
+        approach, where fragment specifies which part of the original image is to be processed
+
+        :param image:
+        :param fragment: the split1 size
+        :return:
+        """
+        split_image = image.read(window=fragment.position)
+
+        kwargs_split_image = image.meta.copy()
+        kwargs_split_image.update(
+            {
+                "height": self.split_size[0],
+                "width": self.split_size[1],
+                "transform": image.window_transform(fragment.position),
+            }
+        )
+
+        return split_image, kwargs_split_image
```

### Comparing `stitch_n_split-0.1.1/stitch_n_split/split/mesh.py` & `stitch_n_split-0.1.2/stitch_n_split/split/mesh.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,301 +1,301 @@
-from dataclasses import dataclass
-from affine import Affine
-
-from stitch_n_split.geo_info import (
-    get_window,
-    get_pixel_resolution,
-    compute_dimension,
-    compute_num_of_col_and_ros,
-    compute_bounds,
-    get_mesh_transform,
-)
-
-
-class Mesh:
-    def _compute_step(self):
-        """
-        Compute Step in X and Y direction
-        :return:
-        """
-
-        raise NotImplementedError
-
-    @staticmethod
-    def _step_in_x(bound, normalizer=1):
-        """
-        Step Size to take in X
-        :param bound:
-        :param normalizer: How small the step to take, Larger the value smaller and smaller step it will take
-        :return:
-        """
-        return int(((bound[2] - bound[0]) / normalizer))
-
-    @staticmethod
-    def _step_in_y(bound, normalizer=1):
-        """
-        Step Size to take in Y
-        :param bound:
-        :param normalizer: How small the step to take, Larger the value smaller and smaller step it will take
-        :return:
-        """
-        return int(((bound[-1] - bound[1]) / normalizer))
-
-    def extent(self) -> dict:
-        """
-        Compute Mesh
-
-        :return:
-        """
-
-        raise NotImplementedError
-
-    def collate_data(self, extent: tuple) -> dict:
-        raise NotImplementedError
-
-
-@dataclass
-class ImageNonOverLapMesh(Mesh):
-    """
-    The Class will compute Grid bounded within complete_size to provide non overlapping grid,
-    The class will adjust the grid to evenly fit the number of tiles
-
-    Working of this class depends on the geo reference information of the image which acts as the starting point
-
-    The geo reference information to be present in the image is source_min_x, source_max_y and pixel resolution
-
-    Based on the geo reference information present in the image, compute grid of size
-    complete_size // int(np.ceil(dst_img_size / src_img_size) over complete_size
-
-    Given an starting image size, final size and its transform this will find all the grid of size
-    complete_size // int(np.ceil(dst_img_size / src_img_size) between the given complete size
-
-    The start position of grid and the step size of grid is computed from the transform info provided, usually
-    present in geo referenced image
-
-    NOTE - The COORDINATES MUST BE IN `EPSG:26910`
-    """
-
-    grid_size: tuple
-    mesh_size: tuple
-    sections: tuple
-    mesh_transform: Affine
-    mesh_bound: tuple
-
-    def _compute_step(self):
-        """
-        Compute Step in X and Y direction
-        :return:
-        """
-
-        step_in_x = self._step_in_x(self.mesh_bound, self.sections[0])
-        step_in_y = self._step_in_y(self.mesh_bound, self.sections[1])
-
-        return step_in_x, step_in_y
-
-    def extent(self) -> dict:
-        """
-        Compute non overlapping grid bounded within complete_size
-
-        :return:
-        """
-
-        (step_in_x, step_in_y) = self._compute_step()
-
-        for y in range(self.sections[1]):
-
-            for x in range(self.sections[0]):
-                tx_start = x * step_in_x + self.mesh_bound[0]
-
-                ty_start = y * step_in_y + self.mesh_bound[1]
-                tx_end = tx_start + step_in_x - 1
-                ty_end = ty_start + step_in_y - 1
-
-                yield self.collate_data((tx_start, ty_start, tx_end, ty_end))
-
-    def collate_data(self, extent: tuple) -> dict:
-        data = {
-            "extent": extent,
-            "window": get_window(extent, self.mesh_transform),
-            "mesh_size": self.mesh_size,
-        }
-        return data
-
-
-@dataclass
-class ImageOverLapMesh(Mesh):
-    """
-    The Class will compute Grid bounded within complete_size and if the provided grid size overlaps, the the class will
-    tune accordingly to provide overlapping grid, The class wont hamper the grid size in any manner, it will find all
-    the possible grid of size provided that could fit in complete_size
-
-    Working of this class depends on the geo reference information of the image which acts as the starting point
-
-    The geo reference information to be present in the image is source_min_x, source_max_y and pixel resolution
-
-    Based on the geo reference information present in the image, compute grid of size grid_size over complete_size
-
-    Given an starting image size, final size and its transform this will find all the grid of size image size
-    between the given complete size
-
-
-    The start position of grid and the step size of grid is computed from the transform info provided, usually
-    present in geo referenced image
-
-    NOTE - The COORDINATES MUST BE IN `EPSG:26910`
-
-    """
-
-    grid_size: tuple
-    mesh_size: tuple
-    sections: tuple
-    mesh_transform: Affine
-    mesh_bound: tuple
-    overlap_mesh_bound: tuple
-    buffer_mesh_bound: tuple
-
-    def _is_overlap_in_col_direction(self):
-        """
-        Check if there is any overlap in X direction
-        :return:
-        """
-        return True if self.mesh_size[0] % self.grid_size[0] else False
-
-    def _is_overlap_in_row_direction(self):
-        """
-        Check if there is any overlap in Y direction
-        :return:
-        """
-        return True if self.mesh_size[1] % self.grid_size[1] else False
-
-    def _compute_buffer_step(self):
-        """
-        To Compute overlapping steps it is essential to compute the the max_x and min_y not based on the complete
-        size but to extrapolate the grid size by number of tiles.
-
-        i.e grid_size = grid_size * tiles
-
-        :return:
-        """
-
-        buffered_step_in_x = self._step_in_x(self.buffer_mesh_bound, self.sections[0])
-        buffered_step_in_y = self._step_in_y(self.buffer_mesh_bound, self.sections[1])
-
-        return buffered_step_in_x, buffered_step_in_y
-
-    def _compute_overlap_step(self):
-        """
-        The overlapping step is nothing but keeping the coordinates in the bound provided in the form of
-        complete_img_size, the overlapping step is difference between complete_size  and grid_size
-
-        :return:
-        """
-        overlap_step_in_x = None
-        overlap_step_in_y = None
-
-        if self._is_overlap_in_col_direction():
-            overlap_step_in_x = self._step_in_x(self.overlap_mesh_bound)
-        if self._is_overlap_in_row_direction():
-            overlap_step_in_y = self._step_in_y(self.overlap_mesh_bound)
-        return overlap_step_in_x, overlap_step_in_y
-
-    def _compute_step(self):
-        return self._compute_buffer_step(), self._compute_overlap_step()
-
-    def extent(self) -> dict:
-        """
-        Compute Overlapping Grid
-        :return:
-        """
-
-        (
-            (buffered_step_in_x, buffered_step_in_y),
-            (overlap_step_in_x, overlap_step_in_y),
-        ) = self._compute_step()
-
-        for y in range(self.sections[1]):
-            for x in range(self.sections[0]):
-                if (x == self.sections[0] - 1) and self._is_overlap_in_col_direction():
-
-                    tx_start = overlap_step_in_x + self.mesh_bound[0]
-                else:
-                    tx_start = x * buffered_step_in_x + self.mesh_bound[0]
-                if y == (self.sections[1] - 1) and self._is_overlap_in_row_direction():
-                    ty_start = overlap_step_in_y + self.mesh_bound[1]
-                else:
-                    ty_start = y * buffered_step_in_y + self.mesh_bound[1]
-                tx_end = tx_start + buffered_step_in_x - 1
-                ty_end = ty_start + buffered_step_in_y - 1
-
-                yield self.collate_data((tx_start, ty_start, tx_end, ty_end))
-
-    def collate_data(self, extent: tuple) -> dict:
-        data = {
-            "extent": extent,
-            "window": get_window(extent, self.mesh_transform),
-            "mesh_size": self.mesh_size,
-        }
-        return data
-
-
-def mesh_from_geo_transform(
-    grid_size=None, mesh_size=None, transform=None, mesh_bounds=None, overlap=True,
-):
-    """
-
-    :param mesh_bounds:
-    :param overlap: it set to true will find overlapping grid if any
-    :param grid_size: size of grid in pixel dimension (w x h)
-    :param mesh_size: mesh grid in (w x h)
-    :param transform: transform information in the units of its coordinate reference system, required to
-     extract pixel resolution for the specified coordinate system
-    :return:
-    """
-
-    if transform is None:
-        raise ValueError("grid_transform can't be None")
-    pixel_resolution = get_pixel_resolution(transform)
-
-    if mesh_size is None:
-        if mesh_bounds is None:
-            raise ValueError("Mesh Bounds and Mesh Size Both can't be None")
-        mesh_size = compute_dimension(mesh_bounds, pixel_resolution)
-    if grid_size[0] > mesh_size[0] or grid_size[1] > mesh_size[1]:
-        raise ValueError(
-            "Size Of Grid Can't Be Greater than Mesh, Given {},"
-            " Expected less than equal to {}".format(grid_size, mesh_size)
-        )
-    sections = compute_num_of_col_and_ros(grid_size, mesh_size)
-
-    if overlap:
-        buffer_mesh_bound = compute_bounds(
-            grid_size[0] * sections[0], grid_size[1] * sections[1], transform=transform,
-        )
-
-        overlap_mesh_bound = compute_bounds(
-            mesh_size[0] - grid_size[0],
-            mesh_size[1] - grid_size[1],
-            transform=transform,
-        )
-
-        mesh_bound = compute_bounds(mesh_size[0], mesh_size[1], transform=transform)
-
-        mesh_transform = get_mesh_transform(mesh_size[0], mesh_size[1], transform)
-
-        grid_data = ImageOverLapMesh(
-            grid_size,
-            mesh_size,
-            sections,
-            mesh_transform,
-            mesh_bound,
-            overlap_mesh_bound,
-            buffer_mesh_bound,
-        )
-    else:
-        mesh_bound = compute_bounds(mesh_size[0], mesh_size[1], transform=transform)
-
-        mesh_transform = get_mesh_transform(mesh_size[0], mesh_size[1], transform)
-
-        grid_data = ImageNonOverLapMesh(
-            grid_size, mesh_size, sections, mesh_transform, mesh_bound
-        )
-    return grid_data
+from dataclasses import dataclass
+from affine import Affine
+
+from stitch_n_split.geo_info import (
+    get_window,
+    get_pixel_resolution,
+    compute_dimension,
+    compute_num_of_col_and_ros,
+    compute_bounds,
+    get_mesh_transform,
+)
+
+
+class Mesh:
+    def _compute_step(self):
+        """
+        Compute Step in X and Y direction
+        :return:
+        """
+
+        raise NotImplementedError
+
+    @staticmethod
+    def _step_in_x(bound, normalizer=1):
+        """
+        Step Size to take in X
+        :param bound:
+        :param normalizer: How small the step to take, Larger the value smaller and smaller step it will take
+        :return:
+        """
+        return int(((bound[2] - bound[0]) / normalizer))
+
+    @staticmethod
+    def _step_in_y(bound, normalizer=1):
+        """
+        Step Size to take in Y
+        :param bound:
+        :param normalizer: How small the step to take, Larger the value smaller and smaller step it will take
+        :return:
+        """
+        return int(((bound[-1] - bound[1]) / normalizer))
+
+    def extent(self) -> dict:
+        """
+        Compute Mesh
+
+        :return:
+        """
+
+        raise NotImplementedError
+
+    def collate_data(self, extent: tuple) -> dict:
+        raise NotImplementedError
+
+
+@dataclass
+class ImageNonOverLapMesh(Mesh):
+    """
+    The Class will compute Grid bounded within complete_size to provide non overlapping grid,
+    The class will adjust the grid to evenly fit the number of tiles
+
+    Working of this class depends on the geo reference information of the image which acts as the starting point
+
+    The geo reference information to be present in the image is source_min_x, source_max_y and pixel resolution
+
+    Based on the geo reference information present in the image, compute grid of size
+    complete_size // int(np.ceil(dst_img_size / src_img_size) over complete_size
+
+    Given an starting image size, final size and its transform this will find all the grid of size
+    complete_size // int(np.ceil(dst_img_size / src_img_size) between the given complete size
+
+    The start position of grid and the step size of grid is computed from the transform info provided, usually
+    present in geo referenced image
+
+    NOTE - The COORDINATES MUST BE IN `EPSG:26910`
+    """
+
+    grid_size: tuple
+    mesh_size: tuple
+    sections: tuple
+    mesh_transform: Affine
+    mesh_bound: tuple
+
+    def _compute_step(self):
+        """
+        Compute Step in X and Y direction
+        :return:
+        """
+
+        step_in_x = self._step_in_x(self.mesh_bound, self.sections[0])
+        step_in_y = self._step_in_y(self.mesh_bound, self.sections[1])
+
+        return step_in_x, step_in_y
+
+    def extent(self) -> dict:
+        """
+        Compute non overlapping grid bounded within complete_size
+
+        :return:
+        """
+
+        (step_in_x, step_in_y) = self._compute_step()
+
+        for y in range(self.sections[1]):
+
+            for x in range(self.sections[0]):
+                tx_start = x * step_in_x + self.mesh_bound[0]
+
+                ty_start = y * step_in_y + self.mesh_bound[1]
+                tx_end = tx_start + step_in_x - 1
+                ty_end = ty_start + step_in_y - 1
+
+                yield self.collate_data((tx_start, ty_start, tx_end, ty_end))
+
+    def collate_data(self, extent: tuple) -> dict:
+        data = {
+            "extent": extent,
+            "window": get_window(extent, self.mesh_transform),
+            "mesh_size": self.mesh_size,
+        }
+        return data
+
+
+@dataclass
+class ImageOverLapMesh(Mesh):
+    """
+    The Class will compute Grid bounded within complete_size and if the provided grid size overlaps, the the class will
+    tune accordingly to provide overlapping grid, The class wont hamper the grid size in any manner, it will find all
+    the possible grid of size provided that could fit in complete_size
+
+    Working of this class depends on the geo reference information of the image which acts as the starting point
+
+    The geo reference information to be present in the image is source_min_x, source_max_y and pixel resolution
+
+    Based on the geo reference information present in the image, compute grid of size grid_size over complete_size
+
+    Given an starting image size, final size and its transform this will find all the grid of size image size
+    between the given complete size
+
+
+    The start position of grid and the step size of grid is computed from the transform info provided, usually
+    present in geo referenced image
+
+    NOTE - The COORDINATES MUST BE IN `EPSG:26910`
+
+    """
+
+    grid_size: tuple
+    mesh_size: tuple
+    sections: tuple
+    mesh_transform: Affine
+    mesh_bound: tuple
+    overlap_mesh_bound: tuple
+    buffer_mesh_bound: tuple
+
+    def _is_overlap_in_col_direction(self):
+        """
+        Check if there is any overlap in X direction
+        :return:
+        """
+        return True if self.mesh_size[0] % self.grid_size[0] else False
+
+    def _is_overlap_in_row_direction(self):
+        """
+        Check if there is any overlap in Y direction
+        :return:
+        """
+        return True if self.mesh_size[1] % self.grid_size[1] else False
+
+    def _compute_buffer_step(self):
+        """
+        To Compute overlapping steps it is essential to compute the the max_x and min_y not based on the complete
+        size but to extrapolate the grid size by number of tiles.
+
+        i.e grid_size = grid_size * tiles
+
+        :return:
+        """
+
+        buffered_step_in_x = self._step_in_x(self.buffer_mesh_bound, self.sections[0])
+        buffered_step_in_y = self._step_in_y(self.buffer_mesh_bound, self.sections[1])
+
+        return buffered_step_in_x, buffered_step_in_y
+
+    def _compute_overlap_step(self):
+        """
+        The overlapping step is nothing but keeping the coordinates in the bound provided in the form of
+        complete_img_size, the overlapping step is difference between complete_size  and grid_size
+
+        :return:
+        """
+        overlap_step_in_x = None
+        overlap_step_in_y = None
+
+        if self._is_overlap_in_col_direction():
+            overlap_step_in_x = self._step_in_x(self.overlap_mesh_bound)
+        if self._is_overlap_in_row_direction():
+            overlap_step_in_y = self._step_in_y(self.overlap_mesh_bound)
+        return overlap_step_in_x, overlap_step_in_y
+
+    def _compute_step(self):
+        return self._compute_buffer_step(), self._compute_overlap_step()
+
+    def extent(self) -> dict:
+        """
+        Compute Overlapping Grid
+        :return:
+        """
+
+        (
+            (buffered_step_in_x, buffered_step_in_y),
+            (overlap_step_in_x, overlap_step_in_y),
+        ) = self._compute_step()
+
+        for y in range(self.sections[1]):
+            for x in range(self.sections[0]):
+                if (x == self.sections[0] - 1) and self._is_overlap_in_col_direction():
+
+                    tx_start = overlap_step_in_x + self.mesh_bound[0]
+                else:
+                    tx_start = x * buffered_step_in_x + self.mesh_bound[0]
+                if y == (self.sections[1] - 1) and self._is_overlap_in_row_direction():
+                    ty_start = overlap_step_in_y + self.mesh_bound[1]
+                else:
+                    ty_start = y * buffered_step_in_y + self.mesh_bound[1]
+                tx_end = tx_start + buffered_step_in_x - 1
+                ty_end = ty_start + buffered_step_in_y - 1
+
+                yield self.collate_data((tx_start, ty_start, tx_end, ty_end))
+
+    def collate_data(self, extent: tuple) -> dict:
+        data = {
+            "extent": extent,
+            "window": get_window(extent, self.mesh_transform),
+            "mesh_size": self.mesh_size,
+        }
+        return data
+
+
+def mesh_from_geo_transform(
+    grid_size=None, mesh_size=None, transform=None, mesh_bounds=None, overlap=True,
+):
+    """
+
+    :param mesh_bounds:
+    :param overlap: it set to true will find overlapping grid if any
+    :param grid_size: size of grid in pixel dimension (w x h)
+    :param mesh_size: mesh grid in (w x h)
+    :param transform: transform information in the units of its coordinate reference system, required to
+     extract pixel resolution for the specified coordinate system
+    :return:
+    """
+
+    if transform is None:
+        raise ValueError("grid_transform can't be None")
+    pixel_resolution = get_pixel_resolution(transform)
+
+    if mesh_size is None:
+        if mesh_bounds is None:
+            raise ValueError("Mesh Bounds and Mesh Size Both can't be None")
+        mesh_size = compute_dimension(mesh_bounds, pixel_resolution)
+    if grid_size[0] > mesh_size[0] or grid_size[1] > mesh_size[1]:
+        raise ValueError(
+            "Size Of Grid Can't Be Greater than Mesh, Given {},"
+            " Expected less than equal to {}".format(grid_size, mesh_size)
+        )
+    sections = compute_num_of_col_and_ros(grid_size, mesh_size)
+
+    if overlap:
+        buffer_mesh_bound = compute_bounds(
+            grid_size[0] * sections[0], grid_size[1] * sections[1], transform=transform,
+        )
+
+        overlap_mesh_bound = compute_bounds(
+            mesh_size[0] - grid_size[0],
+            mesh_size[1] - grid_size[1],
+            transform=transform,
+        )
+
+        mesh_bound = compute_bounds(mesh_size[0], mesh_size[1], transform=transform)
+
+        mesh_transform = get_mesh_transform(mesh_size[0], mesh_size[1], transform)
+
+        grid_data = ImageOverLapMesh(
+            grid_size,
+            mesh_size,
+            sections,
+            mesh_transform,
+            mesh_bound,
+            overlap_mesh_bound,
+            buffer_mesh_bound,
+        )
+    else:
+        mesh_bound = compute_bounds(mesh_size[0], mesh_size[1], transform=transform)
+
+        mesh_transform = get_mesh_transform(mesh_size[0], mesh_size[1], transform)
+
+        grid_data = ImageNonOverLapMesh(
+            grid_size, mesh_size, sections, mesh_transform, mesh_bound
+        )
+    return grid_data
```

### Comparing `stitch_n_split-0.1.1/stitch_n_split/utility.py` & `stitch_n_split-0.1.2/stitch_n_split/utility.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,47 +1,47 @@
-import os
-import cv2
-import rasterio
-
-from sys import stdout
-
-
-class Printer:
-    @staticmethod
-    def print(data):
-        stdout.write("\r\033[1;37m>>\x1b[K" + data.__str__())
-        stdout.flush()
-
-    @staticmethod
-    def print_new_line_pre(data):
-        stdout.write("\n")
-        stdout.write("\r\033[1;37m>>\x1b[K" + data.__str__())
-        stdout.flush()
-
-    @staticmethod
-    def print_new_line_post(data):
-        stdout.write("\r\033[1;37m>>\x1b[K" + data.__str__())
-        stdout.flush()
-        stdout.write("\n")
-
-
-def open_image(path, is_geo_reference=False):
-    if is_geo_reference:
-        return rasterio.open(path, driver="GTiff")
-    else:
-        img = cv2.imread(path)
-        return cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
-
-
-def save_image(path, image, is_geo_reference=False, **kwargs_image):
-    if is_geo_reference:
-        with rasterio.open(path, "w", **kwargs_image) as dst:
-            dst.write(image)
-    else:
-        cv2.imwrite(path, cv2.cvtColor(image, cv2.COLOR_RGB2BGR))
-
-
-def make_save_dir(current_dir, folder_name):
-    new_dir = os.path.join(current_dir, folder_name)
-    if not os.path.exists(new_dir):
-        os.makedirs(new_dir)
-    return new_dir
+import os
+import cv2
+import rasterio
+
+from sys import stdout
+
+
+class Printer:
+    @staticmethod
+    def print(data):
+        stdout.write("\r\033[1;37m>>\x1b[K" + data.__str__())
+        stdout.flush()
+
+    @staticmethod
+    def print_new_line_pre(data):
+        stdout.write("\n")
+        stdout.write("\r\033[1;37m>>\x1b[K" + data.__str__())
+        stdout.flush()
+
+    @staticmethod
+    def print_new_line_post(data):
+        stdout.write("\r\033[1;37m>>\x1b[K" + data.__str__())
+        stdout.flush()
+        stdout.write("\n")
+
+
+def open_image(path, is_geo_reference=False):
+    if is_geo_reference:
+        return rasterio.open(path, driver="GTiff")
+    else:
+        img = cv2.imread(path)
+        return cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
+
+
+def save_image(path, image, is_geo_reference=False, **kwargs_image):
+    if is_geo_reference:
+        with rasterio.open(path, "w", **kwargs_image) as dst:
+            dst.write(image)
+    else:
+        cv2.imwrite(path, cv2.cvtColor(image, cv2.COLOR_RGB2BGR))
+
+
+def make_save_dir(current_dir, folder_name):
+    new_dir = os.path.join(current_dir, folder_name)
+    if not os.path.exists(new_dir):
+        os.makedirs(new_dir)
+    return new_dir
```

