# Comparing `tmp/nanobind-1.2.0-py3-none-any.whl.zip` & `tmp/nanobind-1.3.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,74 +1,77 @@
-Zip file size: 163947 bytes, number of entries: 72
--rw-rw-r--  2.0 unx      536 b- defN 23-Apr-24 15:36 nanobind/__init__.py
--rw-rw-r--  2.0 unx      839 b- defN 23-Apr-24 15:36 nanobind/__main__.py
--rw-rw-r--  2.0 unx    21432 b- defN 23-Apr-24 15:36 nanobind/cmake/darwin-ld-cpython.sym
--rw-rw-r--  2.0 unx    24563 b- defN 23-Apr-24 15:36 nanobind/cmake/darwin-ld-pypy.sym
--rw-rw-r--  2.0 unx    10363 b- defN 23-Apr-24 15:36 nanobind/cmake/nanobind-config.cmake
--rw-rw-r--  2.0 unx    11776 b- defN 23-Apr-24 15:36 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h
--rw-rw-r--  2.0 unx    54550 b- defN 23-Apr-24 15:36 nanobind/ext/robin_map/include/tsl/robin_hash.h
--rw-rw-r--  2.0 unx    28414 b- defN 23-Apr-24 15:36 nanobind/ext/robin_map/include/tsl/robin_map.h
--rw-rw-r--  2.0 unx    23593 b- defN 23-Apr-24 15:36 nanobind/ext/robin_map/include/tsl/robin_set.h
--rw-rw-r--  2.0 unx     5601 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/make_iterator.h
--rw-rw-r--  2.0 unx     1628 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nanobind.h
--rw-rw-r--  2.0 unx     5626 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_accessor.h
--rw-rw-r--  2.0 unx     7173 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_attr.h
--rw-rw-r--  2.0 unx     5325 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_call.h
--rw-rw-r--  2.0 unx    13975 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_cast.h
--rw-rw-r--  2.0 unx    19205 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_class.h
--rw-rw-r--  2.0 unx     5507 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_defs.h
--rw-rw-r--  2.0 unx     4129 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_descr.h
--rw-rw-r--  2.0 unx      666 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_enums.h
--rw-rw-r--  2.0 unx     3526 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_error.h
--rw-rw-r--  2.0 unx     9751 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_func.h
--rw-rw-r--  2.0 unx    18304 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_lib.h
--rw-rw-r--  2.0 unx     1167 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_misc.h
--rw-rw-r--  2.0 unx     1377 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_python.h
--rw-rw-r--  2.0 unx     6280 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_traits.h
--rw-rw-r--  2.0 unx     2468 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_tuple.h
--rw-rw-r--  2.0 unx    25089 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_types.h
--rw-rw-r--  2.0 unx    12285 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/ndarray.h
--rw-rw-r--  2.0 unx     7449 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/operators.h
--rw-rw-r--  2.0 unx     3013 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/trampoline.h
--rw-rw-r--  2.0 unx     8411 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/eigen/dense.h
--rw-rw-r--  2.0 unx     6486 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/eigen/sparse.h
--rw-rw-r--  2.0 unx      535 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/array.h
--rw-rw-r--  2.0 unx     5775 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/bind_map.h
--rw-rw-r--  2.0 unx     7250 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/bind_vector.h
--rw-rw-r--  2.0 unx     2720 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/filesystem.h
--rw-rw-r--  2.0 unx     2478 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/function.h
--rw-rw-r--  2.0 unx      527 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/list.h
--rw-rw-r--  2.0 unx      596 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/map.h
--rw-rw-r--  2.0 unx     2281 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/optional.h
--rw-rw-r--  2.0 unx     3403 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/pair.h
--rw-rw-r--  2.0 unx      575 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/set.h
--rw-rw-r--  2.0 unx     4573 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/shared_ptr.h
--rw-rw-r--  2.0 unx     1019 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/string.h
--rw-rw-r--  2.0 unx     1063 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/string_view.h
--rw-rw-r--  2.0 unx     3463 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/tuple.h
--rw-rw-r--  2.0 unx     4310 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/unique_ptr.h
--rw-rw-r--  2.0 unx      646 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/unordered_map.h
--rw-rw-r--  2.0 unx      652 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/unordered_set.h
--rw-rw-r--  2.0 unx     3386 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/variant.h
--rw-rw-r--  2.0 unx      537 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/vector.h
--rw-rw-r--  2.0 unx     1680 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/detail/nb_array.h
--rw-rw-r--  2.0 unx     2655 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/detail/nb_dict.h
--rw-rw-r--  2.0 unx     2132 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/detail/nb_list.h
--rw-rw-r--  2.0 unx     1942 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/detail/nb_set.h
--rw-rw-r--  2.0 unx     3218 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/detail/traits.h
--rw-rw-r--  2.0 unx     4165 b- defN 23-Apr-24 15:36 nanobind/src/buffer.h
--rw-rw-r--  2.0 unx    27942 b- defN 23-Apr-24 15:36 nanobind/src/common.cpp
--rw-rw-r--  2.0 unx     6327 b- defN 23-Apr-24 15:36 nanobind/src/error.cpp
--rw-rw-r--  2.0 unx     2548 b- defN 23-Apr-24 15:36 nanobind/src/implicit.cpp
--rw-rw-r--  2.0 unx    11560 b- defN 23-Apr-24 15:36 nanobind/src/nb_enum.cpp
--rw-rw-r--  2.0 unx    39337 b- defN 23-Apr-24 15:36 nanobind/src/nb_func.cpp
--rw-rw-r--  2.0 unx    18420 b- defN 23-Apr-24 15:36 nanobind/src/nb_internals.cpp
--rw-rw-r--  2.0 unx     8457 b- defN 23-Apr-24 15:36 nanobind/src/nb_internals.h
--rw-rw-r--  2.0 unx    19495 b- defN 23-Apr-24 15:36 nanobind/src/nb_ndarray.cpp
--rw-rw-r--  2.0 unx    47554 b- defN 23-Apr-24 15:36 nanobind/src/nb_type.cpp
--rw-rw-r--  2.0 unx     3628 b- defN 23-Apr-24 15:36 nanobind/src/trampoline.cpp
--rw-rw-r--  2.0 unx     1521 b- defN 23-Apr-24 15:36 nanobind-1.2.0.dist-info/LICENSE
--rw-rw-r--  2.0 unx     1426 b- defN 23-Apr-24 15:36 nanobind-1.2.0.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-Apr-24 15:36 nanobind-1.2.0.dist-info/WHEEL
--rw-rw-r--  2.0 unx        9 b- defN 23-Apr-24 15:36 nanobind-1.2.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     6651 b- defN 23-Apr-24 15:36 nanobind-1.2.0.dist-info/RECORD
-72 files, 607055 bytes uncompressed, 153257 bytes compressed:  74.8%
+Zip file size: 176885 bytes, number of entries: 75
+-rw-r--r--  2.0 unx      536 b- defN 23-May-31 11:54 nanobind/__init__.py
+-rw-r--r--  2.0 unx      839 b- defN 23-May-31 11:54 nanobind/__main__.py
+-rw-r--r--  2.0 unx    21457 b- defN 23-May-31 11:54 nanobind/cmake/darwin-ld-cpython.sym
+-rw-r--r--  2.0 unx    24563 b- defN 23-May-31 11:54 nanobind/cmake/darwin-ld-pypy.sym
+-rw-r--r--  2.0 unx    10316 b- defN 23-May-31 11:54 nanobind/cmake/nanobind-config.cmake
+-rw-r--r--  2.0 unx    11776 b- defN 23-May-31 11:54 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h
+-rw-r--r--  2.0 unx    54550 b- defN 23-May-31 11:54 nanobind/ext/robin_map/include/tsl/robin_hash.h
+-rw-r--r--  2.0 unx    28414 b- defN 23-May-31 11:54 nanobind/ext/robin_map/include/tsl/robin_map.h
+-rw-r--r--  2.0 unx    23593 b- defN 23-May-31 11:54 nanobind/ext/robin_map/include/tsl/robin_set.h
+-rw-r--r--  2.0 unx     5601 b- defN 23-May-31 11:54 nanobind/include/nanobind/make_iterator.h
+-rw-r--r--  2.0 unx     1628 b- defN 23-May-31 11:54 nanobind/include/nanobind/nanobind.h
+-rw-r--r--  2.0 unx     5626 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_accessor.h
+-rw-r--r--  2.0 unx     7387 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_attr.h
+-rw-r--r--  2.0 unx     5533 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_call.h
+-rw-r--r--  2.0 unx    14781 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_cast.h
+-rw-r--r--  2.0 unx    23845 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_class.h
+-rw-r--r--  2.0 unx     5558 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_defs.h
+-rw-r--r--  2.0 unx     4129 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_descr.h
+-rw-r--r--  2.0 unx      666 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_enums.h
+-rw-r--r--  2.0 unx     4168 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_error.h
+-rw-r--r--  2.0 unx     9769 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_func.h
+-rw-r--r--  2.0 unx    18829 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_lib.h
+-rw-r--r--  2.0 unx     1167 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_misc.h
+-rw-r--r--  2.0 unx     1377 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_python.h
+-rw-r--r--  2.0 unx     6653 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_traits.h
+-rw-r--r--  2.0 unx     2468 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_tuple.h
+-rw-r--r--  2.0 unx    25243 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_types.h
+-rw-r--r--  2.0 unx    13478 b- defN 23-May-31 11:54 nanobind/include/nanobind/ndarray.h
+-rw-r--r--  2.0 unx     7449 b- defN 23-May-31 11:54 nanobind/include/nanobind/operators.h
+-rw-r--r--  2.0 unx     2851 b- defN 23-May-31 11:54 nanobind/include/nanobind/trampoline.h
+-rw-r--r--  2.0 unx     8579 b- defN 23-May-31 11:54 nanobind/include/nanobind/eigen/dense.h
+-rw-r--r--  2.0 unx     6486 b- defN 23-May-31 11:54 nanobind/include/nanobind/eigen/sparse.h
+-rw-r--r--  2.0 unx      535 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/array.h
+-rw-r--r--  2.0 unx     5775 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/bind_map.h
+-rw-r--r--  2.0 unx     7250 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/bind_vector.h
+-rw-r--r--  2.0 unx     8675 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/chrono.h
+-rw-r--r--  2.0 unx     2720 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/filesystem.h
+-rw-r--r--  2.0 unx     2478 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/function.h
+-rw-r--r--  2.0 unx      527 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/list.h
+-rw-r--r--  2.0 unx      596 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/map.h
+-rw-r--r--  2.0 unx     2281 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/optional.h
+-rw-r--r--  2.0 unx     3403 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/pair.h
+-rw-r--r--  2.0 unx      575 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/set.h
+-rw-r--r--  2.0 unx     5022 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/shared_ptr.h
+-rw-r--r--  2.0 unx     1019 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/string.h
+-rw-r--r--  2.0 unx     1063 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/string_view.h
+-rw-r--r--  2.0 unx     3463 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/tuple.h
+-rw-r--r--  2.0 unx     4310 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/unique_ptr.h
+-rw-r--r--  2.0 unx      646 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/unordered_map.h
+-rw-r--r--  2.0 unx      652 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/unordered_set.h
+-rw-r--r--  2.0 unx     3386 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/variant.h
+-rw-r--r--  2.0 unx      537 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/vector.h
+-rw-r--r--  2.0 unx    10571 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/detail/chrono.h
+-rw-r--r--  2.0 unx     1680 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/detail/nb_array.h
+-rw-r--r--  2.0 unx     2655 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/detail/nb_dict.h
+-rw-r--r--  2.0 unx     2132 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/detail/nb_list.h
+-rw-r--r--  2.0 unx     1942 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/detail/nb_set.h
+-rw-r--r--  2.0 unx     3218 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/detail/traits.h
+-rw-r--r--  2.0 unx     4218 b- defN 23-May-31 11:54 nanobind/src/buffer.h
+-rw-r--r--  2.0 unx    28395 b- defN 23-May-31 11:54 nanobind/src/common.cpp
+-rw-r--r--  2.0 unx     5671 b- defN 23-May-31 11:54 nanobind/src/error.cpp
+-rw-r--r--  2.0 unx     2548 b- defN 23-May-31 11:54 nanobind/src/implicit.cpp
+-rw-r--r--  2.0 unx    14685 b- defN 23-May-31 11:54 nanobind/src/nb_enum.cpp
+-rw-r--r--  2.0 unx    41402 b- defN 23-May-31 11:54 nanobind/src/nb_func.cpp
+-rw-r--r--  2.0 unx    14833 b- defN 23-May-31 11:54 nanobind/src/nb_internals.cpp
+-rw-r--r--  2.0 unx     9558 b- defN 23-May-31 11:54 nanobind/src/nb_internals.h
+-rw-r--r--  2.0 unx    21211 b- defN 23-May-31 11:54 nanobind/src/nb_ndarray.cpp
+-rw-r--r--  2.0 unx     2466 b- defN 23-May-31 11:54 nanobind/src/nb_static_property.cpp
+-rw-r--r--  2.0 unx    52907 b- defN 23-May-31 11:54 nanobind/src/nb_type.cpp
+-rw-r--r--  2.0 unx     3796 b- defN 23-May-31 11:54 nanobind/src/trampoline.cpp
+-rw-r--r--  2.0 unx     1521 b- defN 23-May-31 11:54 nanobind-1.3.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1406 b- defN 23-May-31 11:54 nanobind-1.3.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-31 11:54 nanobind-1.3.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        9 b- defN 23-May-31 11:54 nanobind-1.3.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6941 b- defN 23-May-31 11:54 nanobind-1.3.0.dist-info/RECORD
+75 files, 648085 bytes uncompressed, 165731 bytes compressed:  74.4%
```

## zipnote {}

```diff
@@ -99,14 +99,17 @@
 
 Filename: nanobind/include/nanobind/stl/bind_map.h
 Comment: 
 
 Filename: nanobind/include/nanobind/stl/bind_vector.h
 Comment: 
 
+Filename: nanobind/include/nanobind/stl/chrono.h
+Comment: 
+
 Filename: nanobind/include/nanobind/stl/filesystem.h
 Comment: 
 
 Filename: nanobind/include/nanobind/stl/function.h
 Comment: 
 
 Filename: nanobind/include/nanobind/stl/list.h
@@ -147,14 +150,17 @@
 
 Filename: nanobind/include/nanobind/stl/variant.h
 Comment: 
 
 Filename: nanobind/include/nanobind/stl/vector.h
 Comment: 
 
+Filename: nanobind/include/nanobind/stl/detail/chrono.h
+Comment: 
+
 Filename: nanobind/include/nanobind/stl/detail/nb_array.h
 Comment: 
 
 Filename: nanobind/include/nanobind/stl/detail/nb_dict.h
 Comment: 
 
 Filename: nanobind/include/nanobind/stl/detail/nb_list.h
@@ -189,29 +195,32 @@
 
 Filename: nanobind/src/nb_internals.h
 Comment: 
 
 Filename: nanobind/src/nb_ndarray.cpp
 Comment: 
 
+Filename: nanobind/src/nb_static_property.cpp
+Comment: 
+
 Filename: nanobind/src/nb_type.cpp
 Comment: 
 
 Filename: nanobind/src/trampoline.cpp
 Comment: 
 
-Filename: nanobind-1.2.0.dist-info/LICENSE
+Filename: nanobind-1.3.0.dist-info/LICENSE
 Comment: 
 
-Filename: nanobind-1.2.0.dist-info/METADATA
+Filename: nanobind-1.3.0.dist-info/METADATA
 Comment: 
 
-Filename: nanobind-1.2.0.dist-info/WHEEL
+Filename: nanobind-1.3.0.dist-info/WHEEL
 Comment: 
 
-Filename: nanobind-1.2.0.dist-info/top_level.txt
+Filename: nanobind-1.3.0.dist-info/top_level.txt
 Comment: 
 
-Filename: nanobind-1.2.0.dist-info/RECORD
+Filename: nanobind-1.3.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## nanobind/__init__.py

```diff
@@ -8,14 +8,14 @@
     "Return the path to the nanobind include directory"
     return os.path.join(os.path.abspath(os.path.dirname(__file__)), "include")
 
 def cmake_dir() -> str:
     "Return the path to the nanobind CMake module directory."
     return os.path.join(os.path.abspath(os.path.dirname(__file__)), "cmake")
 
-__version__ = "1.2.0"
+__version__ = "1.3.0"
 
 __all__ = (
     "__version__",
     "include_dir",
     "cmake_dir",
 )
```

## nanobind/cmake/darwin-ld-cpython.sym

```diff
@@ -490,14 +490,15 @@
 -U _PyObject_ClearWeakRefs
 -U _PyObject_CopyData
 -U _PyObject_DelItem
 -U _PyObject_DelItemString
 -U _PyObject_Dir
 -U _PyObject_Format
 -U _PyObject_Free
+-U _PyObject_GetTypeData
 -U _PyObject_GC_Del
 -U _PyObject_GC_IsFinalized
 -U _PyObject_GC_IsTracked
 -U _PyObject_GC_Track
 -U _PyObject_GC_UnTrack
 -U _PyObject_GenericGetAttr
 -U _PyObject_GenericGetDict
```

## nanobind/cmake/nanobind-config.cmake

```diff
@@ -17,45 +17,31 @@
     "find 'EXT_SUFFIX' property failed!")
 endif()
 
 set(NB_SUFFIX ${NB_SUFFIX} CACHE INTERNAL "")
 
 get_filename_component(NB_DIR "${CMAKE_CURRENT_LIST_FILE}" PATH)
 get_filename_component(NB_DIR "${NB_DIR}" PATH)
-set(NB_DIR ${NB_DIR} CACHE INTERNAL "")
 
-# ---------------------------------------------------------------------------
-# Helper function to strip unnecessary sections from binaries on Linux/macOS
-# ---------------------------------------------------------------------------
-
-function(nanobind_strip name)
-  if (CMAKE_STRIP AND NOT MSVC AND NOT CMAKE_BUILD_TYPE MATCHES Debug|RelWithDebInfo)
-    if(APPLE)
-      set(NB_STRIP_OPT -x)
-    endif()
-
-    add_custom_command(
-      TARGET ${name}
-      POST_BUILD
-      COMMAND ${CMAKE_STRIP} ${NB_STRIP_OPT} $<TARGET_FILE:${name}>)
-  endif()
-endfunction()
+set(NB_DIR      ${NB_DIR} CACHE INTERNAL "")
+set(NB_OPT      $<OR:$<CONFIG:Release>,$<CONFIG:MinSizeRel>> CACHE INTERNAL "")
+set(NB_OPT_SIZE $<OR:$<CONFIG:Release>,$<CONFIG:MinSizeRel>,$<CONFIG:RelWithDebInfo>> CACHE INTERNAL "")
 
 # ---------------------------------------------------------------------------
 # Helper function to handle undefined CPython API symbols on macOS
 # ---------------------------------------------------------------------------
 
 function (nanobind_link_options name)
   if (APPLE)
     if (Python_INTERPRETER_ID STREQUAL "PyPy")
       set(NB_LINKER_RESPONSE_FILE darwin-ld-pypy.sym)
     else()
       set(NB_LINKER_RESPONSE_FILE darwin-ld-cpython.sym)
     endif()
-    target_link_options(${name} PRIVATE "-Wl,-dead_strip" "-Wl,@${NB_DIR}/cmake/${NB_LINKER_RESPONSE_FILE}")
+    target_link_options(${name} PRIVATE "-Wl,@${NB_DIR}/cmake/${NB_LINKER_RESPONSE_FILE}")
   endif()
 endfunction()
 
 # ---------------------------------------------------------------------------
 # Create shared/static library targets for nanobind's non-templated core
 # ---------------------------------------------------------------------------
 
@@ -124,87 +110,86 @@
     ${NB_DIR}/src/buffer.h
     ${NB_DIR}/src/nb_internals.h
     ${NB_DIR}/src/nb_internals.cpp
     ${NB_DIR}/src/nb_func.cpp
     ${NB_DIR}/src/nb_type.cpp
     ${NB_DIR}/src/nb_enum.cpp
     ${NB_DIR}/src/nb_ndarray.cpp
+    ${NB_DIR}/src/nb_static_property.cpp
     ${NB_DIR}/src/common.cpp
     ${NB_DIR}/src/error.cpp
     ${NB_DIR}/src/trampoline.cpp
     ${NB_DIR}/src/implicit.cpp
   )
 
   if (TARGET_TYPE STREQUAL "SHARED")
     nanobind_link_options(${TARGET_NAME})
     target_compile_definitions(${TARGET_NAME} PRIVATE -DNB_BUILD)
     target_compile_definitions(${TARGET_NAME} PUBLIC -DNB_SHARED)
-    nanobind_strip(${TARGET_NAME})
-  endif()
+    nanobind_lto(${TARGET_NAME})
 
-  if ((TARGET_TYPE STREQUAL "SHARED") OR (TARGET_NAME MATCHES "-lto"))
-    set_target_properties(${TARGET_NAME} PROPERTIES
-      INTERPROCEDURAL_OPTIMIZATION_RELEASE ON
-      INTERPROCEDURAL_OPTIMIZATION_MINSIZEREL ON)
+    nanobind_strip(${TARGET_NAME})
+  elseif(NOT WIN32 AND NOT APPLE)
+    target_compile_options(${TARGET_NAME} PUBLIC $<${NB_OPT_SIZE}:-ffunction-sections -fdata-sections>)
+    target_link_options(${TARGET_NAME} PUBLIC $<${NB_OPT_SIZE}:-Wl,--gc-sections>)
   endif()
 
   set_target_properties(${TARGET_NAME} PROPERTIES
     POSITION_INDEPENDENT_CODE ON)
 
   if (MSVC)
     # Do not complain about vsnprintf
     target_compile_definitions(${TARGET_NAME} PRIVATE -D_CRT_SECURE_NO_WARNINGS)
   else()
+    # Generally needed to handle type punning in Python code
     target_compile_options(${TARGET_NAME} PRIVATE -fno-strict-aliasing)
   endif()
 
   if (WIN32)
     if (${TARGET_NAME} MATCHES "abi3")
       target_link_libraries(${TARGET_NAME} PUBLIC Python::SABIModule)
     else()
       target_link_libraries(${TARGET_NAME} PUBLIC Python::Module)
     endif()
   endif()
 
+  # Nanobind performs many assertion checks -- detailed error messages aren't
+  # included in Release/MinSizeRel modes
+  target_compile_definitions(${TARGET_NAME} PRIVATE
+    $<${NB_OPT_SIZE}:NB_COMPACT_ASSERTIONS>)
+
   target_include_directories(${TARGET_NAME} PRIVATE
     ${NB_DIR}/ext/robin_map/include)
 
   target_include_directories(${TARGET_NAME} PUBLIC
     ${Python_INCLUDE_DIRS}
     ${NB_DIR}/include)
 
   target_compile_features(${TARGET_NAME} PUBLIC cxx_std_17)
+  nanobind_set_visibility(${TARGET_NAME})
 endfunction()
 
 # ---------------------------------------------------------------------------
 # Define a convenience function for creating nanobind targets
 # ---------------------------------------------------------------------------
 
 function(nanobind_opt_size name)
   if (MSVC)
-    set(NB_OPT_SIZE /Os)
+    target_compile_options(${name} PRIVATE $<${NB_OPT_SIZE}:/Os>)
   else()
-    set(NB_OPT_SIZE -Os)
+    target_compile_options(${name} PRIVATE $<${NB_OPT_SIZE}:-Os>)
   endif()
-
-  target_compile_options(${name} PRIVATE
-      $<$<CONFIG:Release>:${NB_OPT_SIZE}>
-      $<$<CONFIG:MinSizeRel>:${NB_OPT_SIZE}>
-      $<$<CONFIG:RelWithDebInfo>:${NB_OPT_SIZE}>)
 endfunction()
 
 function(nanobind_disable_stack_protector name)
   if (NOT MSVC)
     # The stack protector affects binding size negatively (+8% on Linux in my
     # benchmarks). Protecting from stack smashing in a Python VM seems in any
     # case futile, so let's get rid of it by default in optimized modes.
-    target_compile_options(${name} PRIVATE
-        $<$<CONFIG:Release>:-fno-stack-protector>
-        $<$<CONFIG:MinSizeRel>:-fno-stack-protector>
-        $<$<CONFIG:RelWithDebInfo>:-fno-stack-protector>)
+    target_compile_options(${name} PRIVATE $<${NB_OPT}:-fno-stack-protector>)
   endif()
 endfunction()
 
 function(nanobind_extension name)
   set_target_properties(${name} PROPERTIES PREFIX "" SUFFIX "${NB_SUFFIX}")
 endfunction()
 
@@ -221,16 +206,29 @@
 
 function (nanobind_compile_options)
   if (MSVC)
     target_compile_options(${name} PRIVATE /bigobj /MP)
   endif()
 endfunction()
 
+function (nanobind_strip name)
+  if (APPLE)
+    target_link_options(${name} PRIVATE $<${NB_OPT}:-Wl,-dead_strip -Wl,-x -Wl,-S>)
+  elseif (NOT WIN32)
+    target_link_options(${name} PRIVATE $<${NB_OPT}:-Wl,-s>)
+  endif()
+endfunction()
+
+function (nanobind_set_visibility name)
+  set_target_properties(${name} PROPERTIES CXX_VISIBILITY_PRESET hidden)
+endfunction()
+
 function(nanobind_add_module name)
-  cmake_parse_arguments(PARSE_ARGV 1 ARG "NOMINSIZE;STABLE_ABI;NOSTRIP;NB_STATIC;NB_SHARED;PROTECT_STACK;LTO" "" "")
+  cmake_parse_arguments(PARSE_ARGV 1 ARG
+    "STABLE_ABI;NB_STATIC;NB_SHARED;PROTECT_STACK;LTO;NOMINSIZE;NOSTRIP;NOTRIM" "" "")
 
   add_library(${name} MODULE ${ARG_UNPARSED_ARGUMENTS})
 
   nanobind_compile_options(${name})
   nanobind_link_options(${name})
   set_target_properties(${name} PROPERTIES LINKER_LANGUAGE CXX)
 
@@ -265,19 +263,14 @@
     set(libname "${libname}-static")
   endif()
 
   if (ARG_STABLE_ABI)
     set(libname "${libname}-abi3")
   endif()
 
-  # Shared builds always use LTO for release builds of the library component
-  if (ARG_LTO AND NOT ARG_NB_STATIC)
-    set(libname "${libname}-lto")
-  endif()
-
   nanobind_build_library(${libname})
 
   if (ARG_STABLE_ABI)
     target_compile_definitions(${libname} PUBLIC -DPy_LIMITED_API=0x030C0000)
     nanobind_extension_abi3(${name})
   else()
     nanobind_extension(${name})
@@ -297,9 +290,9 @@
     nanobind_strip(${name})
   endif()
 
   if (ARG_LTO)
     nanobind_lto(${name})
   endif()
 
-  set_target_properties(${name} PROPERTIES CXX_VISIBILITY_PRESET hidden)
+  nanobind_set_visibility(${name})
 endfunction()
```

## nanobind/include/nanobind/nanobind.h

```diff
@@ -18,15 +18,15 @@
 #  pragma warning(disable: 4702) // unreachable code (e.g. when binding a noreturn function)
    // The next two lines disable warnings that are "just noise" according to Stephan T. Lavavej (a MSFT STL maintainer)
 #  pragma warning(disable: 4275) // non dll-interface class 'std::exception' used as base for dll-interface class [..]
 #  pragma warning(disable: 4251) // [..] needs to have a dll-interface to be used by clients of class [..]
 #endif
 
 #define NB_VERSION_MAJOR 1
-#define NB_VERSION_MINOR 2
+#define NB_VERSION_MINOR 3
 #define NB_VERSION_PATCH 0
 
 // Core C++ headers that nanobind depends on
 #include <cstdint>
 #include <exception>
 #include <stdexcept>
 #include <type_traits>
```

## nanobind/include/nanobind/nb_attr.h

```diff
@@ -49,29 +49,35 @@
 
 struct dynamic_attr {};
 struct is_method {};
 struct is_implicit {};
 struct is_operator {};
 struct is_arithmetic {};
 struct is_final {};
-struct is_enum { bool is_signed; };
 
 template <size_t /* Nurse */, size_t /* Patient */> struct keep_alive {};
 template <typename T> struct supplement {};
 template <typename T> struct intrusive_ptr {
     intrusive_ptr(void (*set_self_py)(T *, PyObject *) noexcept)
         : set_self_py(set_self_py) { }
     void (*set_self_py)(T *, PyObject *) noexcept;
 };
 
 struct type_slots {
     type_slots (PyType_Slot *value) : value(value) { }
     PyType_Slot *value;
 };
 
+struct type_slots_callback {
+    using cb_t = void (*)(const detail::type_init_data *t,
+                          PyType_Slot *&slots, size_t max_slots) noexcept;
+    type_slots_callback(cb_t callback) : callback(callback) { }
+    cb_t callback;
+};
+
 struct raw_doc {
     const char *value;
     raw_doc(const char *doc) : value(doc) {}
 };
 
 NAMESPACE_BEGIN(literals)
 constexpr arg operator"" _a(const char *name, size_t) { return arg(name); }
```

## nanobind/include/nanobind/nb_call.h

```diff
@@ -6,14 +6,19 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
+#if defined(_MSC_VER)
+#  pragma warning(push)
+#  pragma warning(disable: 6255) // _alloca indicates failure by raising a stack overflow exception
+#endif
+
 class kwargs_proxy : public handle {
 public:
     explicit kwargs_proxy(handle h) : handle(h) { }
 };
 
 class args_proxy : public handle {
 public:
@@ -105,14 +110,15 @@
 
         // Determine storage requirements for positional and keyword args
         (call_analyze(nargs, nkwargs, (const Args &) args_), ...);
 
         // Allocate memory on the stack
         PyObject **args =
             (PyObject **) alloca((nargs + nkwargs + 1) * sizeof(PyObject *));
+
         PyObject *kwnames =
             nkwargs ? PyTuple_New((Py_ssize_t) nkwargs) : nullptr;
 
         // Fill 'args' and 'kwnames' variables
         (call_init<policy>(args + 1, kwnames, nargs2, nkwargs2, nargs,
                            (forward_t<Args>) args_), ...);
 
@@ -130,9 +136,13 @@
 
         NB_DO_VECTORCALL();
     }
 }
 
 #undef NB_DO_VECTORCALL
 
+#if defined(_MSC_VER)
+#  pragma warning(pop)
+#endif
+
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/include/nanobind/nb_cast.h

```diff
@@ -199,15 +199,31 @@
     }
 
     explicit operator const char *() { return value; }
 
     explicit operator char() {
         if (value && value[0] && value[1] == '\0')
             return value[0];
-        throw next_overload();
+        else
+            throw next_overload();
+    }
+};
+
+template <typename T> struct type_caster<pointer_and_handle<T>> {
+    using Caster = detail::make_caster<T>;
+    using T2 = pointer_and_handle<T>;
+    NB_TYPE_CASTER(T2, Caster::Name)
+
+    bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
+        Caster c;
+        if (!c.from_python(src, flags, cleanup))
+            return false;
+        value.h = src;
+        value.p = c.operator T*();
+        return true;
     }
 };
 
 template <typename T, typename X> struct type_caster<typed<T, X>> {
     using Caster = detail::make_caster<T>;
     using T2 = typed<T, X>;
     NB_TYPE_CASTER(T2, X::Name)
@@ -309,22 +325,20 @@
             return nb_type_put_p(type, type_p, ptr, policy, cleanup);
         }
     }
 
     operator Type*() { return value; }
 
     operator Type&() {
-        if (!value)
-            raise_next_overload();
+        raise_next_overload_if_null(value);
         return *value;
     }
 
     operator Type&&() && {
-        if (!value)
-            raise_next_overload();
+        raise_next_overload_if_null(value);
         return (Type &&) *value;
     }
 
 private:
     Type *value;
 };
 
@@ -348,15 +362,25 @@
 
         Caster caster;
         if (!caster.from_python(value.derived().ptr(),
                                 convert ? (uint8_t) detail::cast_flags::convert
                                         : (uint8_t) 0, nullptr))
             detail::raise_cast_error();
 
+        // GCC misses that from_python will return or ensure orderly initialization
+        #if defined(__GNUC__) && !defined(__clang__)
+          #pragma GCC diagnostic push
+          #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
+        #endif
+
         return caster.operator Output();
+
+        #if defined(__GNUC__) && !defined(__clang__)
+          #pragma GCC diagnostic pop
+        #endif
     }
 }
 
 template <typename T>
 object cast(T &&value, rv_policy policy = rv_policy::automatic_reference) {
     handle h = detail::make_caster<T>::from_cpp(
         (detail::forward_t<T>) value, detail::infer_policy<T>(policy), nullptr);
```

## nanobind/include/nanobind/nb_class.h

```diff
@@ -6,151 +6,194 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
+/// Flags about a type that persist throughout its lifetime
 enum class type_flags : uint32_t {
     /// Does the type provide a C++ destructor?
     is_destructible          = (1 << 0),
 
     /// Does the type provide a C++ copy constructor?
     is_copy_constructible    = (1 << 1),
 
     /// Does the type provide a C++ move constructor?
     is_move_constructible    = (1 << 2),
 
-    /// Is this a python type that extends a bound C++ type?
-    is_python_type           = (1 << 4),
-
-    /// Is the 'scope' field of the type_data structure set?
-    has_scope                = (1 << 5),
-
-    /// Is the 'doc' field of the type_data structure set?
-    has_doc                  = (1 << 6),
-
-    /// Is the 'base' field of the type_data structure set?
-    has_base                 = (1 << 7),
-
-    /// Is the 'base_py' field of the type_data structure set?
-    has_base_py              = (1 << 8),
-
     /// Is the 'destruct' field of the type_data structure set?
-    has_destruct             = (1 << 9),
+    has_destruct             = (1 << 4),
 
     /// Is the 'copy' field of the type_data structure set?
-    has_copy                 = (1 << 10),
+    has_copy                 = (1 << 5),
 
     /// Is the 'move' field of the type_data structure set?
-    has_move                 = (1 << 11),
+    has_move                 = (1 << 6),
 
     /// Internal: does the type maintain a list of implicit conversions?
-    has_implicit_conversions = (1 << 12),
-
-    /// This type is a signed enumeration
-    is_signed_enum           = (1 << 13),
+    has_implicit_conversions = (1 << 7),
 
-    /// This type is an unsigned enumeration
-    is_unsigned_enum         = (1 << 14),
-
-    /// This type is an arithmetic enumeration
-    is_arithmetic            = (1 << 15),
-
-    /// This type provides extra PyType_Slot fields
-    has_type_slots           = (1 << 16),
-
-    /// This type does not permit subclassing from Python
-    is_final                 = (1 << 17),
+    /// Is this a python type that extends a bound C++ type?
+    is_python_type           = (1 << 8),
 
     /// This type does not permit subclassing from Python
-    has_supplement           = (1 << 18),
+    is_final                 = (1 << 9),
 
     /// Instances of this type support dynamic attribute assignment
-    has_dynamic_attr         = (1 << 19),
+    has_dynamic_attr         = (1 << 10),
 
     /// The class uses an intrusive reference counting approach
-    intrusive_ptr            = (1 << 20),
+    intrusive_ptr            = (1 << 11),
 
     /// Is this a trampoline class meant to be overloaded in Python?
-    is_trampoline            = (1 << 21)
+    is_trampoline            = (1 << 12),
+
+    /// Is this a class that inherits from enable_shared_from_this?
+    /// If so, type_data::keep_shared_from_this_alive is also set.
+    has_shared_from_this     = (1 << 13),
+
+    // Five more flag bits available (14 through 18) without needing
+    // a larger reorganization
+};
+
+/// Flags about a type that are only relevant when it is being created.
+/// These are currently stored in type_data::flags alongside the type_flags
+/// for more efficient memory layout, but could move elsewhere if we run
+/// out of flags.
+enum class type_init_flags : uint32_t {
+    /// Is the 'supplement' field of the type_init_data structure set?
+    has_supplement           = (1 << 19),
+
+    /// Is the 'doc' field of the type_init_data structure set?
+    has_doc                  = (1 << 20),
+
+    /// Is the 'base' field of the type_init_data structure set?
+    has_base                 = (1 << 21),
+
+    /// Is the 'base_py' field of the type_init_data structure set?
+    has_base_py              = (1 << 22),
+
+    /// This type provides extra PyType_Slot fields via the 'type_slots'
+    /// and/or 'type_slots_callback' members of type_init_data
+    has_type_slots           = (1 << 23),
+
+    all_init_flags           = (0x1f << 19)
 };
 
+/// Information about a type that persists throughout its lifetime
 struct type_data {
     uint32_t size;
     uint32_t align : 8;
     uint32_t flags : 24;
     const char *name;
-    const char *doc;
-    PyObject *scope;
     const std::type_info *type;
-    const std::type_info *base;
     PyTypeObject *type_py;
-    PyTypeObject *base_py;
     void (*destruct)(void *);
     void (*copy)(void *, const void *);
     void (*move)(void *, void *) noexcept;
     const std::type_info **implicit;
     bool (**implicit_py)(PyTypeObject *, PyObject *, cleanup_list *) noexcept;
-    PyType_Slot *type_slots;
-    void *supplement;
     void (*set_self_py)(void *, PyObject *) noexcept;
+    bool (*keep_shared_from_this_alive)(PyObject *) noexcept;
 #if defined(Py_LIMITED_API)
     size_t dictoffset;
 #endif
 };
 
-NB_INLINE void type_extra_apply(type_data &t, const handle &h) {
-    t.flags |= (uint32_t) type_flags::has_base_py;
+/// Information about a type that is only relevant when it is being created
+struct type_init_data : type_data {
+    PyObject *scope;
+    const std::type_info *base;
+    PyTypeObject *base_py;
+    const char *doc;
+    const PyType_Slot *type_slots;
+    void (*type_slots_callback)(const type_init_data *d, PyType_Slot *&slots, size_t max_slots);
+    size_t supplement;
+};
+
+NB_INLINE void type_extra_apply(type_init_data &t, const handle &h) {
+    t.flags |= (uint32_t) type_init_flags::has_base_py;
     t.base_py = (PyTypeObject *) h.ptr();
 }
 
-NB_INLINE void type_extra_apply(type_data &t, const char *doc) {
-    t.flags |= (uint32_t) type_flags::has_doc;
+NB_INLINE void type_extra_apply(type_init_data &t, const char *doc) {
+    t.flags |= (uint32_t) type_init_flags::has_doc;
     t.doc = doc;
 }
 
-NB_INLINE void type_extra_apply(type_data &t, type_slots c) {
-    t.flags |= (uint32_t) type_flags::has_type_slots;
+NB_INLINE void type_extra_apply(type_init_data &t, type_slots c) {
+    if ((t.flags & (uint32_t) type_init_flags::has_type_slots) == 0) {
+        t.flags |= (uint32_t) type_init_flags::has_type_slots;
+        t.type_slots_callback = nullptr;
+    }
     t.type_slots = c.value;
 }
 
+NB_INLINE void type_extra_apply(type_init_data &t, type_slots_callback c) {
+    if ((t.flags & (uint32_t) type_init_flags::has_type_slots) == 0) {
+        t.flags |= (uint32_t) type_init_flags::has_type_slots;
+        t.type_slots = nullptr;
+    }
+    t.type_slots_callback = c.callback;
+}
+
 template <typename T>
-NB_INLINE void type_extra_apply(type_data &t, intrusive_ptr<T> ip) {
+NB_INLINE void type_extra_apply(type_init_data &t, intrusive_ptr<T> ip) {
     t.flags |= (uint32_t) type_flags::intrusive_ptr;
     t.set_self_py = (void (*)(void *, PyObject *) noexcept) ip.set_self_py;
 }
 
-NB_INLINE void type_extra_apply(type_data &t, is_enum e) {
-    if (e.is_signed)
-        t.flags |= (uint32_t) type_flags::is_signed_enum;
-    else
-        t.flags |= (uint32_t) type_flags::is_unsigned_enum;
-}
-
-NB_INLINE void type_extra_apply(type_data &t, is_final) {
+NB_INLINE void type_extra_apply(type_init_data &t, is_final) {
     t.flags |= (uint32_t) type_flags::is_final;
 }
 
-NB_INLINE void type_extra_apply(type_data &t, is_arithmetic) {
-    t.flags |= (uint32_t) type_flags::is_arithmetic;
-}
-
-NB_INLINE void type_extra_apply(type_data &t, dynamic_attr) {
+NB_INLINE void type_extra_apply(type_init_data &t, dynamic_attr) {
     t.flags |= (uint32_t) type_flags::has_dynamic_attr;
 }
 
 template <typename T>
-NB_INLINE void type_extra_apply(type_data &t, supplement<T>) {
+NB_INLINE void type_extra_apply(type_init_data &t, supplement<T>) {
     static_assert(std::is_trivially_default_constructible_v<T>,
-                  "The supplement type must be a POD (plain old data) type");
-    t.flags |= (uint32_t) type_flags::has_supplement | (uint32_t) type_flags::is_final;
-    t.supplement = (void *) malloc(sizeof(T));
+                  "The supplement must be a POD (plain old data) type");
+    static_assert(alignof(T) <= alignof(void *),
+                  "The alignment requirement of the supplement is too high.");
+    t.flags |= (uint32_t) type_init_flags::has_supplement | (uint32_t) type_flags::is_final;
+    t.supplement = sizeof(T);
 }
 
+/// Information about an enum, stored as its type_data::supplement
+struct enum_supplement {
+    bool is_signed = false;
+    PyObject* entries = nullptr;
+    PyObject* scope = nullptr;
+};
+
+/// Information needed to create an enum
+struct enum_init_data : type_init_data {
+    bool is_signed = false;
+    bool is_arithmetic = false;
+};
+
+NB_INLINE void type_extra_apply(enum_init_data &ed, is_arithmetic) {
+    ed.is_arithmetic = true;
+}
+
+// Enums can't have base classes or supplements or be intrusive, and
+// are always final. They can't use type_slots_callback because that is
+// used by the enum mechanism internally, but can provide additional
+// slots using type_slots.
+void type_extra_apply(enum_init_data &, const handle &) = delete;
+template <typename T>
+void type_extra_apply(enum_init_data &, intrusive_ptr<T>) = delete;
+template <typename T>
+void type_extra_apply(enum_init_data &, supplement<T>) = delete;
+void type_extra_apply(enum_init_data &, is_final) = delete;
+void type_extra_apply(enum_init_data &, type_slots_callback) = delete;
+
 template <typename T> void wrap_copy(void *dst, const void *src) {
     new ((T *) dst) T(*(const T *) src);
 }
 
 template <typename T> void wrap_move(void *dst, void *src) noexcept {
     new ((T *) dst) T(std::move(*(T *) src));
 }
@@ -190,14 +233,36 @@
 struct is_copy_constructible : std::is_copy_constructible<T> { };
 
 template <typename T>
 constexpr bool is_copy_constructible_v = is_copy_constructible<T>::value;
 
 NAMESPACE_END(detail)
 
+// Low level access to nanobind type objects
+inline bool type_check(handle h) { return detail::nb_type_check(h.ptr()); }
+inline size_t type_size(handle h) { return detail::nb_type_size(h.ptr()); }
+inline size_t type_align(handle h) { return detail::nb_type_align(h.ptr()); }
+inline const std::type_info& type_info(handle h) { return *detail::nb_type_info(h.ptr()); }
+template <typename T>
+inline T &type_supplement(handle h) { return *(T *) detail::nb_type_supplement(h.ptr()); }
+
+// Low level access to nanobind instance objects
+inline bool inst_check(handle h) { return type_check(h.type()); }
+inline object inst_alloc(handle h) { return steal(detail::nb_inst_alloc((PyTypeObject *) h.ptr())); }
+inline object inst_wrap(handle h, void *p) { return steal(detail::nb_inst_wrap((PyTypeObject *) h.ptr(), p)); }
+inline void inst_zero(handle h) { detail::nb_inst_zero(h.ptr()); }
+inline void inst_set_state(handle h, bool ready, bool destruct) { detail::nb_inst_set_state(h.ptr(), ready, destruct); }
+inline std::pair<bool, bool> inst_state(handle h) { return detail::nb_inst_state(h.ptr()); }
+inline void inst_mark_ready(handle h) { inst_set_state(h, true, true); }
+inline bool inst_ready(handle h) { return inst_state(h).first; }
+inline void inst_destruct(handle h) { detail::nb_inst_destruct(h.ptr()); }
+inline void inst_copy(handle dst, handle src) { detail::nb_inst_copy(dst.ptr(), src.ptr()); }
+inline void inst_move(handle dst, handle src) { detail::nb_inst_move(dst.ptr(), src.ptr()); }
+template <typename T> T *inst_ptr(handle h) { return (T *) detail::nb_inst_ptr(h.ptr()); }
+
 template <typename... Args> struct init {
     template <typename T, typename... Ts> friend class class_;
     NB_INLINE init() {}
 
 private:
     template <typename Class, typename... Extra>
     NB_INLINE static void execute(Class &cl, const Extra&... extra) {
@@ -207,16 +272,23 @@
             detail::make_caster<Type>::IsClass,
             "Attempted to create a constructor for a type that won't be "
             "handled by the nanobind's class type caster. Is it possible that "
             "you forgot to add NB_MAKE_OPAQUE() somewhere?");
 
         cl.def(
             "__init__",
-            [](Type *v, Args... args) {
-                new ((Alias *) v) Alias{ (detail::forward_t<Args>) args... };
+            [](pointer_and_handle<Type> v, Args... args) {
+                if constexpr (!std::is_same_v<Type, Alias> &&
+                              std::is_constructible_v<Type, Args...>) {
+                    if (!detail::nb_inst_python_derived(v.h.ptr())) {
+                        new ((Type *) v.p) Type{ (detail::forward_t<Args>) args... };
+                        return;
+                    }
+                }
+                new ((Alias *) v.p) Alias{ (detail::forward_t<Args>) args... };
             },
             extra...);
     }
 };
 
 template <typename Arg> struct init_implicit {
     template <typename T, typename... Ts> friend class class_;
@@ -232,16 +304,23 @@
             detail::make_caster<Type>::IsClass,
             "Attempted to create a constructor for a type that won't be "
             "handled by the nanobind's class type caster. Is it possible that "
             "you forgot to add NB_MAKE_OPAQUE() somewhere?");
 
         cl.def(
             "__init__",
-            [](Type *v, Arg arg) {
-                new ((Alias *) v) Alias{ (detail::forward_t<Arg>) arg };
+            [](pointer_and_handle<Type> v, Arg arg) {
+                if constexpr (!std::is_same_v<Type, Alias> &&
+                              std::is_constructible_v<Type, Arg>) {
+                    if (!detail::nb_inst_python_derived(v.h.ptr())) {
+                        new ((Type *) v.p) Type{ (detail::forward_t<Arg>) arg };
+                        return;
+                    }
+                }
+                new ((Alias *) v.p) Alias{ (detail::forward_t<Arg>) arg };
             }, is_implicit(), extra...);
 
         if constexpr (!Caster::IsClass) {
             detail::implicitly_convertible(
                 [](PyTypeObject *, PyObject *src,
                    detail::cleanup_list *cleanup) noexcept -> bool {
                     return Caster().from_python(
@@ -264,27 +343,26 @@
     static_assert(alignof(Alias) < (1 << 8), "instance alignment is too big!");
     static_assert(
         sizeof...(Ts) == !std::is_same_v<Base, T> + !std::is_same_v<Alias, T>,
         "nanobind::class_<> was invoked with extra arguments that could not be handled");
 
     template <typename... Extra>
     NB_INLINE class_(handle scope, const char *name, const Extra &... extra) {
-        detail::type_data d;
+        detail::type_init_data d;
 
-        d.flags = (uint32_t) detail::type_flags::has_scope;
+        d.flags = 0;
         d.align = (uint8_t) alignof(Alias);
         d.size = (uint32_t) sizeof(Alias);
-        d.supplement = 0;
         d.name = name;
         d.scope = scope.ptr();
         d.type = &typeid(T);
 
         if constexpr (!std::is_same_v<Base, T>) {
             d.base = &typeid(Base);
-            d.flags |= (uint32_t) detail::type_flags::has_base;
+            d.flags |= (uint32_t) detail::type_init_flags::has_base;
         }
 
         if constexpr (!std::is_same_v<Alias, T>)
             d.flags |= (uint32_t) detail::type_flags::is_trampoline;
 
         if constexpr (detail::is_copy_constructible_v<T>) {
             d.flags |= (uint32_t) detail::type_flags::is_copy_constructible;
@@ -309,14 +387,32 @@
 
             if constexpr (!std::is_trivially_destructible_v<T>) {
                 d.flags |= (uint32_t) detail::type_flags::has_destruct;
                 d.destruct = detail::wrap_destruct<T>;
             }
         }
 
+        if constexpr (detail::has_shared_from_this_v<T>) {
+            d.flags |= (uint32_t) detail::type_flags::has_shared_from_this;
+            d.keep_shared_from_this_alive = [](PyObject *self) noexcept {
+                // weak_from_this().lock() is equivalent to shared_from_this(),
+                // except that it returns an empty shared_ptr instead of
+                // throwing an exception if there is no active shared_ptr
+                // for this object. (Added in C++17.)
+                if (auto sp = inst_ptr<T>(self)->weak_from_this().lock()) {
+                    detail::keep_alive(self, new auto(std::move(sp)),
+                                       [](void *p) noexcept {
+                                           delete (decltype(sp) *) p;
+                                       });
+                    return true;
+                }
+                return false;
+            };
+        }
+
         (detail::type_extra_apply(d, extra), ...);
 
         m_ptr = detail::nb_type_new(&d);
     }
 
     template <typename Func, typename... Extra>
     NB_INLINE class_ &def(const char *name_, Func &&f, const Extra &... extra) {
@@ -358,16 +454,15 @@
                                  scope(*this), is_method(),
                                  rv_policy::reference_internal, extra...);
 
         if constexpr (!std::is_same_v<Setter, std::nullptr_t>)
             set_p = cpp_function((detail::forward_t<Setter>) setter,
                                  scope(*this), is_method(), extra...);
 
-        detail::property_install(m_ptr, name_, false, get_p.ptr(),
-                                 set_p.ptr());
+        detail::property_install(m_ptr, name_, get_p.ptr(), set_p.ptr());
         return *this;
     }
 
     template <typename Getter, typename Setter, typename... Extra>
     NB_INLINE class_ &def_prop_rw_static(const char *name_, Getter &&getter,
                                          Setter &&setter,
                                          const Extra &...extra) {
@@ -377,16 +472,15 @@
             get_p = cpp_function((detail::forward_t<Getter>) getter,
                                  scope(*this), rv_policy::reference, extra...);
 
         if constexpr (!std::is_same_v<Setter, std::nullptr_t>)
             set_p = cpp_function((detail::forward_t<Setter>) setter,
                                  scope(*this), extra...);
 
-        detail::property_install(m_ptr, name_, true, get_p.ptr(),
-                                 set_p.ptr());
+        detail::property_install_static(m_ptr, name_, get_p.ptr(), set_p.ptr());
         return *this;
     }
 
     template <typename Getter, typename... Extra>
     NB_INLINE class_ &def_prop_ro(const char *name_, Getter &&getter,
                                   const Extra &...extra) {
         return def_prop_rw(name_, getter, nullptr, extra...);
@@ -464,17 +558,42 @@
 template <typename T> class enum_ : public class_<T> {
 public:
     static_assert(std::is_enum_v<T>, "nanobind::enum_<> requires an enumeration type!");
 
     using Base = class_<T>;
 
     template <typename... Extra>
-    NB_INLINE enum_(handle scope, const char *name, const Extra &...extra)
-        : Base(scope, name, extra...,
-               is_enum{ std::is_signed_v<std::underlying_type_t<T>> }) { }
+    NB_INLINE enum_(handle scope, const char *name, const Extra &...extra) {
+        detail::enum_init_data d;
+
+        static_assert(std::is_trivially_copyable_v<T>);
+        d.flags = ((uint32_t) detail::type_init_flags::has_supplement |
+                   (uint32_t) detail::type_init_flags::has_type_slots |
+                   (uint32_t) detail::type_flags::is_copy_constructible |
+                   (uint32_t) detail::type_flags::is_move_constructible |
+                   (uint32_t) detail::type_flags::is_destructible |
+                   (uint32_t) detail::type_flags::is_final);
+        d.align = (uint8_t) alignof(T);
+        d.size = (uint32_t) sizeof(T);
+        d.name = name;
+        d.type = &typeid(T);
+        d.supplement = sizeof(detail::enum_supplement);
+        d.scope = scope.ptr();
+        d.type_slots = nullptr;
+        d.type_slots_callback = detail::nb_enum_prepare;
+        d.is_signed = std::is_signed_v<std::underlying_type_t<T>>;
+
+        (detail::type_extra_apply(d, extra), ...);
+
+        Base::m_ptr = detail::nb_type_new(&d);
+
+        detail::enum_supplement &supp = type_supplement<detail::enum_supplement>(*this);
+        supp.is_signed = d.is_signed;
+        supp.scope = d.scope;
+    }
 
     NB_INLINE enum_ &value(const char *name, T value, const char *doc = nullptr) {
         detail::nb_enum_put(Base::m_ptr, name, &value, doc);
         return *this;
     }
 
     NB_INLINE enum_ &export_values() { detail::nb_enum_export(Base::m_ptr); return *this; }
@@ -492,30 +611,8 @@
                 return Caster().from_python(src, detail::cast_flags::convert,
                                             cleanup);
             },
             &typeid(Target));
     }
 }
 
-// Low level access to nanobind type objects
-inline bool type_check(handle h) { return detail::nb_type_check(h.ptr()); }
-inline size_t type_size(handle h) { return detail::nb_type_size(h.ptr()); }
-inline size_t type_align(handle h) { return detail::nb_type_align(h.ptr()); }
-inline const std::type_info& type_info(handle h) { return *detail::nb_type_info(h.ptr()); }
-template <typename T>
-inline T &type_supplement(handle h) { return *(T *) detail::nb_type_supplement(h.ptr()); }
-
-// Low level access to nanobind instance objects
-inline bool inst_check(handle h) { return type_check(h.type()); }
-inline object inst_alloc(handle h) { return steal(detail::nb_inst_alloc((PyTypeObject *) h.ptr())); }
-inline object inst_wrap(handle h, void *p) { return steal(detail::nb_inst_wrap((PyTypeObject *) h.ptr(), p)); }
-inline void inst_zero(handle h) { detail::nb_inst_zero(h.ptr()); }
-inline void inst_set_state(handle h, bool ready, bool destruct) { detail::nb_inst_set_state(h.ptr(), ready, destruct); }
-inline std::pair<bool, bool> inst_state(handle h) { return detail::nb_inst_state(h.ptr()); }
-inline void inst_mark_ready(handle h) { inst_set_state(h, true, true); }
-inline bool inst_ready(handle h) { return inst_state(h).first; }
-inline void inst_destruct(handle h) { detail::nb_inst_destruct(h.ptr()); }
-inline void inst_copy(handle dst, handle src) { detail::nb_inst_copy(dst.ptr(), src.ptr()); }
-inline void inst_move(handle dst, handle src) { detail::nb_inst_move(dst.ptr(), src.ptr()); }
-template <typename T> T *inst_ptr(handle h) { return (T *) detail::nb_inst_ptr(h.ptr()); }
-
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/include/nanobind/nb_defs.h

```diff
@@ -27,15 +27,15 @@
 #  define NB_IMPORT        __declspec(dllimport)
 #  define NB_INLINE        __forceinline
 #  define NB_INLINE_LAMBDA
 #  define NB_NOINLINE      __declspec(noinline)
 # define  NB_STRDUP        _strdup
 #else
 #  define NB_EXPORT        __attribute__ ((visibility("default")))
-#  define NB_IMPORT        __attribute__ ((visibility("default")))
+#  define NB_IMPORT        NB_EXPORT
 #  define NB_INLINE        inline __attribute__((always_inline))
 #  define NB_NOINLINE      __attribute__((noinline))
 #if defined(__clang__)
 #    define NB_INLINE_LAMBDA __attribute__((always_inline))
 #else
 #    define NB_INLINE_LAMBDA
 #endif
@@ -59,19 +59,21 @@
 #if defined(NB_SHARED)
 #  if defined(NB_BUILD)
 #    define NB_CORE NB_EXPORT
 #  else
 #    define NB_CORE NB_IMPORT
 #  endif
 #else
-#  if defined(_WIN32)
-#    define NB_CORE
-#  else
-#    define NB_CORE NB_EXPORT
-#  endif
+#  define NB_CORE
+#endif
+
+#if !defined(NB_SHARED) && defined(__GNUC__)
+#  define NB_EXPORT_SHARED __attribute__ ((visibility("hidden")))
+#else
+#  define NB_EXPORT_SHARED
 #endif
 
 #if defined(__cpp_lib_char8_t) && __cpp_lib_char8_t >= 201811L
 #  define NB_HAS_U8STRING
 #endif
 
 #if defined(Py_TPFLAGS_HAVE_VECTORCALL)
```

## nanobind/include/nanobind/nb_error.h

```diff
@@ -15,78 +15,85 @@
     ~error_scope() { PyErr_Restore(type, value, trace); }
     PyObject *type, *value, *trace;
 };
 
 /// Wraps a Python error state as a C++ exception
 class NB_EXPORT python_error : public std::exception {
 public:
-    python_error();
-    python_error(const python_error &);
-    python_error(python_error &&) noexcept;
-    ~python_error() override;
+    NB_EXPORT_SHARED python_error();
+    NB_EXPORT_SHARED python_error(const python_error &);
+    NB_EXPORT_SHARED python_error(python_error &&) noexcept;
+    NB_EXPORT_SHARED ~python_error() override;
 
     bool matches(handle exc) const noexcept {
         return PyErr_GivenExceptionMatches(m_type, exc.ptr()) != 0;
     }
 
-    /// Move the error back into the Python domain
-    void restore() noexcept;
+    /// Move the error back into the Python domain. This may only be called
+    /// once, and you should not reraise the exception in C++ afterward.
+    NB_EXPORT_SHARED void restore() noexcept;
+
+    /// Pass the error to Python's `sys.unraisablehook`, which prints
+    /// a traceback to `sys.stderr` by default but may be overridden.
+    /// The *context* should be some object whose repr() helps clarify where
+    /// the error occurred. Like `.restore()`, this consumes the error and
+    /// you should not reraise the exception in C++ afterward.
+    void discard_as_unraisable(handle context) noexcept {
+        restore();
+        PyErr_WriteUnraisable(context.ptr());
+    }
 
     handle type() const { return m_type; }
     handle value() const { return m_value; }
     handle trace() const { return m_trace; }
 
-    const char *what() const noexcept override;
+    NB_EXPORT_SHARED const char *what() const noexcept override;
 
 private:
     mutable PyObject *m_type = nullptr;
     mutable PyObject *m_value = nullptr;
     mutable PyObject *m_trace = nullptr;
     mutable char *m_what = nullptr;
 };
 
-/// Throw from a bound method to skip to the next overload
-class NB_EXPORT next_overload : public std::exception {
-public:
-    next_overload();
-    ~next_overload() override;
-    const char *what() const noexcept override;
-};
-
 /// Thrown by nanobind::cast when casting fails
-class NB_EXPORT cast_error : public std::exception {
-public:
-    cast_error();
-    ~cast_error() override;
-    const char *what() const noexcept override;
+using cast_error = std::bad_cast;
+
+enum class exception_type {
+    stop_iteration, index_error, key_error, value_error,
+    type_error, buffer_error, import_error, attribute_error,
+    next_overload
 };
 
 // Base interface used to expose common Python exceptions in C++
 class NB_EXPORT builtin_exception : public std::runtime_error {
 public:
-    using std::runtime_error::runtime_error;
-    virtual void set_error() const = 0;
+    NB_EXPORT_SHARED builtin_exception(exception_type type, const char *what);
+    NB_EXPORT_SHARED builtin_exception(builtin_exception &&) = default;
+    NB_EXPORT_SHARED builtin_exception(const builtin_exception &) = default;
+    NB_EXPORT_SHARED ~builtin_exception();
+    NB_EXPORT_SHARED exception_type type() const { return m_type; }
+private:
+    exception_type m_type;
 };
 
-#define NB_EXCEPTION(type)                                          \
-    class NB_EXPORT type : public builtin_exception {               \
-    public:                                                         \
-        using builtin_exception::builtin_exception;                 \
-        type();                                                     \
-        void set_error() const override;                            \
-    };
+#define NB_EXCEPTION(name)                                                     \
+    inline builtin_exception name(const char *what = nullptr) {                \
+        return builtin_exception(exception_type::name, what);                  \
+    }
 
 NB_EXCEPTION(stop_iteration)
 NB_EXCEPTION(index_error)
 NB_EXCEPTION(key_error)
 NB_EXCEPTION(value_error)
 NB_EXCEPTION(type_error)
 NB_EXCEPTION(buffer_error)
 NB_EXCEPTION(import_error)
 NB_EXCEPTION(attribute_error)
+NB_EXCEPTION(next_overload)
 
 #undef NB_EXCEPTION
 
 inline void register_exception_translator(detail::exception_translator t,
                                           void *payload = nullptr) {
     detail::register_exception_translator(t, payload);
 }
```

## nanobind/include/nanobind/nb_func.h

```diff
@@ -18,15 +18,15 @@
     using Guard = typename extract_guard<Extra...>::type;
 
     if constexpr (CheckGuard && !std::is_same_v<Guard, void>) {
         return func_create<ReturnRef, false>(
             [func = (forward_t<Func>) func](Args... args) NB_INLINE_LAMBDA {
                 typename Guard::type g;
                 (void) g;
-                return func(args...);
+                return func((forward_t<Args>) args...);
             },
             (Return(*)(Args...)) nullptr, is, extra...);
     }
 
     (void) is;
 
     // Detect locations of nb::args / nb::kwargs (if exists)
```

## nanobind/include/nanobind/nb_lib.h

```diff
@@ -57,15 +57,14 @@
 protected:
     uint32_t m_size;
     uint32_t m_capacity;
     PyObject **m_data;
     PyObject *m_local[Small];
 };
 
-
 // ========================================================================
 
 /// Raise a std::runtime_error with the given message
 #if defined(__GNUC__)
     __attribute__((noreturn, __format__ (__printf__, 1, 2)))
 #else
     [[noreturn]]
@@ -77,18 +76,18 @@
     __attribute__((noreturn, __format__ (__printf__, 1, 2)))
 #else
     [[noreturn]]
 #endif
 NB_CORE void fail(const char *fmt, ...) noexcept;
 
 /// Raise nanobind::python_error after an error condition was found
-NB_CORE void raise_python_error();
+[[noreturn]] NB_CORE void raise_python_error();
 
 /// Raise nanobind::next_overload
-NB_CORE void raise_next_overload();
+NB_CORE void raise_next_overload_if_null(void *p);
 
 /// Raise nanobind::cast_error
 NB_CORE void raise_cast_error();
 
 // ========================================================================
 
 /// Convert a Python object into a Python unicode string
@@ -222,16 +221,16 @@
 
 /// Create a Python function object for the given function record
 NB_CORE PyObject *nb_func_new(const void *data) noexcept;
 
 // ========================================================================
 
 /// Create a Python type object for the given type record
-struct type_data;
-NB_CORE PyObject *nb_type_new(const type_data *c) noexcept;
+struct type_init_data;
+NB_CORE PyObject *nb_type_new(const type_init_data *c) noexcept;
 
 /// Extract a pointer to a C++ type underlying a Python object, if possible
 NB_CORE bool nb_type_get(const std::type_info *t, PyObject *o, uint8_t flags,
                          cleanup_list *cleanup, void **out) noexcept;
 
 /// Cast a C++ type instance into a Python object
 NB_CORE PyObject *nb_type_put(const std::type_info *cpp_type, void *value,
@@ -296,14 +295,17 @@
 
 /// Copy-construct 'dst' from 'src', mark it as ready and to be destructed (must have the same nb_type)
 NB_CORE void nb_inst_copy(PyObject *dst, const PyObject *src) noexcept;
 
 /// Move-construct 'dst' from 'src', mark it as ready and to be destructed (must have the same nb_type)
 NB_CORE void nb_inst_move(PyObject *dst, const PyObject *src) noexcept;
 
+/// Check if a particular instance uses a Python-derived type
+NB_CORE bool nb_inst_python_derived(PyObject *o) noexcept;
+
 /**
  * This function can be used to manually set two important flags associated with
  * every nanobind instance (``nb_inst``).
  *
  * 1. 'ready': is the object fully constructed? Otherwise, nanobind will not
  *    allow passing it to a function.
  *
@@ -314,17 +316,21 @@
 
 /// Query the 'ready' and 'destruct' flags of an instance
 NB_CORE std::pair<bool, bool> nb_inst_state(PyObject *o) noexcept;
 
 // ========================================================================
 
 // Create and install a Python property object
-NB_CORE void property_install(PyObject *scope, const char *name, bool is_static,
+NB_CORE void property_install(PyObject *scope, const char *name,
                               PyObject *getter, PyObject *setter) noexcept;
 
+NB_CORE void property_install_static(PyObject *scope, const char *name,
+                                     PyObject *getter,
+                                     PyObject *setter) noexcept;
+
 // ========================================================================
 
 NB_CORE PyObject *get_override(void *ptr, const std::type_info *type,
                                const char *name, bool pure);
 
 // ========================================================================
 
@@ -345,14 +351,18 @@
 NB_CORE void implicitly_convertible(bool (*predicate)(PyTypeObject *,
                                                       PyObject *,
                                                       cleanup_list *),
                                     const std::type_info *dst) noexcept;
 
 // ========================================================================
 
+/// Fill in slots for an enum type being built
+NB_CORE void nb_enum_prepare(const type_init_data *t,
+                             PyType_Slot *&slots, size_t max_slots) noexcept;
+
 /// Add an entry to an enumeration
 NB_CORE void nb_enum_put(PyObject *type, const char *name, const void *value,
                          const char *doc) noexcept;
 
 /// Export enum entries to the parent scope
 NB_CORE void nb_enum_export(PyObject *type);
 
@@ -375,16 +385,16 @@
 NB_CORE ndarray_handle *ndarray_import(PyObject *o, const ndarray_req *req,
                                        bool convert) noexcept;
 
 // Describe a local ndarray object using a DLPack capsule
 NB_CORE ndarray_handle *ndarray_create(void *value, size_t ndim,
                                        const size_t *shape, PyObject *owner,
                                        const int64_t *strides,
-                                       dlpack::dtype *dtype, int32_t device,
-                                       int32_t device_id);
+                                       dlpack::dtype *dtype, bool ro,
+                                       int32_t device, int32_t device_id);
 
 /// Increase the reference count of the given ndarray object; returns a pointer
 /// to the underlying DLTensor
 NB_CORE dlpack::dltensor *ndarray_inc_ref(ndarray_handle *) noexcept;
 
 /// Decrease the reference count of the given ndarray object
 NB_CORE void ndarray_dec_ref(ndarray_handle *) noexcept;
```

## nanobind/include/nanobind/nb_traits.h

```diff
@@ -128,14 +128,24 @@
 
 /* This template is used for docstring generation and specialized in
    ``stl/{variant,optional.h}`` to strip away std::optional and
    ``std::variant<std::monostate>`` in top-level argument types and
    avoid redundancy when combined with nb::arg(...).none(). */
 template <typename T> struct remove_opt_mono { using type = T; };
 
+// Detect std::enable_shared_from_this without including <memory>
+template <typename T>
+auto has_shared_from_this_impl(T *ptr) ->
+    decltype(ptr->weak_from_this().lock().get(), std::true_type{});
+std::false_type has_shared_from_this_impl(...);
+
+template <typename T>
+constexpr bool has_shared_from_this_v =
+    decltype(has_shared_from_this_impl((T *) nullptr))::value;
+
 NAMESPACE_END(detail)
 
 template <typename... Args>
 static constexpr detail::overload_cast_impl<Args...> overload_cast = {};
 static constexpr auto const_ = std::true_type{};
 
 template <template<typename> class Op, typename Arg>
```

## nanobind/include/nanobind/nb_types.h

```diff
@@ -386,20 +386,20 @@
         : object(detail::bytes_from_cstr(s), detail::steal_t{}) { }
 
     explicit bytes(const char *s, size_t n)
         : object(detail::bytes_from_cstr_and_size(s, n), detail::steal_t{}) { }
 
     const char *c_str() { return PyBytes_AsString(m_ptr); }
 
-    size_t size() const { return PyBytes_Size(m_ptr); }
+    size_t size() const { return (size_t) PyBytes_Size(m_ptr); }
 };
 
 class tuple : public object {
     NB_OBJECT_DEFAULT(tuple, object, "tuple", PyTuple_Check)
-    size_t size() const { return NB_TUPLE_GET_SIZE(m_ptr); }
+    size_t size() const { return (size_t) NB_TUPLE_GET_SIZE(m_ptr); }
     template <typename T, detail::enable_if_t<std::is_arithmetic_v<T>> = 1>
     detail::accessor<detail::num_item_tuple> operator[](T key) const;
 
 #if !defined(Py_LIMITED_API) && !defined(PYPY_VERSION)
     detail::fast_iterator begin() const;
     detail::fast_iterator end() const;
 #endif
@@ -408,15 +408,15 @@
 class type_object : public object {
     NB_OBJECT_DEFAULT(type_object, object, "type", PyType_Check)
 };
 
 class list : public object {
     NB_OBJECT(list, object, "list", PyList_Check)
     list() : object(PyList_New(0), detail::steal_t()) { }
-    size_t size() const { return NB_LIST_GET_SIZE(m_ptr); }
+    size_t size() const { return (size_t) NB_LIST_GET_SIZE(m_ptr); }
 
     template <typename T> void append(T &&value);
 
     template <typename T, detail::enable_if_t<std::is_arithmetic_v<T>> = 1>
     detail::accessor<detail::num_item_list> operator[](T key) const;
 
 #if !defined(Py_LIMITED_API) && !defined(PYPY_VERSION)
@@ -424,15 +424,15 @@
     detail::fast_iterator end() const;
 #endif
 };
 
 class dict : public object {
     NB_OBJECT(dict, object, "dict", PyDict_Check)
     dict() : object(PyDict_New(), detail::steal_t()) { }
-    size_t size() const { return NB_DICT_GET_SIZE(m_ptr); }
+    size_t size() const { return (size_t) NB_DICT_GET_SIZE(m_ptr); }
     detail::dict_iterator begin() const;
     detail::dict_iterator end() const;
     list keys() const { return steal<list>(detail::obj_op_1(m_ptr, PyDict_Keys)); }
     list values() const { return steal<list>(detail::obj_op_1(m_ptr, PyDict_Values)); }
     list items() const { return steal<list>(detail::obj_op_1(m_ptr, PyDict_Items)); }
 };
 
@@ -511,17 +511,17 @@
     else
         return detail::make_caster<T>().from_python(h, 0, nullptr);
 }
 
 NB_INLINE str repr(handle h) { return steal<str>(detail::obj_repr(h.ptr())); }
 NB_INLINE size_t len(handle h) { return detail::obj_len(h.ptr()); }
 NB_INLINE size_t len_hint(handle h) { return detail::obj_len_hint(h.ptr()); }
-NB_INLINE size_t len(const tuple &t) { return NB_TUPLE_GET_SIZE(t.ptr()); }
-NB_INLINE size_t len(const list &l) { return NB_LIST_GET_SIZE(l.ptr()); }
-NB_INLINE size_t len(const dict &d) { return NB_DICT_GET_SIZE(d.ptr()); }
+NB_INLINE size_t len(const tuple &t) { return (size_t) NB_TUPLE_GET_SIZE(t.ptr()); }
+NB_INLINE size_t len(const list &l) { return (size_t) NB_LIST_GET_SIZE(l.ptr()); }
+NB_INLINE size_t len(const dict &d) { return (size_t) NB_DICT_GET_SIZE(d.ptr()); }
 
 inline void print(handle value, handle end = handle(), handle file = handle()) {
     detail::print(value.ptr(), end.ptr(), file.ptr());
 }
 
 inline void print(const char *str, handle end = handle(), handle file = handle()) {
     print(nanobind::str(str), end, file);
@@ -549,15 +549,15 @@
     slice(T start, T stop) : slice(int_(start), int_(stop), Py_None) {}
     template <typename T, detail::enable_if_t<std::is_arithmetic_v<T>> = 0>
     slice(T start, T stop, T step) : slice(int_(start), int_(stop), int_(step)) {}
 
     detail::tuple<Py_ssize_t, Py_ssize_t, Py_ssize_t, size_t> compute(size_t size) const {
         Py_ssize_t start, stop, step;
         size_t slice_length;
-        detail::slice_compute(m_ptr, size, start, stop, step, slice_length);
+        detail::slice_compute(m_ptr, (Py_ssize_t) size, start, stop, step, slice_length);
         return detail::tuple(start, stop, step, slice_length);
     }
 };
 
 class ellipsis : public object {
     static bool is_ellipsis(PyObject *obj) { return obj == Py_Ellipsis; }
 
@@ -597,14 +597,19 @@
                PyType_IsSubtype((PyTypeObject *) h.ptr(),
                                 (PyTypeObject *) nanobind::type<T>().ptr());
     }
 };
 
 template <typename T, typename X> struct typed { T value; };
 
+template <typename T> struct pointer_and_handle {
+    T *p;
+    handle h;
+};
+
 NAMESPACE_BEGIN(detail)
 template <typename Derived> NB_INLINE api<Derived>::operator handle() const {
     return derived().ptr();
 }
 
 template <typename Derived> NB_INLINE handle api<Derived>::type() const {
     return (PyObject *) Py_TYPE(derived().ptr());
```

## nanobind/include/nanobind/ndarray.h

```diff
@@ -108,57 +108,67 @@
 
 struct ndarray_req {
     dlpack::dtype dtype;
     uint32_t ndim = 0;
     size_t *shape = nullptr;
     bool req_shape = false;
     bool req_dtype = false;
+    bool req_ro = false;
     char req_order = '\0';
     uint8_t req_device = 0;
 };
 
 template <typename T, typename = int> struct ndarray_arg {
     static constexpr size_t size = 0;
     static constexpr auto name = descr<0>{ };
     static void apply(ndarray_req &) { }
 };
 
 template <typename T> struct ndarray_arg<T, enable_if_t<std::is_floating_point_v<T>>> {
     static constexpr size_t size = 0;
 
     static constexpr auto name =
-        const_name("dtype=float") + const_name<sizeof(T) * 8>();
+        const_name("dtype=float") +
+        const_name<sizeof(T) * 8>() +
+        const_name<std::is_const_v<T>>(", writable=False", "");
 
     static void apply(ndarray_req &tr) {
         tr.dtype = dtype<T>();
         tr.req_dtype = true;
+        tr.req_ro = std::is_const_v<T>;
     }
 };
 
 template <typename T> struct ndarray_arg<T, enable_if_t<std::is_integral_v<T> && !std::is_same_v<T, bool>>> {
     static constexpr size_t size = 0;
 
     static constexpr auto name =
-        const_name("dtype=") + const_name<std::is_unsigned_v<T>>("u", "") +
-        const_name("int") + const_name<sizeof(T) * 8>();
+        const_name("dtype=") +
+        const_name<std::is_unsigned_v<T>>("u", "") +
+        const_name("int") + const_name<sizeof(T) * 8>() +
+        const_name<std::is_const_v<T>>(", writable=False", "");
 
     static void apply(ndarray_req &tr) {
         tr.dtype = dtype<T>();
         tr.req_dtype = true;
+        tr.req_ro = std::is_const_v<T>;
     }
 };
 
 template <typename T> struct ndarray_arg<T, enable_if_t<std::is_same_v<T, bool>>> {
     static constexpr size_t size = 0;
 
-    static constexpr auto name = const_name("dtype=bool");
+    static constexpr auto name =
+        const_name("dtype=bool") +
+        const_name<std::is_const_v<T>>(", writable=False", "");
 
     static void apply(ndarray_req &tr) {
         tr.dtype = dtype<T>();
         tr.req_dtype = true;
+        tr.req_ro = std::is_const_v<T>;
     }
 };
 
 template <size_t... Is> struct ndarray_arg<shape<Is...>> {
     static constexpr size_t size = sizeof...(Is);
     static constexpr auto name =
         const_name("shape=(") +
@@ -244,25 +254,25 @@
     ndarray() = default;
 
     explicit ndarray(detail::ndarray_handle *handle) : m_handle(handle) {
         if (handle)
             m_dltensor = *detail::ndarray_inc_ref(handle);
     }
 
-    ndarray(void *value,
+    ndarray(std::conditional_t<std::is_const_v<Scalar>, const void *, void *> value,
             size_t ndim,
             const size_t *shape,
             handle owner = nanobind::handle(),
             const int64_t *strides = nullptr,
             dlpack::dtype dtype = nanobind::dtype<Scalar>(),
             int32_t device_type = device::cpu::value,
             int32_t device_id = 0) {
-        m_handle =
-            detail::ndarray_create(value, ndim, shape, owner.ptr(), strides,
-                                  &dtype, device_type, device_id);
+        m_handle = detail::ndarray_create(
+            (void *) value, ndim, shape, owner.ptr(), strides, &dtype,
+            std::is_const_v<Scalar>, device_type, device_id);
         m_dltensor = *detail::ndarray_inc_ref(m_handle);
     }
 
     ~ndarray() {
         detail::ndarray_dec_ref(m_handle);
     }
 
@@ -292,55 +302,73 @@
         return *this;
     }
 
     dlpack::dtype dtype() const { return m_dltensor.dtype; }
     size_t ndim() const { return (size_t) m_dltensor.ndim; }
     size_t shape(size_t i) const { return (size_t) m_dltensor.shape[i]; }
     int64_t stride(size_t i) const { return m_dltensor.strides[i]; }
-    int64_t* shape_ptr() const { return m_dltensor.shape; }
-    int64_t* stride_ptr() const { return m_dltensor.strides; }
+    const int64_t* shape_ptr() const { return m_dltensor.shape; }
+    const int64_t* stride_ptr() const { return m_dltensor.strides; }
     bool is_valid() const { return m_handle != nullptr; }
     int32_t device_type() const { return m_dltensor.device.device_type; }
     int32_t device_id() const { return m_dltensor.device.device_id; }
     detail::ndarray_handle *handle() const { return m_handle; }
 
     size_t size() const {
         size_t ret = 1;
         for (size_t i = 0; i < ndim(); ++i)
             ret *= shape(i);
         return ret;
     }
 
+    size_t itemsize() const { return ((size_t) dtype().bits + 7) / 8; }
+    size_t nbytes() const { return ((size_t) dtype().bits * size() + 7) / 8; }
+
     const Scalar *data() const {
         return (const Scalar *)((const uint8_t *) m_dltensor.data + m_dltensor.byte_offset);
     }
 
-    Scalar *data() { return (Scalar *)((uint8_t *) m_dltensor.data + m_dltensor.byte_offset); }
+    template <typename T = Scalar, std::enable_if_t<!std::is_const_v<T>, int> = 1>
+    Scalar *data() {
+        return (Scalar *) ((uint8_t *) m_dltensor.data +
+                           m_dltensor.byte_offset);
+    }
+
+    template <typename T = Scalar,
+              std::enable_if_t<!std::is_const_v<T>, int> = 1, typename... Ts>
+    NB_INLINE auto &operator()(Ts... indices) {
+        return *(Scalar *) ((uint8_t *) m_dltensor.data +
+                            byte_offset(indices...));
+    }
+
+    template <typename... Ts> NB_INLINE const auto & operator()(Ts... indices) const {
+        return *(const Scalar *) ((const uint8_t *) m_dltensor.data +
+                                  byte_offset(indices...));
+    }
 
+private:
     template <typename... Ts>
-    NB_INLINE auto& operator()(Ts... indices) {
+    NB_INLINE int64_t byte_offset(Ts... indices) const {
         static_assert(
             !std::is_same_v<Scalar, void>,
             "To use nb::ndarray::operator(), you must add a scalar type "
             "annotation (e.g. 'float') to the ndarray template parameters.");
         static_assert(
             !std::is_same_v<Scalar, void>,
             "To use nb::ndarray::operator(), you must add a nb::shape<> "
             "annotation to the ndarray template parameters.");
         static_assert(sizeof...(Ts) == Info::shape_type::size,
                       "nb::ndarray::operator(): invalid number of arguments");
-
-        int64_t counter = 0, index = 0;
+        size_t counter = 0;
+        int64_t index = 0;
         ((index += int64_t(indices) * m_dltensor.strides[counter++]), ...);
-        return (Scalar &) *(
-            (uint8_t *) m_dltensor.data + m_dltensor.byte_offset +
-            index * sizeof(typename Info::scalar_type));
+
+        return (int64_t) m_dltensor.byte_offset + index * sizeof(typename Info::scalar_type);
     }
 
-private:
     detail::ndarray_handle *m_handle = nullptr;
     dlpack::dltensor m_dltensor;
 };
 
 NAMESPACE_BEGIN(detail)
 
 template <typename... Args> struct type_caster<ndarray<Args...>> {
```

## nanobind/include/nanobind/trampoline.h

```diff
@@ -51,16 +51,14 @@
             nb_trampoline.base().attr(nb_key)(__VA_ARGS__));                   \
     } else                                                                     \
         return NBBase::func(__VA_ARGS__)
 
 #define NB_OVERRIDE_PURE_NAME(name, func, ...)                                 \
     nanobind::handle nb_key = nb_trampoline.lookup(name, true);                \
     using nb_ret_type = decltype(NBBase::func(__VA_ARGS__));                   \
-    if (!nb_key.is_valid())                                                    \
-        throw std::runtime_error("Method " name " not implemented!");          \
     nanobind::gil_scoped_acquire nb_guard;                                     \
     return nanobind::cast<nb_ret_type>(                                        \
         nb_trampoline.base().attr(nb_key)(__VA_ARGS__))
 
 #define NB_OVERRIDE(func, ...)                                                 \
     NB_OVERRIDE_NAME(#func, func, __VA_ARGS__)
```

## nanobind/include/nanobind/eigen/dense.h

```diff
@@ -136,14 +136,16 @@
         }
 
         object owner;
         if (policy == rv_policy::move) {
             T *temp = new T(std::move(v));
             owner = capsule(temp, [](void *p) noexcept { delete (T *) p; });
             ptr = temp->data();
+        } else if (policy == rv_policy::reference_internal) {
+            owner = borrow(cleanup->self());
         }
 
         rv_policy array_rv_policy =
             policy == rv_policy::move ? rv_policy::reference : policy;
 
         object o = steal(NDArrayCaster::from_cpp(
             NDArray(ptr, NumDimensions<T>, shape, owner, strides),
@@ -207,29 +209,31 @@
 
     StrideType strides() const {
         constexpr int IS = StrideType::InnerStrideAtCompileTime,
                       OS = StrideType::OuterStrideAtCompileTime;
 
         int64_t inner = caster.value.stride(0),
                 outer = caster.value.stride(1);
+        (void) outer;
 
         if constexpr (T::IsRowMajor)
             std::swap(inner, outer);
 
         if constexpr (std::is_same_v<StrideType, Eigen::InnerStride<IS>>)
             return StrideType(inner);
         else if constexpr (std::is_same_v<StrideType, Eigen::OuterStride<OS>>)
             return StrideType(outer);
         else
             return StrideType(outer, inner);
     }
 
     operator Map() {
         NDArray &t = caster.value;
-        return Map(t.data(), t.shape(0), t.shape(1), strides());
+        return Map(t.data(), t.shape(0), t.ndim() == 1 ? 1 : t.shape(1),
+                   strides());
     }
 };
 
 /// Caster for Eigen::Ref<T>
 template <typename T, int Options, typename StrideType>
 struct type_caster<Eigen::Ref<T, Options, StrideType>, enable_if_t<is_eigen_plain_v<T>>> {
     using Ref = Eigen::Ref<T, Options, StrideType>;
```

## nanobind/include/nanobind/stl/shared_ptr.h

```diff
@@ -11,86 +11,94 @@
 
 #include <nanobind/nanobind.h>
 #include <memory>
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
+// shared_ptr deleter that reduces the reference count of a Python object
+struct py_deleter {
+    void operator()(void *) noexcept {
+        // Don't run the deleter if the interpreter has been shut down
+        if (!Py_IsInitialized())
+            return;
+        gil_scoped_acquire guard;
+        Py_DECREF(o);
+    }
+
+    PyObject *o;
+};
+
 /**
- * Create a generic std::shared_ptr to evade population of a potential
- * std::enable_shared_from_this weak pointer. The specified deleter reduces the
- * reference count of the Python object.
+ * Create a std::shared_ptr for `ptr` that owns a reference to the Python
+ * object `h`; if `ptr` is non-null, then the refcount of `h` is incremented
+ * before creating the shared_ptr and decremented by its deleter.
+ *
+ * Usually this is instantiated with T = void, to reduce template bloat.
+ * But if the pointee type uses enable_shared_from_this, we instantiate
+ * with T = that type, in order to allow its internal weak_ptr to share
+ * ownership with the shared_ptr we're creating.
  *
  * The next two functions are simultaneously marked as 'inline' (to avoid
  * linker errors) and 'NB_NOINLINE' (to avoid them being inlined into every
  * single shared_ptr type_caster, which would enlarge the binding size)
  */
-inline NB_NOINLINE std::shared_ptr<void>
-shared_from_python(void *ptr, handle h) noexcept {
-    struct py_deleter {
-        void operator()(void *) noexcept {
-            // Don't run the deleter if the interpreter has been shut down
-            if (!Py_IsInitialized())
-                return;
-            gil_scoped_acquire guard;
-            Py_DECREF(o);
-        }
-
-        PyObject *o;
-    };
-
+template <typename T>
+inline NB_NOINLINE std::shared_ptr<T>
+shared_from_python(T *ptr, handle h) noexcept {
     if (ptr)
-        return std::shared_ptr<void>(ptr, py_deleter{ h.inc_ref().ptr() });
+        return std::shared_ptr<T>(ptr, py_deleter{ h.inc_ref().ptr() });
     else
-        return std::shared_ptr<void>((PyObject *) nullptr);
+        return std::shared_ptr<T>(nullptr);
 }
 
 inline NB_NOINLINE void shared_from_cpp(std::shared_ptr<void> &&ptr,
                                         PyObject *o) noexcept {
     keep_alive(o, new std::shared_ptr<void>(std::move(ptr)),
                [](void *p) noexcept { delete (std::shared_ptr<void> *) p; });
 }
 
-template <class T, class = void>
-struct uses_shared_from_this : std::false_type { };
-
-template <class T>
-struct uses_shared_from_this<
-    T, std::void_t<decltype(std::declval<T>().shared_from_this())>>
-    : std::true_type { };
-
 template <typename T> struct type_caster<std::shared_ptr<T>> {
     using Value = std::shared_ptr<T>;
     using Caster = make_caster<T>;
     static_assert(Caster::IsClass,
                   "Binding 'shared_ptr<T>' requires that 'T' can also be bound "
                   "by nanobind. It appears that you specified a type which "
                   "would undergo conversion/copying, which is not allowed.");
-    static_assert(!uses_shared_from_this<T>::value,
-                  "nanobind does not permit use of std::shared_from_this, "
-                  "which can cause undefined behavior. (Refer to "
-                  "https://nanobind.readthedocs.io/en/latest/ownership.html "
-                  "for details.)");
 
     static constexpr auto Name = Caster::Name;
     static constexpr bool IsClass = true;
 
     template <typename T_> using Cast = movable_cast_t<T_>;
 
     Value value;
 
     bool from_python(handle src, uint8_t flags,
                      cleanup_list *cleanup) noexcept {
         Caster caster;
         if (!caster.from_python(src, flags, cleanup))
             return false;
 
-        value = std::static_pointer_cast<T>(
-            shared_from_python(caster.operator T *(), src));
-
+        T *ptr = caster.operator T *();
+        if constexpr (has_shared_from_this_v<T>) {
+            if (ptr) {
+                if (auto sp = ptr->weak_from_this().lock()) {
+                    // There is already a C++ shared_ptr for this object. Use it.
+                    value = std::static_pointer_cast<T>(std::move(sp));
+                    return true;
+                }
+            }
+            // Otherwise create a new one. Use shared_from_python<T>(...)
+            // so that future calls to ptr->shared_from_this() can share
+            // ownership with it.
+            value = shared_from_python(ptr, src);
+        } else {
+            value = std::static_pointer_cast<T>(
+                shared_from_python(static_cast<void *>(ptr), src));
+        }
         return true;
     }
 
     static handle from_cpp(const Value *value, rv_policy policy,
                            cleanup_list *cleanup) noexcept {
         if (!value)
             return (PyObject *) nullptr;
```

## nanobind/src/buffer.h

```diff
@@ -1,22 +1,22 @@
+#pragma once
 #include <string.h>
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 struct Buffer {
 public:
     // Disable copy/move constructor and assignment
     Buffer(const Buffer &) = delete;
     Buffer(Buffer &&) = delete;
     Buffer &operator=(const Buffer &) = delete;
     Buffer &operator=(Buffer &&) = delete;
 
-    Buffer(size_t size = 0)
-        : m_start((char *) malloc(size)) {
+    Buffer(size_t size = 0) : m_start((char *) malloc(size)) {
         if (!m_start) {
             fprintf(stderr, "Buffer::Buffer(): out of memory (unrecoverable error)!");
             abort();
         }
         m_end = m_start + size;
         if (size)
             clear();
@@ -103,15 +103,15 @@
     }
 
     /// Append an unsigned 32 bit integer
     void put_uint32(uint32_t value) {
         const int digits = 10;
         const char *num = "0123456789";
         char buf[digits];
-        int i = digits;
+        size_t i = digits;
 
         do {
             buf[--i] = num[value % 10];
             value /= 10;
         } while (value);
 
         return put(buf + i, digits - i);
@@ -124,22 +124,22 @@
             fprintf(stderr, "Buffer::copy(): out of memory (unrecoverable error)!");
             abort();
         }
         memcpy(tmp, m_start + offset, copy_size);
         return tmp;
     }
 
-    size_t size() const { return m_cur - m_start; }
-    size_t remain() const { return m_end - m_cur; }
+    size_t size() const { return (size_t) (m_cur - m_start); }
+    size_t remain() const { return (size_t) (m_end - m_cur); }
 
 private:
-    void expand(size_t minval = 2) {
+    NB_NOINLINE void expand(size_t minval = 2) {
         size_t old_alloc_size = m_end - m_start,
                new_alloc_size = 2 * old_alloc_size + minval,
-               used_size      = m_cur - m_start,
+               used_size      = (size_t) (m_cur - m_start),
                copy_size      = used_size + 1;
 
         if (old_alloc_size < copy_size)
             copy_size = old_alloc_size;
 
         char *tmp = (char *) malloc(new_alloc_size);
         if (!tmp) {
```

## nanobind/src/common.cpp

```diff
@@ -20,18 +20,18 @@
     [[noreturn]]
 #endif
 void raise(const char *fmt, ...) {
     char buf[512];
     va_list args;
 
     va_start(args, fmt);
-    size_t size = vsnprintf(buf, sizeof(buf), fmt, args);
+    int size = vsnprintf(buf, sizeof(buf), fmt, args);
     va_end(args);
 
-    if (size < sizeof(buf))
+    if (size < (int) sizeof(buf))
         throw std::runtime_error(buf);
 
     scoped_pymalloc<char> temp(size + 1);
 
     va_start(args, fmt);
     vsnprintf(temp.get(), size + 1, fmt, args);
     va_end(args);
@@ -61,33 +61,32 @@
         auto cleanup_2 = (void (*)(void *))(PyCapsule_GetContext(o));
         if (cleanup_2)
             cleanup_2(PyCapsule_GetPointer(o, PyCapsule_GetName(o)));
     };
 
     PyObject *c = PyCapsule_New((void *) ptr, name, capsule_cleanup);
 
-    if (!c)
-        fail("nanobind::detail::capsule_new(): allocation failed!");
+    check(c, "nanobind::detail::capsule_new(): allocation failed!");
 
-    if (PyCapsule_SetContext(c, (void *) cleanup) != 0)
-        fail("nanobind::detail::capsule_new(): could not set context!");
+    int rv = PyCapsule_SetContext(c, (void *) cleanup);
+    check(rv == 0, "nanobind::detail::capsule_new(): could not set context!");
 
     return c;
 }
 
 void raise_python_error() {
-    if (PyErr_Occurred())
-        throw python_error();
-    else
-        fail("nanobind::detail::raise_python_error() called without "
-             "an error condition!");
+    check(PyErr_Occurred(),
+          "nanobind::detail::raise_python_error() called without "
+          "an error condition!");
+    throw python_error();
 }
 
-void raise_next_overload() {
-    throw next_overload();
+void raise_next_overload_if_null(void *p) {
+    if (NB_UNLIKELY(!p))
+        throw next_overload();
 }
 
 void raise_cast_error() {
     throw cast_error();
 }
 
 // ========================================================================
@@ -101,32 +100,30 @@
         free(m_data);
     m_data = nullptr;
 }
 
 void cleanup_list::expand() noexcept {
     uint32_t new_capacity = m_capacity * 2;
     PyObject **new_data = (PyObject **) malloc(new_capacity * sizeof(PyObject *));
-    if (!new_data)
-        fail("nanobind::detail::cleanup_list::expand(): out of memory!");
+    check(new_data, "nanobind::detail::cleanup_list::expand(): out of memory!");
     memcpy(new_data, m_data, m_size * sizeof(PyObject *));
     if (m_capacity != Small)
         free(m_data);
     m_data = new_data;
     m_capacity = new_capacity;
 }
 
 // ========================================================================
 
 PyObject *module_new(const char *name, PyModuleDef *def) noexcept {
     memset(def, 0, sizeof(PyModuleDef));
     def->m_name = name;
     def->m_size = -1;
     PyObject *m = PyModule_Create(def);
-    if (!m)
-        fail("nanobind::detail::module_new(): allocation failed!");
+    check(m, "nanobind::detail::module_new(): allocation failed!");
     return m;
 }
 
 PyObject *module_import(const char *name) {
     PyObject *res = PyImport_ImportModule(name);
     if (!res)
         throw python_error();
@@ -172,15 +169,15 @@
     Py_INCREF(res);
     if (PyModule_AddObject(base, name, res))
         goto fail;
 
     return res;
 
 fail:
-    fail("nanobind::detail::module_new_submodule(): failed.");
+    check(false, "nanobind::detail::module_new_submodule(): failed.");
 }
 
 // ========================================================================
 
 size_t obj_len(PyObject *o) {
     Py_ssize_t res = PyObject_Length(o);
     if (res < 0)
@@ -250,16 +247,16 @@
 }
 
 PyObject *obj_vectorcall(PyObject *base, PyObject *const *args, size_t nargsf,
                          PyObject *kwnames, bool method_call) {
     PyObject *res = nullptr;
     bool gil_error = false, cast_error = false;
 
-    size_t nargs_total =
-        NB_VECTORCALL_NARGS(nargsf) + (kwnames ? NB_TUPLE_GET_SIZE(kwnames) : 0);
+    size_t nargs_total = (size_t) (NB_VECTORCALL_NARGS(nargsf) +
+                         (kwnames ? NB_TUPLE_GET_SIZE(kwnames) : 0));
 
 #if !defined(Py_LIMITED_API)
     if (!PyGILState_Check()) {
         gil_error = true;
         goto end;
     }
 #endif
@@ -510,15 +507,15 @@
     PyObject *result = PyBytes_FromStringAndSize(str, (Py_ssize_t) size);
     if (!result)
         raise("nanobind::detail::bytes_from_cstr_and_size(): conversion error!");
     return result;
 }
 
 // ========================================================================
-//
+
 PyObject *int_from_obj(PyObject *o) {
     PyObject *result = PyNumber_Long(o);
     if (!result)
         raise_python_error();
     return result;
 }
 
@@ -705,38 +702,47 @@
 
     *temp_out = temp;
     return result;
 }
 
 // ========================================================================
 
-void property_install(PyObject *scope, const char *name, bool is_static,
-                      PyObject *getter, PyObject *setter) noexcept {
+static void property_install_impl(PyTypeObject *tp, PyObject *scope,
+                                  const char *name, PyObject *getter,
+                                  PyObject *setter) {
     const nb_internals &internals = internals_get();
-    handle property = (PyObject *) (is_static ? internals.nb_static_property
-                                              : &PyProperty_Type);
-    (void) is_static;
     PyObject *m = getter ? getter : setter;
     object doc = none();
 
     if (m && (Py_TYPE(m) == internals.nb_func ||
               Py_TYPE(m) == internals.nb_method)) {
         func_data *f = nb_func_data(m);
         if (f->flags & (uint32_t) func_flags::has_doc)
             doc = str(f->doc);
     }
 
-    handle(scope).attr(name) = property(
+    handle(scope).attr(name) = handle(tp)(
         getter ? handle(getter) : handle(Py_None),
         setter ? handle(setter) : handle(Py_None),
         handle(Py_None), // deleter
         doc
     );
 }
 
+void property_install(PyObject *scope, const char *name, PyObject *getter,
+                      PyObject *setter) noexcept {
+    property_install_impl(&PyProperty_Type, scope, name, getter, setter);
+}
+
+void property_install_static(PyObject *scope, const char *name,
+                             PyObject *getter, PyObject *setter) noexcept {
+    property_install_impl(nb_static_property_tp(), scope, name, getter,
+                          setter);
+}
+
 // ========================================================================
 
 void tuple_check(PyObject *tuple, size_t nargs) {
     for (size_t i = 0; i < nargs; ++i) {
         if (!NB_TUPLE_GET_ITEM(tuple, i))
             raise_cast_error();
     }
@@ -811,42 +817,47 @@
             PyErr_Clear();
         }
     }
 
     return false;
 }
 
+#if !defined(Py_LIMITED_API) && !defined(PYPY_VERSION) && PY_VERSION_HEX < 0x030c0000
+// Direct access for compact integers. These functions are
+// available as part of Python starting with version 3.12b1+
+
+NB_INLINE bool PyUnstable_Long_IsCompact(const PyLongObject *o) {
+    return abs(Py_SIZE(o)) <= 1;
+}
+
+NB_INLINE Py_ssize_t PyUnstable_Long_CompactValue(const PyLongObject *o) {
+    return Py_SIZE(o) * (Py_ssize_t) o->ob_digit[0];
+}
+#endif
+
 template <typename T, bool Recurse = true>
 NB_INLINE bool load_int(PyObject *o, uint32_t flags, T *out) noexcept {
     if (NB_LIKELY(PyLong_CheckExact(o))) {
-        // Fast path for integers that aren't too large (max. one 15- or 30-bit "digit")
-        #if !defined(Py_LIMITED_API) && !defined(PYPY_VERSION)
-            PyLongObject *lo = (PyLongObject *) o;
-            Py_ssize_t size = Py_SIZE(o);
-
-            if (size == 0 || size == 1) {
-                digit value_d = lo->ob_digit[0];
-                T value = (T) value_d;
-                *out = value;
-                return sizeof(T) >= sizeof(digit) || value_d == (digit) value;
-            }
+#if !defined(Py_LIMITED_API) && !defined(PYPY_VERSION)
+        PyLongObject *l = (PyLongObject *) o;
 
-            if constexpr (std::is_unsigned_v<T>) {
-                if (size < 0)
-                    return false;
-            } else {
-                if (size == -1) {
-                    sdigit value_d = - (sdigit) lo->ob_digit[0];
-                    T value = (T) value_d;
-                    *out = value;
-                    return sizeof(T) >= sizeof(sdigit) || value_d == (sdigit) value;
-                }
-            }
-        #endif
+        // Fast path for compact integers
+        if (NB_LIKELY(PyUnstable_Long_IsCompact(l))) {
+            Py_ssize_t value = PyUnstable_Long_CompactValue(l);
+            T value_t = (T) value;
+
+            if (NB_UNLIKELY((std::is_unsigned_v<T> && value < 0) ||
+                            (sizeof(T) != sizeof(Py_ssize_t) &&
+                             value != (Py_ssize_t) value_t)))
+                return false;
 
+            *out = value_t;
+            return true;
+        }
+#endif
 
         // Slow path
         using T0 = std::conditional_t<sizeof(T) <= sizeof(long), long, long long>;
         using Tp = std::conditional_t<std::is_signed_v<T>, T0, std::make_unsigned_t<T0>>;
 
         Tp value_p;
         if constexpr (std::is_unsigned_v<Tp>)
@@ -868,22 +879,21 @@
         }
 
         *out = value;
         return true;
     }
 
     if constexpr (Recurse) {
-        if ((flags & (uint8_t)cast_flags::convert) && !PyFloat_Check(o)) {
+        if ((flags & (uint8_t) cast_flags::convert) && !PyFloat_Check(o)) {
             PyObject* temp = PyNumber_Long(o);
             if (temp) {
                 bool result = load_int<T, false>(temp, 0, out);
                 Py_DECREF(temp);
                 return result;
-            }
-            else {
+            } else {
                 PyErr_Clear();
             }
         }
     }
 
     return false;
 }
@@ -953,16 +963,16 @@
 void set_implicit_cast_warnings(bool value) noexcept {
     internals_get().print_implicit_cast_warnings = value;
 }
 
 // ========================================================================
 
 void slice_compute(PyObject *slice, Py_ssize_t size, Py_ssize_t &start,
-                      Py_ssize_t &stop, Py_ssize_t &step,
-                      size_t &slice_length) {
+                   Py_ssize_t &stop, Py_ssize_t &step,
+                   size_t &slice_length) {
     if (PySlice_Unpack(slice, &start, &stop, &step) < 0)
         detail::raise_python_error();
     Py_ssize_t slice_length_ =
         PySlice_AdjustIndices((Py_ssize_t) size, &start, &stop, step);
     slice_length = (size_t) slice_length_;
 }
```

## nanobind/src/error.cpp

```diff
@@ -16,16 +16,16 @@
 
 Buffer buf(128);
 
 NAMESPACE_END(detail)
 
 python_error::python_error() {
     PyErr_Fetch(&m_type, &m_value, &m_trace);
-    if (!m_type)
-        detail::fail("nanobind::python_error::python_error(): error indicator unset!");
+    check(m_type,
+          "nanobind::python_error::python_error(): error indicator unset!");
 }
 
 python_error::~python_error() {
     if (m_type || m_value || m_trace) {
         gil_scoped_acquire acq;
         /* With GIL held */ {
             // Clear error status in case the following executes Python code
@@ -68,17 +68,16 @@
     gil_scoped_acquire acq;
 
     // Try again with GIL held
     if (m_what)
         return m_what;
 
     PyErr_NormalizeException(&m_type, &m_value, &m_trace);
-
-    if (!m_type)
-        detail::fail("nanobind::python_error::what(): PyNormalize_Exception() failed!");
+    check(m_type,
+          "nanobind::python_error::what(): PyNormalize_Exception() failed!");
 
     if (m_trace) {
         if (PyException_SetTraceback(m_value, m_trace) < 0)
             PyErr_Clear();
     }
 
 #if defined(Py_LIMITED_API) || defined(PYPY_VERSION)
@@ -142,72 +141,58 @@
     m_what = buf.copy();
 #endif
 
     return m_what;
 }
 
 void python_error::restore() noexcept {
-    if (!m_type)
-        detail::fail("nanobind::python_error::restore(): error was already restored!");
+    check(m_type,
+          "nanobind::python_error::restore(): error was already restored!");
 
     PyErr_Restore(m_type, m_value, m_trace);
     m_type = m_value = m_trace = nullptr;
 }
 
-next_overload::next_overload() : std::exception() { }
-next_overload::~next_overload() = default;
-const char *next_overload::what() const noexcept { return "nanobind::next_overload"; }
-
-cast_error::cast_error() : std::exception() { }
-cast_error::~cast_error() = default;
-const char *cast_error::what() const noexcept { return "nanobind::cast_error"; }
-
-#define NB_EXCEPTION(name, type)                                               \
-    name::name() : builtin_exception("") { }                                   \
-    void name::set_error() const { PyErr_SetString(type, what()); }
-
-NB_EXCEPTION(stop_iteration, PyExc_StopIteration)
-NB_EXCEPTION(index_error, PyExc_IndexError)
-NB_EXCEPTION(key_error, PyExc_KeyError)
-NB_EXCEPTION(value_error, PyExc_ValueError)
-NB_EXCEPTION(type_error, PyExc_TypeError)
-NB_EXCEPTION(buffer_error, PyExc_BufferError)
-NB_EXCEPTION(import_error, PyExc_ImportError)
-NB_EXCEPTION(attribute_error, PyExc_AttributeError)
-
-#undef NB_EXCEPTION
+builtin_exception::builtin_exception(exception_type type, const char *what)
+    : std::runtime_error(what ? what : ""), m_type(type) { }
+builtin_exception::~builtin_exception() { }
 
 NAMESPACE_BEGIN(detail)
 
 void register_exception_translator(exception_translator t, void *payload) {
-    auto &et = internals_get().exception_translators;
-    et.insert(et.begin(), { t, payload });
+    nb_internals &internals = internals_get();
+
+    nb_translator_seq *cur  = &internals.translators,
+                      *next = new nb_translator_seq(*cur);
+    cur->next = next;
+    cur->payload = payload;
+    cur->translator = t;
 }
 
 NB_CORE PyObject *exception_new(PyObject *scope, const char *name,
                                 PyObject *base) {
     object modname;
     if (PyModule_Check(scope))
         modname = getattr(scope, "__name__", handle());
     else
         modname = getattr(scope, "__module__", handle());
 
     if (!modname.is_valid())
-        raise("nanobind::detail::exception_new(): could not determine module name!");
+        raise("nanobind::detail::exception_new(): could not determine module "
+              "name!");
 
-    str combined = steal<str>(
-        PyUnicode_FromFormat("%U.%s", modname.ptr(), name));
+    str combined =
+        steal<str>(PyUnicode_FromFormat("%U.%s", modname.ptr(), name));
 
-    PyObject *result = PyErr_NewException(combined.c_str(), base, nullptr);
-    if (!result)
-        raise("nanobind::detail::exception_new(): creation failed!");
+    object result = steal(PyErr_NewException(combined.c_str(), base, nullptr));
+    check(result, "nanobind::detail::exception_new(): creation failed!");
 
     if (hasattr(scope, name))
-        raise("nanobind::detail::exception_new(): an object of the same name already "
-              "exists!");
+        raise("nanobind::detail::exception_new(): an object of the same name "
+              "already exists!");
 
     setattr(scope, name, result);
-    return result;
+    return result.release().ptr();
 }
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/src/implicit.cpp

```diff
@@ -11,20 +11,20 @@
 #include "nb_internals.h"
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 void implicitly_convertible(const std::type_info *src,
                             const std::type_info *dst) noexcept {
-    nb_internals &internals = internals_get();
+    nb_type_map &type_c2p = internals_get().type_c2p;
 
-    auto it = internals.type_c2p.find(std::type_index(*dst));
-    if (it == internals.type_c2p.end())
-        fail("nanobind::detail::implicitly_convertible(src=%s, dst=%s): "
-             "destination type unknown!", type_name(src), type_name(dst));
+    nb_type_map::iterator it = type_c2p.find(std::type_index(*dst));
+    check(it != type_c2p.end(),
+          "nanobind::detail::implicitly_convertible(src=%s, dst=%s): "
+          "destination type unknown!", type_name(src), type_name(dst));
 
     type_data *t = it->second;
     size_t size = 0;
 
     if (t->flags & (uint32_t) type_flags::has_implicit_conversions) {
         while (t->implicit && t->implicit[size])
             size++;
@@ -42,20 +42,20 @@
     free(t->implicit);
     t->implicit = (decltype(t->implicit)) data;
 }
 
 void implicitly_convertible(bool (*predicate)(PyTypeObject *, PyObject *,
                                               cleanup_list *),
                             const std::type_info *dst) noexcept {
-    nb_internals &internals = internals_get();
+    nb_type_map &type_c2p = internals_get().type_c2p;
 
-    auto it = internals.type_c2p.find(std::type_index(*dst));
-    if (it == internals.type_c2p.end())
-        fail("nanobind::detail::implicitly_convertible(src=<predicate>, dst=%s): "
-             "destination type unknown!", type_name(dst));
+    nb_type_map::iterator it = type_c2p.find(std::type_index(*dst));
+    check(it != type_c2p.end(),
+          "nanobind::detail::implicitly_convertible(src=<predicate>, dst=%s): "
+          "destination type unknown!", type_name(dst));
 
     type_data *t = it->second;
     size_t size = 0;
 
     if (t->flags & (uint32_t) type_flags::has_implicit_conversions) {
         while (t->implicit_py && t->implicit_py[size])
             size++;
```

## nanobind/src/nb_enum.cpp

```diff
@@ -9,27 +9,31 @@
 
 #include <nanobind/nanobind.h>
 #include "nb_internals.h"
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
-static PyObject *nb_enum_int(PyObject *o);
+NB_INLINE enum_supplement &nb_enum_supplement(PyTypeObject *type) {
+    return type_supplement<enum_supplement>(type);
+}
+
+static PyObject *nb_enum_int_signed(PyObject *o);
+static PyObject *nb_enum_int_unsigned(PyObject *o);
 
 /// Map to unique representative enum instance, returns a borrowed reference
 static PyObject *nb_enum_lookup(PyObject *self) {
-    PyObject *int_val = nb_enum_int(self),
-             *dict    = PyObject_GetAttrString((PyObject *) Py_TYPE(self), "__entries");
-
+    enum_supplement &supp = nb_enum_supplement(Py_TYPE(self));
+    PyObject *int_val = supp.is_signed ? nb_enum_int_signed(self)
+                                       : nb_enum_int_unsigned(self);
     PyObject *rec = nullptr;
-    if (int_val && dict)
-        rec = (PyObject *) PyDict_GetItem(dict, int_val);
+    if (int_val && supp.entries)
+        rec = (PyObject *) PyDict_GetItem(supp.entries, int_val);
 
     Py_XDECREF(int_val);
-    Py_XDECREF(dict);
 
     if (rec && PyTuple_CheckExact(rec) && NB_TUPLE_GET_SIZE(rec) == 3) {
         return rec;
     } else {
         PyErr_Clear();
         PyErr_SetString(PyExc_RuntimeError, "nb_enum: could not find entry!");
         return nullptr;
@@ -65,66 +69,61 @@
         return nullptr;
 
     PyObject *result = NB_TUPLE_GET_ITEM(entry, 1);
     Py_INCREF(result);
     return result;
 }
 
-static PyObject *nb_enum_int(PyObject *o) {
+NB_NOINLINE static PyObject *nb_enum_int_signed(PyObject *o) {
     type_data *t = nb_type_data(Py_TYPE(o));
+    const void *p = inst_ptr((nb_inst *) o);
+    long long value;
+    switch (t->size) {
+        case 1: value = (long long) *(const int8_t *)  p; break;
+        case 2: value = (long long) *(const int16_t *) p; break;
+        case 4: value = (long long) *(const int32_t *) p; break;
+        case 8: value = (long long) *(const int64_t *) p; break;
+        default: PyErr_SetString(PyExc_TypeError, "nb_enum: invalid type size!");
+                 return nullptr;
+    }
+    return PyLong_FromLongLong(value);
+}
 
+NB_NOINLINE static PyObject *nb_enum_int_unsigned(PyObject *o) {
+    type_data *t = nb_type_data(Py_TYPE(o));
     const void *p = inst_ptr((nb_inst *) o);
-    if (t->flags & (uint32_t) type_flags::is_unsigned_enum) {
-        unsigned long long value;
-        switch (t->size) {
-            case 1: value = (unsigned long long) *(const uint8_t *)  p; break;
-            case 2: value = (unsigned long long) *(const uint16_t *) p; break;
-            case 4: value = (unsigned long long) *(const uint32_t *) p; break;
-            case 8: value = (unsigned long long) *(const uint64_t *) p; break;
-            default: PyErr_SetString(PyExc_TypeError, "nb_enum: invalid type size!");
-                     return nullptr;
-        }
-        return PyLong_FromUnsignedLongLong(value);
-    } else if (t->flags & (uint32_t) type_flags::is_signed_enum) {
-        long long value;
-        switch (t->size) {
-            case 1: value = (long long) *(const int8_t *)  p; break;
-            case 2: value = (long long) *(const int16_t *) p; break;
-            case 4: value = (long long) *(const int32_t *) p; break;
-            case 8: value = (long long) *(const int64_t *) p; break;
-            default: PyErr_SetString(PyExc_TypeError, "nb_enum: invalid type size!");
-                     return nullptr;
-        }
-        return PyLong_FromLongLong(value);
-    } else {
-        PyErr_SetString(PyExc_TypeError, "nb_enum: input is not an enumeration!");
-        return nullptr;
+    unsigned long long value;
+    switch (t->size) {
+        case 1: value = (unsigned long long) *(const uint8_t *)  p; break;
+        case 2: value = (unsigned long long) *(const uint16_t *) p; break;
+        case 4: value = (unsigned long long) *(const uint32_t *) p; break;
+        case 8: value = (unsigned long long) *(const uint64_t *) p; break;
+        default: PyErr_SetString(PyExc_TypeError, "nb_enum: invalid type size!");
+                 return nullptr;
     }
+    return PyLong_FromUnsignedLongLong(value);
 }
 
 static PyObject *nb_enum_init(PyObject *, PyObject *, PyObject *) {
     return 0;
 }
 
 static PyObject *nb_enum_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds) {
     PyObject *arg;
 
     if (kwds || NB_TUPLE_GET_SIZE(args) != 1)
         goto error;
 
     arg = NB_TUPLE_GET_ITEM(args, 0);
     if (PyLong_Check(arg)) {
-        PyObject *entries =
-            PyObject_GetAttrString((PyObject *) subtype, "__entries");
-        if (!entries)
+        enum_supplement &supp = nb_enum_supplement(subtype);
+        if (!supp.entries)
             goto error;
 
-        PyObject *item = PyDict_GetItem(entries, arg);
-        Py_DECREF(entries);
-
+        PyObject *item = PyDict_GetItem(supp.entries, arg);
         if (item && PyTuple_CheckExact(item) && NB_TUPLE_GET_SIZE(item) == 3) {
             item = NB_TUPLE_GET_ITEM(item, 2);
             Py_INCREF(item);
             return item;
         }
     } else if (Py_TYPE(arg) == subtype) {
         Py_INCREF(arg);
@@ -142,44 +141,117 @@
 static PyGetSetDef nb_enum_getset[] = {
     { "__doc__", nb_enum_get_doc, nullptr, nullptr, nullptr },
     { "__name__", nb_enum_get_name, nullptr, nullptr, nullptr },
     { nullptr, nullptr, nullptr, nullptr, nullptr }
 };
 
 PyObject *nb_enum_richcompare(PyObject *a, PyObject *b, int op) {
-    PyObject *ia = PyNumber_Long(a);
-    PyObject *ib = PyNumber_Long(b);
-    if (!ia || !ib)
-        return nullptr;
-    PyObject *result = PyObject_RichCompare(ia, ib, op);
-    Py_DECREF(ia);
-    Py_DECREF(ib);
+    // SomeType.tp_richcompare(a, b, op) is always invoked with 'a'
+    // having type SomeType. Note that this is different than binary
+    // arithmetic operations because comparisons can be reversed;
+    // Python will ask type(a) to check 'a > b' if type(b) doesn't
+    // know how to check 'b < a'.
+
+    if (op == Py_EQ || op == Py_NE) {
+        // For equality/inequality comparisons, only allow enums to be
+        // equal with their same enum type or with their underlying
+        // value as an integer.  This is a little awkward (it breaks
+        // transitivity of equality) but it's better than allowing
+        // 'Shape.CIRCLE == Color.RED' to be true just because both
+        // enumerators have the same underlying value (which would
+        // also prevent putting both enumerators in the same set or as
+        // keys in the same dictionary).
+        if (Py_TYPE(a) != Py_TYPE(b) && !PyLong_Check(b)) {
+            Py_RETURN_NOTIMPLEMENTED;
+        }
+    } else {
+        // For ordering, allow comparison against any number,
+        // including floats. Note that enums count as a number for
+        // purposes of this check (it's anything that defines a __float__,
+        // __int__, or __index__ slot).
+        if (!PyNumber_Check(b)) {
+            Py_RETURN_NOTIMPLEMENTED;
+        }
+    }
+
+    PyObject *ia = PyNumber_Index(a); // must succeed since a is an enum
+    PyObject *ib = nullptr;
+    if (PyIndex_Check(b)) {
+        // If b can be converted losslessly to an integer (which includes
+        // the case where b is also an enum) then do that.
+        ib = PyNumber_Index(b);
+    } else {
+        // Otherwise do the comparison against b as-is, which will probably
+        // wind up calling b's tp_richcompare for the reversed operation.
+        ib = b;
+        Py_INCREF(ib);
+    }
+    PyObject *result = nullptr;
+    if (ia && ib) {
+        result = PyObject_RichCompare(ia, ib, op);
+    }
+    Py_XDECREF(ia);
+    Py_XDECREF(ib);
     return result;
 }
 
+// Unary operands are easy because we know the argument will be this enum type
 #define NB_ENUM_UNOP(name, op)                                                 \
     PyObject *nb_enum_##name(PyObject *a) {                                    \
-        PyObject *ia = PyNumber_Long(a);                                       \
+        PyObject *ia = PyNumber_Index(a);                                      \
         if (!ia)                                                               \
             return nullptr;                                                    \
         PyObject *result = op(ia);                                             \
         Py_DECREF(ia);                                                         \
         return result;                                                         \
     }
 
+// Binary operands are trickier due to the potential for reversed operations.
+// We know either a or b is an enum object, but not which one.
+NB_NOINLINE PyObject *nb_enum_binop(PyObject *a, PyObject *b,
+                                    PyObject* (*op)(PyObject*, PyObject*)) {
+    // Both operands should be numbers. (Enums count as numbers because they
+    // define nb_int and nb_index slots.)
+    if (!PyNumber_Check(a) || !PyNumber_Check(b)) {
+        Py_RETURN_NOTIMPLEMENTED;
+    }
+
+    // Convert operands that support __index__ (lossless integer conversion),
+    // including enums, to that integer. Leave other kinds of numbers (such
+    // as floats and Decimals) alone. Then repeat the operation.
+    // Note that we can assume at least one of the PyNumber_Index calls
+    // succeeds, since one of our arguments is an enum.
+    PyObject *ia = nullptr, *ib = nullptr, *result = nullptr;
+    if (PyIndex_Check(a)) {
+        ia = PyNumber_Index(a);
+    } else {
+        ia = a;
+        Py_INCREF(ia);
+    }
+    if (PyIndex_Check(b)) {
+        ib = PyNumber_Index(b);
+    } else {
+        ib = b;
+        Py_INCREF(ib);
+    }
+    if (ia == a && ib == b) {
+        PyErr_SetString(PyExc_SystemError,
+                        "nanobind enum arithmetic invoked without an enum "
+                        "as either operand");
+    } else if (ia && ib) {
+        result = op(ia, ib);
+    }
+    Py_XDECREF(ia);
+    Py_XDECREF(ib);
+    return result;
+}
+
 #define NB_ENUM_BINOP(name, op)                                                \
     PyObject *nb_enum_##name(PyObject *a, PyObject *b) {                       \
-        PyObject *ia = PyNumber_Long(a);                                       \
-        PyObject *ib = PyNumber_Long(b);                                       \
-        if (!ia || !ib)                                                        \
-            return nullptr;                                                    \
-        PyObject *result = op(ia, ib);                                         \
-        Py_DECREF(ia);                                                         \
-        Py_DECREF(ib);                                                         \
-        return result;                                                         \
+        return nb_enum_binop(a, b, op);                                        \
     }
 
 NB_ENUM_BINOP(add, PyNumber_Add)
 NB_ENUM_BINOP(sub, PyNumber_Subtract)
 NB_ENUM_BINOP(mul, PyNumber_Multiply)
 NB_ENUM_BINOP(div, PyNumber_FloorDivide)
 NB_ENUM_BINOP(and, PyNumber_And)
@@ -199,75 +271,74 @@
     Py_VISIT(Py_TYPE(o));
     return 0;
 }
 
 Py_hash_t nb_enum_hash(PyObject *o) {
     Py_hash_t value = 0;
     type_data *t = nb_type_data(Py_TYPE(o));
-    if (t->flags & (uint32_t(type_flags::is_unsigned_enum) |
-                    uint32_t(type_flags::is_signed_enum))) {
-        const void *p = inst_ptr((nb_inst *) o);
-        switch (t->size) {
-            case 1: value = *(const int8_t *)  p; break;
-            case 2: value = *(const int16_t *) p; break;
-            case 4: value = *(const int32_t *) p; break;
-            case 8: value = *(const int64_t *) p; break;
-            default:
-                PyErr_SetString(PyExc_TypeError, "nb_enum: invalid type size!");
-                return -1;
-        }
-    } else {
-        PyErr_SetString(PyExc_TypeError, "nb_enum: input is not an enumeration!");
-        return -1;
+    const void *p = inst_ptr((nb_inst *) o);
+    switch (t->size) {
+        case 1: value = *(const int8_t *)  p; break;
+        case 2: value = *(const int16_t *) p; break;
+        case 4: value = *(const int32_t *) p; break;
+        case 8: value = *(const int64_t *) p; break;
+        default:
+            PyErr_SetString(PyExc_TypeError, "nb_enum: invalid type size!");
+            return -1;
     }
 
     // Hash functions should return -1 when an error occurred.
     // Return -2 that case, since hash(-1) also yields -2.
     if (value == -1) value = -2;
 
     return value;
 }
 
-void nb_enum_prepare(PyType_Slot **s, bool is_arithmetic) {
-    PyType_Slot *t = *s;
+void nb_enum_prepare(const type_init_data *td,
+                     PyType_Slot *&t, size_t max_slots) noexcept {
+    /* 22 is the number of slot assignments below. Update it if you add more.
+       These built-in slots are added before any user-defined ones. */
+    check(max_slots >= 22,
+          "nanobind::detail::nb_enum_prepare(\"%s\"): ran out of "
+          "type slots!", td->name);
+
+    const enum_init_data *ed = static_cast<const enum_init_data *>(td);
+    auto int_fn = ed->is_signed ? nb_enum_int_signed : nb_enum_int_unsigned;
 
-    /* Careful: update 'nb_enum_max_slots' field in nb_type.cpp
-       when adding further type slots */
     *t++ = { Py_tp_new, (void *) nb_enum_new };
     *t++ = { Py_tp_init, (void *) nb_enum_init };
     *t++ = { Py_tp_repr, (void *) nb_enum_repr };
     *t++ = { Py_tp_richcompare, (void *) nb_enum_richcompare };
-    *t++ = { Py_nb_int, (void *) nb_enum_int };
-    *t++ = { Py_nb_index, (void *) nb_enum_int };
+    *t++ = { Py_nb_int, (void *) int_fn };
+    *t++ = { Py_nb_index, (void *) int_fn };
     *t++ = { Py_tp_getset, (void *) nb_enum_getset };
     *t++ = { Py_tp_traverse, (void *) nb_enum_traverse };
     *t++ = { Py_tp_clear, (void *) nb_enum_clear };
     *t++ = { Py_tp_hash, (void *) nb_enum_hash };
 
-    if (is_arithmetic) {
+    if (ed->is_arithmetic) {
         *t++ = { Py_nb_add, (void *) nb_enum_add };
         *t++ = { Py_nb_subtract, (void *) nb_enum_sub };
-        *t++ = { Py_nb_multiply, (void *) nb_enum_sub };
+        *t++ = { Py_nb_multiply, (void *) nb_enum_mul };
         *t++ = { Py_nb_floor_divide, (void *) nb_enum_div };
         *t++ = { Py_nb_or, (void *) nb_enum_or };
         *t++ = { Py_nb_xor, (void *) nb_enum_xor };
         *t++ = { Py_nb_and, (void *) nb_enum_and };
         *t++ = { Py_nb_rshift, (void *) nb_enum_rshift };
         *t++ = { Py_nb_lshift, (void *) nb_enum_lshift };
         *t++ = { Py_nb_negative, (void *) nb_enum_neg };
         *t++ = { Py_nb_invert, (void *) nb_enum_inv };
         *t++ = { Py_nb_absolute, (void *) nb_enum_abs };
     }
-
-    *s = t;
 }
 
 void nb_enum_put(PyObject *type, const char *name, const void *value,
                  const char *doc) noexcept {
-    PyObject *doc_obj, *rec, *dict, *int_val;
+    PyObject *doc_obj, *rec, *int_val;
+    enum_supplement &supp = nb_enum_supplement((PyTypeObject *) type);
 
     PyObject *name_obj = PyUnicode_InternFromString(name);
     if (doc) {
         doc_obj = PyUnicode_FromString(doc);
     } else {
         doc_obj = Py_None;
         Py_INCREF(Py_None);
@@ -287,59 +358,61 @@
     inst->destruct = false;
     inst->cpp_delete = false;
     inst->ready = true;
 
     if (PyObject_SetAttr(type, name_obj, (PyObject *) inst))
         goto error;
 
-    int_val = nb_enum_int((PyObject *) inst);
+    int_val = supp.is_signed ? nb_enum_int_signed((PyObject *) inst)
+                             : nb_enum_int_unsigned((PyObject *) inst);
     if (!int_val)
         goto error;
 
-    dict = PyObject_GetAttrString(type, "__entries");
-    if (!dict) {
-        PyErr_Clear();
-        dict = PyDict_New();
+    if (!supp.entries) {
+        PyObject *dict = PyDict_New();
         if (!dict)
             goto error;
 
-        if (PyObject_SetAttrString(type, "__entries", dict))
+        // Stash the entries dict in the type object's dict so that GC
+        // can see the enumerators. nb_type_setattro ensures that user
+        // code can't reassign or delete this attribute (its logic
+        // is based on the @ prefix in the name).
+        if (PyObject_SetAttrString(type, "@entries", dict))
             goto error;
+
+        supp.entries = dict;
+        Py_DECREF(dict);
     }
 
-    if (PyDict_SetItem(dict, int_val, rec))
+    if (PyDict_SetItem(supp.entries, int_val, rec))
         goto error;
 
     Py_DECREF(int_val);
-    Py_DECREF(dict);
     Py_DECREF(rec);
 
     return;
 
 error:
-    fail("nanobind::detail::nb_enum_add(): could not create enum entry!");
+    check(false,
+          "nanobind::detail::nb_enum_put(): could not create enum entry!");
 }
 
 void nb_enum_export(PyObject *tp) {
-    type_data *t = nb_type_data((PyTypeObject *) tp);
-    PyObject *entries = PyObject_GetAttrString(tp, "__entries");
-
-    if (!entries || !(t->flags & (uint32_t) type_flags::has_scope))
-        fail("nanobind::detail::nb_enum_export(): internal error!");
+    enum_supplement &supp = nb_enum_supplement((PyTypeObject *) tp);
+    check(supp.entries && supp.scope != nullptr,
+          "nanobind::detail::nb_enum_export(): internal error!");
 
     PyObject *key, *value;
     Py_ssize_t pos = 0;
 
-    while (PyDict_Next(entries, &pos, &key, &value)) {
-        if (!PyTuple_CheckExact(value) || NB_TUPLE_GET_SIZE(value) != 3)
-            fail("nanobind::detail::nb_enum_export(): internal error! (2)");
+    while (PyDict_Next(supp.entries, &pos, &key, &value)) {
+        check(PyTuple_CheckExact(value) && NB_TUPLE_GET_SIZE(value) == 3,
+              "nanobind::detail::nb_enum_export(): internal error! (2)");
 
-        setattr(t->scope,
+        setattr(supp.scope,
                 NB_TUPLE_GET_ITEM(value, 0),
                 NB_TUPLE_GET_ITEM(value, 2));
     }
-
-    Py_DECREF(entries);
 }
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/src/nb_func.cpp

```diff
@@ -15,14 +15,15 @@
 
 #if defined(__GNUG__)
 #  include <cxxabi.h>
 #endif
 
 #if defined(_MSC_VER)
 #  pragma warning(disable: 4706) // assignment within conditional expression
+#  pragma warning(disable: 6255) // _alloca indicates failure by raising a stack overflow exception
 #endif
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 // Forward/external declarations
 extern Buffer buf;
@@ -78,20 +79,18 @@
     size_t size = (size_t) Py_SIZE(self);
     if (size) {
         func_data *f = nb_func_data(self);
 
         // Delete from registered function list
         auto &funcs = internals_get().funcs;
         auto it = funcs.find(self);
-        if (it == funcs.end()) {
-            const char *name = (f->flags & (uint32_t) func_flags::has_name)
-                                   ? f->name : "<anonymous>";
-            fail("nanobind::detail::nb_func_dealloc(\"%s\"): function not found!",
-                 name);
-        }
+        check(it != funcs.end(),
+              "nanobind::detail::nb_func_dealloc(\"%s\"): function not found!",
+              ((f->flags & (uint32_t) func_flags::has_name) ? f->name
+                                                            : "<anonymous>"));
         funcs.erase(it);
 
         for (size_t i = 0; i < size; ++i) {
             if (f->flags & (uint32_t) func_flags::has_free)
                 f->free(f->capture);
 
             if (f->flags & (uint32_t) func_flags::has_args) {
@@ -134,14 +133,43 @@
 }
 
 static arg_data method_args[2] = {
     { "self", nullptr, nullptr, false, false },
     { nullptr, nullptr, nullptr, false, false }
 };
 
+static bool set_builtin_exception_status(builtin_exception &e) {
+    PyObject *o;
+
+    switch (e.type()) {
+        case exception_type::stop_iteration: o = PyExc_StopIteration; break;
+        case exception_type::index_error: o = PyExc_IndexError; break;
+        case exception_type::key_error: o = PyExc_KeyError; break;
+        case exception_type::value_error: o = PyExc_ValueError; break;
+        case exception_type::type_error: o = PyExc_TypeError; break;
+        case exception_type::buffer_error: o = PyExc_BufferError; break;
+        case exception_type::import_error: o = PyExc_ImportError; break;
+        case exception_type::attribute_error: o = PyExc_AttributeError; break;
+        case exception_type::next_overload: return false;
+        default:
+            check(false, "nanobind::detail::set_builtin_exception_status(): "
+                         "invalid exception type!");
+    }
+
+    PyErr_SetString(o, e.what());
+    return true;
+}
+
+void *malloc_check(size_t size) {
+    void *ptr = malloc(size);
+    if (!ptr)
+        fail("nanobind: malloc() failed!");
+    return ptr;
+}
+
 /**
  * \brief Wrap a C++ function into a Python function object
  *
  * This is an implementation detail of nanobind::cpp_function.
  */
 PyObject *nb_func_new(const void *in_) noexcept {
     func_data_prelim<0> *f = (func_data_prelim<0> *) in_;
@@ -160,37 +188,38 @@
     PyObject *name = nullptr;
     PyObject *func_prev = nullptr;
     nb_internals &internals = internals_get();
 
     // Check for previous overloads
     if (has_scope && has_name) {
         name = PyUnicode_FromString(f->name);
-        if (!name)
-            fail("nb::detail::nb_func_new(\"%s\"): invalid name.", f->name);
+        check(name, "nb::detail::nb_func_new(\"%s\"): invalid name.", f->name);
 
         func_prev = PyObject_GetAttr(f->scope, name);
         if (func_prev) {
             if (Py_TYPE(func_prev) == internals.nb_func ||
                 Py_TYPE(func_prev) == internals.nb_method) {
                 func_data *fp = nb_func_data(func_prev);
 
-                if ((fp->flags & (uint32_t) func_flags::is_method) !=
-                    (f ->flags & (uint32_t) func_flags::is_method))
-                    fail("nb::detail::nb_func_new(\"%s\"): mismatched static/"
-                         "instance method flags in function overloads!", f->name);
+                check((fp->flags & (uint32_t) func_flags::is_method) ==
+                          (f->flags & (uint32_t) func_flags::is_method),
+                      "nb::detail::nb_func_new(\"%s\"): mismatched static/"
+                      "instance method flags in function overloads!",
+                      f->name);
 
                 /* Never append a method to an overload chain of a parent class;
                    instead, hide the parent's overloads in this case */
                 if (fp->scope != f->scope)
                     Py_CLEAR(func_prev);
             } else if (f->name[0] == '_') {
                 Py_CLEAR(func_prev);
             } else {
-                fail("nb::detail::nb_func_new(\"%s\"): cannot overload "
-                     "existing non-function object of the same name!", f->name);
+                check(false,
+                      "nb::detail::nb_func_new(\"%s\"): cannot overload "
+                      "existing non-function object of the same name!", f->name);
             }
         } else {
             PyErr_Clear();
         }
 
         is_constructor = strcmp(f->name, "__init__") == 0;
 
@@ -206,17 +235,16 @@
         }
     }
 
     // Create a new function and destroy the old one
     Py_ssize_t to_copy = func_prev ? Py_SIZE(func_prev) : 0;
     nb_func *func = (nb_func *) PyType_GenericAlloc(
         is_method ? internals.nb_method : internals.nb_func, to_copy + 1);
-    if (!func)
-        fail("nb::detail::nb_func_new(\"%s\"): alloc. failed (1).",
-             has_name ? f->name : "<anonymous>");
+    check(func, "nb::detail::nb_func_new(\"%s\"): alloc. failed (1).",
+          has_name ? f->name : "<anonymous>");
 
     func->max_nargs_pos = f->nargs;
     func->complex_call = has_args || has_var_args || has_var_kwargs;
 
     if (func_prev) {
         func->complex_call |= ((nb_func *) func_prev)->complex_call;
         func->max_nargs_pos = std::max(func->max_nargs_pos,
@@ -227,73 +255,75 @@
 
         memcpy(cur, prev, sizeof(func_data) * to_copy);
         memset(prev, 0, sizeof(func_data) * to_copy);
 
         ((PyVarObject *) func_prev)->ob_size = 0;
 
         auto it = internals.funcs.find(func_prev);
-        if (it == internals.funcs.end())
-            fail("nanobind::detail::nb_func_new(): internal update failed (1)!");
+        check(it != internals.funcs.end(),
+              "nanobind::detail::nb_func_new(): internal update failed (1)!");
         internals.funcs.erase(it);
     }
 
     func->complex_call |= func->max_nargs_pos >= NB_MAXARGS_SIMPLE;
 
     func->vectorcall = func->complex_call ? nb_func_vectorcall_complex
                                           : nb_func_vectorcall_simple;
 
     // Register the function
-    auto [it, success] = internals.funcs.insert(func);
-    if (!success)
-        fail("nanobind::detail::nb_func_new(): internal update failed (2)!");
+    auto [it, success] = internals.funcs.try_emplace(func, nullptr);
+    check(success,
+          "nanobind::detail::nb_func_new(): internal update failed (2)!");
 
     func_data *fc = nb_func_data(func) + to_copy;
     memcpy(fc, f, sizeof(func_data_prelim<0>));
 
 
     if (is_constructor)
         fc->flags |= (uint32_t) func_flags::is_constructor;
     if (has_args)
         fc->flags |= (uint32_t) func_flags::has_args;
 
     if (!has_name)
         fc->name = "";
 
     if (is_implicit) {
-        if (!(fc->flags & (uint32_t) func_flags::is_constructor))
-            fail("nb::detail::nb_func_new(\"%s\"): nanobind::is_implicit() "
-                 "should only be specified for constructors.", f->name);
-        if (f->nargs != 2)
-            fail("nb::detail::nb_func_new(\"%s\"): implicit constructors "
-                 "should only have one argument.", f->name);
+        check(fc->flags & (uint32_t) func_flags::is_constructor,
+              "nb::detail::nb_func_new(\"%s\"): nanobind::is_implicit() "
+              "should only be specified for constructors.",
+              f->name);
+        check(f->nargs == 2,
+              "nb::detail::nb_func_new(\"%s\"): implicit constructors "
+              "should only have one argument.",
+              f->name);
 
         if (f->descr_types[1])
             implicitly_convertible(f->descr_types[1], f->descr_types[0]);
     }
 
     for (size_t i = 0;; ++i) {
         if (!f->descr[i]) {
-            fc->descr = (char *) malloc(sizeof(char) * (i + 1));
+            fc->descr = (char *) malloc_check(sizeof(char) * (i + 1));
             memcpy((char *) fc->descr, f->descr, (i + 1) * sizeof(char));
             break;
         }
     }
 
     for (size_t i = 0;; ++i) {
         if (!f->descr_types[i]) {
             fc->descr_types = (const std::type_info **)
-                malloc(sizeof(const std::type_info *) * (i + 1));
+                malloc_check(sizeof(const std::type_info *) * (i + 1));
             memcpy(fc->descr_types, f->descr_types,
                         (i + 1) * sizeof(const std::type_info *));
             break;
         }
     }
 
     if (has_args) {
-        fc->args = (arg_data *) malloc(sizeof(arg_data) * f->nargs);
+        fc->args = (arg_data *) malloc_check(sizeof(arg_data) * f->nargs);
 
         if (is_method) // add implicit 'self' argument annotation
             fc->args[0] = method_args[0];
         for (size_t i = is_method; i < fc->nargs; ++i)
             fc->args[i] = args_in[i - is_method];
 
         for (size_t i = 0; i < fc->nargs; ++i) {
@@ -305,16 +335,16 @@
             a.none |= a.value == Py_None;
             Py_XINCREF(a.value);
         }
     }
 
     if (has_scope && name) {
         int rv = PyObject_SetAttr(f->scope, name, (PyObject *) func);
-        if (rv)
-            fail("nb::detail::nb_func_new(\"%s\"): setattr. failed.", f->name);
+        check(rv == 0, "nb::detail::nb_func_new(\"%s\"): setattr. failed.",
+              f->name);
     }
 
     Py_XDECREF(name);
 
     if (return_ref) {
         return (PyObject *) func;
     } else {
@@ -396,31 +426,33 @@
     return nullptr;
 }
 
 /// Used by nb_func_vectorcall: convert a C++ exception into a Python error
 static NB_NOINLINE void nb_func_convert_cpp_exception() noexcept {
     std::exception_ptr e = std::current_exception();
 
-    for (auto pair : internals_get().exception_translators) {
+    nb_translator_seq *cur  = &internals_get().translators;
+
+    while (cur) {
         try {
             // Try exception translator & forward payload
-            pair.first(e, pair.second);
+            cur->translator(e, cur->payload);
             return;
         } catch (...) {
             e = std::current_exception();
         }
+
+        cur = cur->next;
     }
 
     PyErr_SetString(PyExc_SystemError,
                     "nanobind::detail::nb_func_error_except(): exception "
                     "could not be translated!");
 }
 
-static PyTypeObject *nb_type_cache = nullptr;
-
 /// Dispatch loop that is used to invoke functions created by nb_func_new
 static PyObject *nb_func_vectorcall_complex(PyObject *self,
                                             PyObject *const *args_in,
                                             size_t nargsf,
                                             PyObject *kwargs_in) noexcept {
     const size_t count      = (size_t) Py_SIZE(self),
                  nargs_in   = (size_t) NB_VECTORCALL_NARGS(nargsf),
@@ -434,30 +466,31 @@
     uint32_t self_flags = 0;
 
     PyObject *result = nullptr, *self_arg = nullptr;
 
     if (is_method) {
         self_arg = nargs_in > 0 ? args_in[0] : nullptr;
 
-        if (!nb_type_cache)
-            nb_type_cache = internals_get().nb_type;
+        if (NB_LIKELY(self_arg)) {
+            PyTypeObject *self_tp = Py_TYPE(self_arg);
 
-        if (self_arg && Py_TYPE((PyObject *) Py_TYPE(self_arg)) == nb_type_cache) {
-            self_flags = nb_type_data(Py_TYPE(self_arg))->flags;
-            if (self_flags & (uint32_t) type_flags::is_trampoline)
-                current_method_data = current_method{ fr->name, self_arg };
-
-            is_constructor = fr->flags & (uint32_t) func_flags::is_constructor;
-            if (is_constructor) {
-                if (((nb_inst *) self_arg)->ready) {
-                    PyErr_SetString(
-                        PyExc_RuntimeError,
-                        "nanobind::detail::nb_func_vectorcall(): the __init__ "
-                        "method should not be called on an initialized object!");
-                    return nullptr;
+            if (NB_LIKELY(nb_type_check((PyObject *) self_tp))) {
+                self_flags = nb_type_data(self_tp)->flags;
+                if (self_flags & (uint32_t) type_flags::is_trampoline)
+                    current_method_data = current_method{ fr->name, self_arg };
+
+                is_constructor = fr->flags & (uint32_t) func_flags::is_constructor;
+                if (is_constructor) {
+                    if (((nb_inst *) self_arg)->ready) {
+                        PyErr_SetString(
+                            PyExc_RuntimeError,
+                            "nanobind::detail::nb_func_vectorcall(): the __init__ "
+                            "method should not be called on an initialized object!");
+                        return nullptr;
+                    }
                 }
             }
         }
     }
 
     /* The following lines allocate memory on the stack, which is very efficient
        but also potentially dangerous since it can be used to generate stack
@@ -574,15 +607,15 @@
                     arg_none = ad.none;
                 }
 
                 if (!arg || (arg == Py_None && !arg_none))
                     break;
 
                 args[i] = arg;
-                args_flags[i] = arg_convert ? (uint8_t) cast_flags::convert : 0;
+                args_flags[i] = arg_convert ? (uint8_t) cast_flags::convert : (uint8_t) 0;
             }
 
             // Skip this overload if positional arguments were unavailable
             if (i != nargs_pos)
                 continue;
 
             // Deal with remaining positional arguments
@@ -629,16 +662,21 @@
                 result = f->impl((void *) f->capture, args, args_flags,
                                  (rv_policy) (f->flags & 0b111), &cleanup);
 
                 if (NB_UNLIKELY(!result)) {
                     error_handler = nb_func_error_noconvert;
                     goto done;
                 }
-            } catch (next_overload &) {
-                result = NB_NEXT_OVERLOAD;
+            } catch (builtin_exception &e) {
+                if (set_builtin_exception_status(e)) {
+                    result = nullptr;
+                    goto done;
+                } else {
+                    result = NB_NEXT_OVERLOAD;
+                }
             } catch (python_error &e) {
                 e.restore();
                 result = nullptr;
                 goto done;
             } catch (...) {
                 nb_func_convert_cpp_exception();
                 result = nullptr;
@@ -692,30 +730,30 @@
     uint32_t self_flags = 0;
 
     PyObject *result = nullptr, *self_arg = nullptr;
 
     if (is_method) {
         self_arg = nargs_in > 0 ? args_in[0] : nullptr;
 
-        if (NB_UNLIKELY(!nb_type_cache))
-            nb_type_cache = internals_get().nb_type;
+        if (NB_LIKELY(self_arg)) {
+            PyTypeObject *self_tp = Py_TYPE(self_arg);
+            if (NB_LIKELY(nb_type_check((PyObject *) self_tp))) {
+                self_flags = nb_type_data(self_tp)->flags;
+                if (NB_UNLIKELY(self_flags & (uint32_t) type_flags::is_trampoline))
+                    current_method_data = current_method{ fr->name, self_arg };
 
-        if (NB_LIKELY(self_arg && Py_TYPE((PyObject *) Py_TYPE(self_arg)) == nb_type_cache)) {
-            self_flags = nb_type_data(Py_TYPE(self_arg))->flags;
-            if (NB_UNLIKELY(self_flags & (uint32_t) type_flags::is_trampoline))
-                current_method_data = current_method{ fr->name, self_arg };
-
-            is_constructor = fr->flags & (uint32_t) func_flags::is_constructor;
-            if (is_constructor) {
-                if (NB_UNLIKELY(((nb_inst *) self_arg)->ready)) {
-                    PyErr_SetString(PyExc_RuntimeError,
-                                    "nanobind::detail::nb_func_vectorcall_simple():"
-                                    " the __init__ method should not be called on "
-                                    "an initialized object!");
-                    return nullptr;
+                is_constructor = fr->flags & (uint32_t) func_flags::is_constructor;
+                if (is_constructor) {
+                    if (NB_UNLIKELY(((nb_inst *) self_arg)->ready)) {
+                        PyErr_SetString(PyExc_RuntimeError,
+                                        "nanobind::detail::nb_func_vectorcall_simple():"
+                                        " the __init__ method should not be called on "
+                                        "an initialized object!");
+                        return nullptr;
+                    }
                 }
             }
         }
     }
 
     /// Small array holding temporaries (implicit conversion/*args/**kwargs)
     cleanup_list cleanup(self_arg);
@@ -753,16 +791,21 @@
                                  args_flags, (rv_policy) (f->flags & 0b111),
                                  &cleanup);
 
                 if (NB_UNLIKELY(!result)) {
                     error_handler = nb_func_error_noconvert;
                     goto done;
                 }
-            } catch (next_overload &) {
-                result = NB_NEXT_OVERLOAD;
+            } catch (builtin_exception &e) {
+                if (set_builtin_exception_status(e)) {
+                    result = nullptr;
+                    goto done;
+                } else {
+                    result = NB_NEXT_OVERLOAD;
+                }
             } catch (python_error &e) {
                 e.restore();
                 result = nullptr;
                 goto done;
             } catch (...) {
                 nb_func_convert_cpp_exception();
                 result = nullptr;
@@ -800,15 +843,15 @@
 }
 
 static PyObject *nb_bound_method_vectorcall(PyObject *self,
                                             PyObject *const *args_in,
                                             size_t nargsf,
                                             PyObject *kwargs_in) noexcept {
     nb_bound_method *mb = (nb_bound_method *) self;
-    size_t nargs = NB_VECTORCALL_NARGS(nargsf);
+    size_t nargs = (size_t) NB_VECTORCALL_NARGS(nargsf);
 
     PyObject *result;
     if (nargsf & NB_VECTORCALL_ARGUMENTS_OFFSET) {
         PyObject **args_tmp = (PyObject **) args_in - 1;
         PyObject *tmp = args_tmp[0];
         args_tmp[0] = mb->self;
         result = mb->func->vectorcall((PyObject *) mb->func, args_tmp, nargs + 1, kwargs_in);
@@ -857,67 +900,63 @@
                has_args       = f->flags & (uint32_t) func_flags::has_args,
                has_var_args   = f->flags & (uint32_t) func_flags::has_var_args,
                has_var_kwargs = f->flags & (uint32_t) func_flags::has_var_kwargs;
 
     const std::type_info **descr_type = f->descr_types;
     nb_internals &internals = internals_get();
 
-    size_t arg_index = 0;
+    uint32_t arg_index = 0;
     buf.put_dstr(f->name);
 
     for (const char *pc = f->descr; *pc != '\0'; ++pc) {
         char c = *pc;
 
         switch (c) {
             case '{':
-                // Argument name
-                if (has_var_kwargs && arg_index + 1 == (size_t) f->nargs) {
-                    buf.put("**");
-                    if (has_args && f->args[arg_index].name)
-                        buf.put_dstr(f->args[arg_index].name);
-                    else
-                        buf.put("kwargs");
-                    pc += 4; // strlen("dict")
-                    break;
-                }
+                {
+                    const char *arg_name = has_args ? f->args[arg_index].name : nullptr;
 
-                if (has_var_args && arg_index + 1 + has_var_kwargs == (size_t) f->nargs) {
-                    buf.put("*");
-                    if (has_args && f->args[arg_index].name)
-                        buf.put_dstr(f->args[arg_index].name);
-                    else
-                        buf.put("args");
-                    pc += 5; // strlen("tuple")
-                    break;
-                }
+                    // Argument name
+                    if (has_var_kwargs && arg_index + 1 == f->nargs) {
+                        buf.put("**");
+                        buf.put_dstr(arg_name ? arg_name : "kwargs");
+                        pc += 4; // strlen("dict")
+                        break;
+                    }
 
-                if (has_args && f->args[arg_index].name) {
-                    buf.put_dstr(f->args[arg_index].name);
-                } else if (is_method && arg_index == 0) {
-                    buf.put("self");
-
-                    // Skip over type
-                    while (*pc != '}') {
-                        if (*pc == '%')
-                            descr_type++;
-                        pc++;
+                    if (has_var_args && arg_index + 1 + has_var_kwargs == f->nargs) {
+                        buf.put("*");
+                        buf.put_dstr(arg_name ? arg_name : "args");
+                        pc += 5; // strlen("tuple")
+                        break;
+                    }
+
+                    if (is_method && arg_index == 0) {
+                        buf.put("self");
+
+                        // Skip over type
+                        while (*pc != '}') {
+                            if (*pc == '%')
+                                descr_type++;
+                            pc++;
+                        }
+                        arg_index++;
+                        continue;
+                    } else if (arg_name) {
+                        buf.put_dstr(arg_name);
+                    } else {
+                        buf.put("arg");
+                        if (f->nargs > 1 + (uint32_t) is_method)
+                            buf.put_uint32(arg_index - is_method);
                     }
-                    arg_index++;
-                    continue;
-                } else {
-                    buf.put("arg");
-                    if (arg_index > size_t(is_method) ||
-                        f->nargs > 1 + (uint32_t) is_method)
-                        buf.put_uint32((uint32_t) (arg_index - is_method));
-                }
 
-                if (!(is_method && arg_index == 0))
                     buf.put(": ");
-                if (has_args && f->args[arg_index].none)
-                    buf.put("Optional[");
+                    if (has_args && f->args[arg_index].none)
+                        buf.put("Optional[");
+                }
                 break;
 
             case '}':
                 // Default argument
                 if (has_args) {
                     if (f->args[arg_index].none)
                         buf.put(']');
@@ -952,16 +991,16 @@
 
                 if (arg_index == f->nargs - has_var_args - has_var_kwargs && !has_args)
                     buf.put(", /");
 
                 break;
 
             case '%':
-                if (!*descr_type)
-                    fail("nb::detail::nb_func_finalize(): missing type!");
+                check(*descr_type,
+                      "nb::detail::nb_func_finalize(): missing type!");
 
                 if (!(is_method && arg_index == 0)) {
                     auto it = internals.type_c2p.find(std::type_index(**descr_type));
 
                     if (it != internals.type_c2p.end()) {
                         handle th((PyObject *) it->second->type_py);
                         buf.put_dstr((borrow<str>(th.attr("__module__"))).c_str());
@@ -979,16 +1018,17 @@
 
             default:
                 buf.put(c);
                 break;
         }
     }
 
-    if (arg_index != f->nargs || *descr_type != nullptr)
-        fail("nanobind::detail::nb_func_finalize(%s): arguments inconsistent.", f->name);
+    check(arg_index == f->nargs && !*descr_type,
+          "nanobind::detail::nb_func_finalize(%s): arguments inconsistent.",
+          f->name);
 }
 
 static PyObject *nb_func_get_name(PyObject *self) {
     func_data *f = nb_func_data(self);
     if (f->flags & (uint32_t) func_flags::has_name) {
         return PyUnicode_FromString(f->name);
     } else {
@@ -1084,32 +1124,45 @@
         return nb_func_get_qualname(self);
     else if (strcmp(name, "__doc__") == 0)
         return nb_func_get_doc(self, nullptr);
     else
         return PyObject_GenericGetAttr(self, name_);
 }
 
-PyObject *nb_bound_method_getattro(PyObject *self, PyObject *name) {
+PyObject *nb_bound_method_getattro(PyObject *self, PyObject *name_) {
+    bool passthrough = false;
+    if (const char *name = PyUnicode_AsUTF8AndSize(name_, nullptr)) {
+        // These attributes do exist on nb_bound_method (because they
+        // exist on every type) but we want to take their special handling
+        // from nb_func_getattro instead.
+        passthrough = (strcmp(name, "__doc__") == 0 ||
+                       strcmp(name, "__module__") == 0);
+    }
+    if (!passthrough) {
+        if (PyObject* res = PyObject_GenericGetAttr(self, name_))
+            return res;
+        PyErr_Clear();
+    }
     nb_func *func = ((nb_bound_method *) self)->func;
-    return nb_func_getattro((PyObject *) func, name);
+    return nb_func_getattro((PyObject *) func, name_);
 }
 
 /// Excise a substring from 's'
 static void strexc(char *s, const char *sub) {
     size_t len = strlen(sub);
     if (len == 0)
         return;
 
     char *p = s;
     while ((p = strstr(p, sub)))
         memmove(p, p + len, strlen(p + len) + 1);
 }
 
 /// Return a readable string representation of a C++ type
-char *type_name(const std::type_info *t) {
+NB_NOINLINE char *type_name(const std::type_info *t) {
     const char *name_in = t->name();
 
 #if defined(__GNUG__)
     int status = 0;
     char *name = abi::__cxa_demangle(name_in, nullptr, nullptr, &status);
 #else
     char *name = NB_STRDUP(name_in);
```

## nanobind/src/nb_internals.cpp

```diff
@@ -13,15 +13,15 @@
 
 #if defined(__GNUC__) && !defined(__clang__)
 #  pragma GCC diagnostic ignored "-Wmissing-field-initializers"
 #endif
 
 /// Tracks the ABI of nanobind
 #ifndef NB_INTERNALS_VERSION
-#  define NB_INTERNALS_VERSION 7
+#  define NB_INTERNALS_VERSION 8
 #endif
 
 /// On MSVC, debug and release builds are not ABI-compatible!
 #if defined(_MSC_VER) && defined(_DEBUG)
 #  define NB_BUILD_TYPE "_debug"
 #else
 #  define NB_BUILD_TYPE ""
@@ -80,27 +80,34 @@
 extern int nb_func_traverse(PyObject *, visitproc, void *);
 extern int nb_func_clear(PyObject *);
 extern void nb_func_dealloc(PyObject *);
 extern int nb_bound_method_traverse(PyObject *, visitproc, void *);
 extern int nb_bound_method_clear(PyObject *);
 extern void nb_bound_method_dealloc(PyObject *);
 extern PyObject *nb_method_descr_get(PyObject *, PyObject *, PyObject *);
-extern int nb_type_setattro(PyObject*, PyObject*, PyObject*);
-extern PyObject *nb_ndarray_get(PyObject *, PyObject *);
-extern int nb_ndarray_getbuffer(PyObject *exporter, Py_buffer *view, int);
-extern void nb_ndarray_releasebuffer(PyObject *, Py_buffer *);
-extern void nb_ndarray_dealloc(PyObject *self);
-static PyObject *nb_static_property_get(PyObject *, PyObject *, PyObject *);
 
 #if PY_VERSION_HEX >= 0x03090000
 #  define NB_HAVE_VECTORCALL_PY39_OR_NEWER NB_HAVE_VECTORCALL
 #else
 #  define NB_HAVE_VECTORCALL_PY39_OR_NEWER 0
 #endif
 
+static PyType_Slot nb_meta_slots[] = {
+    { Py_tp_base, nullptr },
+    { 0, nullptr }
+};
+
+static PyType_Spec nb_meta_spec = {
+    /* .name = */ "nanobind.nb_meta",
+    /* .basicsize = */ 0,
+    /* .itemsize = */ 0,
+    /* .flags = */ Py_TPFLAGS_DEFAULT,
+    /* .slots = */ nb_meta_slots
+};
+
 static PyMemberDef nb_func_members[] = {
     { "__vectorcalloffset__", T_PYSSIZET,
       (Py_ssize_t) offsetof(nb_func, vectorcall), READONLY, nullptr },
     { nullptr, 0, 0, 0, nullptr }
 };
 
 static PyGetSetDef nb_func_getset[] = {
@@ -140,26 +147,30 @@
     { Py_tp_descr_get, (void *) nb_method_descr_get },
     { Py_tp_new, (void *) PyType_GenericNew },
     { Py_tp_call, (void *) PyVectorcall_Call },
     { 0, nullptr }
 };
 
 static PyType_Spec nb_method_spec = {
-    /*.name = */"nanobind.nb_method",
-    /*.basicsize = */(int) sizeof(nb_func),
-    /*.itemsize = */(int) sizeof(func_data),
-    /*.flags = */Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC
-        | Py_TPFLAGS_METHOD_DESCRIPTOR
-        | NB_HAVE_VECTORCALL_PY39_OR_NEWER,
-    /*.slots = */nb_method_slots
+    /*.name = */ "nanobind.nb_method",
+    /*.basicsize = */ (int) sizeof(nb_func),
+    /*.itemsize = */ (int) sizeof(func_data),
+    /*.flags = */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+                  Py_TPFLAGS_METHOD_DESCRIPTOR |
+                  NB_HAVE_VECTORCALL_PY39_OR_NEWER,
+    /*.slots = */ nb_method_slots
 };
 
 static PyMemberDef nb_bound_method_members[] = {
     { "__vectorcalloffset__", T_PYSSIZET,
       (Py_ssize_t) offsetof(nb_bound_method, vectorcall), READONLY, nullptr },
+    { "__func__", T_OBJECT_EX,
+      (Py_ssize_t) offsetof(nb_bound_method, func), READONLY, nullptr },
+    { "__self__", T_OBJECT_EX,
+      (Py_ssize_t) offsetof(nb_bound_method, self), READONLY, nullptr },
     { nullptr, 0, 0, 0, nullptr }
 };
 
 static PyType_Slot nb_bound_method_slots[] = {
     { Py_tp_members, (void *) nb_bound_method_members },
     { Py_tp_getattro, (void *) nb_bound_method_getattro },
     { Py_tp_traverse, (void *) nb_bound_method_traverse },
@@ -175,112 +186,22 @@
     /* .basicsize = */ (int) sizeof(nb_bound_method),
     /* .itemsize = */ 0,
     /* .flags = */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
                    NB_HAVE_VECTORCALL_PY39_OR_NEWER,
     /* .slots = */ nb_bound_method_slots
 };
 
-static PyType_Slot nb_type_slots[] = {
-    { Py_tp_base, nullptr },
-    { Py_tp_dealloc, (void *) nb_type_dealloc },
-    { Py_tp_setattro, (void *) nb_type_setattro },
-    { Py_tp_init, (void *) nb_type_init },
-    { 0, nullptr }
-};
-
-static PyType_Spec nb_type_spec = {
-    /* .name = */ "nanobind.nb_type",
-    /* .basicsize = */ 0,
-    /* .itemsize = */ 0,
-    /* .flags = */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
-    /* .slots = */ nb_type_slots
-};
-
-#if PY_VERSION_HEX >= 0x030C0000
-static PyMemberDef nb_static_property_members[] = {
-    { "__doc__", T_OBJECT, 0, 0, nullptr },
-    { nullptr, 0, 0, 0, nullptr }
-};
-#endif
-
-static PyType_Slot nb_static_property_slots[] = {
-    { Py_tp_base, nullptr },
-    { Py_tp_members, nullptr },
-    { Py_tp_descr_get, (void *) nb_static_property_get },
-    { 0, nullptr }
-};
-
-static PyType_Spec nb_static_property_spec = {
-    /* .name = */ "nanobind.nb_static_property",
-    /* .basicsize = */ 0,
-    /* .itemsize = */ 0,
-    /* .flags = */ Py_TPFLAGS_DEFAULT,
-    /* .slots = */ nb_static_property_slots
-};
-
-static PyType_Slot nb_ndarray_slots[] = {
-    { Py_tp_dealloc, (void *) nb_ndarray_dealloc },
-#if PY_VERSION_HEX >= 0x03090000
-    { Py_bf_getbuffer, (void *) nb_ndarray_getbuffer },
-    { Py_bf_releasebuffer, (void *) nb_ndarray_releasebuffer },
-#endif
-    { 0, nullptr }
-};
-
-static PyType_Spec nb_ndarray_spec = {
-    /* .name = */ "nanobind.nb_ndarray",
-    /* .basicsize = */ (int) sizeof(nb_ndarray),
-    /* .itemsize = */ 0,
-    /* .flags = */ Py_TPFLAGS_DEFAULT,
-    /* .slots = */ nb_ndarray_slots
-};
-
-/// `nb_static_property_property.__get__()`: Always pass the class instead of the instance.
-static PyObject *nb_static_property_get(PyObject *self, PyObject *, PyObject *cls) {
-    if (internals_get().nb_static_property_enabled) {
-        #if defined(Py_LIMITED_API)
-            static descrgetfunc tp_descr_get =
-                (descrgetfunc) PyType_GetSlot(&PyProperty_Type, Py_tp_descr_get);
-        #else
-            descrgetfunc tp_descr_get = PyProperty_Type.tp_descr_get;
-        #endif
-
-        return tp_descr_get(self, cls, cls);
-    } else {
-        Py_INCREF(self);
-        return self;
-    }
-}
-
-/// `nb_static_property_property.__set__()`: Just like the above `__get__()`.
-int nb_static_property_set(PyObject *self, PyObject *obj, PyObject *value) {
-    PyObject *cls = PyType_Check(obj) ? obj : (PyObject *) Py_TYPE(obj);
-
-    #if defined(Py_LIMITED_API)
-        static descrsetfunc tp_descr_set =
-            (descrsetfunc) PyType_GetSlot(&PyProperty_Type, Py_tp_descr_set);
-    #else
-        descrsetfunc tp_descr_set = PyProperty_Type.tp_descr_set;
-    #endif
-
-    return tp_descr_set(self, cls, value);
-}
-
 NB_THREAD_LOCAL current_method current_method_data =
     current_method{ nullptr, nullptr };
 
-static nb_internals *internals_p = nullptr;
+nb_internals *internals_p = nullptr;
 
 void default_exception_translator(const std::exception_ptr &p, void *) {
     try {
         std::rethrow_exception(p);
-    } catch (python_error &e) {
-        e.restore();
-    } catch (const builtin_exception &e) {
-        e.set_error();
     } catch (const std::bad_alloc &e) {
         PyErr_SetString(PyExc_MemoryError, e.what());
     } catch (const std::domain_error &e) {
         PyErr_SetString(PyExc_ValueError, e.what());
     } catch (const std::invalid_argument &e) {
         PyErr_SetString(PyExc_ValueError, e.what());
     } catch (const std::length_error &e) {
@@ -333,15 +254,15 @@
     }
 
     if (!internals_p->funcs.empty()) {
         if (internals_p->print_leak_warnings) {
             fprintf(stderr, "nanobind: leaked %zu functions!\n",
                     internals_p->funcs.size());
             int ctr = 0;
-            for (void *f : internals_p->funcs) {
+            for (auto [f, p] : internals_p->funcs) {
                 fprintf(stderr, " - leaked function \"%s\"\n",
                         nb_func_data(f)->name);
                 if (ctr++ == 10) {
                     fprintf(stderr, " - ... skipped remainder\n");
                     break;
                 }
             }
@@ -369,102 +290,70 @@
 #if defined(PYPY_VERSION)
     PyObject *dict = PyEval_GetBuiltins();
 #elif PY_VERSION_HEX < 0x03090000
     PyObject *dict = PyInterpreterState_GetDict(_PyInterpreterState_Get());
 #else
     PyObject *dict = PyInterpreterState_GetDict(PyInterpreterState_Get());
 #endif
-    if (!dict)
-        fail("nanobind::detail::internals_dict(): failed!");
+    check(dict, "nanobind::detail::internals_dict(): failed!");
 
     return dict;
 }
 
 static NB_NOINLINE nb_internals *internals_make() {
     str nb_name("nanobind");
 
     nb_internals *p = new nb_internals();
 
     PyObject *dict = internals_dict();
 
     const char *internals_id = NB_INTERNALS_ID;
     PyObject *capsule = PyCapsule_New(p, internals_id, nullptr);
-    PyObject *nb_module = PyModule_NewObject(nb_name.ptr());
     int rv = PyDict_SetItemString(dict, internals_id, capsule);
-    if (rv || !capsule || !nb_module)
-        fail("nanobind::detail::internals_make(): allocation failed!");
+    check(!rv && capsule,
+          "nanobind::detail::internals_make(): allocation failed!");
     Py_DECREF(capsule);
 
-    p->nb_module = nb_module;
+    nb_meta_slots[0].pfunc = (PyObject *) &PyType_Type;
 
-    // Function objects
+    p->nb_module = PyModule_NewObject(nb_name.ptr());
+    p->nb_meta = (PyTypeObject *) PyType_FromSpec(&nb_meta_spec);
+    p->nb_type_dict = PyDict_New();
     p->nb_func = (PyTypeObject *) PyType_FromSpec(&nb_func_spec);
     p->nb_method = (PyTypeObject *) PyType_FromSpec(&nb_method_spec);
-    p->nb_bound_method =
-        (PyTypeObject *) PyType_FromSpec(&nb_bound_method_spec);
+    p->nb_bound_method = (PyTypeObject *) PyType_FromSpec(&nb_bound_method_spec);
 
-    // Metaclass (nb_type)
-#if defined(Py_LIMITED_API)
-    int tp_itemsize = cast<int>(handle(&PyType_Type).attr("__itemsize__"));
-    int tp_basicsize = cast<int>(handle(&PyType_Type).attr("__basicsize__"));
-#else
-    int tp_itemsize = (int) PyType_Type.tp_itemsize;
-    int tp_basicsize = (int) PyType_Type.tp_basicsize;
-#endif
-    nb_type_spec.basicsize = tp_basicsize
-        + (int) sizeof(type_data);
-    nb_type_spec.itemsize = tp_itemsize;
-    nb_type_slots[0].pfunc = &PyType_Type;
-    p->nb_type = (PyTypeObject *) PyType_FromSpec(&nb_type_spec);
-
-    /// Static properties
- #if defined(Py_LIMITED_API)
-    tp_basicsize = cast<int>(handle(&PyProperty_Type).attr("__basicsize__"));
-    tp_itemsize = cast<int>(handle(&PyProperty_Type).attr("__itemsize__"));
- #else
-    tp_basicsize = (int) PyProperty_Type.tp_basicsize;
-    tp_itemsize = (int) PyProperty_Type.tp_itemsize;
- #endif
-
-    // See https://github.com/python/cpython/issues/98963
-#if PY_VERSION_HEX >= 0x030C0000
-    nb_static_property_members[0].offset = tp_basicsize;
-    nb_static_property_slots[1].pfunc = nb_static_property_members;
-    tp_basicsize += sizeof(PyObject *);
-#else
-    nb_static_property_slots[1].pfunc = PyProperty_Type.tp_members;
-#endif
-    nb_static_property_slots[0].pfunc = &PyProperty_Type;
-    nb_static_property_spec.basicsize = tp_basicsize;
-    nb_static_property_spec.itemsize = tp_itemsize;
-
-    p->nb_static_property =
-        (PyTypeObject *) PyType_FromSpec(&nb_static_property_spec);
-    p->nb_static_property_enabled = true;
-
-    // Tensor type
-    p->nb_ndarray = (PyTypeObject *) PyType_FromSpec(&nb_ndarray_spec);
-
-    if (!p->nb_func || !p->nb_method ||
-        !p->nb_bound_method || !p->nb_type ||
-        !p->nb_static_property || !p->nb_ndarray)
-        fail("nanobind::detail::internals_make(): type initialization failed!");
+    check(p->nb_module && p->nb_meta && p->nb_type_dict && p->nb_func &&
+              p->nb_method && p->nb_bound_method,
+          "nanobind::detail::internals_make(): initialization failed!");
 
 #if PY_VERSION_HEX < 0x03090000
-    p->nb_ndarray->tp_as_buffer->bf_getbuffer = nb_ndarray_getbuffer;
-    p->nb_ndarray->tp_as_buffer->bf_releasebuffer = nb_ndarray_releasebuffer;
     p->nb_func->tp_flags |= NB_HAVE_VECTORCALL;
     p->nb_func->tp_vectorcall_offset = offsetof(nb_func, vectorcall);
     p->nb_method->tp_flags |= NB_HAVE_VECTORCALL;
     p->nb_method->tp_vectorcall_offset = offsetof(nb_func, vectorcall);
     p->nb_bound_method->tp_flags |= NB_HAVE_VECTORCALL;
     p->nb_bound_method->tp_vectorcall_offset = offsetof(nb_bound_method, vectorcall);
 #endif
 
-    register_exception_translator(default_exception_translator, nullptr);
+#if defined(Py_LIMITED_API)
+    // Cache important functions from PyType_Type and PyProperty_Type
+    p->PyType_Type_tp_free = (freefunc) PyType_GetSlot(&PyType_Type, Py_tp_free);
+    p->PyType_Type_tp_init = (initproc) PyType_GetSlot(&PyType_Type, Py_tp_init);
+    p->PyType_Type_tp_dealloc =
+        (destructor) PyType_GetSlot(&PyType_Type, Py_tp_dealloc);
+    p->PyType_Type_tp_setattro =
+        (setattrofunc) PyType_GetSlot(&PyType_Type, Py_tp_setattro);
+    p->PyProperty_Type_tp_descr_get =
+        (descrgetfunc) PyType_GetSlot(&PyProperty_Type, Py_tp_descr_get);
+    p->PyProperty_Type_tp_descr_set =
+        (descrsetfunc) PyType_GetSlot(&PyProperty_Type, Py_tp_descr_set);
+#endif
+
+    p->translators = { default_exception_translator, nullptr, nullptr };
 
 #if PY_VERSION_HEX < 0x030C0000 && !defined(PYPY_VERSION)
     /* The implementation of typing.py on CPython <3.12 tends to introduce
        spurious reference leaks that upset nanobind's leak checker. The
        following band-aid, installs an 'atexit' handler that clears LRU caches
        used in typing.py. To be resilient to potential future changes in
        typing.py, the implementation fails silently if any step goes wrong. For
@@ -506,36 +395,37 @@
                 "resources at interpreter shutdown (e.g., to avoid leaks being "
                 "reported by tools like 'valgrind'). If you are a user of a "
                 "python extension library, you can ignore this warning.");
 #endif
     return p;
 }
 
-static nb_internals *internals_fetch() {
+nb_internals *internals_fetch() {
     PyObject *dict = internals_dict();
 
     const char *internals_id = NB_INTERNALS_ID;
     PyObject *capsule = PyDict_GetItemString(dict, internals_id);
 
     nb_internals *ptr;
     if (capsule) {
         ptr = (nb_internals *) PyCapsule_GetPointer(capsule, internals_id);
-        if (!ptr)
-            fail("nanobind::detail::internals_fetch(): capsule pointer is NULL!");
+        check(ptr,
+              "nanobind::detail::internals_fetch(): capsule pointer is NULL!");
     } else {
         ptr = internals_make();
     }
 
     internals_p = ptr;
 
     return ptr;
 }
 
-nb_internals &internals_get() noexcept {
-    nb_internals *ptr = internals_p;
-    if (NB_UNLIKELY(!ptr))
-        ptr = internals_fetch();
-    return *ptr;
+#if defined(NB_COMPACT_ASSERTIONS)
+NB_NOINLINE void fail_unspecified() noexcept {
+    fail("nanobind: encountered an unrecoverable error condition. Recompile "
+         "using the 'Debug' or 'RelWithDebInfo' modes to obtain further "
+         "information about this problem.");
 }
+#endif
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/src/nb_internals.h

```diff
@@ -1,31 +1,39 @@
+#pragma once
+
 #if defined(__GNUC__)
 // Don't warn about missing fields in PyTypeObject declarations
 #  pragma GCC diagnostic ignored "-Wmissing-field-initializers"
 #elif defined(_MSC_VER)
 // Silence warnings that MSVC reports in robin_*.h
 #  pragma warning(disable: 4127) // conditional expression is constant
 #  pragma warning(disable: 4324) // structure was padded due to alignment specifier
 #endif
 
 #include <nanobind/nanobind.h>
 #include <tsl/robin_map.h>
-#include <tsl/robin_set.h>
 #include <typeindex>
 #include <cstring>
 
 #if defined(_MSC_VER)
 #  define NB_THREAD_LOCAL __declspec(thread)
 #else
 #  define NB_THREAD_LOCAL __thread
 #endif
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
+#if defined(NB_COMPACT_ASSERTIONS)
+[[noreturn]] extern void fail_unspecified() noexcept;
+#  define check(cond, ...) if (NB_UNLIKELY(!(cond))) nanobind::detail::fail_unspecified()
+#else
+#  define check(cond, ...) if (NB_UNLIKELY(!(cond))) nanobind::detail::fail(__VA_ARGS__)
+#endif
+
 /// Nanobind function metadata (overloads, etc.)
 struct func_data : func_data_prelim<0> {
     arg_data *args;
 };
 
 /// Python object representing an instance of a bound C++ type
 struct nb_inst { // usually: 24 bytes
@@ -56,19 +64,14 @@
 
     /// Does this instance hold reference to others? (via internals.keep_alive)
     bool clear_keep_alive : 1;
 };
 
 static_assert(sizeof(nb_inst) == sizeof(PyObject) + sizeof(void *));
 
-struct nb_enum_supplement {
-    PyObject *name;
-    const char *doc;
-};
-
 /// Python object representing a bound C++ function
 struct nb_func {
     PyObject_VAR_HEAD
     PyObject* (*vectorcall)(PyObject *, PyObject * const*, size_t, PyObject *);
     uint32_t max_nargs_pos;
     bool complex_call;
 };
@@ -97,37 +100,14 @@
         v ^= v >> 33;
         v *= (uintptr_t) 0xc4ceb9fe1a85ec53ull;
         v ^= v >> 33;
         return (size_t) v;
     }
 };
 
-struct keep_alive_entry {
-    void *data; // unique data pointer
-    void (*deleter)(void *) noexcept; // custom deleter, excluded from hashing/equality
-
-    keep_alive_entry(void *data, void (*deleter)(void *) noexcept = nullptr)
-        : data(data), deleter(deleter) { }
-};
-
-/// Equality operator for keep_alive_entry (only targets data field)
-struct keep_alive_eq {
-    NB_INLINE bool operator()(const keep_alive_entry &a,
-                              const keep_alive_entry &b) const {
-        return a.data == b.data;
-    }
-};
-
-/// Hash operator for keep_alive_entry (only targets data field)
-struct keep_alive_hash {
-    NB_INLINE size_t operator()(const keep_alive_entry &entry) const {
-        return ptr_hash()(entry.data);
-    }
-};
-
 // Minimal allocator definition, contains only the parts needed by tsl::*
 template <typename T> class py_allocator {
 public:
     using value_type = T;
     using pointer = T *;
     using size_type = std::size_t;
 
@@ -142,95 +122,145 @@
             fail("PyMem_Malloc(): out of memory!");
         return static_cast<pointer>(p);
     }
 
     void deallocate(T *p, size_type /*n*/) noexcept { PyMem_Free(p); }
 };
 
-template <class T1, class T2>
-bool operator==(const py_allocator<T1> &, const py_allocator<T2> &) noexcept {
-    return true;
-}
-
-template <typename key, typename hash = std::hash<key>,
-          typename eq = std::equal_to<key>>
-using py_set = tsl::robin_set<key, hash, eq, py_allocator<key>>;
-
 template <typename key, typename value, typename hash = std::hash<key>,
           typename eq = std::equal_to<key>>
-using py_map =
-    tsl::robin_map<key, value, hash, eq, py_allocator<std::pair<key, value>>>;
-
-using keep_alive_set =
-    py_set<keep_alive_entry, keep_alive_hash, keep_alive_eq>;
+using py_map = tsl::robin_map<key, value, hash, eq>;
 
-// Linked list of instances with the same pointer address. Usually just 1..
+// Linked list of instances with the same pointer address. Usually just 1.
 struct nb_inst_seq {
-    nb_inst *inst;
-    nb_inst_seq *next = nullptr;
+    PyObject *inst;
+    nb_inst_seq *next;
+};
+
+// Weak reference list. Usually, there is just one entry
+struct nb_weakref_seq {
+    void (*callback)(void *) noexcept;
+    void *payload;
+    nb_weakref_seq *next;
 };
 
-using nb_inst_map = py_map<void *, nb_inst_seq, ptr_hash>;
 using nb_type_map = py_map<std::type_index, type_data *>;
 
+/// A simple pointer-to-pointer map that is reused a few times below (even if
+/// not 100% ideal) to avoid template code generation bloat.
+using nb_ptr_map  = py_map<void *, void*, ptr_hash>;
+
+/// Convenience functions to deal with the pointer encoding in 'internals.inst_c2p'
+
+/// Does this entry store a linked list of instances?
+NB_INLINE bool         nb_is_seq(void *p)   { return ((uintptr_t) p) & 1; }
+
+/// Tag a nb_inst_seq* pointer as such
+NB_INLINE void*        nb_mark_seq(void *p) { return (void *) (((uintptr_t) p) | 1); }
+
+/// Retrieve the nb_inst_seq* pointer from an 'inst_c2p' value
+NB_INLINE nb_inst_seq* nb_get_seq(void *p)  { return (nb_inst_seq *) (((uintptr_t) p) ^ 1); }
+
+struct nb_translator_seq {
+    exception_translator translator;
+    void *payload;
+    nb_translator_seq *next = nullptr;
+};
+
 struct nb_internals {
     /// Internal nanobind module
     PyObject *nb_module;
 
-    /// Registered metaclasses for nanobind classes and enumerations
-    PyTypeObject *nb_type;
+    /// Meta-metaclass of nanobind instances
+    PyTypeObject *nb_meta;
+
+    /// Dictionary with nanobind metaclass(es) for different payload sizes
+    PyObject *nb_type_dict;
 
     /// Types of nanobind functions and methods
     PyTypeObject *nb_func, *nb_method, *nb_bound_method;
 
-    /// Property variant for static attributes
-    PyTypeObject *nb_static_property;
-    bool nb_static_property_enabled;
+    /// Property variant for static attributes (created on demand)
+    PyTypeObject *nb_static_property = nullptr;
+    bool nb_static_property_enabled = true;
+    descrsetfunc nb_static_property_descr_set = nullptr;
 
-    /// N-dimensional array wrapper
-    PyTypeObject *nb_ndarray;
+    /// N-dimensional array wrapper (created on demand)
+    PyTypeObject *nb_ndarray = nullptr;
 
-    /// Instance pointer -> Python object mapping
-    nb_inst_map inst_c2p;
+    /**
+     * C++ -> Python instance map
+     *
+     * This associative data structure maps a C++ instance pointer onto its
+     * associated PyObject* (if bit 0 of the map value is zero) or a linked
+     * list of type `nb_inst_seq*` (if bit 0 is set---it must be cleared before
+     * interpreting the pointer in this case).
+     *
+     * The latter case occurs when several distinct Python objects reference
+     * the same memory address (e.g. a struct and its first member).
+     */
+    nb_ptr_map inst_c2p;
 
-    /// C++ type -> Python type mapping
+    /// C++ -> Python type map
     nb_type_map type_c2p;
 
-    /// Dictionary of sets storing keep_alive references
-    py_map<void *, keep_alive_set, ptr_hash> keep_alive;
+    /// Dictionary storing keep_alive references
+    nb_ptr_map keep_alive;
 
-    /// nb_func/meth instance list for leak reporting
-    py_set<void *, ptr_hash> funcs;
+    /// nb_func/meth instance map for leak reporting (used as set, the value is unused)
+    nb_ptr_map funcs;
 
     /// Registered C++ -> Python exception translators
-    std::vector<std::pair<exception_translator, void *>> exception_translators;
+    nb_translator_seq translators;
 
     /// Should nanobind print leak warnings on exit?
     bool print_leak_warnings = true;
 
     /// Should nanobind print warnings after implicit cast failures?
     bool print_implicit_cast_warnings = true;
+
+#if defined(Py_LIMITED_API)
+    // Cache important functions from PyType_Type and PyProperty_Type
+    freefunc PyType_Type_tp_free;
+    initproc PyType_Type_tp_init;
+    destructor PyType_Type_tp_dealloc;
+    setattrofunc PyType_Type_tp_setattro;
+    descrgetfunc PyProperty_Type_tp_descr_get;
+    descrsetfunc PyProperty_Type_tp_descr_set;
+#endif
 };
 
+/// Convenience macro to potentially access cached functions
+#if defined(Py_LIMITED_API)
+#  define NB_SLOT(internals, type, name) internals.type##_##name
+#else
+#  define NB_SLOT(internals, type, name) type.name
+#endif
+
 struct current_method {
     const char *name;
     PyObject *self;
 };
 
 extern NB_THREAD_LOCAL current_method current_method_data;
+extern nb_internals *internals_p;
+extern nb_internals *internals_fetch();
+
+inline nb_internals &internals_get() noexcept {
+    nb_internals *ptr = internals_p;
+    if (NB_UNLIKELY(!ptr))
+        ptr = internals_fetch();
+    return *ptr;
+}
 
-extern nb_internals &internals_get() noexcept;
 extern char *type_name(const std::type_info *t);
 
 // Forward declarations
-extern int nb_type_init(PyObject *, PyObject *, PyObject *);
-extern void nb_type_dealloc(PyObject *o);
 extern PyObject *inst_new_impl(PyTypeObject *tp, void *value);
-extern void nb_enum_prepare(PyType_Slot **s, bool is_arithmetic);
-extern int nb_static_property_set(PyObject *, PyObject *, PyObject *);
+extern PyTypeObject *nb_static_property_tp() noexcept;
 
 /// Fetch the nanobind function record from a 'nb_func' instance
 NB_INLINE func_data *nb_func_data(void *o) {
     return (func_data *) (((char *) o) + sizeof(nb_func));
 }
 
 #if defined(Py_LIMITED_API)
@@ -243,15 +273,17 @@
         return (type_data *) (((char *) o) + sizeof(PyHeapTypeObject));
     #else
         return nb_type_data_static(o);
     #endif
 }
 
 extern PyObject *nb_type_name(PyTypeObject *o) noexcept;
-inline PyObject *nb_inst_name(PyObject *o) noexcept { return nb_type_name(Py_TYPE(o)); }
+inline PyObject *nb_inst_name(PyObject *o) noexcept {
+        return nb_type_name(Py_TYPE(o));
+}
 
 inline void *inst_ptr(nb_inst *self) {
     void *ptr = (void *) ((intptr_t) self + self->offset);
     return self->direct ? ptr : *(void **) ptr;
 }
 
 template <typename T> struct scoped_pymalloc {
@@ -271,8 +303,7 @@
     T *operator->() { return ptr; }
 private:
     T *ptr{ nullptr };
 };
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
-
```

## nanobind/src/nb_ndarray.cpp

```diff
@@ -12,34 +12,35 @@
     void *manager_ctx;
     void (*deleter)(managed_dltensor *);
 };
 
 struct ndarray_handle {
     managed_dltensor *ndarray;
     std::atomic<size_t> refcount;
-    PyObject *owner;
+    PyObject *owner, *self;
     bool free_shape;
     bool free_strides;
     bool call_deleter;
+    bool ro;
 };
 
-void nb_ndarray_dealloc(PyObject *self) {
+static void nb_ndarray_dealloc(PyObject *self) {
     ndarray_dec_ref(((nb_ndarray *) self)->th);
 
     freefunc tp_free;
 #if defined(Py_LIMITED_API)
     tp_free = (freefunc) PyType_GetSlot(Py_TYPE(self), Py_tp_free);
 #else
     tp_free = Py_TYPE(self)->tp_free;
 #endif
 
     tp_free(self);
 }
 
-int nb_ndarray_getbuffer(PyObject *exporter, Py_buffer *view, int) {
+static int nd_ndarray_tpbuffer(PyObject *exporter, Py_buffer *view, int) {
     nb_ndarray *self = (nb_ndarray *) exporter;
 
     dlpack::dltensor &t = self->th->ndarray->dltensor;
 
     if (t.device.device_type != device::cpu::value) {
         PyErr_SetString(PyExc_BufferError, "Only CPU-allocated ndarrays can be "
                                            "accessed via the buffer protocol!");
@@ -92,42 +93,81 @@
     view->format = (char *) format;
     view->itemsize = t.dtype.bits / 8;
     view->buf = (void *) ((uintptr_t) t.data + t.byte_offset);
     view->obj = exporter;
     Py_INCREF(exporter);
 
     Py_ssize_t len = view->itemsize;
-    scoped_pymalloc<Py_ssize_t> strides(t.ndim), shape(t.ndim);
-    for (int32_t i = 0; i < t.ndim; ++i) {
+    scoped_pymalloc<Py_ssize_t> strides((size_t) t.ndim),
+                                  shape((size_t) t.ndim);
+
+    for (size_t i = 0; i < (size_t) t.ndim; ++i) {
         len *= (Py_ssize_t) t.shape[i];
         strides[i] = (Py_ssize_t) t.strides[i] * view->itemsize;
         shape[i] = (Py_ssize_t) t.shape[i];
     }
 
     view->ndim = t.ndim;
     view->len = len;
-    view->readonly = false;
+    view->readonly = self->th->ro;
     view->suboffsets = nullptr;
     view->internal = nullptr;
     view->strides = strides.release();
     view->shape = shape.release();
 
     return 0;
 }
 
-void nb_ndarray_releasebuffer(PyObject *, Py_buffer *view) {
+static void nb_ndarray_releasebuffer(PyObject *, Py_buffer *view) {
     PyMem_Free(view->shape);
     PyMem_Free(view->strides);
 }
 
-static PyObject *dlpack_from_buffer_protocol(PyObject *o) {
+static PyTypeObject *nd_ndarray_tp() noexcept {
+    nb_internals &internals = internals_get();
+    PyTypeObject *tp = internals.nb_ndarray;
+
+    if (NB_UNLIKELY(!tp)) {
+        PyType_Slot slots[] = {
+            { Py_tp_dealloc, (void *) nb_ndarray_dealloc },
+#if PY_VERSION_HEX >= 0x03090000
+            { Py_bf_getbuffer, (void *) nd_ndarray_tpbuffer },
+            { Py_bf_releasebuffer, (void *) nb_ndarray_releasebuffer },
+#endif
+            { 0, nullptr }
+        };
+
+        PyType_Spec spec = {
+            /* .name = */ "nanobind.nb_ndarray",
+            /* .basicsize = */ (int) sizeof(nb_ndarray),
+            /* .itemsize = */ 0,
+            /* .flags = */ Py_TPFLAGS_DEFAULT,
+            /* .slots = */ slots
+        };
+
+        tp = (PyTypeObject *) PyType_FromSpec(&spec);
+        check(tp, "nb_ndarray type creation failed!");
+
+#if PY_VERSION_HEX < 0x03090000
+        tp->tp_as_buffer->bf_getbuffer = nd_ndarray_tpbuffer;
+        tp->tp_as_buffer->bf_releasebuffer = nb_ndarray_releasebuffer;
+#endif
+
+        internals.nb_ndarray = tp;
+    }
+
+    return tp;
+}
+
+static PyObject *dlpack_from_buffer_protocol(PyObject *o, bool ro) {
     scoped_pymalloc<Py_buffer> view;
     scoped_pymalloc<managed_dltensor> mt;
 
-    if (PyObject_GetBuffer(o, view.get(), PyBUF_RECORDS)) {
+    if (PyObject_GetBuffer(o, view.get(),
+                           ro ? PyBUF_RECORDS_RO : PyBUF_RECORDS)) {
         PyErr_Clear();
         return nullptr;
     }
 
     char format = 'B';
     const char *format_str = view->format;
     if (format_str)
@@ -207,16 +247,16 @@
 
     mt->dltensor.data = (void *) value_rounded;
     mt->dltensor.device = { device::cpu::value, 0 };
     mt->dltensor.ndim = view->ndim;
     mt->dltensor.dtype = dt;
     mt->dltensor.byte_offset = value_int - value_rounded;
 
-    scoped_pymalloc<int64_t> strides(view->ndim);
-    scoped_pymalloc<int64_t> shape(view->ndim);
+    scoped_pymalloc<int64_t> strides((size_t) view->ndim);
+    scoped_pymalloc<int64_t> shape((size_t) view->ndim);
     for (size_t i = 0; i < (size_t) view->ndim; ++i) {
         strides[i] = (int64_t) (view->strides[i] / view->itemsize);
         shape[i] = (int64_t) view->shape[i];
     }
 
     mt->manager_ctx = view.release();
     mt->dltensor.shape = shape.release();
@@ -232,19 +272,20 @@
         } else {
             PyErr_Clear();
         }
     });
 }
 
 ndarray_handle *ndarray_import(PyObject *o, const ndarray_req *req,
-                             bool convert) noexcept {
+                               bool convert) noexcept {
     object capsule;
+    bool is_pycapsule = PyCapsule_CheckExact(o);
 
     // If this is not a capsule, try calling o.__dlpack__()
-    if (!PyCapsule_CheckExact(o)) {
+    if (!is_pycapsule) {
         capsule = steal(PyObject_CallMethod(o, "__dlpack__", nullptr));
 
         if (!capsule.is_valid()) {
             PyErr_Clear();
             PyTypeObject *tp = Py_TYPE(o);
 
             try {
@@ -264,15 +305,15 @@
             } catch (...) {
                 capsule.reset();
             }
         }
 
         // Try creating a ndarray via the buffer protocol
         if (!capsule.is_valid())
-            capsule = steal(dlpack_from_buffer_protocol(o));
+            capsule = steal(dlpack_from_buffer_protocol(o, req->req_ro));
 
         if (!capsule.is_valid())
             return nullptr;
     } else {
         capsule = borrow(o);
     }
 
@@ -309,42 +350,42 @@
         }
     }
 
     int64_t size = 1;
     for (uint32_t i = 0; i < req->ndim; ++i)
         size *= t.shape[i];
 
-    scoped_pymalloc<int64_t> strides(t.ndim);
+    scoped_pymalloc<int64_t> strides((size_t) t.ndim);
     if ((req->req_order || !t.strides) && t.ndim > 0) {
         size_t accum = 1;
 
         if (req->req_order == 'C' || !t.strides) {
-            for (uint32_t i = (uint32_t) (t.ndim - 1);;) {
-                strides[i] = accum;
+            for (size_t i = (size_t) (t.ndim - 1);;) {
+                strides[i] = (int64_t) accum;
                 accum *= t.shape[i];
                 if (i == 0)
                     break;
                 --i;
             }
         } else if (req->req_order == 'F') {
-            for (uint32_t i = 0; i < (uint32_t) t.ndim; ++i) {
-                strides[i] = accum;
+            for (size_t i = 0; i < (size_t) t.ndim; ++i) {
+                strides[i] = (int64_t) accum;
                 accum *= t.shape[i];
             }
         } else {
             pass_order = false;
         }
 
         if (req->req_order && size != 0) { // Tolerate any strides if empty
             if (!t.strides) {
                 /* The provided tensor does not have a valid strides
                    field, which implies a C-style ordering. */
                 pass_order = req->req_order == 'C';
             } else {
-                for (uint32_t i = 0; i < (uint32_t) t.ndim; ++i) {
+                for (size_t i = 0; i < (size_t) t.ndim; ++i) {
                     if (t.shape[i] != 1 && strides[i] != t.strides[i]) {
                         pass_order = false;
                         break;
                     }
                 }
             }
         }
@@ -409,28 +450,35 @@
     // Create a reference-counted wrapper
     scoped_pymalloc<ndarray_handle> result;
     result->ndarray = (managed_dltensor *) ptr;
     result->refcount = 0;
     result->owner = nullptr;
     result->free_shape = false;
     result->call_deleter = true;
+    result->ro = req->req_ro;
+    if (is_pycapsule) {
+        result->self = nullptr;
+    } else {
+        result->self = o;
+        Py_INCREF(o);
+    }
 
     // Ensure that the strides member is always initialized
     if (t.strides) {
         result->free_strides = false;
     } else {
         result->free_strides = true;
         t.strides = strides.release();
     }
 
     // Mark the dltensor capsule as "consumed"
     if (PyCapsule_SetName(capsule.ptr(), "used_dltensor") ||
         PyCapsule_SetDestructor(capsule.ptr(), nullptr))
-        fail("nanobind::detail::ndarray_import(): could not mark dltensor "
-             "capsule as consumed!");
+        check(false, "nanobind::detail::ndarray_import(): could not mark "
+                     "dltensor capsule as consumed!");
 
     return result.release();
 }
 
 dlpack::dltensor *ndarray_inc_ref(ndarray_handle *th) noexcept {
     if (!th)
         return nullptr;
@@ -440,17 +488,18 @@
 
 void ndarray_dec_ref(ndarray_handle *th) noexcept {
     if (!th)
         return;
     size_t rc_value = th->refcount--;
 
     if (rc_value == 0) {
-        fail("ndarray_dec_ref(): reference count became negative!");
+        check(false, "ndarray_dec_ref(): reference count became negative!");
     } else if (rc_value == 1) {
         Py_XDECREF(th->owner);
+        Py_XDECREF(th->self);
         managed_dltensor *mt = th->ndarray;
         if (th->free_shape) {
             PyMem_Free(mt->dltensor.shape);
             mt->dltensor.shape = nullptr;
         }
         if (th->free_strides) {
             PyMem_Free(mt->dltensor.strides);
@@ -463,28 +512,27 @@
             PyMem_Free(mt);
         }
         PyMem_Free(th);
     }
 }
 
 ndarray_handle *ndarray_create(void *value, size_t ndim, const size_t *shape_in,
-                            PyObject *owner, const int64_t *strides_in,
-                            dlpack::dtype *dtype, int32_t device_type,
-                            int32_t device_id) {
+                               PyObject *owner, const int64_t *strides_in,
+                               dlpack::dtype *dtype, bool ro,
+                               int32_t device_type, int32_t device_id) {
     /* DLPack mandates 256-byte alignment of the 'DLTensor::data' field, but
        PyTorch unfortunately ignores the 'byte_offset' value.. :-( */
 #if 0
     uintptr_t value_int = (uintptr_t) value,
               value_rounded = (value_int / 256) * 256;
 #else
     uintptr_t value_int = (uintptr_t) value,
               value_rounded = value_int;
 #endif
 
-
     scoped_pymalloc<managed_dltensor> ndarray;
     scoped_pymalloc<ndarray_handle> result;
     scoped_pymalloc<int64_t> shape(ndim), strides(ndim);
 
     auto deleter = [](managed_dltensor *mt) {
         gil_scoped_acquire guard;
         ndarray_handle *th = (ndarray_handle *) mt->manager_ctx;
@@ -517,17 +565,19 @@
     ndarray->dltensor.shape = shape.release();
     ndarray->dltensor.strides = strides.release();
     ndarray->manager_ctx = result.get();
     ndarray->deleter = deleter;
     result->ndarray = (managed_dltensor *) ndarray.release();
     result->refcount = 0;
     result->owner = owner;
+    result->self = nullptr;
     result->free_shape = true;
     result->free_strides = true;
     result->call_deleter = false;
+    result->ro = ro;
     Py_XINCREF(owner);
     return result.release();
 }
 
 static void ndarray_capsule_destructor(PyObject *o) {
     error_scope scope; // temporarily save any existing errors
     managed_dltensor *mt =
@@ -535,23 +585,29 @@
 
     if (mt)
         ndarray_dec_ref((ndarray_handle *) mt->manager_ctx);
     else
         PyErr_Clear();
 }
 
-PyObject *ndarray_wrap(ndarray_handle *th, int framework, rv_policy policy) noexcept {
+PyObject *ndarray_wrap(ndarray_handle *th, int framework,
+                       rv_policy policy) noexcept {
     if (!th)
         return none().release().ptr();
 
+    if (th->self) {
+        Py_INCREF(th->self);
+        return th->self;
+    }
+
     bool copy = policy == rv_policy::copy || policy == rv_policy::move;
 
     if ((ndarray_framework) framework == ndarray_framework::numpy) {
         try {
-            object o = steal(PyType_GenericAlloc(internals_get().nb_ndarray, 0));
+            object o = steal(PyType_GenericAlloc(nd_ndarray_tp(), 0));
             if (!o.is_valid())
                 return nullptr;
             ((nb_ndarray *) o.ptr())->th = th;
             ndarray_inc_ref(th);
 
             return module_::import_("numpy")
                 .attr("array")(o, arg("copy") = copy)
@@ -582,16 +638,16 @@
 
             case ndarray_framework::jax:
                 package = module_::import_("jax.dlpack");
                 break;
 
 
             default:
-                fail("nanobind::detail::ndarray_wrap(): unknown framework "
-                     "specified!");
+                check(false, "nanobind::detail::ndarray_wrap(): unknown "
+                             "framework specified!");
         }
     } catch (const std::exception &e) {
         PyErr_Format(PyExc_RuntimeError,
                      "nanobind::detail::ndarray_wrap(): could not import ndarray "
                      "framework: %s", e.what());
         return nullptr;
     }
```

## nanobind/src/nb_type.cpp

```diff
@@ -111,41 +111,53 @@
             self->direct = false;
         }
 
         self->internal = false;
     }
 
     // Update hash table that maps from C++ to Python instance
-    nb_inst_seq seq_v { self };
     auto [it, success] =
-        internals_get().inst_c2p.try_emplace(value, seq_v);
+        internals_get().inst_c2p.try_emplace(value, self);
 
-    if (!success) {
-        nb_inst_seq *seq = &it.value();
+    if (NB_UNLIKELY(!success)) {
+        void *entry = it->second;
+
+        // Potentially convert the map value into linked list format
+        if (!nb_is_seq(entry)) {
+            nb_inst_seq *first = (nb_inst_seq *) PyMem_Malloc(sizeof(nb_inst_seq));
+            check(first, "nanobind::detail::inst_new(): list element "
+                         "allocation failed!");
+            first->inst = (PyObject *) entry;
+            first->next = nullptr;
+            entry = it.value() = nb_mark_seq(first);
+        }
+
+        nb_inst_seq *seq = nb_get_seq(entry);
         while (true) {
-            if (NB_UNLIKELY(seq->inst == self))
-                fail("nanobind::detail::inst_new(): duplicate instance!");
+            check((nb_inst *) seq->inst != self,
+                  "nanobind::detail::inst_new(): duplicate instance!");
             if (!seq->next)
                 break;
             seq = seq->next;
         }
 
         nb_inst_seq *next = (nb_inst_seq *) PyMem_Malloc(sizeof(nb_inst_seq));
-        if (NB_UNLIKELY(!next))
-            fail("nanobind::detail::inst_new(): list element allocation failed!");
+        check(next,
+              "nanobind::detail::inst_new(): list element allocation failed!");
 
-        *next = seq_v;
+        next->inst = (PyObject *) self;
+        next->next = nullptr;
         seq->next = next;
     }
 
     return (PyObject *) self;
 }
 
 // Allocate a new instance with co-located storage
-PyObject *inst_new(PyTypeObject *type, PyObject *, PyObject *) {
+static PyObject *inst_new(PyTypeObject *type, PyObject *, PyObject *) {
     return inst_new_impl(type, nullptr);
 }
 
 static void inst_dealloc(PyObject *self) {
     PyTypeObject *tp = Py_TYPE(self);
     const type_data *t = nb_type_data(tp);
 
@@ -158,130 +170,124 @@
         Py_CLEAR(dict);
     }
 
     nb_inst *inst = (nb_inst *) self;
     void *p = inst_ptr(inst);
 
     if (inst->destruct) {
-        if (t->flags & (uint32_t) type_flags::is_destructible) {
-            if (t->flags & (uint32_t) type_flags::has_destruct)
-                t->destruct(p);
-        } else {
-            fail("nanobind::detail::inst_dealloc(\"%s\"): attempted to call "
-                 "the destructor of a non-destructible type!", t->name);
-        }
+        check(t->flags & (uint32_t) type_flags::is_destructible,
+              "nanobind::detail::inst_dealloc(\"%s\"): attempted to call "
+              "the destructor of a non-destructible type!", t->name);
+        if (t->flags & (uint32_t) type_flags::has_destruct)
+            t->destruct(p);
     }
 
     if (inst->cpp_delete) {
         if (t->align <= (uint32_t) __STDCPP_DEFAULT_NEW_ALIGNMENT__)
             operator delete(p);
         else
             operator delete(p, std::align_val_t(t->align));
     }
 
     nb_internals &internals = internals_get();
     if (inst->clear_keep_alive) {
         auto it = internals.keep_alive.find(self);
-        if (it == internals.keep_alive.end())
-            fail("nanobind::detail::inst_dealloc(\"%s\"): inconsistent "
-                 "keep_alive information", t->name);
+        check(it != internals.keep_alive.end(),
+              "nanobind::detail::inst_dealloc(\"%s\"): inconsistent "
+              "keep_alive information", t->name);
 
-        keep_alive_set ref_set = std::move(it.value());
+        nb_weakref_seq *s = (nb_weakref_seq *) it->second;
         internals.keep_alive.erase(it);
+        do {
+            nb_weakref_seq *c = s;
+            s = c->next;
 
-        for (keep_alive_entry e: ref_set) {
-            if (!e.deleter)
-                Py_DECREF((PyObject *) e.data);
+            if (c->callback)
+                c->callback(c->payload);
             else
-                e.deleter(e.data);
-        }
+                Py_DECREF((PyObject *) c->payload);
+
+            PyObject_Free(c);
+        } while (s);
     }
 
     // Update hash table that maps from C++ to Python instance
-    nb_inst_seq *seq = nullptr, *pred = nullptr;
-    nb_inst_map &inst_c2p = internals.inst_c2p;
-    nb_inst_map::iterator it = inst_c2p.find(p);
-
-    if (it != inst_c2p.end()) {
-        seq = &it.value();
-
-        do {
-            if (seq->inst == inst)
-                break;
-            pred = seq;
-            seq = seq->next;
-        } while (seq);
-    }
+    nb_ptr_map &inst_c2p = internals.inst_c2p;
+    nb_ptr_map::iterator it = inst_c2p.find(p);
+    bool found = false;
+
+    if (NB_LIKELY(it != inst_c2p.end())) {
+        void *entry = it->second;
+        if (NB_LIKELY(entry == inst)) {
+            found = true;
+            inst_c2p.erase(it);
+        } else if (nb_is_seq(entry)) {
+            // Multiple objects are associated with this address. Find the right one!
+            nb_inst_seq *seq = nb_get_seq(entry),
+                        *pred = nullptr;
+
+            do {
+                if ((nb_inst *) seq->inst == inst) {
+                    found = true;
+
+                    if (pred) {
+                        pred->next = seq->next;
+                    } else {
+                        if (seq->next)
+                            it.value() = nb_mark_seq(seq->next);
+                        else
+                            inst_c2p.erase(it);
+                    }
 
-    if (!seq || seq->inst != inst)
-        fail("nanobind::detail::inst_dealloc(\"%s\"): attempted to delete "
-             "an unknown instance (%p)!", t->name, p);
+                    PyMem_Free(seq);
+                    break;
+                }
 
-    if (pred) {
-        pred->next = seq->next;
-        PyMem_Free(seq);
-    } else {
-        if (seq->next) {
-            it.value() = *(seq->next);
-            PyMem_Free(seq->next);
-        } else {
-            inst_c2p.erase(it);
+                pred = seq;
+                seq = seq->next;
+            } while (seq);
         }
     }
 
-    if (gc) {
-        #if defined(Py_LIMITED_API)
-            static freefunc tp_free =
-                (freefunc) PyType_GetSlot(tp, Py_tp_free);
-        #else
-            freefunc tp_free = tp->tp_free;
-        #endif
+    check(found,
+          "nanobind::detail::inst_dealloc(\"%s\"): attempted to delete an "
+          "unknown instance (%p)!", t->name, p);
 
-        tp_free(self);
-    } else {
+    if (NB_UNLIKELY(gc))
+        NB_SLOT(internals, PyType_Type, tp_free)(self);
+    else
         PyObject_Free(self);
-    }
 
     Py_DECREF(tp);
 }
 
-void nb_type_dealloc(PyObject *o) {
+static void nb_type_dealloc(PyObject *o) {
     type_data *t = nb_type_data((PyTypeObject *) o);
 
     if (t->type && (t->flags & (uint32_t) type_flags::is_python_type) == 0) {
-        nb_internals &internals = internals_get();
-        auto it = internals.type_c2p.find(std::type_index(*t->type));
-        if (it == internals.type_c2p.end())
-            fail("nanobind::detail::nb_type_dealloc(\"%s\"): could not "
-                 "find type!", t->name);
-        internals.type_c2p.erase(it);
+        nb_type_map &type_c2p = internals_get().type_c2p;
+        nb_type_map::iterator it = type_c2p.find(std::type_index(*t->type));
+        check(it != type_c2p.end(),
+              "nanobind::detail::nb_type_dealloc(\"%s\"): could not "
+              "find type!", t->name);
+        type_c2p.erase(it);
     }
 
     if (t->flags & (uint32_t) type_flags::has_implicit_conversions) {
         free(t->implicit);
         free(t->implicit_py);
     }
 
-    if (t->flags & (uint32_t) type_flags::has_supplement)
-        free(t->supplement);
-
     free((char *) t->name);
 
-    #if defined(Py_LIMITED_API)
-        static destructor tp_dealloc =
-            (destructor) PyType_GetSlot(&PyType_Type, Py_tp_dealloc);
-    #else
-        destructor tp_dealloc = PyType_Type.tp_dealloc;
-    #endif
-
-    tp_dealloc(o);
+    NB_SLOT(internals_get(), PyType_Type, tp_dealloc)(o);
 }
 
 /// Called when a C++ type is extended from within Python
-int nb_type_init(PyObject *self, PyObject *args, PyObject *kwds) {
+static int nb_type_init(PyObject *self, PyObject *args, PyObject *kwds) {
     if (NB_TUPLE_GET_SIZE(args) != 3) {
         PyErr_SetString(PyExc_RuntimeError,
                         "nb_type_init(): invalid number of arguments!");
         return -1;
     }
 
     PyObject *bases = NB_TUPLE_GET_ITEM(args, 1);
@@ -300,102 +306,409 @@
     type_data *t_b = nb_type_data((PyTypeObject *) base);
     if (t_b->flags & (uint32_t) type_flags::is_final) {
         PyErr_Format(PyExc_TypeError, "The type '%s' prohibits subclassing!",
                      t_b->name);
         return -1;
     }
 
-    #if defined(Py_LIMITED_API)
-        static initproc tp_init =
-            (initproc) PyType_GetSlot(&PyType_Type, Py_tp_init);
-    #else
-        initproc tp_init = PyType_Type.tp_init;
-    #endif
-
-    int rv = tp_init(self, args, kwds);
+    int rv = NB_SLOT(internals_get(), PyType_Type, tp_init)(self, args, kwds);
     if (rv)
         return rv;
 
     type_data *t = nb_type_data((PyTypeObject *) self);
 
     *t = *t_b;
     t->flags |=  (uint32_t) type_flags::is_python_type;
-    t->flags &= ~((uint32_t) type_flags::has_implicit_conversions |
-                  (uint32_t) type_flags::has_supplement);
+    t->flags &= ~((uint32_t) type_flags::has_implicit_conversions);
     PyObject *name = nb_type_name((PyTypeObject *) self);
     t->name = NB_STRDUP(PyUnicode_AsUTF8AndSize(name, nullptr));
     Py_DECREF(name);
     t->type_py = (PyTypeObject *) self;
-    t->base = t_b->type;
-    t->base_py = t_b->type_py;
     t->implicit = nullptr;
     t->implicit_py = nullptr;
-    t->supplement = nullptr;
 
     return 0;
 }
 
+/// Special case to handle 'Class.property = value' assignments
+static int nb_type_setattro(PyObject* obj, PyObject* name, PyObject* value) {
+    nb_internals &internals = internals_get();
+
+    internals.nb_static_property_enabled = false;
+    PyObject *cur = PyObject_GetAttr(obj, name);
+    internals.nb_static_property_enabled = true;
+
+    if (cur) {
+        PyTypeObject *tp = internals.nb_static_property;
+        if (Py_TYPE(cur) == tp) {
+            int rv = internals.nb_static_property_descr_set(cur, obj, value);
+            Py_DECREF(cur);
+            return rv;
+        }
+        Py_DECREF(cur);
+
+        const char *cname = PyUnicode_AsUTF8AndSize(name, nullptr);
+        if (!cname) {
+            PyErr_Clear(); // probably a non-string attribute name
+        } else if (cname[0] == '@') {
+            /* Prevent type attributes starting with an `@` sign from being
+               rebound or deleted. This is useful to safely stash owning
+               references. The ``nb::enum_<>`` class, e.g., uses this to ensure
+               indirect ownership of a borrowed reference in the supplemental
+               type data. */
+            PyErr_Format(PyExc_AttributeError,
+                         "internal nanobind attribute '%s' cannot be "
+                         "reassigned or deleted.", cname);
+            return -1;
+        }
+    } else {
+        PyErr_Clear();
+    }
+
+    return NB_SLOT(internals, PyType_Type, tp_setattro)(obj, name, value);
+}
+
+#if PY_VERSION_HEX < 0x030C0000
+#  if PY_VERSION_HEX < 0x03090000
+#    define Py_bf_getbuffer 1
+#    define Py_bf_releasebuffer 2
+#  endif
+
+template <size_t I1, size_t I2, size_t Offset> uint8_t constexpr Ei() {
+    // Compile-time check to ensure that indices and alignment match our expectation
+    static_assert(I1 == I2 && (Offset % sizeof(void *)) == 0,
+                  "type_slots: internal error");
+    return (uint8_t) (Offset / sizeof(void *));
+}
+
+#define E(i1, p1, p2, name)                                                    \
+    Ei<i1, Py_##p2##_##name, offsetof(PyHeapTypeObject, p1.p2##_##name)>()
+
+// Precomputed mapping from type slot ID to an entry in the data structure
+static const uint8_t type_slots[] {
+    E(1, as_buffer, bf, getbuffer),
+    E(2, as_buffer, bf, releasebuffer),
+    E(3, as_mapping, mp, ass_subscript),
+    E(4, as_mapping, mp, length),
+    E(5, as_mapping, mp, subscript),
+    E(6, as_number, nb, absolute),
+    E(7, as_number, nb, add),
+    E(8, as_number, nb, and),
+    E(9, as_number, nb, bool),
+    E(10, as_number, nb, divmod),
+    E(11, as_number, nb, float),
+    E(12, as_number, nb, floor_divide),
+    E(13, as_number, nb, index),
+    E(14, as_number, nb, inplace_add),
+    E(15, as_number, nb, inplace_and),
+    E(16, as_number, nb, inplace_floor_divide),
+    E(17, as_number, nb, inplace_lshift),
+    E(18, as_number, nb, inplace_multiply),
+    E(19, as_number, nb, inplace_or),
+    E(20, as_number, nb, inplace_power),
+    E(21, as_number, nb, inplace_remainder),
+    E(22, as_number, nb, inplace_rshift),
+    E(23, as_number, nb, inplace_subtract),
+    E(24, as_number, nb, inplace_true_divide),
+    E(25, as_number, nb, inplace_xor),
+    E(26, as_number, nb, int),
+    E(27, as_number, nb, invert),
+    E(28, as_number, nb, lshift),
+    E(29, as_number, nb, multiply),
+    E(30, as_number, nb, negative),
+    E(31, as_number, nb, or),
+    E(32, as_number, nb, positive),
+    E(33, as_number, nb, power),
+    E(34, as_number, nb, remainder),
+    E(35, as_number, nb, rshift),
+    E(36, as_number, nb, subtract),
+    E(37, as_number, nb, true_divide),
+    E(38, as_number, nb, xor),
+    E(39, as_sequence, sq, ass_item),
+    E(40, as_sequence, sq, concat),
+    E(41, as_sequence, sq, contains),
+    E(42, as_sequence, sq, inplace_concat),
+    E(43, as_sequence, sq, inplace_repeat),
+    E(44, as_sequence, sq, item),
+    E(45, as_sequence, sq, length),
+    E(46, as_sequence, sq, repeat),
+    E(47, ht_type, tp, alloc),
+    E(48, ht_type, tp, base),
+    E(49, ht_type, tp, bases),
+    E(50, ht_type, tp, call),
+    E(51, ht_type, tp, clear),
+    E(52, ht_type, tp, dealloc),
+    E(53, ht_type, tp, del),
+    E(54, ht_type, tp, descr_get),
+    E(55, ht_type, tp, descr_set),
+    E(56, ht_type, tp, doc),
+    E(57, ht_type, tp, getattr),
+    E(58, ht_type, tp, getattro),
+    E(59, ht_type, tp, hash),
+    E(60, ht_type, tp, init),
+    E(61, ht_type, tp, is_gc),
+    E(62, ht_type, tp, iter),
+    E(63, ht_type, tp, iternext),
+    E(64, ht_type, tp, methods),
+    E(65, ht_type, tp, new),
+    E(66, ht_type, tp, repr),
+    E(67, ht_type, tp, richcompare),
+    E(68, ht_type, tp, setattr),
+    E(69, ht_type, tp, setattro),
+    E(70, ht_type, tp, str),
+    E(71, ht_type, tp, traverse),
+    E(72, ht_type, tp, members),
+    E(73, ht_type, tp, getset),
+    E(74, ht_type, tp, free),
+    E(75, as_number, nb, matrix_multiply),
+    E(76, as_number, nb, inplace_matrix_multiply),
+    E(77, as_async, am, await),
+    E(78, as_async, am, aiter),
+    E(79, as_async, am, anext),
+    E(80, ht_type, tp, finalize),
+#if PY_VERSION_HEX >= 0x030A0000
+    E(81, as_async, am, send),
+#endif
+};
+
+#endif
+
+static PyObject *nb_type_from_metaclass(PyTypeObject *meta, PyObject *mod,
+                                        PyType_Spec *spec) {
+#if PY_VERSION_HEX >= 0x030C0000
+    // Life is good, PyType_FromMetaclass() is available
+    return PyType_FromMetaclass(meta, mod, spec, nullptr);
+#else
+    /* The fallback code below emulates PyType_FromMetaclass() on Python prior
+       to version 3.12. It requires access to CPython-internal structures, which
+       is why nanobind can only target the stable ABI on version 3.12+. */
+
+    const char *name = strrchr(spec->name, '.');
+    if (name)
+        name++;
+    else
+        name = spec->name;
+
+    PyObject *name_o = PyUnicode_FromString(name);
+    if (!name_o)
+        return nullptr;
+
+    const char *name_cstr = PyUnicode_AsUTF8AndSize(name_o, nullptr);
+    if (!name_cstr) {
+        Py_DECREF(name_o);
+        return nullptr;
+    }
+
+    PyHeapTypeObject *ht = (PyHeapTypeObject *) PyType_GenericAlloc(meta, 0);
+    if (!ht) {
+        Py_DECREF(name_o);
+        return nullptr;
+    }
+
+    ht->ht_name = name_o;
+    ht->ht_qualname = name_o;
+    Py_INCREF(name_o);
+
+#if PY_VERSION_HEX >= 0x03090000
+    if (mod) {
+        Py_INCREF(mod);
+        ht->ht_module = mod;
+    }
+#else
+    (void) mod;
+#endif
+
+    PyTypeObject *tp = &ht->ht_type;
+    tp->tp_name = name_cstr;
+    tp->tp_basicsize = spec->basicsize;
+    tp->tp_itemsize = spec->itemsize;
+    tp->tp_flags = spec->flags | Py_TPFLAGS_HEAPTYPE;
+    tp->tp_as_async = &ht->as_async;
+    tp->tp_as_number = &ht->as_number;
+    tp->tp_as_sequence = &ht->as_sequence;
+    tp->tp_as_mapping = &ht->as_mapping;
+    tp->tp_as_buffer = &ht->as_buffer;
+
+    PyType_Slot *ts = spec->slots;
+    bool fail = false;
+    while (true) {
+        int slot = ts->slot;
+
+        if (slot == 0) {
+            break;
+        } else if (slot < (int) sizeof(type_slots)) {
+            *(((void **) ht) + type_slots[slot - 1]) = ts->pfunc;
+        } else {
+            PyErr_Format(PyExc_RuntimeError,
+                         "nb_type_from_metaclass(): unhandled slot %i", slot);
+            fail = true;
+            break;
+        }
+        ts++;
+    }
+
+    // Bring type object into a safe state (before error handling)
+    const PyMemberDef *members = tp->tp_members;
+    const char *doc = tp->tp_doc;
+    tp->tp_members = nullptr;
+    tp->tp_doc = nullptr;
+    Py_XINCREF(tp->tp_base);
+
+    if (doc && !fail) {
+        size_t size = strlen(doc) + 1;
+        char *target = (char *) PyObject_Malloc(size);
+        if (!target) {
+            PyErr_NoMemory();
+            fail = true;
+        } else {
+            memcpy(target, doc, size);
+            tp->tp_doc = target;
+        }
+    }
+
+    if (members && !fail) {
+        while (members->name) {
+            if (members->type == T_PYSSIZET && members->flags == READONLY) {
+                if (strcmp(members->name, "__dictoffset__") == 0)
+                    tp->tp_dictoffset = members->offset;
+                else if (strcmp(members->name, "__weaklistoffset__") == 0)
+                    tp->tp_weaklistoffset = members->offset;
+                else if (strcmp(members->name, "__vectorcalloffset__") == 0)
+                    tp->tp_vectorcall_offset = members->offset;
+                else
+                    fail = true;
+            } else {
+                fail = true;
+            }
+
+            if (fail) {
+                PyErr_Format(
+                    PyExc_RuntimeError,
+                    "nb_type_from_metaclass(): unhandled tp_members entry!");
+                break;
+            }
+
+            members++;
+        }
+    }
+
+    if (fail || PyType_Ready(tp) != 0) {
+        Py_DECREF(tp);
+        return nullptr;
+    }
+
+    return (PyObject *) tp;
+#endif
+}
+
+static PyTypeObject *nb_type_tp(nb_internals &internals,
+                                size_t supplement) noexcept {
+    object key = steal(PyLong_FromSize_t(supplement));
+
+    PyTypeObject *tp =
+        (PyTypeObject *) PyDict_GetItem(internals.nb_type_dict, key.ptr());
+
+    if (NB_UNLIKELY(!tp)) {
+        PyType_Slot slots[] = {
+            { Py_tp_base, &PyType_Type },
+            { Py_tp_dealloc, (void *) nb_type_dealloc },
+            { Py_tp_setattro, (void *) nb_type_setattro },
+            { Py_tp_init, (void *) nb_type_init },
+            { 0, nullptr }
+        };
+
+#if PY_VERSION_HEX >= 0x030C0000
+        int basicsize = -(int) (sizeof(type_data) + supplement),
+            itemsize = 0;
+#else
+        int basicsize = (int) (PyType_Type.tp_basicsize + (sizeof(type_data) + supplement)),
+            itemsize = (int) PyType_Type.tp_itemsize;
+#endif
+
+        char name[17 + 20 + 1];
+        snprintf(name, sizeof(name), "nanobind.nb_type_%zu", supplement);
+
+        PyType_Spec spec = {
+            /* .name = */ name,
+            /* .basicsize = */ basicsize,
+            /* .itemsize = */ itemsize,
+            /* .flags = */ Py_TPFLAGS_DEFAULT,
+            /* .slots = */ slots
+        };
+
+        tp = (PyTypeObject *) nb_type_from_metaclass(
+            internals.nb_meta, internals.nb_module, &spec);
+
+        handle(tp).attr("__module__") = "nanobind";
+
+        int rv = 1;
+        if (tp)
+            rv = PyDict_SetItem(internals.nb_type_dict, key.ptr(), (PyObject *) tp);
+        check(rv == 0, "nb_type type creation failed!");
+
+        Py_DECREF(tp);
+    }
+
+    return tp;
+}
+
 /// Called when a C++ type is bound via nb::class_<>
-PyObject *nb_type_new(const type_data *t) noexcept {
-    bool is_signed_enum    = t->flags & (uint32_t) type_flags::is_signed_enum,
-         is_unsigned_enum  = t->flags & (uint32_t) type_flags::is_unsigned_enum,
-         is_arithmetic     = t->flags & (uint32_t) type_flags::is_arithmetic,
-         is_enum           = is_signed_enum || is_unsigned_enum,
-         has_scope         = t->flags & (uint32_t) type_flags::has_scope,
-         has_doc           = t->flags & (uint32_t) type_flags::has_doc,
-         has_base          = t->flags & (uint32_t) type_flags::has_base,
-         has_base_py       = t->flags & (uint32_t) type_flags::has_base_py,
-         has_type_slots    = t->flags & (uint32_t) type_flags::has_type_slots,
-         has_supplement    = t->flags & (uint32_t) type_flags::has_supplement,
+PyObject *nb_type_new(const type_init_data *t) noexcept {
+    bool has_doc           = t->flags & (uint32_t) type_init_flags::has_doc,
+         has_base          = t->flags & (uint32_t) type_init_flags::has_base,
+         has_base_py       = t->flags & (uint32_t) type_init_flags::has_base_py,
+         has_type_slots    = t->flags & (uint32_t) type_init_flags::has_type_slots,
+         has_supplement    = t->flags & (uint32_t) type_init_flags::has_supplement,
          has_dynamic_attr  = t->flags & (uint32_t) type_flags::has_dynamic_attr,
-         intrusive_ptr     = t->flags & (uint32_t) type_flags::intrusive_ptr;
+         intrusive_ptr     = t->flags & (uint32_t) type_flags::intrusive_ptr,
+         has_shared_from_this = t->flags & (uint32_t) type_flags::has_shared_from_this;
 
     nb_internals &internals = internals_get();
     str name(t->name), qualname = name;
     object modname;
     PyObject *mod = nullptr;
 
-    if (has_scope) {
-        has_scope = t->scope != nullptr;
-
-        if (has_scope) {
-            if (PyModule_Check(t->scope)) {
-                mod = t->scope;
-                modname = getattr(t->scope, "__name__", handle());
-            } else {
-                modname = getattr(t->scope, "__module__", handle());
+    if (t->scope != nullptr) {
+        if (PyModule_Check(t->scope)) {
+            mod = t->scope;
+            modname = getattr(t->scope, "__name__", handle());
+        } else {
+            modname = getattr(t->scope, "__module__", handle());
 
-                object scope_qualname = getattr(t->scope, "__qualname__", handle());
-                if (scope_qualname.is_valid())
-                    qualname = steal<str>(
-                        PyUnicode_FromFormat("%U.%U", scope_qualname.ptr(), name.ptr()));
-            }
+            object scope_qualname = getattr(t->scope, "__qualname__", handle());
+            if (scope_qualname.is_valid())
+                qualname = steal<str>(
+                    PyUnicode_FromFormat("%U.%U", scope_qualname.ptr(), name.ptr()));
         }
     }
 
     if (modname.is_valid())
         name = steal<str>(
             PyUnicode_FromFormat("%U.%U", modname.ptr(), name.ptr()));
 
     constexpr size_t ptr_size = sizeof(void *);
     size_t basicsize = sizeof(nb_inst) + t->size;
     if (t->align > ptr_size)
         basicsize += t->align - ptr_size;
 
     PyObject *base = nullptr;
     if (has_base_py) {
-        if (has_base)
-            fail("nanobind::detail::nb_type_new(\"%s\"): multiple base types "
-                 "specified!", t->name);
+        check(!has_base,
+              "nanobind::detail::nb_type_new(\"%s\"): multiple base types "
+              "specified!", t->name);
         base = (PyObject *) t->base_py;
+        check(nb_type_check(base),
+              "nanobind::detail::nb_type_new(\"%s\"): base type is not a "
+              "nanobind type!", t->name);
     } else if (has_base) {
-        auto it = internals.type_c2p.find(std::type_index(*t->base));
-        if (it == internals.type_c2p.end())
-            fail("nanobind::detail::nb_type_new(\"%s\"): base type \"%s\" not "
-                 "known to nanobind!", t->name, type_name(t->base));
+        nb_type_map::iterator it =
+            internals.type_c2p.find(std::type_index(*t->base));
+        check(it != internals.type_c2p.end(),
+                  "nanobind::detail::nb_type_new(\"%s\"): base type \"%s\" not "
+                  "known to nanobind!", t->name, type_name(t->base));
         base = (PyObject *) it->second->type_py;
     }
 
     type_data *tb = nullptr;
     if (base) {
         // Check if the base type already has dynamic attributes
         tb = nb_type_data((PyTypeObject *) base);
@@ -408,19 +721,17 @@
         if (tb->align > ptr_size)
             base_basicsize += tb->align - ptr_size;
         if (base_basicsize > basicsize)
             basicsize = base_basicsize;
     }
     char *name_copy = NB_STRDUP(name.c_str());
 
-    constexpr size_t nb_enum_max_slots = 22,
-                     nb_type_max_slots = 10,
+    constexpr size_t nb_type_max_slots = 10,
                      nb_extra_slots = 80,
-                     nb_total_slots = nb_enum_max_slots +
-                                      nb_type_max_slots +
+                     nb_total_slots = nb_type_max_slots +
                                       nb_extra_slots + 1;
 
     PyMemberDef members[2] { };
     PyType_Slot slots[nb_total_slots], *s = slots;
     PyType_Spec spec = {
         /* .name = */ name_copy,
         /* .basicsize = */ (int) basicsize,
@@ -436,26 +747,34 @@
     *s++ = { Py_tp_new, (void *) inst_new };
     *s++ = { Py_tp_dealloc, (void *) inst_dealloc };
 
     if (has_doc)
         *s++ = { Py_tp_doc, (void *) t->doc };
 
     if (has_type_slots) {
-        size_t i = 0;
-        while (t->type_slots[i].slot) {
-            if (i == nb_extra_slots)
-                fail("nanobind::detail::nb_type_new(\"%s\"): ran out of type "
-                     "slots!", t->name);
-            *s++ = t->type_slots[i++];
+        size_t num_avail = nb_extra_slots;
+        if (t->type_slots_callback) {
+            PyType_Slot* first_new = s;
+            t->type_slots_callback(t, s, num_avail);
+            check(first_new + num_avail >= s,
+                  "nanobind::detail::nb_type_new(\"%s\"): type_slots_callback "
+                  "overflowed the slots array!", t->name);
+            num_avail -= (s - first_new);
+        }
+        if (t->type_slots) {
+            size_t i = 0;
+            while (t->type_slots[i].slot) {
+                check(i != num_avail,
+                      "nanobind::detail::nb_type_new(\"%s\"): ran out of "
+                      "type slots!", t->name);
+                *s++ = t->type_slots[i++];
+            }
         }
     }
 
-    if (is_enum)
-        nb_enum_prepare(&s, is_arithmetic);
-
     bool has_traverse = false;
     for (PyType_Slot *ts = slots; ts != s; ++ts) {
         if (ts->slot == Py_tp_traverse)
             has_traverse = true;
     }
 
     if (has_dynamic_attr) {
@@ -480,236 +799,52 @@
 
     if (has_traverse && (!base || (PyType_GetFlags((PyTypeObject *) base) &
                                    Py_TPFLAGS_HAVE_GC) == 0))
         spec.flags |= Py_TPFLAGS_HAVE_GC;
 
     *s++ = { 0, nullptr };
 
-    PyTypeObject *metaclass =  internals.nb_type;
+    PyTypeObject *metaclass =
+        nb_type_tp(internals, has_supplement ? t->supplement : 0);
 
-#if PY_VERSION_HEX >= 0x030C0000
-    // Life is good, PyType_FromMetaclass() is available
-    PyObject *result = PyType_FromMetaclass(metaclass, mod, &spec, base);
+    PyObject *result = nb_type_from_metaclass(metaclass, mod, &spec);
     if (!result) {
         python_error err;
-        fail("nanobind::detail::nb_type_new(\"%s\"): type construction failed: %s!", t->name, err.what());
-    }
-#else
-    /* The fallback code below is cursed. It provides an alternative when
-       PyType_FromMetaclass() is not available (i.e., on Python < 3.12). It
-       calls PyType_FromSpec() to create a tentative type, copies its contents
-       into a larger type with a different metaclass, then lets the original
-       type expire. This approach is incompatible with stable ABI builds. */
-
-    (void) mod;
-
-    PyObject *temp = PyType_FromSpec(&spec);
-    if (!temp) {
-        python_error err;
-        fail("nanobind::detail::nb_type_new(\"%s\"): type construction failed: %s!", t->name, err.what());
-    }
-
-    PyHeapTypeObject *temp_ht = (PyHeapTypeObject *) temp;
-    PyTypeObject *temp_tp = &temp_ht->ht_type;
-
-    Py_INCREF (temp_ht->ht_name);
-    Py_INCREF (temp_ht->ht_qualname);
-    Py_XINCREF(temp_ht->ht_slots);
-    Py_INCREF (temp_tp->tp_base);
-
-#if PY_VERSION_HEX >= 0x03090000
-    Py_XINCREF(temp_ht->ht_module);
-#endif
-
-    char *tp_doc = nullptr;
-    if (temp_tp->tp_doc) {
-        size_t size = strlen(temp_tp->tp_doc) + 1;
-        tp_doc = (char *) PyObject_Malloc(size);
-        memcpy(tp_doc, temp_tp->tp_doc, size);
-    }
-
-    const char *tp_name = PyUnicode_AsUTF8AndSize(temp_ht->ht_name, nullptr);
-
-    PyObject *result = PyType_GenericAlloc(metaclass, Py_SIZE(temp_tp));
-    if (!temp || !result)
-        fail("nanobind::detail::nb_type_new(\"%s\"): type construction failed!",
-             t->name);
-
-    PyHeapTypeObject *ht = (PyHeapTypeObject *) result;
-    PyTypeObject *tp = &ht->ht_type;
-
-    ht->ht_name = temp_ht->ht_name;
-    ht->ht_qualname = temp_ht->ht_qualname;
-    ht->ht_slots = temp_ht->ht_slots;
-
-#if PY_VERSION_HEX >= 0x03090000
-    ht->ht_module = temp_ht->ht_module;
-#endif
-
-    tp->tp_name = tp_name;
-    tp->tp_doc = tp_doc;
-    tp->tp_basicsize = temp_tp->tp_basicsize;
-    tp->tp_itemsize = temp_tp->tp_itemsize;
-    tp->tp_vectorcall_offset = temp_tp->tp_vectorcall_offset;
-    tp->tp_weaklistoffset = temp_tp->tp_weaklistoffset;
-    tp->tp_dictoffset = temp_tp->tp_dictoffset;
-    tp->tp_vectorcall = temp_tp->tp_vectorcall;
-    tp->tp_flags = spec.flags | Py_TPFLAGS_HEAPTYPE;
-
-    PyAsyncMethods    *am = tp->tp_as_async = &ht->as_async;
-    PyNumberMethods   *nb = tp->tp_as_number = &ht->as_number;
-    PySequenceMethods *sq = tp->tp_as_sequence = &ht->as_sequence;
-    PyMappingMethods  *mp = tp->tp_as_mapping = &ht->as_mapping;
-    PyBufferProcs     *bf = tp->tp_as_buffer = &ht->as_buffer;
-
-    #define CASE(tp, name) \
-        case Py_##tp##_##name: \
-            tp->tp##_##name = (decltype(tp->tp##_##name)) ts->pfunc; \
-            break;
-
-    for (PyType_Slot *ts = slots; ts != s; ++ts) {
-        switch (ts->slot) {
-            CASE(tp, dealloc)
-            CASE(tp, getattr)
-            CASE(tp, setattr)
-            CASE(tp, repr)
-            CASE(tp, hash)
-            CASE(tp, call)
-            CASE(tp, str)
-            CASE(tp, getattro)
-            CASE(tp, setattro)
-            CASE(tp, traverse)
-            CASE(tp, clear)
-            CASE(tp, richcompare)
-            CASE(tp, iter)
-            CASE(tp, iternext)
-            CASE(tp, methods)
-            CASE(tp, getset)
-            CASE(tp, base)
-            CASE(tp, descr_get)
-            CASE(tp, descr_set)
-            CASE(tp, init)
-            CASE(tp, alloc)
-            CASE(tp, new)
-            CASE(tp, free)
-            CASE(tp, is_gc)
-            CASE(tp, del)
-            CASE(tp, finalize)
-
-            #if PY_VERSION_HEX < 0x03090000
-            #  define Py_bf_getbuffer 1
-            #  define Py_bf_releasebuffer 2
-            #endif
-
-            CASE(bf, getbuffer)
-            CASE(bf, releasebuffer)
-
-            CASE(mp, ass_subscript)
-            CASE(mp, length)
-            CASE(mp, subscript)
-
-            CASE(nb, absolute)
-            CASE(nb, add)
-            CASE(nb, and)
-            CASE(nb, bool)
-            CASE(nb, divmod)
-            CASE(nb, float)
-            CASE(nb, floor_divide)
-            CASE(nb, index)
-            CASE(nb, inplace_add)
-            CASE(nb, inplace_and)
-            CASE(nb, inplace_floor_divide)
-            CASE(nb, inplace_lshift)
-            CASE(nb, inplace_multiply)
-            CASE(nb, inplace_or)
-            CASE(nb, inplace_power)
-            CASE(nb, inplace_remainder)
-            CASE(nb, inplace_rshift)
-            CASE(nb, inplace_subtract)
-            CASE(nb, inplace_true_divide)
-            CASE(nb, inplace_xor)
-            CASE(nb, int)
-            CASE(nb, invert)
-            CASE(nb, lshift)
-            CASE(nb, multiply)
-            CASE(nb, negative)
-            CASE(nb, or)
-            CASE(nb, positive)
-            CASE(nb, power)
-            CASE(nb, remainder)
-            CASE(nb, rshift)
-            CASE(nb, subtract)
-            CASE(nb, true_divide)
-            CASE(nb, xor)
-            CASE(nb, matrix_multiply)
-            CASE(nb, inplace_matrix_multiply)
-
-            CASE(sq, ass_item)
-            CASE(sq, concat)
-            CASE(sq, contains)
-            CASE(sq, inplace_concat)
-            CASE(sq, inplace_repeat)
-            CASE(sq, item)
-            CASE(sq, length)
-            CASE(sq, repeat)
-
-            CASE(am, await)
-            CASE(am, aiter)
-            CASE(am, anext)
-#if PY_VERSION_HEX >= 0x030A0000
-            CASE(am, send)
-#endif
-        }
+        check(false,
+              "nanobind::detail::nb_type_new(\"%s\"): type construction "
+              "failed: %s!", t->name, err.what());
     }
 
-    if (temp_tp->tp_members) {
-        tp->tp_members = (PyMemberDef*)((char *)tp + Py_TYPE(tp)->tp_basicsize);
-        std::memcpy(tp->tp_members, temp_tp->tp_members, tp->tp_itemsize * Py_SIZE(temp_tp));
-    }
-
-#if PY_VERSION_HEX < 0x03090000
-    if (has_dynamic_attr)
-        tp->tp_dictoffset = (Py_ssize_t) (basicsize - ptr_size);
-#endif
-
-    PyType_Ready(tp);
-    Py_DECREF(temp);
-#endif
-
     type_data *to = nb_type_data((PyTypeObject *) result);
-    *to = *t;
-
-    if (!has_scope)
-        to->flags &= ~(uint32_t) type_flags::has_scope;
+    *to = *t; // note: slices off _init parts
+    to->flags &= ~(uint32_t) type_init_flags::all_init_flags;
 
     if (!intrusive_ptr && tb &&
         (tb->flags & (uint32_t) type_flags::intrusive_ptr)) {
         to->flags |= (uint32_t) type_flags::intrusive_ptr;
         to->set_self_py = tb->set_self_py;
     }
 
+    if (!has_shared_from_this && tb &&
+        (tb->flags & (uint32_t) type_flags::has_shared_from_this)) {
+        to->flags |= (uint32_t) type_flags::has_shared_from_this;
+        to->keep_shared_from_this_alive = tb->keep_shared_from_this_alive;
+    }
+
     to->name = name_copy;
     to->type_py = (PyTypeObject *) result;
 
-    if (has_supplement) {
-        if (!to->supplement)
-            fail("nanobind::detail::nb_type_new(\"%s\"): supplemental data "
-                 "allocation failed!", t->name);
-    } else {
-        to->supplement = nullptr;
-    }
-
     if (has_dynamic_attr) {
         to->flags |= (uint32_t) type_flags::has_dynamic_attr;
         #if defined(Py_LIMITED_API)
             to->dictoffset = (size_t) (basicsize - ptr_size);
         #endif
     }
 
-    if (has_scope)
+    if (t->scope != nullptr)
         setattr(t->scope, t->name, result);
 
     setattr(result, "__qualname__", qualname.ptr());
 
     if (modname.is_valid())
         setattr(result, "__module__", modname.ptr());
 
@@ -818,16 +953,15 @@
         *out = nullptr;
         return true;
     }
 
     nb_internals &internals = internals_get();
     PyTypeObject *src_type = Py_TYPE(src);
     const std::type_info *cpp_type_src = nullptr;
-    const PyTypeObject *metaclass = Py_TYPE((PyObject *) src_type);
-    const bool src_is_nb_type = metaclass == internals.nb_type;
+    const bool src_is_nb_type = nb_type_check((PyObject *) src_type);
 
     type_data *dst_type = nullptr;
 
     // If 'src' is a nanobind-bound type
     if (src_is_nb_type) {
         type_data *t = nb_type_data(src_type);
         cpp_type_src = t->type;
@@ -872,89 +1006,96 @@
         }
 
         if (dst_type &&
             (dst_type->flags & (uint32_t) type_flags::has_implicit_conversions))
             return nb_type_get_implicit(src, cpp_type_src, dst_type, internals,
                                         cleanup, out);
     }
+
     return false;
 }
 
 static PyObject *keep_alive_callback(PyObject *self, PyObject *const *args,
                                      Py_ssize_t nargs) {
-    if (nargs != 1 || !PyWeakref_CheckRefExact(args[0]))
-        fail("nanobind::detail::keep_alive_callback(): invalid input!");
+    check(nargs == 1 && PyWeakref_CheckRefExact(args[0]),
+          "nanobind::detail::keep_alive_callback(): invalid input!");
     Py_DECREF(args[0]); // self
     Py_DECREF(self); // patient
     Py_INCREF(Py_None);
     return Py_None;
 }
 
 static PyMethodDef keep_alive_callback_def = {
-    "keep_alive_callback",
-    (PyCFunction) (void *) keep_alive_callback,
-    METH_FASTCALL,
-    "Implementation detail of nanobind::detail::keep_alive"
+    "keep_alive_callback", (PyCFunction) (void *) keep_alive_callback,
+    METH_FASTCALL, nullptr
 };
 
-
 void keep_alive(PyObject *nurse, PyObject *patient) {
     if (!patient || !nurse || nurse == Py_None || patient == Py_None)
         return;
 
-    nb_internals &internals = internals_get();
-    PyTypeObject *metaclass = Py_TYPE((PyObject *) Py_TYPE(nurse));
+    if (nb_type_check((PyObject *) Py_TYPE(nurse))) {
+        nb_weakref_seq **pp =
+            (nb_weakref_seq **) &internals_get().keep_alive[nurse];
 
-    if (metaclass == internals.nb_type) {
-        // Populate nanobind-internal data structures
-        keep_alive_set &keep_alive = internals.keep_alive[nurse];
-
-        auto [it, success] = keep_alive.emplace(patient);
-        if (success) {
-            Py_INCREF(patient);
-            ((nb_inst *) nurse)->clear_keep_alive = true;
-        } else {
-            if (it->deleter)
-                fail("nanobind::detail::keep_alive(): internal error: entry "
-                     "has a deletion callback!");
-        }
+        do {
+            nb_weakref_seq *p = *pp;
+            if (!p)
+                break;
+            else if (p->payload == patient && !p->callback)
+                return;
+            pp = &p->next;
+        } while (true);
+
+        nb_weakref_seq *s =
+            (nb_weakref_seq *) PyObject_Malloc(sizeof(nb_weakref_seq));
+        check(s, "nanobind::detail::keep_alive(): out of memory!");
+
+        s->payload = patient;
+        s->callback = nullptr;
+        s->next = nullptr;
+        *pp = s;
+
+        Py_INCREF(patient);
+        ((nb_inst *) nurse)->clear_keep_alive = true;
     } else {
         PyObject *callback =
             PyCFunction_New(&keep_alive_callback_def, patient);
         PyObject *weakref = PyWeakref_NewRef(nurse, callback);
         if (!weakref) {
             Py_DECREF(callback);
             PyErr_Clear();
             raise("nanobind::detail::keep_alive(): could not create a weak "
                   "reference! Likely, the 'nurse' argument you specified is not "
                   "a weak-referenceable type!");
         }
-        if (!callback)
-            fail("nanobind::detail::keep_alive(): callback creation failed!");
+        check(callback,
+              "nanobind::detail::keep_alive(): callback creation failed!");
 
         // Increase patient reference count, leak weak reference
         Py_INCREF(patient);
         Py_DECREF(callback);
     }
 }
 
 void keep_alive(PyObject *nurse, void *payload,
                 void (*callback)(void *) noexcept) noexcept {
-    if (!nurse)
-        fail("nanobind::detail::keep_alive(): nurse==nullptr!");
+    check(nurse, "nanobind::detail::keep_alive(): 'nurse' is undefined!");
 
-    PyTypeObject *metaclass = Py_TYPE((PyObject *) Py_TYPE(nurse));
-
-    nb_internals &internals = internals_get();
+    if (nb_type_check((PyObject *) Py_TYPE(nurse))) {
+        nb_weakref_seq
+            **pp = (nb_weakref_seq **) &internals_get().keep_alive[nurse],
+            *s   = (nb_weakref_seq *) PyObject_Malloc(sizeof(nb_weakref_seq));
+        check(s, "nanobind::detail::keep_alive(): out of memory!");
+
+        s->payload = payload;
+        s->callback = callback;
+        s->next = *pp;
+        *pp = s;
 
-    if (metaclass == internals.nb_type) {
-        keep_alive_set &keep_alive = internals.keep_alive[nurse];
-        auto [it, success] = keep_alive.emplace(payload, callback);
-        if (!success)
-            raise("keep_alive(): the given 'payload' pointer was already registered!");
         ((nb_inst *) nurse)->clear_keep_alive = true;
     } else {
         PyObject *patient = capsule_new(payload, nullptr, callback);
         keep_alive(nurse, patient);
         Py_DECREF(patient);
     }
 }
@@ -973,17 +1114,14 @@
     const bool store_in_obj = rvp == rv_policy::copy || rvp == rv_policy::move;
 
     nb_inst *inst =
         (nb_inst *) inst_new_impl(t->type_py, store_in_obj ? nullptr : value);
     if (!inst)
         return nullptr;
 
-    if (is_new)
-        *is_new = true;
-
     void *new_value = inst_ptr(inst);
     if (rvp == rv_policy::move) {
         if (t->flags & (uint32_t) type_flags::is_move_constructible) {
             if (t->flags & (uint32_t) type_flags::has_move) {
                 try {
                     t->move(new_value, value);
                 } catch (...) {
@@ -991,42 +1129,52 @@
                     return nullptr;
                 }
             } else {
                 memcpy(new_value, value, t->size);
                 memset(value, 0, t->size);
             }
         } else {
-            if (t->flags & (uint32_t) type_flags::is_copy_constructible) {
-                rvp = rv_policy::copy;
-            } else {
-                fail("nanobind::detail::nb_type_put(\"%s\"): attempted to move "
-                     "an instance that is neither copy- nor move-constructible!",
-                     t->name);
-            }
+            check(t->flags & (uint32_t) type_flags::is_copy_constructible,
+                  "nanobind::detail::nb_type_put(\"%s\"): attempted to move "
+                  "an instance that is neither copy- nor move-constructible!",
+                  t->name);
+
+            rvp = rv_policy::copy;
         }
     }
 
     if (rvp == rv_policy::copy) {
-        if (t->flags & (uint32_t) type_flags::is_copy_constructible) {
-            if (t->flags & (uint32_t) type_flags::has_copy) {
-                try {
-                    t->copy(new_value, value);
-                } catch (...) {
-                    Py_DECREF(inst);
-                    return nullptr;
-                }
-            } else {
-                memcpy(new_value, value, t->size);
+        check(t->flags & (uint32_t) type_flags::is_copy_constructible,
+              "nanobind::detail::nb_type_put(\"%s\"): attempted to copy "
+              "an instance that is not copy-constructible!", t->name);
+
+        if (t->flags & (uint32_t) type_flags::has_copy) {
+            try {
+                t->copy(new_value, value);
+            } catch (...) {
+                Py_DECREF(inst);
+                return nullptr;
             }
         } else {
-            fail("nanobind::detail::nb_type_put(\"%s\"): attempted to copy "
-                 "an instance that is not copy-constructible!", t->name);
+            memcpy(new_value, value, t->size);
         }
     }
 
+    // If we can find an existing C++ shared_ptr for this object, and
+    // the instance we're creating just holds a pointer, then take out
+    // another C++ shared_ptr that shares ownership with the existing
+    // one, and tie its lifetime to the Python object. This is the
+    // same thing done by the <nanobind/stl/shared_ptr.h> caster when
+    // returning shared_ptr<T> to Python explicitly.
+    if ((t->flags & (uint32_t) type_flags::has_shared_from_this) &&
+        !store_in_obj && t->keep_shared_from_this_alive((PyObject *) inst))
+        rvp = rv_policy::reference;
+    else if (is_new)
+        *is_new = true;
+
     inst->destruct = rvp != rv_policy::reference && rvp != rv_policy::reference_internal;
     inst->cpp_delete = rvp == rv_policy::take_ownership;
     inst->ready = true;
 
     if (rvp == rv_policy::reference_internal)
         keep_alive((PyObject *) inst, cleanup->self());
 
@@ -1043,15 +1191,15 @@
     // Convert nullptr -> None
     if (!value) {
         Py_INCREF(Py_None);
         return Py_None;
     }
 
     nb_internals &internals = internals_get();
-    nb_inst_map &map = internals.inst_c2p;
+    nb_ptr_map &inst_c2p = internals.inst_c2p;
     nb_type_map &type_map = internals.type_c2p;
     type_data *td = nullptr;
 
     auto lookup_type = [cpp_type, &td, &type_map]() -> bool {
         if (!td) {
             nb_type_map::iterator it =
                 type_map.find(std::type_index(*cpp_type));
@@ -1063,37 +1211,47 @@
         }
 
         return true;
     };
 
     if (rvp != rv_policy::copy) {
         // Check if the instance is already registered with nanobind
-        nb_inst_map::iterator it = map.find(value);
+        nb_ptr_map::iterator it = inst_c2p.find(value);
 
-        if (it != map.end()) {
-            const nb_inst_seq *seq = &it->second;
+        if (it != inst_c2p.end()) {
+            void *entry = it->second;
+            nb_inst_seq seq;
 
-            while (seq) {
-                PyObject *inst = (PyObject *) seq->inst;
-                PyTypeObject *tp = Py_TYPE(inst);
+            if (NB_UNLIKELY(nb_is_seq(entry))) {
+                seq = *nb_get_seq(entry);
+            } else {
+                seq.inst = (PyObject *) entry;
+                seq.next = nullptr;
+            }
+
+            while (true) {
+                PyTypeObject *tp = Py_TYPE(seq.inst);
 
                 if (nb_type_data(tp)->type == cpp_type) {
-                    Py_INCREF(inst);
-                    return inst;
+                    Py_INCREF(seq.inst);
+                    return seq.inst;
                 }
 
                 if (!lookup_type())
                     return nullptr;
 
                 if (PyType_IsSubtype(tp, td->type_py)) {
-                    Py_INCREF(inst);
-                    return inst;
+                    Py_INCREF(seq.inst);
+                    return seq.inst;
                 }
 
-                seq = seq->next;
+                if (seq.next == nullptr)
+                    break;
+
+                seq = *seq.next;
             }
         } else if (rvp == rv_policy::none) {
             return nullptr;
         }
     }
 
     // Look up the corresponding Python type if not already done
@@ -1104,25 +1262,23 @@
 }
 
 PyObject *nb_type_put_p(const std::type_info *cpp_type,
                         const std::type_info *cpp_type_p,
                         void *value, rv_policy rvp,
                         cleanup_list *cleanup,
                         bool *is_new) noexcept {
-    using Key = std::pair<void *, PyTypeObject *>;
-
     // Convert nullptr -> None
     if (!value) {
         Py_INCREF(Py_None);
         return Py_None;
     }
 
     // Check if the instance is already registered with nanobind
     nb_internals &internals = internals_get();
-    nb_inst_map &map = internals.inst_c2p;
+    nb_ptr_map &inst_c2p = internals.inst_c2p;
     nb_type_map &type_map = internals.type_c2p;
 
     // Look up the corresponding Python type
     type_data *td = nullptr,
               *td_p = nullptr;
 
     auto lookup_type = [cpp_type, cpp_type_p, &td, &td_p, &type_map]() -> bool {
@@ -1144,38 +1300,50 @@
         }
 
         return true;
     };
 
     if (rvp != rv_policy::copy) {
         // Check if the instance is already registered with nanobind
-        nb_inst_map::iterator it = map.find(value);
+        nb_ptr_map::iterator it = inst_c2p.find(value);
+
+        if (it != inst_c2p.end()) {
+            void *entry = it->second;
+            nb_inst_seq seq;
+
+            if (NB_UNLIKELY(nb_is_seq(entry))) {
+                seq = *nb_get_seq(entry);
+            } else {
+                seq.inst = (PyObject *) entry;
+                seq.next = nullptr;
+            }
+
+            while (true) {
+                PyTypeObject *tp = Py_TYPE(seq.inst);
 
-        if (it != map.end()) {
-            const nb_inst_seq *seq = &it->second;
-            while (seq) {
-                PyObject *inst = (PyObject *) seq->inst;
-                PyTypeObject *tp = Py_TYPE(inst);
                 const std::type_info *p = nb_type_data(tp)->type;
 
                 if (p == cpp_type || p == cpp_type_p) {
-                    Py_INCREF(inst);
-                    return inst;
+                    Py_INCREF(seq.inst);
+                    return seq.inst;
                 }
 
                 if (!lookup_type())
                     return nullptr;
 
                 if (PyType_IsSubtype(tp, td->type_py) ||
                     (td_p && PyType_IsSubtype(tp, td_p->type_py))) {
-                    Py_INCREF(inst);
-                    return inst;
+                    Py_INCREF(seq.inst);
+                    return seq.inst;
                 }
 
-                seq = seq->next;
+                if (seq.next == nullptr)
+                    break;
+
+                seq = *seq.next;
             }
         } else if (rvp == rv_policy::none) {
             return nullptr;
         }
     }
 
     // Look up the corresponding Python type if not already done
@@ -1184,35 +1352,36 @@
 
     return nb_type_put_common(value, td_p ? td_p : td, rvp, cleanup, is_new);
 }
 
 static void nb_type_put_unique_finalize(PyObject *o,
                                         const std::type_info *cpp_type,
                                         bool cpp_delete, bool is_new) {
-    if (!cpp_delete && is_new)
-        fail("nanobind::detail::nb_type_put_unique(type='%s', cpp_delete=%i): "
-             "ownership status has become corrupted.",
-             type_name(cpp_type), cpp_delete);
+    (void) cpp_type;
+    check(cpp_delete || !is_new,
+          "nanobind::detail::nb_type_put_unique(type='%s', cpp_delete=%i): "
+          "ownership status has become corrupted.",
+          type_name(cpp_type), cpp_delete);
 
     nb_inst *inst = (nb_inst *) o;
 
     if (cpp_delete) {
-        if (inst->ready != is_new || inst->destruct != is_new ||
-            inst->cpp_delete != is_new)
-            fail("nanobind::detail::nb_type_put_unique(type='%s', "
-                 "cpp_delete=%i): unexpected status flags! (ready=%i, "
-                 "destruct=%i, cpp_delete=%i)",
-                 type_name(cpp_type), cpp_delete, inst->ready,
-                 inst->destruct, inst->cpp_delete);
+        check(inst->ready == is_new && inst->destruct == is_new &&
+                  inst->cpp_delete == is_new,
+              "nanobind::detail::nb_type_put_unique(type='%s', cpp_delete=%i): "
+              "unexpected status flags! (ready=%i, destruct=%i, cpp_delete=%i)",
+              type_name(cpp_type), cpp_delete, inst->ready, inst->destruct,
+              inst->cpp_delete);
 
         inst->ready = inst->destruct = inst->cpp_delete = true;
     } else {
-        if (inst->ready)
-            fail("nanobind::detail::nb_type_put_unique('%s'): ownership "
-                 "status has become corrupted.", type_name(cpp_type));
+        check(!inst->ready,
+                  "nanobind::detail::nb_type_put_unique('%s'): ownership "
+                  "status has become corrupted.", type_name(cpp_type));
+
         inst->ready = true;
     }
 }
 
 PyObject *nb_type_put_unique(const std::type_info *cpp_type,
                              void *value,
                              cleanup_list *cleanup, bool cpp_delete) noexcept {
@@ -1243,18 +1412,18 @@
     return o;
 }
 
 void nb_type_relinquish_ownership(PyObject *o, bool cpp_delete) {
     nb_inst *inst = (nb_inst *) o;
 
     // This function is called to indicate ownership *changes*
-    if (!inst->ready)
-        fail("nanobind::detail::nb_relinquish_ownership('%s'): ownership "
-             "status has become corrupted.",
-             PyUnicode_AsUTF8AndSize(nb_inst_name(o), nullptr));
+    check(inst->ready,
+          "nanobind::detail::nb_relinquish_ownership('%s'): ownership "
+          "status has become corrupted.",
+          PyUnicode_AsUTF8AndSize(nb_inst_name(o), nullptr));
 
     if (cpp_delete) {
         if (!inst->cpp_delete || !inst->destruct || inst->internal) {
             PyObject *name = nb_inst_name(o);
             PyErr_WarnFormat(
                 PyExc_RuntimeWarning, 1,
                 "nanobind::detail::nb_relinquish_ownership(): could not "
@@ -1262,53 +1431,24 @@
                 "This is only possible when the instance was previously "
                 "constructed on the C++ side and is now owned by Python, which "
                 "was not the case here. You could change the unique pointer "
                 "signature to std::unique_ptr<T, nb::deleter<T>> to work around "
                 "this issue.", name);
 
             Py_DECREF(name);
-            raise_next_overload();
+            throw next_overload();
         }
 
         inst->cpp_delete = false;
         inst->destruct = false;
     }
 
     inst->ready = false;
 }
 
-/// Special case to handle 'Class.property = value' assignments
-int nb_type_setattro(PyObject* obj, PyObject* name, PyObject* value) {
-    nb_internals &internals = internals_get();
-
-    internals.nb_static_property_enabled = false;
-    PyObject *cur = PyObject_GetAttr(obj, name);
-    internals.nb_static_property_enabled = true;
-
-    if (cur) {
-        if (Py_TYPE(cur) == internals.nb_static_property) {
-            int rv = nb_static_property_set(cur, obj, value);
-            Py_DECREF(cur);
-            return rv;
-        }
-        Py_DECREF(cur);
-    } else {
-        PyErr_Clear();
-    }
-
-    #if defined(Py_LIMITED_API)
-        static setattrofunc tp_setattro =
-            (setattrofunc) PyType_GetSlot(&PyType_Type, Py_tp_setattro);
-    #else
-        setattrofunc tp_setattro = PyType_Type.tp_setattro;
-    #endif
-
-    return tp_setattro(obj, name, value);
-}
-
 bool nb_type_isinstance(PyObject *o, const std::type_info *t) noexcept {
     nb_internals &internals = internals_get();
     auto it = internals.type_c2p.find(std::type_index(*t));
     if (it == internals.type_c2p.end())
         return false;
     return PyType_IsSubtype(Py_TYPE(o), it->second->type_py);
 }
@@ -1317,19 +1457,24 @@
     nb_internals &internals = internals_get();
     auto it = internals.type_c2p.find(std::type_index(*t));
     if (it != internals.type_c2p.end())
         return (PyObject *) it->second->type_py;
     return nullptr;
 }
 
+static PyTypeObject *nb_meta_cache = nullptr;
+
 bool nb_type_check(PyObject *t) noexcept {
-    nb_internals &internals = internals_get();
-    PyTypeObject *metaclass = Py_TYPE(t);
+    if (NB_UNLIKELY(!nb_meta_cache))
+        nb_meta_cache = internals_get().nb_meta;
+
+    PyTypeObject *meta  = Py_TYPE(t),
+                 *meta2 = Py_TYPE((PyObject *) meta);
 
-    return metaclass == internals.nb_type;
+    return meta2 == nb_meta_cache;
 }
 
 size_t nb_type_size(PyObject *t) noexcept {
     return nb_type_data((PyTypeObject *) t)->size;
 }
 
 size_t nb_type_align(PyObject *t) noexcept {
@@ -1337,15 +1482,15 @@
 }
 
 const std::type_info *nb_type_info(PyObject *t) noexcept {
     return nb_type_data((PyTypeObject *) t)->type;
 }
 
 void *nb_type_supplement(PyObject *t) noexcept {
-    return nb_type_data((PyTypeObject *) t)->supplement;
+    return nb_type_data((PyTypeObject *) t) + 1;
 }
 
 PyObject *nb_inst_alloc(PyTypeObject *t) {
     PyObject *result = inst_new_impl(t, nullptr);
     if (!result)
         raise_python_error();
     return result;
@@ -1382,34 +1527,33 @@
 }
 
 void nb_inst_destruct(PyObject *o) noexcept {
     nb_inst *nbi = (nb_inst *) o;
     type_data *t = nb_type_data(Py_TYPE(o));
 
     if (nbi->destruct) {
-        if (t->flags & (uint32_t) type_flags::is_destructible) {
-            if (t->flags & (uint32_t) type_flags::has_destruct)
-                t->destruct(inst_ptr(nbi));
-        } else {
-            fail("nanobind::detail::nb_inst_destruct(\"%s\"): attempted to call "
-                 "the destructor of a non-destructible type!", t->name);
-        }
+        check(t->flags & (uint32_t) type_flags::is_destructible,
+              "nanobind::detail::nb_inst_destruct(\"%s\"): attempted to call "
+              "the destructor of a non-destructible type!",
+              t->name);
+        if (t->flags & (uint32_t) type_flags::has_destruct)
+            t->destruct(inst_ptr(nbi));
         nbi->destruct = false;
     }
 
     nbi->ready = false;
 }
 
 void nb_inst_copy(PyObject *dst, const PyObject *src) noexcept {
     PyTypeObject *tp = Py_TYPE((PyObject *) src);
     type_data *t = nb_type_data(tp);
 
-    if (tp != Py_TYPE(dst) ||
-        (t->flags & (uint32_t) type_flags::is_copy_constructible) == 0)
-        fail("nanobind::detail::nb_inst_copy(): invalid arguments!");
+    check(tp == Py_TYPE(dst) &&
+              (t->flags & (uint32_t) type_flags::is_copy_constructible),
+          "nanobind::detail::nb_inst_copy(): invalid arguments!");
 
     nb_inst *nbi = (nb_inst *) dst;
     const void *src_data = inst_ptr((nb_inst *) src);
     void *dst_data = inst_ptr(nbi);
 
     if (t->flags & (uint32_t) type_flags::has_copy)
         t->copy(dst_data, src_data);
@@ -1419,17 +1563,17 @@
     nbi->ready = nbi->destruct = true;
 }
 
 void nb_inst_move(PyObject *dst, const PyObject *src) noexcept {
     PyTypeObject *tp = Py_TYPE((PyObject *) src);
     type_data *t = nb_type_data(tp);
 
-    if (tp != Py_TYPE(dst) ||
-        (t->flags & (uint32_t) type_flags::is_move_constructible) == 0)
-        fail("nanobind::detail::nb_inst_move(): invalid arguments!");
+    check(tp == Py_TYPE(dst) &&
+              (t->flags & (uint32_t) type_flags::is_move_constructible),
+          "nanobind::detail::nb_inst_move(): invalid arguments!");
 
     nb_inst *nbi = (nb_inst *) dst;
     void *src_data = inst_ptr((nb_inst *) src);
     void *dst_data = inst_ptr(nbi);
 
     if (t->flags & (uint32_t) type_flags::has_move) {
         t->move(dst_data, src_data);
@@ -1438,19 +1582,16 @@
         memset(src_data, 0, t->size);
     }
 
     nbi->ready = nbi->destruct = true;
 }
 
 #if defined(Py_LIMITED_API)
-static size_t type_basicsize = 0;
 type_data *nb_type_data_static(PyTypeObject *o) noexcept {
-    if (type_basicsize == 0)
-        type_basicsize = cast<size_t>(handle(&PyType_Type).attr("__basicsize__"));
-    return (type_data *) (((char *) o) + type_basicsize);
+    return (type_data *) PyObject_GetTypeData((PyObject *) o, Py_TYPE((PyObject *) o));
 }
 #endif
 
 /// Fetch the name of an instance as 'char *' (must be deallocated using 'free'!)
 PyObject *nb_type_name(PyTypeObject *tp) noexcept {
     PyObject *name = PyObject_GetAttrString((PyObject *) tp, "__name__");
 
@@ -1462,10 +1603,14 @@
         Py_DECREF(name);
         name = combined;
     }
 
     return name;
 }
 
+bool nb_inst_python_derived(PyObject *o) noexcept {
+    return nb_type_data(Py_TYPE(o))->flags &
+           (uint32_t) type_flags::is_python_type;
+}
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/src/trampoline.cpp

```diff
@@ -11,36 +11,40 @@
 #include "nb_internals.h"
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 void trampoline_new(void **data, size_t size, void *ptr) noexcept {
     // GIL is held when the trampoline constructor runs
-    nb_inst_map &inst_c2p = internals_get().inst_c2p;
-    nb_inst_map::iterator it = inst_c2p.find(ptr);
-    if (it == inst_c2p.end() || it->second.next)
-        fail("nanobind::detail::trampoline_new(): unique instance not found!");
+    nb_ptr_map &inst_c2p = internals_get().inst_c2p;
+    nb_ptr_map::iterator it = inst_c2p.find(ptr);
+    check(it != inst_c2p.end() && (((uintptr_t) it->second) & 1) == 0,
+          "nanobind::detail::trampoline_new(): unique instance not found!");
 
-    data[0] = it->second.inst;
+    data[0] = it->second;
     memset(data + 1, 0, sizeof(void *) * 2 * size);
 }
 
 void trampoline_release(void **data, size_t size) noexcept {
     // GIL is held when the trampoline destructor runs
     for (size_t i = 0; i < size; ++i)
         Py_XDECREF((PyObject *) data[i*2 + 2]);
 }
 
 PyObject *trampoline_lookup(void **data, size_t size, const char *name,
                             bool pure) {
     const PyObject *None = Py_None;
 
     current_method cm = current_method_data;
-    if (cm.self == data[0] && (cm.name == name || strcmp(cm.name, name) == 0))
+    if (cm.self == data[0] && (cm.name == name || strcmp(cm.name, name) == 0)) {
+        if (pure)
+            raise("nanobind::detail::get_trampoline('%s()'): tried to call a "
+                  "pure virtual function!", name);
         return nullptr;
+    }
 
     // First quick sweep without lock
     for (size_t i = 0; i < size; i++) {
         void *d_name  = data[2*i + 1],
              *d_value = data[2*i + 2];
         if (name == d_name && d_value)
             return d_value != None ? (PyObject *) d_value : nullptr;
```

## Comparing `nanobind-1.2.0.dist-info/LICENSE` & `nanobind-1.3.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `nanobind-1.2.0.dist-info/METADATA` & `nanobind-1.3.0.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,15 @@
 Metadata-Version: 2.1
 Name: nanobind
-Version: 1.2.0
+Version: 1.3.0
 Summary: nanobind: tiny and efficient C++/Python bindings
 Home-page: https://github.com/wjakob/nanobind
 Author: Wenzel Jakob
 Author-email: wenzel.jakob@epfl.ch
 License: BSD
-Platform: UNKNOWN
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 
 ![nanobind logo](
 https://github.com/wjakob/nanobind/raw/master/docs/images/logo.jpg?raw=True)
 
@@ -28,9 +27,7 @@
 runtime overheads compared to pybind11. nanobind also outperforms Cython in
 important metrics (**3-12×** binary size reduction, **1.6-4×** compilation time
 reduction, similar runtime performance).
 
 Please see the following links for tutorial and reference documentation in
 [HTML](https://nanobind.readthedocs.io/en/latest/) and
 [PDF](https://nanobind.readthedocs.io/_/downloads/en/latest/pdf/) formats.
-
-
```

## Comparing `nanobind-1.2.0.dist-info/RECORD` & `nanobind-1.3.0.dist-info/RECORD`

 * *Files 25% similar despite different names*

```diff
@@ -1,72 +1,75 @@
-nanobind/__init__.py,sha256=BfWmYNuAbvagMWq0QeU_R-u537oxkXAPJsYxD3loVu8,536
+nanobind/__init__.py,sha256=ovwkTZ6NeONDA5DVNEZSTiLk7jzOr3QFfQYXmyHFuH8,536
 nanobind/__main__.py,sha256=pOZfAi6HXCHLnzBZ0Ax1jJ-PbFDYJ-XP51yG5AgTmjA,839
-nanobind/cmake/darwin-ld-cpython.sym,sha256=qi-ZCmrzmvlN6QdhfUmQLQAyVaAg7dhH-DTSpGWhvoQ,21432
+nanobind/cmake/darwin-ld-cpython.sym,sha256=BlvfYcn-_krnQQZ_qF0APuKtsZke8jzoymkpxAK7hF0,21457
 nanobind/cmake/darwin-ld-pypy.sym,sha256=QF3OnNiEZfCskhbCig1FaaNF3DfkjDzLTMcP94o1_uE,24563
-nanobind/cmake/nanobind-config.cmake,sha256=sqWcyrMVyu6Efelrbe0wQDLrVXR9-o5s6NzE7Omz2rs,10363
+nanobind/cmake/nanobind-config.cmake,sha256=fj6JRpm_qoKY8x_s8meGFuxHDXteJ3uYz2XQGCziVTg,10316
 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h,sha256=LJaMwboQYidGGoaldoAplZDcslLeT5sP6L8lZghVaDU,11776
 nanobind/ext/robin_map/include/tsl/robin_hash.h,sha256=9jsUsbV085jb736e5Z6MJIYUSvrwBpLYmagPsOTiglc,54550
 nanobind/ext/robin_map/include/tsl/robin_map.h,sha256=WQiZfe4hA3mzQLlJXDZQax0rWjctSnyJnB9jJJgeC6Y,28414
 nanobind/ext/robin_map/include/tsl/robin_set.h,sha256=m5o-74heDBBcvGNsGME8_Y4wiLMO8Ax8t70urBH6srk,23593
 nanobind/include/nanobind/make_iterator.h,sha256=WKcEOQc_L_Mhhk1GgwwvsysUTbSgiBCmDnm0X7K330o,5601
-nanobind/include/nanobind/nanobind.h,sha256=gxmjG9gLJGLiCiiu2L_c_IKzbMIWeepQrGXYSfJAdsI,1628
+nanobind/include/nanobind/nanobind.h,sha256=3p0Z9Shtith7Ijrn5AeZAfdc3r7AvjVkoOfVhe-m3DA,1628
 nanobind/include/nanobind/nb_accessor.h,sha256=27K0E4cJYSBtD5VVsBtrLCWZTnTXXdr0IwtqLHeQ0aQ,5626
-nanobind/include/nanobind/nb_attr.h,sha256=REBdouY7U8ZHif3rTWv8Ar73RarjMeXSev-w5JHR3QU,7173
-nanobind/include/nanobind/nb_call.h,sha256=nNDUBNN8bbTgMUYRry_I7SR8deNHs2P1T7pPemCFK9k,5325
-nanobind/include/nanobind/nb_cast.h,sha256=5LDpGd1mF6eR9eIEaltD1r-JoR83_eByemvkTdB0E2Q,13975
-nanobind/include/nanobind/nb_class.h,sha256=PUGiWi58P4Dz4G2EO3wqORF_GwJ9M9_-rE4jYQLMSj8,19205
-nanobind/include/nanobind/nb_defs.h,sha256=3oQ6zkZwCO6VVDqjeh6l_77U2rkEDdhGMeGctUdNOzQ,5507
+nanobind/include/nanobind/nb_attr.h,sha256=FX-g3VwLt0DXn7D2YJSixGRPRsUFBgd1fw_OwD0VLW4,7387
+nanobind/include/nanobind/nb_call.h,sha256=kbJ6BL617m44XrkIY7kajFwBw59xcI8KGzGlgGDu0Bc,5533
+nanobind/include/nanobind/nb_cast.h,sha256=MYgPCQ_8wodwYLalnmklaNjnkJZYogL-o3p2BvEOjNI,14781
+nanobind/include/nanobind/nb_class.h,sha256=laD3sNLYkQ01d0_LI6u_XMTS31QOWVhgBDFpVDQ0whk,23845
+nanobind/include/nanobind/nb_defs.h,sha256=gK0JvSYf5qWm8joL4j04DphZTTtcFQk4mjZdfgOSUdE,5558
 nanobind/include/nanobind/nb_descr.h,sha256=tX2-_5kHTuIe62iGi0sqn-QehGNYGjcL32OmeWoYY2g,4129
 nanobind/include/nanobind/nb_enums.h,sha256=JSxGC4c2YyN83gmcTVV450KLJX_RTRPAHRPUhxuAvds,666
-nanobind/include/nanobind/nb_error.h,sha256=Z8rGRtW9D7FjIOeS0G_tXYN5zN1LAvZNvVQ5O3r2FBs,3526
-nanobind/include/nanobind/nb_func.h,sha256=QMxiOQf6LnI5hDcrHa5r-KEkXLfbEJ-n64xmL1Y98Rk,9751
-nanobind/include/nanobind/nb_lib.h,sha256=g5Biz2O7Gf9MZ0da87OoHmpn8WPLi0PRrHHU2hfTIeY,18304
+nanobind/include/nanobind/nb_error.h,sha256=Akrj5ojzXHFA_EMXAHRhgfEWxINFkMEWzionhR7Rt3k,4168
+nanobind/include/nanobind/nb_func.h,sha256=fihjY5ofALSSyFul1XtRkXgfuPqMnAFr05FSjYZS9gQ,9769
+nanobind/include/nanobind/nb_lib.h,sha256=RvvqGKzRldZwG0mDJ7ZJNbsnAbO-88Q2lrlqD_JeQbw,18829
 nanobind/include/nanobind/nb_misc.h,sha256=D9NdER_kwi7qHGgYtKTsjPKHIkZqcGpqG9wT9XMtT74,1167
 nanobind/include/nanobind/nb_python.h,sha256=tuHjb9Dd4X5MOILJdgOFN_7RBIAAq3Y1bL_-POIRqKU,1377
-nanobind/include/nanobind/nb_traits.h,sha256=eJNLIHHx_1PMYHJwxsbf_QaM_1fGb3vsj1OES-7hCb8,6280
+nanobind/include/nanobind/nb_traits.h,sha256=NJAmlqi9G5fYtx2HiT0d9mcJpxsZPxDSfYFLvxemc20,6653
 nanobind/include/nanobind/nb_tuple.h,sha256=aqqTm9DkjH_SvDuPLKjU3Ya1lgs_LWyaQMkhTQRZoIc,2468
-nanobind/include/nanobind/nb_types.h,sha256=xxXX5X9XsMbNNcagEOC_6lFi78qpN26G3YH4R9L5bq4,25089
-nanobind/include/nanobind/ndarray.h,sha256=pUyfae5pWFHzdpw_VJo4DCYED5sehEYx0W-PgVXfSq4,12285
+nanobind/include/nanobind/nb_types.h,sha256=UKTEgkInNZS_bf4hEHf6UFPSxNGPg00-E0wwkdrON-8,25243
+nanobind/include/nanobind/ndarray.h,sha256=tZxkzVtWRCGHdjNQYijwBgGwDPFLs8mIp3AaQSdci-k,13478
 nanobind/include/nanobind/operators.h,sha256=jSHKzNE_NDc--E65ycUsU6b0x1O_ThpzzCMV4uv5IE4,7449
-nanobind/include/nanobind/trampoline.h,sha256=Dx2NVfwiMkiqZ_zMxodWTkBQwmTrXAj599dueIIkCYY,3013
-nanobind/include/nanobind/eigen/dense.h,sha256=XXvpoh1sszCq6x_hxpVnhP11UwDNOvTiHx0YDBgxqZo,8411
+nanobind/include/nanobind/trampoline.h,sha256=w10Sw8RLAgjwvYPxjwuD14TWZ4jUN3RLP9rJCGIKgDE,2851
+nanobind/include/nanobind/eigen/dense.h,sha256=RfR8NHzMvkEfr7UxAwFukxLo1BwKz8IScZQekSYkj5E,8579
 nanobind/include/nanobind/eigen/sparse.h,sha256=M1y9wF0AqVaIXXywzQVFtGZ91t5z8dytv_st5CxBhjg,6486
 nanobind/include/nanobind/stl/array.h,sha256=-jdVTy9gcqjH4kBVWbm52dGecHr90rwkusJX6ucHrII,535
 nanobind/include/nanobind/stl/bind_map.h,sha256=iEyY2r8iNdCYGY6_MHv6XsSzjWW_TY97ZQOBVflOo8w,5775
 nanobind/include/nanobind/stl/bind_vector.h,sha256=5z2IDbBMULnBdoJqRoQQFAWBwOPVhH40JVUqqZw8t9A,7250
+nanobind/include/nanobind/stl/chrono.h,sha256=BAAn1ZoY3tJVqzWnIv7tNdd3qpz6NwMsH-XQDACCWyw,8675
 nanobind/include/nanobind/stl/filesystem.h,sha256=MAGHVOW5fq7GP3HwB-UaXDADA1kkPp1Y6JVe55XNFbk,2720
 nanobind/include/nanobind/stl/function.h,sha256=wlfxVQW3_c2KUJI9AFgq1MG9F9tXHJ8ASqjENy7CC3A,2478
 nanobind/include/nanobind/stl/list.h,sha256=6ZAtdW-epqSXkrXSEOl8fbutH36Eosd8qH2KrXSvIUk,527
 nanobind/include/nanobind/stl/map.h,sha256=1wxxFgt_oxW8zN-AMFPHhCQkaY5cZlA46x0wmKKoPLw,596
 nanobind/include/nanobind/stl/optional.h,sha256=Nb1jK2x46i2eFnPABiB4xSrm-_ML_3RSu95ehmwJ_O0,2281
 nanobind/include/nanobind/stl/pair.h,sha256=Xb4f3mmZAggKEk_Icq7zhlKDLOGuEuCHIX_VodrmizI,3403
 nanobind/include/nanobind/stl/set.h,sha256=_kN6BEkiLKE6JdJjlQAFdb79GQ27rtUvMVrkU5Zx_OA,575
-nanobind/include/nanobind/stl/shared_ptr.h,sha256=GPgyyAft7FNMCTk6WDLSoLefKcH4sNbRLfZQ17CSbCY,4573
+nanobind/include/nanobind/stl/shared_ptr.h,sha256=AIo9W-CzxGGBeLnsYeme7a4TcJnTfKbukkXIIFujfdk,5022
 nanobind/include/nanobind/stl/string.h,sha256=IarbTvSVgOoa3d-yeS57QtChXCcf-s836HoUojhl7BA,1019
 nanobind/include/nanobind/stl/string_view.h,sha256=Lc28MwFtEy_LuComWUPho_ZJROP3xF8vhMoDmy7S4Og,1063
 nanobind/include/nanobind/stl/tuple.h,sha256=r1m7whXMNH4dUNO_li0BIjYjib5TLlj6TWkE07RIbDA,3463
 nanobind/include/nanobind/stl/unique_ptr.h,sha256=zV-x5cIDmjJKa9x9XSzwpPckITYN3AfGNsUBbF9Z1sw,4310
 nanobind/include/nanobind/stl/unordered_map.h,sha256=CtLH0eyX3FzYPKFV6yYEr9R-yEKoVTnKITwwWLoYxZI,646
 nanobind/include/nanobind/stl/unordered_set.h,sha256=60NNDLwnLr-D2INwMSokHVJPwbmJ50iFuuhHjoHsP0g,652
 nanobind/include/nanobind/stl/variant.h,sha256=L4uX1IeUnnZOfGXjVczHDksOK0k7YCxeBuRKCdQIA1I,3386
 nanobind/include/nanobind/stl/vector.h,sha256=22zqOx9R65LCLc5k4UJit84NwWxBQsYVtcQaNraFs2M,537
+nanobind/include/nanobind/stl/detail/chrono.h,sha256=bT5XK6rf52kLrrNw9PwvrOsZqsJUEYLWp3lGG3HkCT8,10571
 nanobind/include/nanobind/stl/detail/nb_array.h,sha256=WAZNfoUYHGgDQwE6GJcmJ80zAhBpVX_JG6-EVeWHglo,1680
 nanobind/include/nanobind/stl/detail/nb_dict.h,sha256=SU18AkR6yw_nZGCXkU38f1GtIpXQE4QuuWPaFFQGcFA,2655
 nanobind/include/nanobind/stl/detail/nb_list.h,sha256=6WI8NOXhQRxqyUzr7hFVhUvhOQxmOL0t8TE5tTDOXt4,2132
 nanobind/include/nanobind/stl/detail/nb_set.h,sha256=vEq2LqjblYcgFHoC0VMptmTLq9-fH4SzY2ABNBZRNnM,1942
 nanobind/include/nanobind/stl/detail/traits.h,sha256=Aaa89qY0NJpmbkRzZA8OLLkH3IBZMV1aQ5Y1u9RUoaw,3218
-nanobind/src/buffer.h,sha256=Rmh6YRwuyajBiWq5FRh4nVvXNhD46f_qPz79obX_mqs,4165
-nanobind/src/common.cpp,sha256=lZuP5vlzcan7-LjEOTsSCmIhZWlDOuZz5VleETfsJtI,27942
-nanobind/src/error.cpp,sha256=dTB6RacW7SRHyUIBuYNRnUMaZFHiTPhxkjOOJC1WIqE,6327
-nanobind/src/implicit.cpp,sha256=9IJHaA8GJ1TTZ4AeChFbmWFKI6IvELG1hVwwr_9ZbCg,2548
-nanobind/src/nb_enum.cpp,sha256=Cf8xJ4uB7FyBdhNmvP_zo5LgDU2k6ZBURecPWkTpJX8,11560
-nanobind/src/nb_func.cpp,sha256=4IPJJEDnos5z_WgeldmvQWMw2dqSgReYdbzg6Iz2N6Q,39337
-nanobind/src/nb_internals.cpp,sha256=ozSpVJMP-uIty5pvHIEOLgSmoh6MxN7o9X0kRq4pEsU,18420
-nanobind/src/nb_internals.h,sha256=bFn22JXq3FeA6yKNu4LxAZoWODt5lg3O_6OkF0fOw10,8457
-nanobind/src/nb_ndarray.cpp,sha256=st0LPnCSy5cWrX25dxUgdaRK_ARDl_IocFQCDm1uISA,19495
-nanobind/src/nb_type.cpp,sha256=IG8eaP6ELEGT3Gu5e7Gn1kQSSuc11xiRq9UuStsM74Q,47554
-nanobind/src/trampoline.cpp,sha256=dXZQjj2nKxcUjg4Nca4FPqRegp_HPHSNz77DwaC5TcA,3628
-nanobind-1.2.0.dist-info/LICENSE,sha256=8wUJGk5XgFhwsheijqSx8WYQ7s6EV9I3D4Iqlpa3WDY,1521
-nanobind-1.2.0.dist-info/METADATA,sha256=K5vpQYJYaEvvlBzrTd8aqS66IilxWCFdfuGDFhvOWxU,1426
-nanobind-1.2.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-nanobind-1.2.0.dist-info/top_level.txt,sha256=3pRezwhnZCbmPhzcbPKfaw-IRYTQ6WbLWu14UZgONhs,9
-nanobind-1.2.0.dist-info/RECORD,,
+nanobind/src/buffer.h,sha256=Yk2RUt38GW4uFNAhhdhMbNGfakA0ike3twEzhEuEFDQ,4218
+nanobind/src/common.cpp,sha256=1x-ceMcIKXRlNwBsDoAP12HCiqU3HazyVUaKVsgQsp0,28395
+nanobind/src/error.cpp,sha256=al-TrMRxd-6iu6uvqh8jpDC2OpRSRd1RsI4SrQKXClY,5671
+nanobind/src/implicit.cpp,sha256=r7IDxgu-sbzzL_WaNzGwEC3CnL8kHwOTNyaR0x3ZLQE,2548
+nanobind/src/nb_enum.cpp,sha256=vkWwgVLMiEJnL7ci_YmLVgZMcVbtK7oo-eIXrjlvjwA,14685
+nanobind/src/nb_func.cpp,sha256=peRtcWsF7ejSouR2y6YXDiLmT5CUVrKr1d3w5ZJ8bCY,41402
+nanobind/src/nb_internals.cpp,sha256=ysc6IQ5PkJPQFCp6pH9pHQNBehaBDfW84dqljw-fKEk,14833
+nanobind/src/nb_internals.h,sha256=XTTtMGJrYLtTaDNp0-4pgS-pRk7TPB5Kt1vufbDNWEY,9558
+nanobind/src/nb_ndarray.cpp,sha256=OVrY1EEhP9K6SXH7UV6JACb2wfQeGJlU2kgVLei5H2Q,21211
+nanobind/src/nb_static_property.cpp,sha256=6-vaicJEaSLm3KipTst_nVuAMW8ClgWSVUwFVpno7_M,2466
+nanobind/src/nb_type.cpp,sha256=Qrw3VGGH-jncPmYQJSdpjYjCrgNSDqN68e4NrN3IIM8,52907
+nanobind/src/trampoline.cpp,sha256=nZWDoYNYw19X7rr2c6Pk-2fJn4wJn6AVwR6cwcKSVec,3796
+nanobind-1.3.0.dist-info/LICENSE,sha256=8wUJGk5XgFhwsheijqSx8WYQ7s6EV9I3D4Iqlpa3WDY,1521
+nanobind-1.3.0.dist-info/METADATA,sha256=gGx-5WUOkDV8aG02bnbBJUA5pWypnVAPH9rsTDvvm3k,1406
+nanobind-1.3.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+nanobind-1.3.0.dist-info/top_level.txt,sha256=3pRezwhnZCbmPhzcbPKfaw-IRYTQ6WbLWu14UZgONhs,9
+nanobind-1.3.0.dist-info/RECORD,,
```

