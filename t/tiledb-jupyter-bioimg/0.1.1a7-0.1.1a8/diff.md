# Comparing `tmp/tiledb_jupyter_bioimg-0.1.1a7.tar.gz` & `tmp/tiledb_jupyter_bioimg-0.1.1a8.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "tiledb_jupyter_bioimg-0.1.1a7.tar", last modified: Wed May 31 09:40:02 2023, max compression
+gzip compressed data, was "tiledb_jupyter_bioimg-0.1.1a8.tar", last modified: Wed May 31 11:25:53 2023, max compression
```

## Comparing `tiledb_jupyter_bioimg-0.1.1a7.tar` & `tiledb_jupyter_bioimg-0.1.1a8.tar`

### file list

```diff
@@ -1,49 +1,49 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 09:40:02.418595 tiledb_jupyter_bioimg-0.1.1a7/
--rw-r--r--   0 runner    (1001) docker     (123)     1506 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)      439 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (123)     2741 2023-05-31 09:40:02.418595 tiledb_jupyter_bioimg-0.1.1a7/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     1988 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/README.md
--rw-r--r--   0 runner    (1001) docker     (123)      203 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/install.json
--rw-r--r--   0 runner    (1001) docker     (123)     3074 2023-05-31 09:37:17.000000 tiledb_jupyter_bioimg-0.1.1a7/package.json
--rw-r--r--   0 runner    (1001) docker     (123)      157 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (123)       38 2023-05-31 09:40:02.418595 tiledb_jupyter_bioimg-0.1.1a7/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     2581 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 09:40:02.410595 tiledb_jupyter_bioimg-0.1.1a7/src/
--rw-r--r--   0 runner    (1001) docker     (123)      841 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/src/index.ts
--rw-r--r--   0 runner    (1001) docker     (123)      572 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/src/version.ts
--rw-r--r--   0 runner    (1001) docker     (123)     1454 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/src/widget.ts
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 09:40:02.410595 tiledb_jupyter_bioimg-0.1.1a7/style/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/style/base.css
--rw-r--r--   0 runner    (1001) docker     (123)       25 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/style/index.css
--rw-r--r--   0 runner    (1001) docker     (123)       21 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/style/index.js
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 09:40:02.410595 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/
--rw-r--r--   0 runner    (1001) docker     (123)      353 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      313 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/_frontend.py
--rw-r--r--   0 runner    (1001) docker     (123)      774 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/_version.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 09:40:02.414595 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/
--rw-r--r--   0 runner    (1001) docker     (123)     3216 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/package.json
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 09:40:02.418595 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/
--rw-r--r--   0 runner    (1001) docker     (123)   189298 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/08450fe724517d116eb4ec755231ced4eb5bf019b478cb080efd58ad83c5e211.svg
--rw-r--r--   0 runner    (1001) docker     (123)    14610 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/172.6267f3dd3063477e34ed.js
--rw-r--r--   0 runner    (1001) docker     (123)   725916 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/344.8db93920a8ca0f0600d9.js
--rw-r--r--   0 runner    (1001) docker     (123)      452 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/344.8db93920a8ca0f0600d9.js.LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (123)      152 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/446.3bf34f45c93ace9c0f28.js
--rw-r--r--   0 runner    (1001) docker     (123)     3942 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/633.1125117a0017a3fcb647.js
--rw-r--r--   0 runner    (1001) docker     (123)   516691 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/635.812cb387a85b4a4dd127.js
--rw-r--r--   0 runner    (1001) docker     (123)      808 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/635.812cb387a85b4a4dd127.js.LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (123)   172313 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/713.44bebcfa12a45c30ff83.js
--rw-r--r--   0 runner    (1001) docker     (123)      218 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/713.44bebcfa12a45c30ff83.js.LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3997 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/744.ca2ab2033fd1289054ea.js
--rw-r--r--   0 runner    (1001) docker     (123)     3410 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/747.433530952542f03ebc71.js
--rw-r--r--   0 runner    (1001) docker     (123)     8233 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/remoteEntry.5cdbd27cab7657a97979.js
--rw-r--r--   0 runner    (1001) docker     (123)      178 2023-05-31 09:39:29.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/style.js
--rw-r--r--   0 runner    (1001) docker     (123)    90733 2023-05-31 09:40:00.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/third-party-licenses.json
--rw-r--r--   0 runner    (1001) docker     (123)     1162 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/render.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 09:40:02.414595 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)     2741 2023-05-31 09:40:02.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     1746 2023-05-31 09:40:02.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-31 09:40:02.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-31 09:38:33.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg.egg-info/not-zip-safe
--rw-r--r--   0 runner    (1001) docker     (123)       46 2023-05-31 09:40:02.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)       22 2023-05-31 09:40:02.000000 tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (123)      615 2023-05-31 09:34:48.000000 tiledb_jupyter_bioimg-0.1.1a7/tsconfig.json
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 11:25:53.624462 tiledb_jupyter_bioimg-0.1.1a8/
+-rw-r--r--   0 runner    (1001) docker     (123)     1506 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)      439 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     2741 2023-05-31 11:25:53.624462 tiledb_jupyter_bioimg-0.1.1a8/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     1988 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      203 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/install.json
+-rw-r--r--   0 runner    (1001) docker     (123)     3269 2023-05-31 11:23:43.000000 tiledb_jupyter_bioimg-0.1.1a8/package.json
+-rw-r--r--   0 runner    (1001) docker     (123)      157 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-05-31 11:25:53.624462 tiledb_jupyter_bioimg-0.1.1a8/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     2581 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 11:25:53.616462 tiledb_jupyter_bioimg-0.1.1a8/src/
+-rw-r--r--   0 runner    (1001) docker     (123)      841 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/src/index.ts
+-rw-r--r--   0 runner    (1001) docker     (123)      572 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/src/version.ts
+-rw-r--r--   0 runner    (1001) docker     (123)     1454 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/src/widget.ts
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 11:25:53.616462 tiledb_jupyter_bioimg-0.1.1a8/style/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/style/base.css
+-rw-r--r--   0 runner    (1001) docker     (123)       25 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/style/index.css
+-rw-r--r--   0 runner    (1001) docker     (123)       21 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/style/index.js
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 11:25:53.620462 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/
+-rw-r--r--   0 runner    (1001) docker     (123)      353 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      313 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/_frontend.py
+-rw-r--r--   0 runner    (1001) docker     (123)      774 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/_version.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 11:25:53.620462 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/
+-rw-r--r--   0 runner    (1001) docker     (123)     3411 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/package.json
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 11:25:53.624462 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/
+-rw-r--r--   0 runner    (1001) docker     (123)   189298 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/08450fe724517d116eb4ec755231ced4eb5bf019b478cb080efd58ad83c5e211.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    14610 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/172.6267f3dd3063477e34ed.js
+-rw-r--r--   0 runner    (1001) docker     (123)   728398 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/287.6f9268acd2e30d19aed9.js
+-rw-r--r--   0 runner    (1001) docker     (123)      452 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/287.6f9268acd2e30d19aed9.js.LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      152 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/446.3bf34f45c93ace9c0f28.js
+-rw-r--r--   0 runner    (1001) docker     (123)     3942 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/633.f2676ca35060e71f16a0.js
+-rw-r--r--   0 runner    (1001) docker     (123)   516688 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/635.f8f404497739316e801c.js
+-rw-r--r--   0 runner    (1001) docker     (123)      808 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/635.f8f404497739316e801c.js.LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (123)   172313 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/713.44bebcfa12a45c30ff83.js
+-rw-r--r--   0 runner    (1001) docker     (123)      218 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/713.44bebcfa12a45c30ff83.js.LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4156 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/744.d153a5e460cf3f20c96b.js
+-rw-r--r--   0 runner    (1001) docker     (123)     3410 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/747.433530952542f03ebc71.js
+-rw-r--r--   0 runner    (1001) docker     (123)     8235 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/remoteEntry.d5c184be36166b094633.js
+-rw-r--r--   0 runner    (1001) docker     (123)      178 2023-05-31 11:25:25.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/style.js
+-rw-r--r--   0 runner    (1001) docker     (123)    90780 2023-05-31 11:25:52.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/third-party-licenses.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1162 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/render.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-31 11:25:53.620462 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     2741 2023-05-31 11:25:53.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     1746 2023-05-31 11:25:53.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-31 11:25:53.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-31 11:24:43.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (123)       46 2023-05-31 11:25:53.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       22 2023-05-31 11:25:53.000000 tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      615 2023-05-31 11:21:38.000000 tiledb_jupyter_bioimg-0.1.1a8/tsconfig.json
```

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/LICENSE` & `tiledb_jupyter_bioimg-0.1.1a8/LICENSE`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/PKG-INFO` & `tiledb_jupyter_bioimg-0.1.1a8/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: tiledb_jupyter_bioimg
-Version: 0.1.1a7
+Version: 0.1.1a8
 Summary: A jupyterlab extension to visualize bioimages in TileDB format
 Home-page: https://github.com/TileDB-Inc/TileDB-Jupyter-BioImage-Viewer
 Author: TileDB
 License: BSD-3-Clause
 Keywords: Jupyter,JupyterLab,JupyterLab3
 Platform: Linux
 Platform: Mac OS X
```

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/README.md` & `tiledb_jupyter_bioimg-0.1.1a8/README.md`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/package.json` & `tiledb_jupyter_bioimg-0.1.1a8/package.json`

 * *Files 11% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9583333333333334%*

 * *Differences: {"'resolutions'": "{'@luma.gl/constants': '8.5.16', '@deck.gl/aggregation-layers': '8.8.12', "*

 * *                  "'@deck.gl/core': '8.8.12', '@deck.gl/carto': '8.8.12', '@deck.gl/extensions': "*

 * *                  "'8.8.12', '@deck.gl/geo-layers': '8.8.12', '@deck.gl/google-maps': '8.8.12', "*

 * *                  "'@deck.gl/mapbox': '8.8.12', '@deck.gl/json': '8.8.12', '@deck.gl/layers': "*

 * *                  "'8.8.12', '@deck.gl/mesh-layers': '8.8.12', '@deck.gl/react': '8.8.12', "*

 * *                  "'@luma.gl/co […]*

```diff
@@ -42,26 +42,32 @@
     "main": "lib/index.js",
     "name": "@tiledb-inc/jupyter-bioimage-viewer",
     "repository": {
         "type": "git",
         "url": "https://github.com/TileDB-Inc/TileDB-Jupyter-BioImage-Viewer.git"
     },
     "resolutions": {
-        "@deck.gl/aggregation-layers": "^8.8.12",
-        "@deck.gl/carto": "^8.8.12",
-        "@deck.gl/core": "^8.8.12",
-        "@deck.gl/extensions": "^8.8.12",
-        "@deck.gl/geo-layers": "^8.8.12",
-        "@deck.gl/google-maps": "^8.8.12",
-        "@deck.gl/json": "^8.8.12",
-        "@deck.gl/layers": "^8.8.12",
-        "@deck.gl/mapbox": "^8.8.12",
-        "@deck.gl/mesh-layers": "^8.8.12",
-        "@deck.gl/react": "^8.8.12",
-        "@luma.gl/constants": "^8.5.16"
+        "@deck.gl/aggregation-layers": "8.8.12",
+        "@deck.gl/carto": "8.8.12",
+        "@deck.gl/core": "8.8.12",
+        "@deck.gl/extensions": "8.8.12",
+        "@deck.gl/geo-layers": "8.8.12",
+        "@deck.gl/google-maps": "8.8.12",
+        "@deck.gl/json": "8.8.12",
+        "@deck.gl/layers": "8.8.12",
+        "@deck.gl/mapbox": "8.8.12",
+        "@deck.gl/mesh-layers": "8.8.12",
+        "@deck.gl/react": "8.8.12",
+        "@luma.gl/constants": "8.5.16",
+        "@luma.gl/core": "8.5.16",
+        "@luma.gl/engine": "8.5.16",
+        "@luma.gl/experimental": "8.5.16",
+        "@luma.gl/gltools": "8.5.16",
+        "@luma.gl/shadertools": "8.5.16",
+        "@luma.gl/webgl": "8.5.16"
     },
     "scripts": {
         "build": "jlpm run build:lib && jlpm run build:labextension:dev",
         "build:labextension": "jupyter labextension build .",
         "build:labextension:dev": "jupyter labextension build --development True .",
         "build:lib": "tsc",
         "build:prod": "jlpm run build:lib && jlpm run build:labextension",
@@ -81,9 +87,9 @@
     "sideEffects": [
         "style/*.css",
         "style/index.js"
     ],
     "style": "style/index.css",
     "styleModule": "style/index.js",
     "types": "lib/index.d.ts",
-    "version": "0.1.1-alpha.7"
+    "version": "0.1.1-alpha.8"
 }
```

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/setup.py` & `tiledb_jupyter_bioimg-0.1.1a8/setup.py`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/src/index.ts` & `tiledb_jupyter_bioimg-0.1.1a8/src/index.ts`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/src/version.ts` & `tiledb_jupyter_bioimg-0.1.1a8/src/version.ts`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/src/widget.ts` & `tiledb_jupyter_bioimg-0.1.1a8/src/widget.ts`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/_version.py` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/_version.py`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/package.json` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/package.json`

 * *Files 12% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9578125%*

 * *Differences: {"'jupyterlab'": "{'_build': {'load': 'static/remoteEntry.d5c184be36166b094633.js'}}",*

 * * "'resolutions'": "{'@luma.gl/constants': '8.5.16', '@deck.gl/aggregation-layers': '8.8.12', "*

 * *                  "'@deck.gl/core': '8.8.12', '@deck.gl/carto': '8.8.12', '@deck.gl/extensions': "*

 * *                  "'8.8.12', '@deck.gl/geo-layers': '8.8.12', '@deck.gl/google-maps': '8.8.12', "*

 * *                  "'@deck.gl/mapbox': '8.8.12', '@deck.gl/json': '8.8.12', '@deck.gl/layers': "*

 * *                  "'8.8.12', '@deck.g […]*

```diff
@@ -27,15 +27,15 @@
         "style/*.css",
         "style/index.js"
     ],
     "homepage": "https://github.com/TileDB-Inc/TileDB-Jupyter-BioImage-Viewer",
     "jupyterlab": {
         "_build": {
             "extension": "./extension",
-            "load": "static/remoteEntry.5cdbd27cab7657a97979.js",
+            "load": "static/remoteEntry.d5c184be36166b094633.js",
             "style": "./style"
         },
         "extension": "lib/index",
         "outputDir": "tiledb_jupyter_bioimg/labextension",
         "webpackConfig": "./webpack.config.js"
     },
     "keywords": [
@@ -47,26 +47,32 @@
     "main": "lib/index.js",
     "name": "@tiledb-inc/jupyter-bioimage-viewer",
     "repository": {
         "type": "git",
         "url": "https://github.com/TileDB-Inc/TileDB-Jupyter-BioImage-Viewer.git"
     },
     "resolutions": {
-        "@deck.gl/aggregation-layers": "^8.8.12",
-        "@deck.gl/carto": "^8.8.12",
-        "@deck.gl/core": "^8.8.12",
-        "@deck.gl/extensions": "^8.8.12",
-        "@deck.gl/geo-layers": "^8.8.12",
-        "@deck.gl/google-maps": "^8.8.12",
-        "@deck.gl/json": "^8.8.12",
-        "@deck.gl/layers": "^8.8.12",
-        "@deck.gl/mapbox": "^8.8.12",
-        "@deck.gl/mesh-layers": "^8.8.12",
-        "@deck.gl/react": "^8.8.12",
-        "@luma.gl/constants": "^8.5.16"
+        "@deck.gl/aggregation-layers": "8.8.12",
+        "@deck.gl/carto": "8.8.12",
+        "@deck.gl/core": "8.8.12",
+        "@deck.gl/extensions": "8.8.12",
+        "@deck.gl/geo-layers": "8.8.12",
+        "@deck.gl/google-maps": "8.8.12",
+        "@deck.gl/json": "8.8.12",
+        "@deck.gl/layers": "8.8.12",
+        "@deck.gl/mapbox": "8.8.12",
+        "@deck.gl/mesh-layers": "8.8.12",
+        "@deck.gl/react": "8.8.12",
+        "@luma.gl/constants": "8.5.16",
+        "@luma.gl/core": "8.5.16",
+        "@luma.gl/engine": "8.5.16",
+        "@luma.gl/experimental": "8.5.16",
+        "@luma.gl/gltools": "8.5.16",
+        "@luma.gl/shadertools": "8.5.16",
+        "@luma.gl/webgl": "8.5.16"
     },
     "scripts": {
         "build": "jlpm run build:lib && jlpm run build:labextension:dev",
         "build:labextension": "jupyter labextension build .",
         "build:labextension:dev": "jupyter labextension build --development True .",
         "build:lib": "tsc",
         "build:prod": "jlpm run build:lib && jlpm run build:labextension",
@@ -86,9 +92,9 @@
     "sideEffects": [
         "style/*.css",
         "style/index.js"
     ],
     "style": "style/index.css",
     "styleModule": "style/index.js",
     "types": "lib/index.d.ts",
-    "version": "0.1.1-alpha.7"
+    "version": "0.1.1-alpha.8"
 }
```

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/08450fe724517d116eb4ec755231ced4eb5bf019b478cb080efd58ad83c5e211.svg` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/08450fe724517d116eb4ec755231ced4eb5bf019b478cb080efd58ad83c5e211.svg`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/172.6267f3dd3063477e34ed.js` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/172.6267f3dd3063477e34ed.js`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/344.8db93920a8ca0f0600d9.js` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/287.6f9268acd2e30d19aed9.js`

 * *Files 1% similar despite different names*

#### js-beautify {}

```diff
@@ -1,10 +1,10 @@
-/*! For license information please see 344.8db93920a8ca0f0600d9.js.LICENSE.txt */
+/*! For license information please see 287.6f9268acd2e30d19aed9.js.LICENSE.txt */
 (self.webpackChunk_tiledb_inc_jupyter_bioimage_viewer = self.webpackChunk_tiledb_inc_jupyter_bioimage_viewer || []).push([
-    [344], {
+    [287], {
         597: (t, e, n) => {
             "use strict";
             var i, r = Object.assign || function(t) {
                     for (var e = 1; e < arguments.length; e++) {
                         var n = arguments[e];
                         for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
                     }
@@ -73,15 +73,90 @@
                         height: l
                     }, h)
                 }, u), s.default.createElement("path", {
                     d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z"
                 }))
             }
         },
-        344: (t, e, n) => {
+        9296: t => {
+            "use strict";
+            t.exports = n, t.exports.default = n;
+            var e = 1e20;
+
+            function n(t, e, n, i, r, s) {
+                this.fontSize = t || 24, this.buffer = void 0 === e ? 3 : e, this.cutoff = i || .25, this.fontFamily = r || "sans-serif", this.fontWeight = s || "normal", this.radius = n || 8;
+                var o = this.size = this.fontSize + 2 * this.buffer,
+                    a = o + 2 * this.buffer;
+                this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = o, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textAlign = "left", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(a * a), this.gridInner = new Float64Array(a * a), this.f = new Float64Array(a), this.z = new Float64Array(a + 1), this.v = new Uint16Array(a), this.useMetrics = void 0 !== this.ctx.measureText("A").actualBoundingBoxLeft, this.middle = Math.round(o / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1))
+            }
+
+            function i(t, e, n, i, s, o) {
+                for (var a = 0; a < e; a++) r(t, a, e, n, i, s, o);
+                for (var l = 0; l < n; l++) r(t, l * e, 1, e, i, s, o)
+            }
+
+            function r(t, n, i, r, s, o, a) {
+                var l, c, h, u;
+                for (o[0] = 0, a[0] = -e, a[1] = e, l = 0; l < r; l++) s[l] = t[n + l * i];
+                for (l = 1, c = 0, h = 0; l < r; l++) {
+                    do {
+                        u = o[c], h = (s[l] - s[u] + l * l - u * u) / (l - u) / 2
+                    } while (h <= a[c] && --c > -1);
+                    o[++c] = l, a[c] = h, a[c + 1] = e
+                }
+                for (l = 0, c = 0; l < r; l++) {
+                    for (; a[c + 1] < l;) c++;
+                    u = o[c], t[n + l * i] = s[u] + (l - u) * (l - u)
+                }
+            }
+            n.prototype._draw = function(t, n) {
+                var r, s, o, a, l, c, h, u, d, p = this.ctx.measureText(t),
+                    f = p.width,
+                    g = 2 * this.buffer;
+                n && this.useMetrics ? (l = Math.floor(p.actualBoundingBoxAscent), u = this.buffer + Math.ceil(p.actualBoundingBoxAscent), c = this.buffer, h = this.buffer, r = (s = Math.min(this.size, Math.ceil(p.actualBoundingBoxRight - p.actualBoundingBoxLeft))) + g, o = (a = Math.min(this.size - c, Math.ceil(p.actualBoundingBoxAscent + p.actualBoundingBoxDescent))) + g, this.ctx.textBaseline = "alphabetic") : (r = s = this.size, o = a = this.size, l = 19 * this.fontSize / 24, c = h = 0, u = this.middle, this.ctx.textBaseline = "middle"), s && a && (this.ctx.clearRect(h, c, s, a), this.ctx.fillText(t, this.buffer, u), d = this.ctx.getImageData(h, c, s, a));
+                var m = new Uint8ClampedArray(r * o);
+                return function(t, n, i, r, s, o, a) {
+                        o.fill(e, 0, n * i), a.fill(0, 0, n * i);
+                        for (var l = (n - r) / 2, c = 0; c < s; c++)
+                            for (var h = 0; h < r; h++) {
+                                var u = (c + l) * n + h + l,
+                                    d = t.data[4 * (c * r + h) + 3] / 255;
+                                if (1 === d) o[u] = 0, a[u] = e;
+                                else if (0 === d) o[u] = e, a[u] = 0;
+                                else {
+                                    var p = Math.max(0, .5 - d),
+                                        f = Math.max(0, d - .5);
+                                    o[u] = p * p, a[u] = f * f
+                                }
+                            }
+                    }(d, r, o, s, a, this.gridOuter, this.gridInner), i(this.gridOuter, r, o, this.f, this.v, this.z), i(this.gridInner, r, o, this.f, this.v, this.z),
+                    function(t, e, n, i, r, s, o) {
+                        for (var a = 0; a < e * n; a++) {
+                            var l = Math.sqrt(i[a]) - Math.sqrt(r[a]);
+                            t[a] = Math.round(255 - 255 * (l / s + o))
+                        }
+                    }(m, r, o, this.gridOuter, this.gridInner, this.radius, this.cutoff), {
+                        data: m,
+                        metrics: {
+                            width: s,
+                            height: a,
+                            sdfWidth: r,
+                            sdfHeight: o,
+                            top: l,
+                            left: 0,
+                            advance: f
+                        }
+                    }
+            }, n.prototype.draw = function(t) {
+                return this._draw(t, !1).data
+            }, n.prototype.drawWithMetrics = function(t) {
+                return this._draw(t, !0)
+            }
+        },
+        7287: (t, e, n) => {
             "use strict";
             n.r(e), n.d(e, {
                 default: () => rE
             });
             var i = n(3379),
                 r = n.n(i),
                 s = n(4272);
@@ -597,47 +672,47 @@
                             style: i.slider
                         }))))
                     }
                 }]), e
             }(c.PureComponent || c.Component);
             var O = n(5697),
                 L = n.n(O);
-            const R = function(t, e) {
+            const k = function(t, e) {
                     return t === e || t != t && e != e
                 },
-                I = function(t, e) {
+                R = function(t, e) {
                     for (var n = t.length; n--;)
-                        if (R(t[n][0], e)) return n;
+                        if (k(t[n][0], e)) return n;
                     return -1
                 };
-            var k = Array.prototype.splice;
+            var I = Array.prototype.splice;
 
             function j(t) {
                 var e = -1,
                     n = null == t ? 0 : t.length;
                 for (this.clear(); ++e < n;) {
                     var i = t[e];
                     this.set(i[0], i[1])
                 }
             }
             j.prototype.clear = function() {
                 this.__data__ = [], this.size = 0
             }, j.prototype.delete = function(t) {
                 var e = this.__data__,
-                    n = I(e, t);
-                return !(n < 0 || (n == e.length - 1 ? e.pop() : k.call(e, n, 1), --this.size, 0))
+                    n = R(e, t);
+                return !(n < 0 || (n == e.length - 1 ? e.pop() : I.call(e, n, 1), --this.size, 0))
             }, j.prototype.get = function(t) {
                 var e = this.__data__,
-                    n = I(e, t);
+                    n = R(e, t);
                 return n < 0 ? void 0 : e[n][1]
             }, j.prototype.has = function(t) {
-                return I(this.__data__, t) > -1
+                return R(this.__data__, t) > -1
             }, j.prototype.set = function(t, e) {
                 var n = this.__data__,
-                    i = I(n, t);
+                    i = R(n, t);
                 return i < 0 ? (++this.size, n.push([t, e])) : n[i][1] = e, this
             };
             const F = j;
             var z = n(6169);
             const B = z.Z.Symbol;
             var D = Object.prototype,
                 N = D.hasOwnProperty,
@@ -802,15 +877,15 @@
                         configurable: !0,
                         enumerable: !0,
                         value: n,
                         writable: !0
                     }) : t[e] = n
                 },
                 yt = function(t, e, n) {
-                    (void 0 !== n && !R(t[e], n) || void 0 === n && !(e in t)) && bt(t, e, n)
+                    (void 0 !== n && !k(t[e], n) || void 0 === n && !(e in t)) && bt(t, e, n)
                 },
                 _t = function(t, e, n) {
                     for (var i = -1, r = Object(t), s = n(t), o = s.length; o--;) {
                         var a = s[++i];
                         if (!1 === e(r[a], a, r)) break
                     }
                     return t
@@ -848,21 +923,21 @@
                 },
                 Ot = function(t) {
                     return null != t && "object" == typeof t
                 },
                 Lt = function(t) {
                     return Ot(t) && "[object Arguments]" == H(t)
                 };
-            var Rt = Object.prototype,
-                It = Rt.hasOwnProperty,
-                kt = Rt.propertyIsEnumerable;
+            var kt = Object.prototype,
+                Rt = kt.hasOwnProperty,
+                It = kt.propertyIsEnumerable;
             const jt = Lt(function() {
                     return arguments
                 }()) ? Lt : function(t) {
-                    return Ot(t) && It.call(t, "callee") && !kt.call(t, "callee")
+                    return Ot(t) && Rt.call(t, "callee") && !It.call(t, "callee")
                 },
                 Ft = Array.isArray,
                 zt = function(t) {
                     return "number" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991
                 },
                 Bt = function(t) {
                     return null != t && zt(t.length) && !q(t)
@@ -885,15 +960,15 @@
             var Yt;
             const Kt = function(t, e) {
                 if (("constructor" !== e || "function" != typeof t[e]) && "__proto__" != e) return t[e]
             };
             var Qt = Object.prototype.hasOwnProperty;
             const Jt = function(t, e, n) {
                 var i = t[e];
-                Qt.call(t, e) && R(i, n) && (void 0 !== n || e in t) || bt(t, e, n)
+                Qt.call(t, e) && k(i, n) && (void 0 !== n || e in t) || bt(t, e, n)
             };
             var $t = /^(?:0|[1-9]\d*)$/;
             const te = function(t, e) {
                 var n = typeof t;
                 return !!(e = null == e ? 9007199254740991 : e) && ("number" == n || "symbol" != n && $t.test(t)) && t > -1 && t % 1 == 0 && t < e
             };
             var ee = Object.prototype.hasOwnProperty;
@@ -1036,15 +1111,15 @@
                     var n = -1,
                         i = e.length,
                         r = i > 1 ? e[i - 1] : void 0,
                         s = i > 2 ? e[2] : void 0;
                     for (r = me.length > 3 && "function" == typeof r ? (i--, r) : void 0, s && function(t, e, n) {
                             if (!Z(n)) return !1;
                             var i = typeof e;
-                            return !!("number" == i ? Bt(n) && te(e, n.length) : "string" == i && e in n) && R(n[e], t)
+                            return !!("number" == i ? Bt(n) && te(e, n.length) : "string" == i && e in n) && k(n[e], t)
                         }(e[0], e[1], s) && (r = i < 3 ? void 0 : r, i = 1), t = Object(t); ++n < i;) {
                         var o = e[n];
                         o && me(t, o, n)
                     }
                     return t
                 })));
             var me, ve = function(t) {
@@ -1209,26 +1284,26 @@
                 }
                 return e = Ae(e) || 0, Z(n) && (h = !!n.leading, s = (u = "maxWait" in n) ? Me(Ae(n.maxWait) || 0, e) : s, d = "trailing" in n ? !!n.trailing : d), v.cancel = function() {
                     void 0 !== a && clearTimeout(a), c = 0, i = l = r = a = void 0
                 }, v.flush = function() {
                     return void 0 === a ? o : m(ye())
                 }, v
             };
-            var Re = function() {
+            var ke = function() {
                     function t(t, e) {
                         for (var n = 0; n < e.length; n++) {
                             var i = e[n];
                             i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                         }
                     }
                     return function(e, n, i) {
                         return n && t(e.prototype, n), i && t(e, i), e
                     }
                 }(),
-                Ie = function(t) {
+                Re = function(t) {
                     function e(t) {
                         ! function(t, e) {
                             if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                         }(this, e);
                         var n = function(t, e) {
                             if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                             return !e || "object" != typeof e && "function" != typeof e ? t : e
@@ -1278,15 +1353,15 @@
                             constructor: {
                                 value: t,
                                 enumerable: !1,
                                 writable: !0,
                                 configurable: !0
                             }
                         }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
-                    }(e, t), Re(e, [{
+                    }(e, t), ke(e, [{
                         key: "componentWillUnmount",
                         value: function() {
                             this.throttle.cancel(), this.unbindEventListeners()
                         }
                     }, {
                         key: "getContainerRenderWindow",
                         value: function() {
@@ -1368,15 +1443,15 @@
                                 style: a.pointer
                             }, this.props.pointer ? h().createElement(this.props.pointer, this.props) : h().createElement("div", {
                                 style: a.circle
                             }))))
                         }
                     }]), e
                 }(c.PureComponent || c.Component);
-            const ke = Ie,
+            const Ie = Re,
                 je = function(t, e) {
                     for (var n = -1, i = null == t ? 0 : t.length; ++n < i && !1 !== e(t[n], n, t););
                     return t
                 },
                 Fe = Ct(Object.keys, Object);
             var ze = Object.prototype.hasOwnProperty;
             const Be = function(t) {
@@ -2235,31 +2310,31 @@
             var Ln = Object.assign || function(t) {
                     for (var e = 1; e < arguments.length; e++) {
                         var n = arguments[e];
                         for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
                     }
                     return t
                 },
-                Rn = function() {
+                kn = function() {
                     function t(t, e) {
                         for (var n = 0; n < e.length; n++) {
                             var i = e[n];
                             i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                         }
                     }
                     return function(e, n, i) {
                         return n && t(e.prototype, n), i && t(e, i), e
                     }
                 }();
 
-            function In(t, e) {
+            function Rn(t, e) {
                 if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                 return !e || "object" != typeof e && "function" != typeof e ? t : e
             }
-            var kn = Object.assign || function(t) {
+            var In = Object.assign || function(t) {
                 for (var e = 1; e < arguments.length; e++) {
                     var n = arguments[e];
                     for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
                 }
                 return t
             };
             const jn = function(t) {
@@ -2267,37 +2342,37 @@
                 return function(n) {
                     function i() {
                         var t, e, n;
                         ! function(t, e) {
                             if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                         }(this, i);
                         for (var r = arguments.length, s = Array(r), o = 0; o < r; o++) s[o] = arguments[o];
-                        return e = n = In(this, (t = i.__proto__ || Object.getPrototypeOf(i)).call.apply(t, [this].concat(s))), n.state = {
+                        return e = n = Rn(this, (t = i.__proto__ || Object.getPrototypeOf(i)).call.apply(t, [this].concat(s))), n.state = {
                             focus: !1
                         }, n.handleFocus = function() {
                             return n.setState({
                                 focus: !0
                             })
                         }, n.handleBlur = function() {
                             return n.setState({
                                 focus: !1
                             })
-                        }, In(n, e)
+                        }, Rn(n, e)
                     }
                     return function(t, e) {
                         if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                         t.prototype = Object.create(e && e.prototype, {
                             constructor: {
                                 value: t,
                                 enumerable: !1,
                                 writable: !0,
                                 configurable: !0
                             }
                         }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
-                    }(i, n), Rn(i, [{
+                    }(i, n), kn(i, [{
                         key: "render",
                         value: function() {
                             return h().createElement(e, {
                                 onFocus: this.handleFocus,
                                 onBlur: this.handleBlur
                             }, h().createElement(t, Ln({}, this.props, this.state)))
                         }
@@ -2314,28 +2389,28 @@
                     l = t.children,
                     c = t.focus,
                     u = t.focusStyle,
                     d = void 0 === u ? {} : u,
                     f = "transparent" === e,
                     g = (0, p.ZP)({
                         default: {
-                            swatch: kn({
+                            swatch: In({
                                 background: e,
                                 height: "100%",
                                 width: "100%",
                                 cursor: "pointer",
                                 position: "relative",
                                 outline: "none"
                             }, n, c ? d : {})
                         }
                     }),
                     m = {};
                 return s && (m.onMouseOver = function(t) {
                     return s(e, t)
-                }), h().createElement("div", kn({
+                }), h().createElement("div", In({
                     style: g.swatch,
                     onClick: function(t) {
                         return r(e, t)
                     },
                     title: a,
                     tabIndex: 0,
                     onKeyDown: function(t) {
@@ -2575,15 +2650,15 @@
                                 if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
                                 t = t.buffer, e = e.buffer;
                             case "[object ArrayBuffer]":
                                 return !(t.byteLength != e.byteLength || !s(new wt(t), new wt(e)));
                             case "[object Boolean]":
                             case "[object Date]":
                             case "[object Number]":
-                                return R(+t, +e);
+                                return k(+t, +e);
                             case "[object Error]":
                                 return t.name == e.name && t.message == e.message;
                             case "[object RegExp]":
                             case "[object String]":
                                 return t == e + "";
                             case "[object Map]":
                                 var a = Wn;
@@ -2719,25 +2794,25 @@
                 return e
             }((function(t) {
                 var e = [];
                 return 46 === t.charCodeAt(0) && e.push(""), t.replace(Mi, (function(t, n, i, r) {
                     e.push(i ? r.replace(Oi, "$1") : n || t)
                 })), e
             }));
-            var Ri = B ? B.prototype : void 0,
-                Ii = Ri ? Ri.toString : void 0;
-            const ki = function t(e) {
+            var ki = B ? B.prototype : void 0,
+                Ri = ki ? ki.toString : void 0;
+            const Ii = function t(e) {
                     if ("string" == typeof e) return e;
                     if (Ft(e)) return Bn(e, t) + "";
-                    if (Ee(e)) return Ii ? Ii.call(e) : "";
+                    if (Ee(e)) return Ri ? Ri.call(e) : "";
                     var n = e + "";
                     return "0" == n && 1 / e == -1 / 0 ? "-0" : n
                 },
                 ji = function(t) {
-                    return null == t ? "" : ki(t)
+                    return null == t ? "" : Ii(t)
                 },
                 Fi = function(t, e) {
                     return Ft(t) ? t : Ci(t, e) ? [t] : Li(ji(t))
                 },
                 zi = function(t) {
                     if ("string" == typeof t || Ee(t)) return t;
                     var e = t + "";
@@ -2976,17 +3051,17 @@
                 Sr = "#03a9f4",
                 Cr = "#0288d1",
                 Tr = "#01579b",
                 Ar = "#b2ebf2",
                 Mr = "#4dd0e1",
                 Or = "#00bcd4",
                 Lr = "#0097a7",
-                Rr = "#006064",
-                Ir = "#b2dfdb",
-                kr = "#4db6ac",
+                kr = "#006064",
+                Rr = "#b2dfdb",
+                Ir = "#4db6ac",
                 jr = "#009688",
                 Fr = "#00796b",
                 zr = "#004d40",
                 Br = "#c8e6c9",
                 Dr = "#81c784",
                 Nr = "#4caf50",
                 Vr = "#388e3c",
@@ -3141,27 +3216,27 @@
                 circleSpacing: 14,
                 colors: [Yi, tr, sr, hr, gr, _r, Sr, Or, jr, Nr, Wr, Yr, ts, ss, hs, gs, _s, Ss],
                 styles: {}
             }, On(Os);
             const Ls = function(t) {
                 return void 0 === t
             };
-            var Rs = n(1995),
-                Is = function() {
+            var ks = n(1995),
+                Rs = function() {
                     function t(t, e) {
                         for (var n = 0; n < e.length; n++) {
                             var i = e[n];
                             i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                         }
                     }
                     return function(e, n, i) {
                         return n && t(e.prototype, n), i && t(e, i), e
                     }
                 }(),
-                ks = function(t) {
+                Is = function(t) {
                     function e(t) {
                         ! function(t, e) {
                             if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                         }(this, e);
                         var n = function(t, e) {
                             if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                             return !e || "object" != typeof e && "function" != typeof e ? t : e
@@ -3213,15 +3288,15 @@
                             constructor: {
                                 value: t,
                                 enumerable: !1,
                                 writable: !0,
                                 configurable: !0
                             }
                         }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
-                    }(e, t), Is(e, [{
+                    }(e, t), Rs(e, [{
                         key: "render",
                         value: function() {
                             var t = this,
                                 e = (0, p.ZP)({
                                     default: {
                                         wrap: {
                                             paddingTop: "16px",
@@ -3403,15 +3478,15 @@
                                 style: e.toggle
                             }, h().createElement("div", {
                                 style: e.icon,
                                 onClick: this.toggleViews,
                                 ref: function(e) {
                                     return t.icon = e
                                 }
-                            }, h().createElement(Rs.Z, {
+                            }, h().createElement(ks.Z, {
                                 style: e.svg,
                                 onMouseOver: this.showHighlight,
                                 onMouseEnter: this.showHighlight,
                                 onMouseOut: this.hideHighlight
                             }))))
                         }
                     }], [{
@@ -3419,18 +3494,18 @@
                         value: function(t, e) {
                             return 1 !== t.hsl.a && "hex" === e.view ? {
                                 view: "rgb"
                             } : null
                         }
                     }]), e
                 }(h().Component);
-            ks.defaultProps = {
+            Is.defaultProps = {
                 view: "hex"
             };
-            const js = ks,
+            const js = Is,
                 Fs = function() {
                     var t = (0, p.ZP)({
                         default: {
                             picker: {
                                 width: "12px",
                                 height: "12px",
                                 borderRadius: "6px",
@@ -3557,15 +3632,15 @@
                         disableAlpha: i
                     });
                 return h().createElement("div", {
                     style: m.picker,
                     className: "chrome-picker " + f
                 }, h().createElement("div", {
                     style: m.saturation
-                }, h().createElement(ke, {
+                }, h().createElement(Ie, {
                     style: m.Saturation,
                     hsl: s,
                     hsv: o,
                     pointer: zs,
                     onChange: n
                 })), h().createElement("div", {
                     style: m.body
@@ -4656,15 +4731,15 @@
                             }, h().createElement("div", {
                                 style: s.head
                             }, this.props.header), h().createElement("div", {
                                 style: s.body,
                                 className: "flexbox-fix"
                             }, h().createElement("div", {
                                 style: s.saturation
-                            }, h().createElement(ke, {
+                            }, h().createElement(Ie, {
                                 hsl: this.props.hsl,
                                 hsv: this.props.hsv,
                                 pointer: qs,
                                 onChange: this.props.onChange
                             })), h().createElement("div", {
                                 style: s.hue
                             }, h().createElement(M, {
@@ -5008,15 +5083,15 @@
                             disableAlpha: l
                         });
                     return h().createElement("div", {
                         style: v.picker,
                         className: "sketch-picker " + m
                     }, h().createElement("div", {
                         style: v.saturation
-                    }, h().createElement(ke, {
+                    }, h().createElement(Ie, {
                         style: v.Saturation,
                         hsl: s,
                         hsv: r,
                         onChange: o
                     })), h().createElement("div", {
                         style: v.controls,
                         className: "flexbox-fix"
@@ -5401,16 +5476,16 @@
                     [Qi, Ki, Yi, Xi, qi],
                     [nr, er, tr, $i, Ji],
                     [ar, or, sr, rr, ir],
                     [dr, ur, hr, cr, lr],
                     [vr, mr, gr, fr, pr],
                     [wr, xr, _r, yr, br],
                     [Tr, Cr, Sr, Pr, Er],
-                    [Rr, Lr, Or, Mr, Ar],
-                    [zr, Fr, jr, kr, Ir],
+                    [kr, Lr, Or, Mr, Ar],
+                    [zr, Fr, jr, Ir, Rr],
                     ["#194D33", Vr, Nr, Dr, Br],
                     [Zr, Hr, Wr, Gr, Ur],
                     [Qr, Kr, Yr, Xr, qr],
                     [ns, es, ts, $r, Jr],
                     [as, os, ss, rs, is],
                     [ds, us, hs, cs, ls],
                     [vs, ms, gs, fs, ps],
@@ -5892,15 +5967,15 @@
                     className: "google-picker " + d
                 }, h().createElement("div", {
                     style: f.head
                 }, a), h().createElement("div", {
                     style: f.swatch
                 }), h().createElement("div", {
                     style: f.saturation
-                }, h().createElement(ke, {
+                }, h().createElement(Ie, {
                     hsl: r,
                     hsv: s,
                     pointer: mo,
                     onChange: n
                 })), h().createElement("div", {
                     style: f.body
                 }, h().createElement("div", {
@@ -6031,36 +6106,34 @@
                 }
                 _setChannelTime(t, e) {
                     const n = e - t.delay;
                     n >= t.duration * t.repeat ? t.time = t.duration * t.rate : (t.time = Math.max(0, n) % t.duration, t.time *= t.rate)
                 }
             }
             const Co = Symbol.for("component"),
-                To = Symbol.for("propTypes"),
-                Ao = Symbol.for("deprecatedProps"),
-                Mo = Symbol.for("asyncPropDefaults"),
-                Oo = Symbol.for("asyncPropOriginal"),
-                Lo = Symbol.for("asyncPropResolved");
-            var Ro = n(4155);
+                To = Symbol.for("asyncPropDefaults"),
+                Ao = Symbol.for("asyncPropOriginal"),
+                Mo = Symbol.for("asyncPropResolved");
+            var Oo = n(4155);
 
-            function Io(t) {
+            function Lo(t) {
                 if ("undefined" != typeof window && "object" == typeof window.process && "renderer" === window.process.type) return !0;
-                if (void 0 !== Ro && "object" == typeof Ro.versions && Boolean(Ro.versions.electron)) return !0;
+                if (void 0 !== Oo && "object" == typeof Oo.versions && Boolean(Oo.versions.electron)) return !0;
                 const e = "object" == typeof navigator && "string" == typeof navigator.userAgent && navigator.userAgent,
                     n = t || e;
                 return !!(n && n.indexOf("Electron") >= 0)
             }
             var ko = n(4155);
 
-            function jo() {
-                return !("object" == typeof ko && "[object process]" === String(ko) && !ko.browser) || Io()
+            function Ro() {
+                return !("object" == typeof ko && "[object process]" === String(ko) && !ko.browser) || Lo()
             }
-            const Fo = "undefined" != typeof __VERSION__ ? __VERSION__ : "untranspiled source";
-            jo();
-            class zo {
+            const Io = "undefined" != typeof __VERSION__ ? __VERSION__ : "untranspiled source";
+            Ro();
+            class jo {
                 constructor(t, e) {
                     let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "sessionStorage";
                     wo(this, "storage", void 0), wo(this, "id", void 0), wo(this, "config", void 0), this.storage = function(t) {
                         try {
                             const e = window[t],
                                 n = "__storage_test__";
                             return e.setItem(n, n), e.removeItem(n), e
@@ -6084,82 +6157,82 @@
                         const e = this.storage.getItem(this.id);
                         t = e ? JSON.parse(e) : {}
                     }
                     return Object.assign(this.config, t), this
                 }
             }
 
-            function Bo(t, e, n) {
+            function Fo(t, e, n) {
                 let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 600;
                 const r = t.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
                 t.width > i && (n = Math.min(n, i / t.width));
                 const s = t.width * n,
                     o = t.height * n,
                     a = ["font-size:1px;", "padding:".concat(Math.floor(o / 2), "px ").concat(Math.floor(s / 2), "px;"), "line-height:".concat(o, "px;"), "background:url(".concat(r, ");"), "background-size:".concat(s, "px ").concat(o, "px;"), "color:transparent;"].join("");
                 return ["".concat(e, " %c+"), a]
             }
-            let Do;
+            let zo;
 
-            function No(t) {
-                return "string" == typeof t ? Do[t.toUpperCase()] || Do.WHITE : t
+            function Bo(t) {
+                return "string" == typeof t ? zo[t.toUpperCase()] || zo.WHITE : t
             }
 
-            function Vo(t, e) {
+            function Do(t, e) {
                 if (!t) throw new Error(e || "Assertion failed")
             }! function(t) {
                 t[t.BLACK = 30] = "BLACK", t[t.RED = 31] = "RED", t[t.GREEN = 32] = "GREEN", t[t.YELLOW = 33] = "YELLOW", t[t.BLUE = 34] = "BLUE", t[t.MAGENTA = 35] = "MAGENTA", t[t.CYAN = 36] = "CYAN", t[t.WHITE = 37] = "WHITE", t[t.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", t[t.BRIGHT_RED = 91] = "BRIGHT_RED", t[t.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", t[t.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", t[t.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", t[t.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", t[t.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", t[t.BRIGHT_WHITE = 97] = "BRIGHT_WHITE"
-            }(Do || (Do = {}));
-            var Uo = n(4155);
-            const Go = {
+            }(zo || (zo = {}));
+            var No = n(4155);
+            const Vo = {
                     self: "undefined" != typeof self && self,
                     window: "undefined" != typeof window && window,
                     global: void 0 !== n.g && n.g,
                     document: "undefined" != typeof document && document,
-                    process: "object" == typeof Uo && Uo
+                    process: "object" == typeof No && No
                 },
-                Wo = (globalThis, Go.window || Go.self || Go.global),
-                Ho = Go.process || {};
+                Uo = (globalThis, Vo.window || Vo.self || Vo.global),
+                Go = Vo.process || {};
 
-            function Zo() {
+            function Wo() {
                 let t;
                 var e, n;
-                if (jo && "performance" in Wo) t = null == Wo || null === (e = Wo.performance) || void 0 === e || null === (n = e.now) || void 0 === n ? void 0 : n.call(e);
-                else if ("hrtime" in Ho) {
+                if (Ro && "performance" in Uo) t = null == Uo || null === (e = Uo.performance) || void 0 === e || null === (n = e.now) || void 0 === n ? void 0 : n.call(e);
+                else if ("hrtime" in Go) {
                     var i;
-                    const e = null == Ho || null === (i = Ho.hrtime) || void 0 === i ? void 0 : i.call(Ho);
+                    const e = null == Go || null === (i = Go.hrtime) || void 0 === i ? void 0 : i.call(Go);
                     t = 1e3 * e[0] + e[1] / 1e6
                 } else t = Date.now();
                 return t
             }
             console;
-            const qo = {
-                    debug: jo && console.debug || console.log,
+            const Ho = {
+                    debug: Ro && console.debug || console.log,
                     log: console.log,
                     info: console.info,
                     warn: console.warn,
                     error: console.error
                 },
-                Xo = {
+                Zo = {
                     enabled: !0,
                     level: 0
                 };
 
-            function Yo() {}
-            const Ko = {},
-                Qo = {
+            function qo() {}
+            const Xo = {},
+                Yo = {
                     once: !0
                 };
-            class Jo {
+            class Ko {
                 constructor() {
                     let {
                         id: t
                     } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                         id: ""
                     };
-                    wo(this, "id", void 0), wo(this, "VERSION", Fo), wo(this, "_startTs", Zo()), wo(this, "_deltaTs", Zo()), wo(this, "_storage", void 0), wo(this, "userData", {}), wo(this, "LOG_THROTTLE_TIMEOUT", 0), this.id = t, this.userData = {}, this._storage = new zo("__probe-".concat(this.id, "__"), Xo), this.timeStamp("".concat(this.id, " started")),
+                    wo(this, "id", void 0), wo(this, "VERSION", Io), wo(this, "_startTs", Wo()), wo(this, "_deltaTs", Wo()), wo(this, "_storage", void 0), wo(this, "userData", {}), wo(this, "LOG_THROTTLE_TIMEOUT", 0), this.id = t, this.userData = {}, this._storage = new jo("__probe-".concat(this.id, "__"), Zo), this.timeStamp("".concat(this.id, " started")),
                         function(t) {
                             let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ["constructor"];
                             const n = Object.getPrototypeOf(t),
                                 i = Object.getOwnPropertyNames(n);
                             for (const n of i) "function" == typeof t[n] && (e.find((t => n === t)) || (t[n] = t[n].bind(t)))
                         }(this), Object.seal(this)
                 }
@@ -6172,18 +6245,18 @@
                 isEnabled() {
                     return this._storage.config.enabled
                 }
                 getLevel() {
                     return this._storage.config.level
                 }
                 getTotal() {
-                    return Number((Zo() - this._startTs).toPrecision(10))
+                    return Number((Wo() - this._startTs).toPrecision(10))
                 }
                 getDelta() {
-                    return Number((Zo() - this._deltaTs).toPrecision(10))
+                    return Number((Wo() - this._deltaTs).toPrecision(10))
                 }
                 set priority(t) {
                     this.level = t
                 }
                 get priority() {
                     return this.level
                 }
@@ -6209,108 +6282,108 @@
                         [t]: e
                     })
                 }
                 settings() {
                     console.table ? console.table(this._storage.config) : console.log(this._storage.config)
                 }
                 assert(t, e) {
-                    Vo(t, e)
+                    Do(t, e)
                 }
                 warn(t) {
-                    return this._getLogFunction(0, t, qo.warn, arguments, Qo)
+                    return this._getLogFunction(0, t, Ho.warn, arguments, Yo)
                 }
                 error(t) {
-                    return this._getLogFunction(0, t, qo.error, arguments)
+                    return this._getLogFunction(0, t, Ho.error, arguments)
                 }
                 deprecated(t, e) {
                     return this.warn("`".concat(t, "` is deprecated and will be removed in a later version. Use `").concat(e, "` instead"))
                 }
                 removed(t, e) {
                     return this.error("`".concat(t, "` has been removed. Use `").concat(e, "` instead"))
                 }
                 probe(t, e) {
-                    return this._getLogFunction(t, e, qo.log, arguments, {
+                    return this._getLogFunction(t, e, Ho.log, arguments, {
                         time: !0,
                         once: !0
                     })
                 }
                 log(t, e) {
-                    return this._getLogFunction(t, e, qo.debug, arguments)
+                    return this._getLogFunction(t, e, Ho.debug, arguments)
                 }
                 info(t, e) {
                     return this._getLogFunction(t, e, console.info, arguments)
                 }
                 once(t, e) {
                     for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) i[r - 2] = arguments[r];
-                    return this._getLogFunction(t, e, qo.debug || qo.info, arguments, Qo)
+                    return this._getLogFunction(t, e, Ho.debug || Ho.info, arguments, Yo)
                 }
                 table(t, e, n) {
-                    return e ? this._getLogFunction(t, e, console.table || Yo, n && [n], {
-                        tag: ea(e)
-                    }) : Yo
+                    return e ? this._getLogFunction(t, e, console.table || qo, n && [n], {
+                        tag: $o(e)
+                    }) : qo
                 }
                 image(t) {
                     let {
                         logLevel: e,
                         priority: n,
                         image: i,
                         message: r = "",
                         scale: s = 1
                     } = t;
-                    return this._shouldLog(e || n) ? jo ? function(t) {
+                    return this._shouldLog(e || n) ? Ro ? function(t) {
                         let {
                             image: e,
                             message: n = "",
                             scale: i = 1
                         } = t;
                         if ("string" == typeof e) {
                             const t = new Image;
                             return t.onload = () => {
-                                const e = Bo(t, n, i);
+                                const e = Fo(t, n, i);
                                 console.log(...e)
-                            }, t.src = e, Yo
+                            }, t.src = e, qo
                         }
                         const r = e.nodeName || "";
-                        if ("img" === r.toLowerCase()) return console.log(...Bo(e, n, i)), Yo;
+                        if ("img" === r.toLowerCase()) return console.log(...Fo(e, n, i)), qo;
                         if ("canvas" === r.toLowerCase()) {
                             const t = new Image;
-                            return t.onload = () => console.log(...Bo(t, n, i)), t.src = e.toDataURL(), Yo
+                            return t.onload = () => console.log(...Fo(t, n, i)), t.src = e.toDataURL(), qo
                         }
-                        return Yo
+                        return qo
                     }({
                         image: i,
                         message: r,
                         scale: s
                     }) : function(t) {
                         let {
                             image: e,
                             message: n = "",
                             scale: i = 1
                         } = t;
-                        return console.warn("removed"), Yo
+                        return console.warn("removed"), qo
                     }({
                         image: i,
                         message: r,
                         scale: s
-                    }) : Yo
+                    }) : qo
                 }
                 time(t, e) {
                     return this._getLogFunction(t, e, console.time ? console.time : console.info)
                 }
                 timeEnd(t, e) {
                     return this._getLogFunction(t, e, console.timeEnd ? console.timeEnd : console.info)
                 }
                 timeStamp(t, e) {
-                    return this._getLogFunction(t, e, console.timeStamp || Yo)
+                    return this._getLogFunction(t, e, console.timeStamp || qo)
                 }
                 group(t, e) {
                     let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                         collapsed: !1
                     };
-                    const i = ta({
+                    const i = Jo({
                             logLevel: t,
                             message: e,
                             opts: n
                         }),
                         {
                             collapsed: r
                         } = n;
@@ -6319,159 +6392,155 @@
                 groupCollapsed(t, e) {
                     let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                     return this.group(t, e, Object.assign({}, n, {
                         collapsed: !0
                     }))
                 }
                 groupEnd(t) {
-                    return this._getLogFunction(t, "", console.groupEnd || Yo)
+                    return this._getLogFunction(t, "", console.groupEnd || qo)
                 }
                 withGroup(t, e, n) {
                     this.group(t, e)();
                     try {
                         n()
                     } finally {
                         this.groupEnd(t)()
                     }
                 }
                 trace() {
                     console.trace && console.trace()
                 }
                 _shouldLog(t) {
-                    return this.isEnabled() && this.getLevel() >= $o(t)
+                    return this.isEnabled() && this.getLevel() >= Qo(t)
                 }
                 _getLogFunction(t, e, n, i, r) {
                     if (this._shouldLog(t)) {
-                        r = ta({
+                        r = Jo({
                             logLevel: t,
                             message: e,
                             args: i,
                             opts: r
-                        }), Vo(n = n || r.method), r.total = this.getTotal(), r.delta = this.getDelta(), this._deltaTs = Zo();
+                        }), Do(n = n || r.method), r.total = this.getTotal(), r.delta = this.getDelta(), this._deltaTs = Wo();
                         const s = r.tag || r.message;
                         if (r.once) {
-                            if (Ko[s]) return Yo;
-                            Ko[s] = Zo()
+                            if (Xo[s]) return qo;
+                            Xo[s] = Wo()
                         }
                         return e = function(t, e, n) {
                             if ("string" == typeof e) {
                                 const o = n.time ? function(t) {
                                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 8;
                                     const n = Math.max(e - t.length, 0);
                                     return "".concat(" ".repeat(n)).concat(t)
                                 }(function(t) {
                                     let e;
                                     return e = t < 10 ? "".concat(t.toFixed(2), "ms") : t < 100 ? "".concat(t.toFixed(1), "ms") : t < 1e3 ? "".concat(t.toFixed(0), "ms") : "".concat((t / 1e3).toFixed(2), "s"), e
                                 }(n.total)) : "";
-                                i = e = n.time ? "".concat(t, ": ").concat(o, "  ").concat(e) : "".concat(t, ": ").concat(e), r = n.color, s = n.background, jo || "string" != typeof i || (r && (r = No(r), i = "[".concat(r, "m").concat(i, "[39m")), s && (r = No(s), i = "[".concat(s + 10, "m").concat(i, "[49m"))), e = i
+                                i = e = n.time ? "".concat(t, ": ").concat(o, "  ").concat(e) : "".concat(t, ": ").concat(e), r = n.color, s = n.background, Ro || "string" != typeof i || (r && (r = Bo(r), i = "[".concat(r, "m").concat(i, "[39m")), s && (r = Bo(s), i = "[".concat(s + 10, "m").concat(i, "[49m"))), e = i
                             }
                             var i, r, s;
                             return e
                         }(this.id, r.message, r), n.bind(console, e, ...r.args)
                     }
-                    return Yo
+                    return qo
                 }
             }
 
-            function $o(t) {
+            function Qo(t) {
                 if (!t) return 0;
                 let e;
                 switch (typeof t) {
                     case "number":
                         e = t;
                         break;
                     case "object":
                         e = t.logLevel || t.priority || 0;
                         break;
                     default:
                         return 0
                 }
-                return Vo(Number.isFinite(e) && e >= 0), e
+                return Do(Number.isFinite(e) && e >= 0), e
             }
 
-            function ta(t) {
+            function Jo(t) {
                 const {
                     logLevel: e,
                     message: n
                 } = t;
-                t.logLevel = $o(e);
+                t.logLevel = Qo(e);
                 const i = t.args ? Array.from(t.args) : [];
                 for (; i.length && i.shift() !== n;);
                 switch (typeof e) {
                     case "string":
                     case "function":
                         void 0 !== n && i.unshift(n), t.message = e;
                         break;
                     case "object":
                         Object.assign(t, e)
                 }
                 "function" == typeof t.message && (t.message = t.message());
                 const r = typeof t.message;
-                return Vo("string" === r || "object" === r), Object.assign(t, {
+                return Do("string" === r || "object" === r), Object.assign(t, {
                     args: i
                 }, t.opts)
             }
 
-            function ea(t) {
+            function $o(t) {
                 for (const e in t)
                     for (const n in t[e]) return n || "untitled";
                 return "empty"
             }
-            wo(Jo, "VERSION", Fo);
-            const na = new Jo({
+            wo(Ko, "VERSION", Io);
+            const ta = new Ko({
                 id: "deck"
             });
-            let ia = {};
+            let ea = {};
 
-            function ra(t) {
-                ia = t
+            function na(t, e, n, i) {
+                ta.level > 0 && ea[t] && ea[t].call(null, e, n, i)
             }
 
-            function sa(t, e, n, i) {
-                na.level > 0 && ia[t] && ia[t].call(null, e, n, i)
+            function ia(t, e = (() => !0)) {
+                return Array.isArray(t) ? ra(t, e, []) : e(t) ? [t] : []
             }
 
-            function oa(t, e = (() => !0)) {
-                return Array.isArray(t) ? aa(t, e, []) : e(t) ? [t] : []
-            }
-
-            function aa(t, e, n) {
+            function ra(t, e, n) {
                 let i = -1;
                 for (; ++i < t.length;) {
                     const r = t[i];
-                    Array.isArray(r) ? aa(r, e, n) : e(r) && n.push(r)
+                    Array.isArray(r) ? ra(r, e, n) : e(r) && n.push(r)
                 }
                 return n
             }
 
-            function la({
+            function sa({
                 target: t,
                 source: e,
                 start: n = 0,
                 count: i = 1
             }) {
                 const r = e.length,
                     s = i * r;
                 let o = 0;
                 for (let i = n; o < r; o++) t[i++] = e[o];
                 for (; o < s;) o < s - o ? (t.copyWithin(n + o, n, n + o), o *= 2) : (t.copyWithin(n + o, n, n + s - o), o = s);
                 return t
             }
-            var ca = n(4155);
+            var oa = n(4155);
 
-            function ha() {
+            function aa() {
                 let t;
                 if ("undefined" != typeof window && window.performance) t = window.performance.now();
-                else if (void 0 !== ca && ca.hrtime) {
-                    const e = ca.hrtime();
+                else if (void 0 !== oa && oa.hrtime) {
+                    const e = oa.hrtime();
                     t = 1e3 * e[0] + e[1] / 1e6
                 } else t = Date.now();
                 return t
             }
-            class ua {
+            class la {
                 constructor(t, e) {
                     wo(this, "name", void 0), wo(this, "type", void 0), wo(this, "sampleSize", 1), wo(this, "time", void 0), wo(this, "count", void 0), wo(this, "samples", void 0), wo(this, "lastTiming", void 0), wo(this, "lastSampleTime", void 0), wo(this, "lastSampleCount", void 0), wo(this, "_count", 0), wo(this, "_time", 0), wo(this, "_samples", 0), wo(this, "_startTime", 0), wo(this, "_timerPending", !1), this.name = t, this.type = e, this.reset()
                 }
                 setSampleSize(t) {
                     return this.sampleSize = t, this
                 }
                 incrementCount() {
@@ -6486,18 +6555,18 @@
                 subtractCount(t) {
                     return this._count -= t, this._samples++, this._checkSampling(), this
                 }
                 addTime(t) {
                     return this._time += t, this.lastTiming = t, this._samples++, this._checkSampling(), this
                 }
                 timeStart() {
-                    return this._startTime = ha(), this._timerPending = !0, this
+                    return this._startTime = aa(), this._timerPending = !0, this
                 }
                 timeEnd() {
-                    return this._timerPending ? (this.addTime(ha() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this
+                    return this._timerPending ? (this.addTime(aa() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this
                 }
                 getSampleAverageCount() {
                     return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0
                 }
                 getSampleAverageTime() {
                     return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0
                 }
@@ -6516,15 +6585,15 @@
                 reset() {
                     return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this
                 }
                 _checkSampling() {
                     this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0)
                 }
             }
-            class da {
+            class ca {
                 constructor(t) {
                     wo(this, "id", void 0), wo(this, "stats", {}), this.id = t.id, this.stats = {}, this._initializeStats(t.stats), Object.seal(this)
                 }
                 get(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "count";
                     return this._getOrCreate({
                         name: t,
@@ -6557,87 +6626,87 @@
                 }
                 _getOrCreate(t) {
                     if (!t || !t.name) return null;
                     const {
                         name: e,
                         type: n
                     } = t;
-                    return this.stats[e] || (this.stats[e] = t instanceof ua ? t : new ua(e, n)), this.stats[e]
+                    return this.stats[e] || (this.stats[e] = t instanceof la ? t : new la(e, n)), this.stats[e]
                 }
             }
-            const pa = t => "function" == typeof t,
-                fa = t => null !== t && "object" == typeof t,
-                ga = t => fa(t) && t.constructor === {}.constructor,
-                ma = t => t && "function" == typeof t[Symbol.iterator],
-                va = t => t && "function" == typeof t[Symbol.asyncIterator],
-                ba = t => "undefined" != typeof Response && t instanceof Response || t && t.arrayBuffer && t.text && t.json,
-                ya = t => "undefined" != typeof Blob && t instanceof Blob,
-                _a = t => t && "object" == typeof t && t.isBuffer,
-                xa = t => (t => "undefined" != typeof ReadableStream && t instanceof ReadableStream || fa(t) && pa(t.tee) && pa(t.cancel) && pa(t.getReader))(t) || (t => fa(t) && pa(t.read) && pa(t.pipe) && (t => "boolean" == typeof t)(t.readable))(t);
+            const ha = t => "function" == typeof t,
+                ua = t => null !== t && "object" == typeof t,
+                da = t => ua(t) && t.constructor === {}.constructor,
+                pa = t => t && "function" == typeof t[Symbol.iterator],
+                fa = t => t && "function" == typeof t[Symbol.asyncIterator],
+                ga = t => "undefined" != typeof Response && t instanceof Response || t && t.arrayBuffer && t.text && t.json,
+                ma = t => "undefined" != typeof Blob && t instanceof Blob,
+                va = t => t && "object" == typeof t && t.isBuffer,
+                ba = t => (t => "undefined" != typeof ReadableStream && t instanceof ReadableStream || ua(t) && ha(t.tee) && ha(t.cancel) && ha(t.getReader))(t) || (t => ua(t) && ha(t.read) && ha(t.pipe) && (t => "boolean" == typeof t)(t.readable))(t);
 
-            function wa(t, e) {
+            function ya(t, e) {
                 if (!t) throw new Error(e || "loader assertion failed.")
             }
 
-            function Ea(t) {
+            function _a(t) {
                 var e;
                 return !!t && (Array.isArray(t) && (t = t[0]), Array.isArray(null === (e = t) || void 0 === e ? void 0 : e.extensions))
             }
 
-            function Pa(t) {
+            function xa(t) {
                 var e, n;
                 let i;
-                return wa(t, "null loader"), wa(Ea(t), "invalid loader"), Array.isArray(t) && (i = t[1], t = t[0], t = {
+                return ya(t, "null loader"), ya(_a(t), "invalid loader"), Array.isArray(t) && (i = t[1], t = t[0], t = {
                     ...t,
                     options: {
                         ...t.options,
                         ...i
                     }
                 }), (null !== (e = t) && void 0 !== e && e.parseTextSync || null !== (n = t) && void 0 !== n && n.parseText) && (t.text = !0), t.text || (t.binary = !0), t
             }
-            let Sa = "";
-            const Ca = {},
-                Ta = /^data:([-\w.]+\/[-\w.+]+)(;|,)/,
-                Aa = /^([-\w.]+\/[-\w.+]+)/;
+            let wa = "";
+            const Ea = {},
+                Pa = /^data:([-\w.]+\/[-\w.+]+)(;|,)/,
+                Sa = /^([-\w.]+\/[-\w.+]+)/;
 
-            function Ma(t) {
-                const e = Ta.exec(t);
+            function Ca(t) {
+                const e = Pa.exec(t);
                 return e ? e[1] : ""
             }
-            const Oa = /\?.*/;
+            const Ta = /\?.*/;
 
-            function La(t) {
-                return t.replace(Oa, "")
+            function Aa(t) {
+                return t.replace(Ta, "")
             }
 
-            function Ra(t) {
-                return ba(t) ? t.url : ya(t) ? t.name || "" : "string" == typeof t ? t : ""
+            function Ma(t) {
+                return ga(t) ? t.url : ma(t) ? t.name || "" : "string" == typeof t ? t : ""
             }
 
-            function Ia(t) {
-                if (ba(t)) {
+            function Oa(t) {
+                if (ga(t)) {
                     const e = t,
                         n = e.headers.get("content-type") || "",
-                        i = La(e.url);
+                        i = Aa(e.url);
                     return function(t) {
-                        const e = Aa.exec(t);
+                        const e = Sa.exec(t);
                         return e ? e[1] : t
-                    }(n) || Ma(i)
+                    }(n) || Ca(i)
                 }
-                return ya(t) ? t.type || "" : "string" == typeof t ? Ma(t) : ""
+                return ma(t) ? t.type || "" : "string" == typeof t ? Ca(t) : ""
             }
-            async function ka(t) {
-                if (ba(t)) return t;
+            async function La(t) {
+                if (ga(t)) return t;
                 const e = {},
                     n = function(t) {
-                        return ba(t) ? t.headers["content-length"] || -1 : ya(t) ? t.size : "string" == typeof t ? t.length : t instanceof ArrayBuffer || ArrayBuffer.isView(t) ? t.byteLength : -1
+                        return ga(t) ? t.headers["content-length"] || -1 : ma(t) ? t.size : "string" == typeof t ? t.length : t instanceof ArrayBuffer || ArrayBuffer.isView(t) ? t.byteLength : -1
                     }(t);
                 n >= 0 && (e["content-length"] = String(n));
-                const i = Ra(t),
-                    r = Ia(t);
+                const i = Ma(t),
+                    r = Oa(t);
                 r && (e["content-type"] = r);
                 const s = await async function(t) {
                     if ("string" == typeof t) return "data:,".concat(t.slice(0, 5));
                     if (t instanceof Blob) {
                         const e = t.slice(0, 5);
                         return await new Promise((t => {
                             const n = new FileReader;
@@ -6662,42 +6731,42 @@
                 const o = new Response(t, {
                     headers: e
                 });
                 return Object.defineProperty(o, "url", {
                     value: i
                 }), o
             }
-            async function ja(t, e) {
+            async function ka(t, e) {
                 if ("string" == typeof t) {
                     t = function(t) {
-                        for (const e in Ca)
+                        for (const e in Ea)
                             if (t.startsWith(e)) {
-                                const n = Ca[e];
+                                const n = Ea[e];
                                 t = t.replace(e, n)
-                            } return t.startsWith("http://") || t.startsWith("https://") || (t = "".concat(Sa).concat(t)), t
+                            } return t.startsWith("http://") || t.startsWith("https://") || (t = "".concat(wa).concat(t)), t
                     }(t);
                     let n = e;
                     return null != e && e.fetch && "function" != typeof(null == e ? void 0 : e.fetch) && (n = e.fetch), await fetch(t, n)
                 }
-                return await ka(t)
+                return await La(t)
             }
-            var Fa = n(4155),
-                za = n(4155);
+            var Ra = n(4155),
+                Ia = n(4155);
 
-            function Ba() {
-                return !("object" == typeof za && "[object process]" === String(za) && !za.browser) || function(t) {
+            function ja() {
+                return !("object" == typeof Ia && "[object process]" === String(Ia) && !Ia.browser) || function(t) {
                     if ("undefined" != typeof window && "object" == typeof window.process && "renderer" === window.process.type) return !0;
-                    if (void 0 !== Fa && "object" == typeof Fa.versions && Boolean(Fa.versions.electron)) return !0;
+                    if (void 0 !== Ra && "object" == typeof Ra.versions && Boolean(Ra.versions.electron)) return !0;
                     const e = "object" == typeof navigator && "string" == typeof navigator.userAgent && navigator.userAgent;
                     return !!(e && e.indexOf("Electron") >= 0)
                 }()
             }
-            const Da = "undefined" != typeof __VERSION__ ? __VERSION__ : "untranspiled source";
-            Ba();
-            class Na {
+            const Fa = "undefined" != typeof __VERSION__ ? __VERSION__ : "untranspiled source";
+            ja();
+            class za {
                 constructor(t, e) {
                     let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "sessionStorage";
                     wo(this, "storage", void 0), wo(this, "id", void 0), wo(this, "config", void 0), this.storage = function(t) {
                         try {
                             const e = window[t],
                                 n = "__storage_test__";
                             return e.setItem(n, n), e.removeItem(n), e
@@ -6721,76 +6790,76 @@
                         const e = this.storage.getItem(this.id);
                         t = e ? JSON.parse(e) : {}
                     }
                     return Object.assign(this.config, t), this
                 }
             }
 
-            function Va(t, e, n) {
+            function Ba(t, e, n) {
                 let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 600;
                 const r = t.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
                 t.width > i && (n = Math.min(n, i / t.width));
                 const s = t.width * n,
                     o = t.height * n,
                     a = ["font-size:1px;", "padding:".concat(Math.floor(o / 2), "px ").concat(Math.floor(s / 2), "px;"), "line-height:".concat(o, "px;"), "background:url(".concat(r, ");"), "background-size:".concat(s, "px ").concat(o, "px;"), "color:transparent;"].join("");
                 return ["".concat(e, " %c+"), a]
             }
-            let Ua;
+            let Da;
             ! function(t) {
                 t[t.BLACK = 30] = "BLACK", t[t.RED = 31] = "RED", t[t.GREEN = 32] = "GREEN", t[t.YELLOW = 33] = "YELLOW", t[t.BLUE = 34] = "BLUE", t[t.MAGENTA = 35] = "MAGENTA", t[t.CYAN = 36] = "CYAN", t[t.WHITE = 37] = "WHITE", t[t.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", t[t.BRIGHT_RED = 91] = "BRIGHT_RED", t[t.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", t[t.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", t[t.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", t[t.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", t[t.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", t[t.BRIGHT_WHITE = 97] = "BRIGHT_WHITE"
-            }(Ua || (Ua = {}));
+            }(Da || (Da = {}));
 
-            function Ga(t) {
-                return "string" != typeof t ? t : (t = t.toUpperCase(), Ua[t] || Ua.WHITE)
+            function Na(t) {
+                return "string" != typeof t ? t : (t = t.toUpperCase(), Da[t] || Da.WHITE)
             }
 
-            function Wa(t, e) {
+            function Va(t, e) {
                 if (!t) throw new Error(e || "Assertion failed")
             }
             globalThis, globalThis.self || globalThis.window || globalThis.global;
-            const Ha = globalThis.window || globalThis.self || globalThis.global,
-                Za = (globalThis.document, globalThis.process || {});
+            const Ua = globalThis.window || globalThis.self || globalThis.global,
+                Ga = (globalThis.document, globalThis.process || {});
 
-            function qa() {
+            function Wa() {
                 let t;
                 var e, n;
-                if (Ba() && Ha.performance) t = null == Ha || null === (e = Ha.performance) || void 0 === e || null === (n = e.now) || void 0 === n ? void 0 : n.call(e);
-                else if ("hrtime" in Za) {
+                if (ja() && Ua.performance) t = null == Ua || null === (e = Ua.performance) || void 0 === e || null === (n = e.now) || void 0 === n ? void 0 : n.call(e);
+                else if ("hrtime" in Ga) {
                     var i;
-                    const e = null == Za || null === (i = Za.hrtime) || void 0 === i ? void 0 : i.call(Za);
+                    const e = null == Ga || null === (i = Ga.hrtime) || void 0 === i ? void 0 : i.call(Ga);
                     t = 1e3 * e[0] + e[1] / 1e6
                 } else t = Date.now();
                 return t
             }
             globalThis.console, globalThis.navigator;
-            const Xa = {
-                    debug: Ba() && console.debug || console.log,
+            const Ha = {
+                    debug: ja() && console.debug || console.log,
                     log: console.log,
                     info: console.info,
                     warn: console.warn,
                     error: console.error
                 },
-                Ya = {
+                Za = {
                     enabled: !0,
                     level: 0
                 };
 
-            function Ka() {}
-            const Qa = {},
-                Ja = {
+            function qa() {}
+            const Xa = {},
+                Ya = {
                     once: !0
                 };
-            class $a {
+            class Ka {
                 constructor() {
                     let {
                         id: t
                     } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                         id: ""
                     };
-                    wo(this, "id", void 0), wo(this, "VERSION", Da), wo(this, "_startTs", qa()), wo(this, "_deltaTs", qa()), wo(this, "_storage", void 0), wo(this, "userData", {}), wo(this, "LOG_THROTTLE_TIMEOUT", 0), this.id = t, this.userData = {}, this._storage = new Na("__probe-".concat(this.id, "__"), Ya), this.timeStamp("".concat(this.id, " started")),
+                    wo(this, "id", void 0), wo(this, "VERSION", Fa), wo(this, "_startTs", Wa()), wo(this, "_deltaTs", Wa()), wo(this, "_storage", void 0), wo(this, "userData", {}), wo(this, "LOG_THROTTLE_TIMEOUT", 0), this.id = t, this.userData = {}, this._storage = new za("__probe-".concat(this.id, "__"), Za), this.timeStamp("".concat(this.id, " started")),
                         function(t) {
                             let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ["constructor"];
                             const n = Object.getPrototypeOf(t),
                                 i = Object.getOwnPropertyNames(n),
                                 r = t;
                             for (const n of i) {
                                 const i = r[n];
@@ -6807,18 +6876,18 @@
                 isEnabled() {
                     return this._storage.config.enabled
                 }
                 getLevel() {
                     return this._storage.config.level
                 }
                 getTotal() {
-                    return Number((qa() - this._startTs).toPrecision(10))
+                    return Number((Wa() - this._startTs).toPrecision(10))
                 }
                 getDelta() {
-                    return Number((qa() - this._deltaTs).toPrecision(10))
+                    return Number((Wa() - this._deltaTs).toPrecision(10))
                 }
                 set priority(t) {
                     this.level = t
                 }
                 get priority() {
                     return this.level
                 }
@@ -6844,107 +6913,107 @@
                         [t]: e
                     })
                 }
                 settings() {
                     console.table ? console.table(this._storage.config) : console.log(this._storage.config)
                 }
                 assert(t, e) {
-                    Wa(t, e)
+                    Va(t, e)
                 }
                 warn(t) {
-                    return this._getLogFunction(0, t, Xa.warn, arguments, Ja)
+                    return this._getLogFunction(0, t, Ha.warn, arguments, Ya)
                 }
                 error(t) {
-                    return this._getLogFunction(0, t, Xa.error, arguments)
+                    return this._getLogFunction(0, t, Ha.error, arguments)
                 }
                 deprecated(t, e) {
                     return this.warn("`".concat(t, "` is deprecated and will be removed in a later version. Use `").concat(e, "` instead"))
                 }
                 removed(t, e) {
                     return this.error("`".concat(t, "` has been removed. Use `").concat(e, "` instead"))
                 }
                 probe(t, e) {
-                    return this._getLogFunction(t, e, Xa.log, arguments, {
+                    return this._getLogFunction(t, e, Ha.log, arguments, {
                         time: !0,
                         once: !0
                     })
                 }
                 log(t, e) {
-                    return this._getLogFunction(t, e, Xa.debug, arguments)
+                    return this._getLogFunction(t, e, Ha.debug, arguments)
                 }
                 info(t, e) {
                     return this._getLogFunction(t, e, console.info, arguments)
                 }
                 once(t, e) {
-                    return this._getLogFunction(t, e, Xa.debug || Xa.info, arguments, Ja)
+                    return this._getLogFunction(t, e, Ha.debug || Ha.info, arguments, Ya)
                 }
                 table(t, e, n) {
-                    return e ? this._getLogFunction(t, e, console.table || Ka, n && [n], {
-                        tag: nl(e)
-                    }) : Ka
+                    return e ? this._getLogFunction(t, e, console.table || qa, n && [n], {
+                        tag: $a(e)
+                    }) : qa
                 }
                 image(t) {
                     let {
                         logLevel: e,
                         priority: n,
                         image: i,
                         message: r = "",
                         scale: s = 1
                     } = t;
-                    return this._shouldLog(e || n) ? Ba() ? function(t) {
+                    return this._shouldLog(e || n) ? ja() ? function(t) {
                         let {
                             image: e,
                             message: n = "",
                             scale: i = 1
                         } = t;
                         if ("string" == typeof e) {
                             const t = new Image;
                             return t.onload = () => {
-                                const e = Va(t, n, i);
+                                const e = Ba(t, n, i);
                                 console.log(...e)
-                            }, t.src = e, Ka
+                            }, t.src = e, qa
                         }
                         const r = e.nodeName || "";
-                        if ("img" === r.toLowerCase()) return console.log(...Va(e, n, i)), Ka;
+                        if ("img" === r.toLowerCase()) return console.log(...Ba(e, n, i)), qa;
                         if ("canvas" === r.toLowerCase()) {
                             const t = new Image;
-                            return t.onload = () => console.log(...Va(t, n, i)), t.src = e.toDataURL(), Ka
+                            return t.onload = () => console.log(...Ba(t, n, i)), t.src = e.toDataURL(), qa
                         }
-                        return Ka
+                        return qa
                     }({
                         image: i,
                         message: r,
                         scale: s
                     }) : function(t) {
                         let {
                             image: e,
                             message: n = "",
                             scale: i = 1
                         } = t;
-                        return console.warn("removed"), Ka
+                        return console.warn("removed"), qa
                     }({
                         image: i,
                         message: r,
                         scale: s
-                    }) : Ka
+                    }) : qa
                 }
                 time(t, e) {
                     return this._getLogFunction(t, e, console.time ? console.time : console.info)
                 }
                 timeEnd(t, e) {
                     return this._getLogFunction(t, e, console.timeEnd ? console.timeEnd : console.info)
                 }
                 timeStamp(t, e) {
-                    return this._getLogFunction(t, e, console.timeStamp || Ka)
+                    return this._getLogFunction(t, e, console.timeStamp || qa)
                 }
                 group(t, e) {
                     let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                         collapsed: !1
                     };
-                    const i = el({
+                    const i = Ja({
                             logLevel: t,
                             message: e,
                             opts: n
                         }),
                         {
                             collapsed: r
                         } = n;
@@ -6953,141 +7022,141 @@
                 groupCollapsed(t, e) {
                     let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                     return this.group(t, e, Object.assign({}, n, {
                         collapsed: !0
                     }))
                 }
                 groupEnd(t) {
-                    return this._getLogFunction(t, "", console.groupEnd || Ka)
+                    return this._getLogFunction(t, "", console.groupEnd || qa)
                 }
                 withGroup(t, e, n) {
                     this.group(t, e)();
                     try {
                         n()
                     } finally {
                         this.groupEnd(t)()
                     }
                 }
                 trace() {
                     console.trace && console.trace()
                 }
                 _shouldLog(t) {
-                    return this.isEnabled() && this.getLevel() >= tl(t)
+                    return this.isEnabled() && this.getLevel() >= Qa(t)
                 }
                 _getLogFunction(t, e, n, i, r) {
                     if (this._shouldLog(t)) {
-                        r = el({
+                        r = Ja({
                             logLevel: t,
                             message: e,
                             args: i,
                             opts: r
-                        }), Wa(n = n || r.method), r.total = this.getTotal(), r.delta = this.getDelta(), this._deltaTs = qa();
+                        }), Va(n = n || r.method), r.total = this.getTotal(), r.delta = this.getDelta(), this._deltaTs = Wa();
                         const s = r.tag || r.message;
                         if (r.once && s) {
-                            if (Qa[s]) return Ka;
-                            Qa[s] = qa()
+                            if (Xa[s]) return qa;
+                            Xa[s] = Wa()
                         }
                         return e = function(t, e, n) {
                             if ("string" == typeof e) {
                                 const i = n.time ? function(t) {
                                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 8;
                                     const n = Math.max(e - t.length, 0);
                                     return "".concat(" ".repeat(n)).concat(t)
                                 }(function(t) {
                                     let e;
                                     return e = t < 10 ? "".concat(t.toFixed(2), "ms") : t < 100 ? "".concat(t.toFixed(1), "ms") : t < 1e3 ? "".concat(t.toFixed(0), "ms") : "".concat((t / 1e3).toFixed(2), "s"), e
                                 }(n.total)) : "";
                                 e = function(t, e, n) {
-                                    if (!Ba && "string" == typeof t) {
+                                    if (!ja && "string" == typeof t) {
                                         if (e) {
-                                            const n = Ga(e);
+                                            const n = Na(e);
                                             t = "[".concat(n, "m").concat(t, "[39m")
                                         }
                                         if (n) {
-                                            const e = Ga(n);
+                                            const e = Na(n);
                                             t = "[".concat(e + 10, "m").concat(t, "[49m")
                                         }
                                     }
                                     return t
                                 }(e = n.time ? "".concat(t, ": ").concat(i, "  ").concat(e) : "".concat(t, ": ").concat(e), n.color, n.background)
                             }
                             return e
                         }(this.id, r.message, r), n.bind(console, e, ...r.args)
                     }
-                    return Ka
+                    return qa
                 }
             }
 
-            function tl(t) {
+            function Qa(t) {
                 if (!t) return 0;
                 let e;
                 switch (typeof t) {
                     case "number":
                         e = t;
                         break;
                     case "object":
                         e = t.logLevel || t.priority || 0;
                         break;
                     default:
                         return 0
                 }
-                return Wa(Number.isFinite(e) && e >= 0), e
+                return Va(Number.isFinite(e) && e >= 0), e
             }
 
-            function el(t) {
+            function Ja(t) {
                 const {
                     logLevel: e,
                     message: n
                 } = t;
-                t.logLevel = tl(e);
+                t.logLevel = Qa(e);
                 const i = t.args ? Array.from(t.args) : [];
                 for (; i.length && i.shift() !== n;);
                 switch (typeof e) {
                     case "string":
                     case "function":
                         void 0 !== n && i.unshift(n), t.message = e;
                         break;
                     case "object":
                         Object.assign(t, e)
                 }
                 "function" == typeof t.message && (t.message = t.message());
                 const r = typeof t.message;
-                return Wa("string" === r || "object" === r), Object.assign(t, {
+                return Va("string" === r || "object" === r), Object.assign(t, {
                     args: i
                 }, t.opts)
             }
 
-            function nl(t) {
+            function $a(t) {
                 for (const e in t)
                     for (const n in t[e]) return n || "untitled";
                 return "empty"
             }
-            wo($a, "VERSION", Da);
-            const il = new $a({
+            wo(Ka, "VERSION", Fa);
+            const tl = new Ka({
                 id: "loaders.gl"
             });
-            class rl {
+            class el {
                 log() {
                     return () => {}
                 }
                 info() {
                     return () => {}
                 }
                 warn() {
                     return () => {}
                 }
                 error() {
                     return () => {}
                 }
             }
-            var sl = n(4155);
+            var nl = n(4155);
             "undefined" != typeof self && self, "undefined" != typeof window && window, void 0 !== n.g && n.g, "undefined" != typeof document && document;
-            const ol = Boolean("object" != typeof sl || "[object process]" !== String(sl) || sl.browser),
-                al = void 0 !== sl && sl.version && /v([0-9]*)/.exec(sl.version),
-                ll = (al && parseFloat(al[1]), {
+            const il = Boolean("object" != typeof nl || "[object process]" !== String(nl) || nl.browser),
+                rl = void 0 !== nl && nl.version && /v([0-9]*)/.exec(nl.version),
+                sl = (rl && parseFloat(rl[1]), {
                     fetch: null,
                     mimeType: void 0,
                     nothrow: !1,
                     log: new class {
                         constructor() {
                             wo(this, "console", void 0), this.console = console
                         }
@@ -7108,25 +7177,25 @@
                             return this.console.error.bind(this.console, ...e)
                         }
                     },
                     CDN: "https://unpkg.com/@loaders.gl",
                     worker: !0,
                     maxConcurrency: 3,
                     maxMobileConcurrency: 1,
-                    reuseWorkers: ol,
+                    reuseWorkers: il,
                     _nodeWorkers: !1,
                     _workerType: "",
                     limit: 0,
                     _limitMB: 0,
                     batchSize: "auto",
                     batchDebounceMs: 0,
                     metadata: !1,
                     transforms: []
                 }),
-                cl = {
+                ol = {
                     throws: "nothrow",
                     dataType: "(no longer used)",
                     uri: "baseUri",
                     method: "fetch.method",
                     headers: "fetch.headers",
                     body: "fetch.body",
                     mode: "fetch.mode",
@@ -7136,161 +7205,161 @@
                     referrer: "fetch.referrer",
                     referrerPolicy: "fetch.referrerPolicy",
                     integrity: "fetch.integrity",
                     keepalive: "fetch.keepalive",
                     signal: "fetch.signal"
                 };
 
-            function hl() {
+            function al() {
                 globalThis.loaders = globalThis.loaders || {};
                 const {
                     loaders: t
                 } = globalThis;
                 return t._state = t._state || {}, t._state
             }
-            const ul = () => {
-                const t = hl();
+            const ll = () => {
+                const t = al();
                 return t.globalOptions = t.globalOptions || {
-                    ...ll
+                    ...sl
                 }, t.globalOptions
             };
 
-            function dl(t, e, n, i) {
+            function cl(t, e, n, i) {
                 return n = n || [],
                     function(t, e) {
-                        pl(t, null, ll, cl, e);
+                        hl(t, null, sl, ol, e);
                         for (const n of e) {
                             const i = t && t[n.id] || {},
                                 r = n.options && n.options[n.id] || {},
                                 s = n.deprecatedOptions && n.deprecatedOptions[n.id] || {};
-                            pl(i, n.id, r, s, e)
+                            hl(i, n.id, r, s, e)
                         }
                     }(t, n = Array.isArray(n) ? n : [n]),
                     function(t, e, n) {
                         const i = {
                             ...t.options || {}
                         };
                         return function(t, e) {
                             e && !("baseUri" in t) && (t.baseUri = e)
-                        }(i, n), null === i.log && (i.log = new rl), gl(i, ul()), gl(i, e), i
+                        }(i, n), null === i.log && (i.log = new el), dl(i, ll()), dl(i, e), i
                     }(e, t, i)
             }
 
-            function pl(t, e, n, i, r) {
+            function hl(t, e, n, i, r) {
                 const s = e || "Top level",
                     o = e ? "".concat(e, ".") : "";
                 for (const a in t) {
-                    const l = !e && fa(t[a]);
+                    const l = !e && ua(t[a]);
                     if (!(a in n) && ("baseUri" !== a || e) && ("workerUrl" !== a || !e))
-                        if (a in i) il.warn("".concat(s, " loader option '").concat(o).concat(a, "' no longer supported, use '").concat(i[a], "'"))();
+                        if (a in i) tl.warn("".concat(s, " loader option '").concat(o).concat(a, "' no longer supported, use '").concat(i[a], "'"))();
                         else if (!l) {
-                        const t = fl(a, r);
-                        il.warn("".concat(s, " loader option '").concat(o).concat(a, "' not recognized. ").concat(t))()
+                        const t = ul(a, r);
+                        tl.warn("".concat(s, " loader option '").concat(o).concat(a, "' not recognized. ").concat(t))()
                     }
                 }
             }
 
-            function fl(t, e) {
+            function ul(t, e) {
                 const n = t.toLowerCase();
                 let i = "";
                 for (const r of e)
                     for (const e in r.options) {
                         if (t === e) return "Did you mean '".concat(r.id, ".").concat(e, "'?");
                         const s = e.toLowerCase();
                         (n.startsWith(s) || s.startsWith(n)) && (i = i || "Did you mean '".concat(r.id, ".").concat(e, "'?"))
                     }
                 return i
             }
 
-            function gl(t, e) {
+            function dl(t, e) {
                 for (const n in e)
                     if (n in e) {
                         const i = e[n];
-                        ga(i) && ga(t[n]) ? t[n] = {
+                        da(i) && da(t[n]) ? t[n] = {
                             ...t[n],
                             ...e[n]
                         } : t[n] = e[n]
                     }
             }
 
-            function ml(t, e) {
-                const n = ul(),
+            function pl(t, e) {
+                const n = ll(),
                     i = t || n;
-                return "function" == typeof i.fetch ? i.fetch : fa(i.fetch) ? t => ja(t, i) : null != e && e.fetch ? null == e ? void 0 : e.fetch : ja
+                return "function" == typeof i.fetch ? i.fetch : ua(i.fetch) ? t => ka(t, i) : null != e && e.fetch ? null == e ? void 0 : e.fetch : ka
             }
 
-            function vl(t, e) {
+            function fl(t, e) {
                 if (!t) throw new Error(e || "loaders.gl assertion failed.")
             }
-            var bl = n(4155);
+            var gl = n(4155);
             "undefined" != typeof self && self, "undefined" != typeof window && window, void 0 !== n.g && n.g, "undefined" != typeof document && document;
-            const yl = "object" != typeof bl || "[object process]" !== String(bl) || bl.browser,
-                _l = "undefined" != typeof window && void 0 !== window.orientation,
-                xl = void 0 !== bl && bl.version && /v([0-9]*)/.exec(bl.version);
-            xl && parseFloat(xl[1]);
-            class wl {
+            const ml = "object" != typeof gl || "[object process]" !== String(gl) || gl.browser,
+                vl = "undefined" != typeof window && void 0 !== window.orientation,
+                bl = void 0 !== gl && gl.version && /v([0-9]*)/.exec(gl.version);
+            bl && parseFloat(bl[1]);
+            class yl {
                 terminate() {}
             }
-            const El = new Map;
+            const _l = new Map;
 
-            function Pl(t) {
+            function xl(t) {
                 const e = new Blob([t], {
                     type: "application/javascript"
                 });
                 return URL.createObjectURL(e)
             }
 
-            function Sl(t) {
+            function wl(t) {
                 let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                     n = arguments.length > 2 ? arguments[2] : void 0;
                 const i = n || new Set;
                 if (t)
-                    if (Cl(t)) i.add(t);
-                    else if (Cl(t.buffer)) i.add(t.buffer);
+                    if (El(t)) i.add(t);
+                    else if (El(t.buffer)) i.add(t.buffer);
                 else if (ArrayBuffer.isView(t));
                 else if (e && "object" == typeof t)
-                    for (const n in t) Sl(t[n], e, i);
+                    for (const n in t) wl(t[n], e, i);
                 return void 0 === n ? Array.from(i) : []
             }
 
-            function Cl(t) {
+            function El(t) {
                 return !!t && (t instanceof ArrayBuffer || "undefined" != typeof MessagePort && t instanceof MessagePort || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas)
             }
-            const Tl = () => {};
-            class Al {
+            const Pl = () => {};
+            class Sl {
                 static isSupported() {
-                    return "undefined" != typeof Worker && yl || void 0 !== wl && !yl
+                    return "undefined" != typeof Worker && ml || void 0 !== yl && !ml
                 }
                 constructor(t) {
                     wo(this, "name", void 0), wo(this, "source", void 0), wo(this, "url", void 0), wo(this, "terminated", !1), wo(this, "worker", void 0), wo(this, "onMessage", void 0), wo(this, "onError", void 0), wo(this, "_loadableURL", "");
                     const {
                         name: e,
                         source: n,
                         url: i
                     } = t;
-                    vl(n || i), this.name = e, this.source = n, this.url = i, this.onMessage = Tl, this.onError = t => console.log(t), this.worker = yl ? this._createBrowserWorker() : this._createNodeWorker()
+                    fl(n || i), this.name = e, this.source = n, this.url = i, this.onMessage = Pl, this.onError = t => console.log(t), this.worker = ml ? this._createBrowserWorker() : this._createNodeWorker()
                 }
                 destroy() {
-                    this.onMessage = Tl, this.onError = Tl, this.worker.terminate(), this.terminated = !0
+                    this.onMessage = Pl, this.onError = Pl, this.worker.terminate(), this.terminated = !0
                 }
                 get isRunning() {
                     return Boolean(this.onMessage)
                 }
                 postMessage(t, e) {
-                    e = e || Sl(t), this.worker.postMessage(t, e)
+                    e = e || wl(t), this.worker.postMessage(t, e)
                 }
                 _getErrorFromErrorEvent(t) {
                     let e = "Failed to load ";
                     return e += "worker ".concat(this.name, " from ").concat(this.url, ". "), t.message && (e += "".concat(t.message, " in ")), t.lineno && (e += ":".concat(t.lineno, ":").concat(t.colno)), new Error(e)
                 }
                 _createBrowserWorker() {
                     this._loadableURL = function(t) {
-                        vl(t.source && !t.url || !t.source && t.url);
-                        let e = El.get(t.source || t.url);
-                        return e || (t.url && (e = (n = t.url).startsWith("http") ? Pl("try {\n  importScripts('".concat(n, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}")) : n, El.set(t.url, e)), t.source && (e = Pl(t.source), El.set(t.source, e))), vl(e), e;
+                        fl(t.source && !t.url || !t.source && t.url);
+                        let e = _l.get(t.source || t.url);
+                        return e || (t.url && (e = (n = t.url).startsWith("http") ? xl("try {\n  importScripts('".concat(n, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}")) : n, _l.set(t.url, e)), t.source && (e = xl(t.source), _l.set(t.source, e))), fl(e), e;
                         var n
                     }({
                         source: this.source,
                         url: this.url
                     });
                     const t = new Worker(this._loadableURL, {
                         name: this.name
@@ -7301,53 +7370,53 @@
                         this.onError(this._getErrorFromErrorEvent(t)), this.terminated = !0
                     }, t.onmessageerror = t => console.error(t), t
                 }
                 _createNodeWorker() {
                     let t;
                     if (this.url) {
                         const e = this.url.includes(":/") || this.url.startsWith("/") ? this.url : "./".concat(this.url);
-                        t = new wl(e, {
+                        t = new yl(e, {
                             eval: !1
                         })
                     } else {
                         if (!this.source) throw new Error("no worker");
-                        t = new wl(this.source, {
+                        t = new yl(this.source, {
                             eval: !0
                         })
                     }
                     return t.on("message", (t => {
                         this.onMessage(t)
                     })), t.on("error", (t => {
                         this.onError(t)
                     })), t.on("exit", (t => {})), t
                 }
             }
-            class Ml {
+            class Cl {
                 constructor(t, e) {
                     wo(this, "name", void 0), wo(this, "workerThread", void 0), wo(this, "isRunning", !0), wo(this, "result", void 0), wo(this, "_resolve", (() => {})), wo(this, "_reject", (() => {})), this.name = t, this.workerThread = e, this.result = new Promise(((t, e) => {
                         this._resolve = t, this._reject = e
                     }))
                 }
                 postMessage(t, e) {
                     this.workerThread.postMessage({
                         source: "loaders.gl",
                         type: t,
                         payload: e
                     })
                 }
                 done(t) {
-                    vl(this.isRunning), this.isRunning = !1, this._resolve(t)
+                    fl(this.isRunning), this.isRunning = !1, this._resolve(t)
                 }
                 error(t) {
-                    vl(this.isRunning), this.isRunning = !1, this._reject(t)
+                    fl(this.isRunning), this.isRunning = !1, this._reject(t)
                 }
             }
-            class Ol {
+            class Tl {
                 static isSupported() {
-                    return Al.isSupported()
+                    return Sl.isSupported()
                 }
                 constructor(t) {
                     wo(this, "name", "unnamed"), wo(this, "source", void 0), wo(this, "url", void 0), wo(this, "maxConcurrency", 1), wo(this, "maxMobileConcurrency", 1), wo(this, "onDebug", (() => {})), wo(this, "reuseWorkers", !0), wo(this, "props", {}), wo(this, "jobQueue", []), wo(this, "idleQueue", []), wo(this, "count", 0), wo(this, "isDestroyed", !1), this.source = t.source, this.url = t.url, this.setProps(t)
                 }
                 destroy() {
                     this.idleQueue.forEach((t => t.destroy())), this.isDestroyed = !0
                 }
@@ -7376,15 +7445,15 @@
                     if (e) {
                         this.onDebug({
                             message: "Starting job",
                             name: e.name,
                             workerThread: t,
                             backlog: this.jobQueue.length
                         });
-                        const n = new Ml(e.name, t);
+                        const n = new Cl(e.name, t);
                         t.onMessage = t => e.onMessage(n, t.type, t.payload), t.onError = t => e.onError(n, t), e.onStart(n);
                         try {
                             await n.result
                         } finally {
                             this.returnWorkerToQueue(t)
                         }
                     }
@@ -7393,43 +7462,43 @@
                     this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (t.destroy(), this.count--) : this.idleQueue.push(t), this.isDestroyed || this._startQueuedJob()
                 }
                 _getAvailableWorker() {
                     if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;
                     if (this.count < this._getMaxConcurrency()) {
                         this.count++;
                         const t = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
-                        return new Al({
+                        return new Sl({
                             name: t,
                             source: this.source,
                             url: this.url
                         })
                     }
                     return null
                 }
                 _getMaxConcurrency() {
-                    return _l ? this.maxMobileConcurrency : this.maxConcurrency
+                    return vl ? this.maxMobileConcurrency : this.maxConcurrency
                 }
             }
-            const Ll = {
+            const Al = {
                 maxConcurrency: 3,
                 maxMobileConcurrency: 1,
                 reuseWorkers: !0,
                 onDebug: () => {}
             };
-            class Rl {
+            class Ml {
                 static isSupported() {
-                    return Al.isSupported()
+                    return Sl.isSupported()
                 }
                 static getWorkerFarm() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                    return Rl._workerFarm = Rl._workerFarm || new Rl({}), Rl._workerFarm.setProps(t), Rl._workerFarm
+                    return Ml._workerFarm = Ml._workerFarm || new Ml({}), Ml._workerFarm.setProps(t), Ml._workerFarm
                 }
                 constructor(t) {
                     wo(this, "props", void 0), wo(this, "workerPools", new Map), this.props = {
-                        ...Ll
+                        ...Al
                     }, this.setProps(t), this.workerPools = new Map
                 }
                 destroy() {
                     for (const t of this.workerPools.values()) t.destroy();
                     this.workerPools = new Map
                 }
                 setProps(t) {
@@ -7442,61 +7511,61 @@
                 getWorkerPool(t) {
                     const {
                         name: e,
                         source: n,
                         url: i
                     } = t;
                     let r = this.workerPools.get(e);
-                    return r || (r = new Ol({
+                    return r || (r = new Tl({
                         name: e,
                         source: n,
                         url: i
                     }), r.setProps(this._getWorkerPoolProps()), this.workerPools.set(e, r)), r
                 }
                 _getWorkerPoolProps() {
                     return {
                         maxConcurrency: this.props.maxConcurrency,
                         maxMobileConcurrency: this.props.maxMobileConcurrency,
                         reuseWorkers: this.props.reuseWorkers,
                         onDebug: this.props.onDebug
                     }
                 }
             }
-            wo(Rl, "_workerFarm", void 0);
-            const Il = "latest";
-            async function kl(t, e, n, i, r) {
+            wo(Ml, "_workerFarm", void 0);
+            const Ol = "latest";
+            async function Ll(t, e, n, i, r) {
                 const s = t.id,
                     o = function(t) {
                         let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                         const n = e[t.id] || {},
                             i = "".concat(t.id, "-worker.js");
                         let r = n.workerUrl;
                         if (r || "compression" !== t.id || (r = e.workerUrl), "test" === e._workerType && (r = "modules/".concat(t.module, "/dist/").concat(i)), !r) {
                             let e = t.version;
-                            "latest" === e && (e = Il);
+                            "latest" === e && (e = Ol);
                             const n = e ? "@".concat(e) : "";
                             r = "https://unpkg.com/@loaders.gl/".concat(t.module).concat(n, "/dist/").concat(i)
                         }
-                        return vl(r), r
+                        return fl(r), r
                     }(t, n),
-                    a = Rl.getWorkerFarm(n).getWorkerPool({
+                    a = Ml.getWorkerFarm(n).getWorkerPool({
                         name: s,
                         url: o
                     });
                 n = JSON.parse(JSON.stringify(n)), i = JSON.parse(JSON.stringify(i || {}));
-                const l = await a.startJob("process-on-worker", jl.bind(null, r));
+                const l = await a.startJob("process-on-worker", kl.bind(null, r));
                 l.postMessage("process", {
                     input: e,
                     options: n,
                     context: i
                 });
                 const c = await l.result;
                 return await c.result
             }
-            async function jl(t, e, n, i) {
+            async function kl(t, e, n, i) {
                 switch (n) {
                     case "done":
                         e.done(i);
                         break;
                     case "error":
                         e.error(new Error(i.error));
                         break;
@@ -7518,71 +7587,71 @@
                             })
                         }
                         break;
                     default:
                         console.warn("parse-with-worker unknown message ".concat(n))
                 }
             }
-            const Fl = 262144,
-                zl = 262144,
-                Bl = 1048576;
+            const Rl = 262144,
+                Il = 262144,
+                jl = 1048576;
 
-            function Dl(t) {
+            function Fl(t) {
                 if ((e = t) && "object" == typeof e && e.isBuffer) return t;
                 var e;
                 if (t instanceof ArrayBuffer) return t;
                 if (ArrayBuffer.isView(t)) return 0 === t.byteOffset && t.byteLength === t.buffer.byteLength ? t.buffer : t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
                 if ("string" == typeof t) {
                     const e = t;
                     return (new TextEncoder).encode(e).buffer
                 }
                 if (t && "object" == typeof t && t._toArrayBuffer) return t._toArrayBuffer();
                 throw new Error("toArrayBuffer")
             }
 
-            function Nl(t, e) {
-                return ol ? async function*(t, e) {
+            function zl(t, e) {
+                return il ? async function*(t, e) {
                     const n = t.getReader();
                     let i;
                     try {
                         for (;;) {
                             const t = i || n.read();
                             null != e && e._streamReadAhead && (i = n.read());
                             const {
                                 done: r,
                                 value: s
                             } = await t;
                             if (r) return;
-                            yield Dl(s)
+                            yield Fl(s)
                         }
                     } catch (t) {
                         n.releaseLock()
                     }
                 }(t, e): async function*(t, e) {
-                    for await (const e of t) yield Dl(e)
+                    for await (const e of t) yield Fl(e)
                 }(t)
             }
-            const Vl = "Cannot convert supplied data type";
-            async function Ul(t, e, n) {
+            const Bl = "Cannot convert supplied data type";
+            async function Dl(t, e, n) {
                 const i = t instanceof ArrayBuffer || ArrayBuffer.isView(t);
                 if ("string" == typeof t || i) return function(t, e, n) {
                     if (e.text && "string" == typeof t) return t;
-                    if (_a(t) && (t = t.buffer), t instanceof ArrayBuffer) {
+                    if (va(t) && (t = t.buffer), t instanceof ArrayBuffer) {
                         const n = t;
                         return e.text && !e.binary ? new TextDecoder("utf8").decode(n) : n
                     }
                     if (ArrayBuffer.isView(t)) {
                         if (e.text && !e.binary) return new TextDecoder("utf8").decode(t);
                         let n = t.buffer;
                         const i = t.byteLength || t.length;
                         return 0 === t.byteOffset && i === n.byteLength || (n = n.slice(t.byteOffset, t.byteOffset + i)), n
                     }
-                    throw new Error(Vl)
+                    throw new Error(Bl)
                 }(t, e);
-                if (ya(t) && (t = await ka(t)), ba(t)) {
+                if (ma(t) && (t = await La(t)), ga(t)) {
                     const n = t;
                     return await async function(t) {
                         if (!t.ok) {
                             const e = await async function(t) {
                                 let e = "Failed to fetch resource ".concat(t.url, " (").concat(t.status, "): ");
                                 try {
                                     const n = t.headers.get("Content-Type");
@@ -7591,233 +7660,233 @@
                                 } catch (t) {}
                                 return e
                             }(t);
                             throw new Error(e)
                         }
                     }(n), e.binary ? await n.arrayBuffer() : await n.text()
                 }
-                if (xa(t) && (t = function(t, e) {
+                if (ba(t) && (t = function(t, e) {
                         if ("string" == typeof t) return function*(t, e) {
-                            const n = (null == e ? void 0 : e.chunkSize) || Fl;
+                            const n = (null == e ? void 0 : e.chunkSize) || Rl;
                             let i = 0;
                             const r = new TextEncoder;
                             for (; i < t.length;) {
                                 const e = Math.min(t.length - i, n),
                                     s = t.slice(i, i + e);
                                 i += e, yield r.encode(s)
                             }
                         }(t, e);
                         if (t instanceof ArrayBuffer) return function(t) {
                             let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                             return function*() {
                                 const {
-                                    chunkSize: n = zl
+                                    chunkSize: n = Il
                                 } = e;
                                 let i = 0;
                                 for (; i < t.byteLength;) {
                                     const e = Math.min(t.byteLength - i, n),
                                         r = new ArrayBuffer(e),
                                         s = new Uint8Array(t, i, e);
                                     new Uint8Array(r).set(s), i += e, yield r
                                 }
                             }()
                         }(t, e);
-                        if (ya(t)) return async function*(t, e) {
-                            const n = (null == e ? void 0 : e.chunkSize) || Bl;
+                        if (ma(t)) return async function*(t, e) {
+                            const n = (null == e ? void 0 : e.chunkSize) || jl;
                             let i = 0;
                             for (; i < t.size;) {
                                 const e = i + n,
                                     r = await t.slice(i, e).arrayBuffer();
                                 i = e, yield r
                             }
                         }(t, e);
-                        if (xa(t)) return Nl(t, e);
-                        if (ba(t)) return Nl(t.body, e);
+                        if (ba(t)) return zl(t, e);
+                        if (ga(t)) return zl(t.body, e);
                         throw new Error("makeIterator")
-                    }(t, n)), ma(t) || va(t)) return async function(t) {
+                    }(t, n)), pa(t) || fa(t)) return async function(t) {
                     const e = [];
                     for await (const n of t) e.push(n);
                     return function() {
                         for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                         const i = e.map((t => t instanceof ArrayBuffer ? new Uint8Array(t) : t)),
                             r = i.reduce(((t, e) => t + e.byteLength), 0),
                             s = new Uint8Array(r);
                         let o = 0;
                         for (const t of i) s.set(t, o), o += t.byteLength;
                         return s.buffer
                     }(...e)
                 }(t);
-                throw new Error(Vl)
+                throw new Error(Bl)
             }
 
-            function Gl(t) {
+            function Nl(t) {
                 const e = t ? t.lastIndexOf("/") : -1;
                 return e >= 0 ? t.substr(e + 1) : ""
             }
-            const Wl = new $a({
+            const Vl = new Ka({
                     id: "loaders.gl"
                 }),
-                Hl = () => {
-                    const t = hl();
+                Ul = () => {
+                    const t = al();
                     return t.loaderRegistry = t.loaderRegistry || [], t.loaderRegistry
                 },
-                Zl = /\.([^.]+)$/;
+                Gl = /\.([^.]+)$/;
 
-            function ql(t) {
+            function Wl(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                     n = arguments.length > 2 ? arguments[2] : void 0,
                     i = arguments.length > 3 ? arguments[3] : void 0;
-                if (!Xl(t)) return null;
-                if (e && !Array.isArray(e)) return Pa(e);
+                if (!Hl(t)) return null;
+                if (e && !Array.isArray(e)) return xa(e);
                 let r = [];
-                e && (r = r.concat(e)), null != n && n.ignoreRegisteredLoaders || r.push(...Hl()),
+                e && (r = r.concat(e)), null != n && n.ignoreRegisteredLoaders || r.push(...Ul()),
                     function(t) {
-                        for (const e of t) Pa(e)
+                        for (const e of t) xa(e)
                     }(r);
                 const s = function(t, e, n, i) {
-                    const r = Ra(t),
-                        s = Ia(t),
-                        o = La(r) || (null == i ? void 0 : i.url);
+                    const r = Ma(t),
+                        s = Oa(t),
+                        o = Aa(r) || (null == i ? void 0 : i.url);
                     let a = null,
                         l = "";
                     var c;
-                    return null != n && n.mimeType && (a = Kl(e, null == n ? void 0 : n.mimeType), l = "match forced by supplied MIME type ".concat(null == n ? void 0 : n.mimeType)), a = a || function(t, e) {
-                        const n = e && Zl.exec(e),
+                    return null != n && n.mimeType && (a = ql(e, null == n ? void 0 : n.mimeType), l = "match forced by supplied MIME type ".concat(null == n ? void 0 : n.mimeType)), a = a || function(t, e) {
+                        const n = e && Gl.exec(e),
                             i = n && n[1];
                         return i ? function(t, e) {
                             e = e.toLowerCase();
                             for (const n of t)
                                 for (const t of n.extensions)
                                     if (t.toLowerCase() === e) return n;
                             return null
                         }(t, i) : null
-                    }(e, o), l = l || (a ? "matched url ".concat(o) : ""), a = a || Kl(e, s), l = l || (a ? "matched MIME type ".concat(s) : ""), a = a || function(t, e) {
+                    }(e, o), l = l || (a ? "matched url ".concat(o) : ""), a = a || ql(e, s), l = l || (a ? "matched MIME type ".concat(s) : ""), a = a || function(t, e) {
                         if (!e) return null;
                         for (const n of t)
                             if ("string" == typeof e) {
-                                if (Ql(e, n)) return n
+                                if (Xl(e, n)) return n
                             } else if (ArrayBuffer.isView(e)) {
-                            if (Jl(e.buffer, e.byteOffset, n)) return n
-                        } else if (e instanceof ArrayBuffer && Jl(e, 0, n)) return n;
+                            if (Yl(e.buffer, e.byteOffset, n)) return n
+                        } else if (e instanceof ArrayBuffer && Yl(e, 0, n)) return n;
                         return null
-                    }(e, t), l = l || (a ? "matched initial data ".concat($l(t)) : ""), a = a || Kl(e, null == n ? void 0 : n.fallbackMimeType), l = l || (a ? "matched fallback MIME type ".concat(s) : ""), l && Wl.log(1, "selectLoader selected ".concat(null === (c = a) || void 0 === c ? void 0 : c.name, ": ").concat(l, ".")), a
+                    }(e, t), l = l || (a ? "matched initial data ".concat(Kl(t)) : ""), a = a || ql(e, null == n ? void 0 : n.fallbackMimeType), l = l || (a ? "matched fallback MIME type ".concat(s) : ""), l && Vl.log(1, "selectLoader selected ".concat(null === (c = a) || void 0 === c ? void 0 : c.name, ": ").concat(l, ".")), a
                 }(t, r, n, i);
-                if (!(s || null != n && n.nothrow)) throw new Error(Yl(t));
+                if (!(s || null != n && n.nothrow)) throw new Error(Zl(t));
                 return s
             }
 
-            function Xl(t) {
+            function Hl(t) {
                 return !(t instanceof Response && 204 === t.status)
             }
 
-            function Yl(t) {
-                const e = Ra(t),
-                    n = Ia(t);
+            function Zl(t) {
+                const e = Ma(t),
+                    n = Oa(t);
                 let i = "No valid loader found (";
-                i += e ? "".concat(Gl(e), ", ") : "no url provided, ", i += "MIME type: ".concat(n ? '"'.concat(n, '"') : "not provided", ", ");
-                const r = t ? $l(t) : "";
+                i += e ? "".concat(Nl(e), ", ") : "no url provided, ", i += "MIME type: ".concat(n ? '"'.concat(n, '"') : "not provided", ", ");
+                const r = t ? Kl(t) : "";
                 return i += r ? ' first bytes: "'.concat(r, '"') : "first bytes: not available", i += ")", i
             }
 
-            function Kl(t, e) {
+            function ql(t, e) {
                 for (const n of t) {
                     if (n.mimeTypes && n.mimeTypes.includes(e)) return n;
                     if (e === "application/x.".concat(n.id)) return n
                 }
                 return null
             }
 
-            function Ql(t, e) {
+            function Xl(t, e) {
                 return e.testText ? e.testText(t) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((e => t.startsWith(e)))
             }
 
-            function Jl(t, e, n) {
+            function Yl(t, e, n) {
                 return (Array.isArray(n.tests) ? n.tests : [n.tests]).some((i => function(t, e, n, i) {
                     if (i instanceof ArrayBuffer) return function(t, e, n) {
                         if (n = n || t.byteLength, t.byteLength < n || e.byteLength < n) return !1;
                         const i = new Uint8Array(t),
                             r = new Uint8Array(e);
                         for (let t = 0; t < i.length; ++t)
                             if (i[t] !== r[t]) return !1;
                         return !0
                     }(i, t, i.byteLength);
                     switch (typeof i) {
                         case "function":
                             return i(t, n);
                         case "string":
-                            return i === tc(t, e, i.length);
+                            return i === Ql(t, e, i.length);
                         default:
                             return !1
                     }
                 }(t, e, n, i)))
             }
 
-            function $l(t) {
+            function Kl(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5;
-                return "string" == typeof t ? t.slice(0, e) : ArrayBuffer.isView(t) ? tc(t.buffer, t.byteOffset, e) : t instanceof ArrayBuffer ? tc(t, 0, e) : ""
+                return "string" == typeof t ? t.slice(0, e) : ArrayBuffer.isView(t) ? Ql(t.buffer, t.byteOffset, e) : t instanceof ArrayBuffer ? Ql(t, 0, e) : ""
             }
 
-            function tc(t, e, n) {
+            function Ql(t, e, n) {
                 if (t.byteLength < e + n) return "";
                 const i = new DataView(t);
                 let r = "";
                 for (let t = 0; t < n; t++) r += String.fromCharCode(i.getUint8(e + t));
                 return r
             }
-            async function ec(t, e, n, i) {
-                vl(!i || "object" == typeof i), !e || Array.isArray(e) || Ea(e) || (i = void 0, n = e, e = void 0), n = n || {};
-                const r = Ra(t = await t),
+            async function Jl(t, e, n, i) {
+                fl(!i || "object" == typeof i), !e || Array.isArray(e) || _a(e) || (i = void 0, n = e, e = void 0), n = n || {};
+                const r = Ma(t = await t),
                     s = function(t, e) {
                         if (!e && t && !Array.isArray(t)) return t;
                         let n;
                         if (t && (n = Array.isArray(t) ? t : [t]), e && e.loaders) {
                             const t = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
                             n = n ? [...n, ...t] : t
                         }
                         return n && n.length ? n : null
                     }(e, i),
                     o = await async function(t) {
                         let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                             n = arguments.length > 2 ? arguments[2] : void 0,
                             i = arguments.length > 3 ? arguments[3] : void 0;
-                        if (!Xl(t)) return null;
-                        let r = ql(t, e, {
+                        if (!Hl(t)) return null;
+                        let r = Wl(t, e, {
                             ...n,
                             nothrow: !0
                         }, i);
                         if (r) return r;
-                        if (ya(t) && (r = ql(t = await t.slice(0, 10).arrayBuffer(), e, n, i)), !(r || null != n && n.nothrow)) throw new Error(Yl(t));
+                        if (ma(t) && (r = Wl(t = await t.slice(0, 10).arrayBuffer(), e, n, i)), !(r || null != n && n.nothrow)) throw new Error(Zl(t));
                         return r
                     }(t, s, n);
                 return o ? (i = function(t, e, n) {
                     if (n) return n;
                     const i = {
-                        fetch: ml(e, t),
+                        fetch: pl(e, t),
                         ...t
                     };
                     if (i.url) {
-                        const t = La(i.url);
+                        const t = Aa(i.url);
                         i.baseUrl = t, i.queryString = function(t) {
-                            const e = t.match(Oa);
+                            const e = t.match(Ta);
                             return e && e[0]
-                        }(i.url), i.filename = Gl(t), i.baseUrl = function(t) {
+                        }(i.url), i.filename = Nl(t), i.baseUrl = function(t) {
                             const e = t ? t.lastIndexOf("/") : -1;
                             return e >= 0 ? t.substr(0, e) : ""
                         }(t)
                     }
                     return Array.isArray(i.loaders) || (i.loaders = null), i
                 }({
                     url: r,
-                    parse: ec,
+                    parse: Jl,
                     loaders: s
-                }, n = dl(n, o, s, r), i || null), await async function(t, e, n, i) {
+                }, n = cl(n, o, s, r), i || null), await async function(t, e, n, i) {
                     if (function(t) {
-                            vl(t, "no worker provided");
+                            fl(t, "no worker provided");
                             t.version
-                        }(t), ba(e)) {
+                        }(t), ga(e)) {
                         const t = e,
                             {
                                 ok: n,
                                 redirected: r,
                                 status: s,
                                 statusText: o,
                                 type: a,
@@ -7830,30 +7899,30 @@
                             redirected: r,
                             status: s,
                             statusText: o,
                             type: a,
                             url: l
                         }
                     }
-                    if (e = await Ul(e, t, n), t.parseTextSync && "string" == typeof e) return n.dataType = "text", t.parseTextSync(e, n, i, t);
+                    if (e = await Dl(e, t, n), t.parseTextSync && "string" == typeof e) return n.dataType = "text", t.parseTextSync(e, n, i, t);
                     if (function(t, e) {
-                            return !!Rl.isSupported() && !!(yl || null != e && e._nodeWorkers) && t.worker && (null == e ? void 0 : e.worker)
-                        }(t, n)) return await kl(t, e, n, i, ec);
+                            return !!Ml.isSupported() && !!(ml || null != e && e._nodeWorkers) && t.worker && (null == e ? void 0 : e.worker)
+                        }(t, n)) return await Ll(t, e, n, i, Jl);
                     if (t.parseText && "string" == typeof e) return await t.parseText(e, n, i, t);
                     if (t.parse) return await t.parse(e, n, i, t);
-                    throw vl(!t.parseSync), new Error("".concat(t.id, " loader - no parser found and worker is disabled"))
+                    throw fl(!t.parseSync), new Error("".concat(t.id, " loader - no parser found and worker is disabled"))
                 }(o, t, n, i)) : null
             }
-            async function nc(t, e, n, i) {
-                Array.isArray(e) || Ea(e) || (n = e, e = void 0);
-                const r = ml(n);
+            async function $l(t, e, n, i) {
+                Array.isArray(e) || _a(e) || (n = e, e = void 0);
+                const r = pl(n);
                 let s = t;
-                return "string" == typeof t && (s = await r(t)), ya(t) && (s = await r(t)), await ec(s, e, n)
+                return "string" == typeof t && (s = await r(t)), ma(t) && (s = await r(t)), await Jl(s, e, n)
             }
-            class ic {
+            class tc {
                 constructor(t, e, n) {
                     wo(this, "id", void 0), wo(this, "context", void 0), wo(this, "isLoaded", void 0), wo(this, "persistent", void 0), wo(this, "_loadCount", 0), wo(this, "_subscribers", new Set), wo(this, "_data", void 0), wo(this, "_loader", void 0), wo(this, "_error", void 0), wo(this, "_content", void 0), this.id = t, this.context = n, this.setData(e)
                 }
                 subscribe(t) {
                     this._subscribers.add(t)
                 }
                 unsubscribe(t) {
@@ -7867,23 +7936,23 @@
                     return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then((() => this.getData()))
                 }
                 setData(t, e) {
                     if (t === this._data && !e) return;
                     this._data = t;
                     const n = ++this._loadCount;
                     let i = t;
-                    "string" == typeof t && (i = nc(t)), i instanceof Promise ? (this.isLoaded = !1, this._loader = i.then((t => {
+                    "string" == typeof t && (i = $l(t)), i instanceof Promise ? (this.isLoaded = !1, this._loader = i.then((t => {
                         this._loadCount === n && (this.isLoaded = !0, this._error = void 0, this._content = t)
                     })).catch((t => {
                         this._loadCount === n && (this.isLoaded = !0, this._error = t || !0)
                     }))) : (this.isLoaded = !0, this._error = void 0, this._content = t);
                     for (const t of this._subscribers) t.onChange(this.getData())
                 }
             }
-            class rc {
+            class ec {
                 constructor({
                     gl: t,
                     protocol: e
                 }) {
                     wo(this, "protocol", void 0), wo(this, "_context", void 0), wo(this, "_resources", void 0), wo(this, "_consumers", void 0), wo(this, "_pruneRequest", void 0), this.protocol = e || "resource://", this._context = {
                         gl: t,
                         resourceManager: this
@@ -7895,15 +7964,15 @@
                 add({
                     resourceId: t,
                     data: e,
                     forceUpdate: n = !1,
                     persistent: i = !0
                 }) {
                     let r = this._resources[t];
-                    r ? r.setData(e, n) : (r = new ic(t, e, this._context), this._resources[t] = r), r.persistent = i
+                    r ? r.setData(e, n) : (r = new tc(t, e, this._context), this._resources[t] = r), r.persistent = i
                 }
                 remove(t) {
                     const e = this._resources[t];
                     e && (e.delete(), delete this._resources[t])
                 }
                 unsubscribe({
                     consumerId: t
@@ -7953,15 +8022,15 @@
                     this._pruneRequest = null;
                     for (const t of Object.keys(this._resources)) {
                         const e = this._resources[t];
                         e.persistent || e.inUse() || (e.delete(), delete this._resources[t])
                     }
                 }
             }
-            const sc = new class {
+            const nc = new class {
                     constructor(t = {}) {
                         wo(this, "_pool", []), wo(this, "opts", {
                             overAlloc: 2,
                             poolSize: 100
                         }), this.setOptions(t)
                     }
                     setOptions(t) {
@@ -8010,70 +8079,70 @@
                             {
                                 byteLength: i
                             } = n,
                             r = e.findIndex((t => t.byteLength >= i));
                         r < 0 ? e.push(n) : (r > 0 || e.length < this.opts.poolSize) && e.splice(r, 0, n), e.length > this.opts.poolSize && e.shift()
                     }
                 },
-                oc = (Math.PI, Math.PI, {
+                ic = (Math.PI, Math.PI, {
                     EPSILON: 1e-12,
                     debug: !1,
                     precision: 4,
                     printTypes: !1,
                     printDegrees: !1,
                     printRowMajor: !0
                 });
 
-            function ac(t, {
-                precision: e = oc.precision
+            function rc(t, {
+                precision: e = ic.precision
             } = {}) {
                 return t = function(t) {
-                    return Math.round(t / oc.EPSILON) * oc.EPSILON
+                    return Math.round(t / ic.EPSILON) * ic.EPSILON
                 }(t), "".concat(parseFloat(t.toPrecision(e)))
             }
 
-            function lc(t) {
+            function sc(t) {
                 return Array.isArray(t) || ArrayBuffer.isView(t) && !(t instanceof DataView)
             }
 
-            function cc(t, e, n) {
+            function oc(t, e, n) {
                 return function(t, e, n) {
-                    if (lc(t)) {
+                    if (sc(t)) {
                         const i = t;
                         n = n || function(t) {
                             return t.clone ? t.clone() : new Array(t.length)
                         }(i);
                         for (let r = 0; r < n.length && r < i.length; ++r) n[r] = e(t[r], r, n);
                         return n
                     }
                     return e(t)
                 }(t, (t => Math.max(e, Math.min(n, t))))
             }
 
-            function hc(t, e, n) {
-                return lc(t) ? t.map(((t, i) => hc(t, e[i], n))) : n * e + (1 - n) * t
+            function ac(t, e, n) {
+                return sc(t) ? t.map(((t, i) => ac(t, e[i], n))) : n * e + (1 - n) * t
             }
 
-            function uc(t, e, n) {
-                const i = oc.EPSILON;
-                n && (oc.EPSILON = n);
+            function lc(t, e, n) {
+                const i = ic.EPSILON;
+                n && (ic.EPSILON = n);
                 try {
                     if (t === e) return !0;
-                    if (lc(t) && lc(e)) {
+                    if (sc(t) && sc(e)) {
                         if (t.length !== e.length) return !1;
                         for (let n = 0; n < t.length; ++n)
-                            if (!uc(t[n], e[n])) return !1;
+                            if (!lc(t[n], e[n])) return !1;
                         return !0
                     }
-                    return t && t.equals ? t.equals(e) : e && e.equals ? e.equals(t) : "number" == typeof t && "number" == typeof e && Math.abs(t - e) <= oc.EPSILON * Math.max(1, Math.abs(t), Math.abs(e))
+                    return t && t.equals ? t.equals(e) : e && e.equals ? e.equals(t) : "number" == typeof t && "number" == typeof e && Math.abs(t - e) <= ic.EPSILON * Math.max(1, Math.abs(t), Math.abs(e))
                 } finally {
-                    oc.EPSILON = i
+                    ic.EPSILON = i
                 }
             }
-            class dc extends(function(t) {
+            class cc extends(function(t) {
                 function e() {
                     var e = Reflect.construct(t, Array.from(arguments));
                     return Object.setPrototypeOf(e, Object.getPrototypeOf(this)), e
                 }
                 return e.prototype = Object.create(t.prototype, {
                     constructor: {
                         value: t,
@@ -8094,34 +8163,34 @@
                     for (let n = 0; n < this.ELEMENTS; ++n) t[e + n] = this[n];
                     return t
                 }
                 from(t) {
                     return Array.isArray(t) ? this.copy(t) : this.fromObject(t)
                 }
                 to(t) {
-                    return t === this ? this : lc(t) ? this.toArray(t) : this.toObject(t)
+                    return t === this ? this : sc(t) ? this.toArray(t) : this.toObject(t)
                 }
                 toTarget(t) {
                     return t ? this.to(t) : this
                 }
                 toFloat32Array() {
                     return new Float32Array(this)
                 }
                 toString() {
-                    return this.formatString(oc)
+                    return this.formatString(ic)
                 }
                 formatString(t) {
                     let e = "";
-                    for (let n = 0; n < this.ELEMENTS; ++n) e += (n > 0 ? ", " : "") + ac(this[n], t);
+                    for (let n = 0; n < this.ELEMENTS; ++n) e += (n > 0 ? ", " : "") + rc(this[n], t);
                     return "".concat(t.printTypes ? this.constructor.name : "", "[").concat(e, "]")
                 }
                 equals(t) {
                     if (!t || this.length !== t.length) return !1;
                     for (let e = 0; e < this.ELEMENTS; ++e)
-                        if (!uc(this[e], t[e])) return !1;
+                        if (!lc(this[e], t[e])) return !1;
                     return !0
                 }
                 exactEquals(t) {
                     if (!t || this.length !== t.length) return !1;
                     for (let e = 0; e < this.ELEMENTS; ++e)
                         if (this[e] !== t[e]) return !1;
                     return !0
@@ -8168,15 +8237,15 @@
                     return this.check()
                 }
                 multiplyByScalar(t) {
                     for (let e = 0; e < this.ELEMENTS; ++e) this[e] *= t;
                     return this.check()
                 }
                 check() {
-                    if (oc.debug && !this.validate()) throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
+                    if (ic.debug && !this.validate()) throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
                     return this
                 }
                 validate() {
                     let t = this.length === this.ELEMENTS;
                     for (let e = 0; e < this.ELEMENTS; ++e) t = t && Number.isFinite(this[e]);
                     return t
                 }
@@ -8206,44 +8275,44 @@
                     return this.check()
                 }
                 get elements() {
                     return this
                 }
             }
 
-            function pc(t) {
+            function hc(t) {
                 if (!Number.isFinite(t)) throw new Error("Invalid number ".concat(t));
                 return t
             }
 
-            function fc(t, e, n = "") {
-                if (oc.debug && ! function(t, e) {
+            function uc(t, e, n = "") {
+                if (ic.debug && ! function(t, e) {
                         if (t.length !== e) return !1;
                         for (let e = 0; e < t.length; ++e)
                             if (!Number.isFinite(t[e])) return !1;
                         return !0
                     }(t, e)) throw new Error("math.gl: ".concat(n, " some fields set to invalid numbers'"));
                 return t
             }
 
-            function gc(t, e) {
+            function dc(t, e) {
                 if (!t) throw new Error("math.gl assertion ".concat(e))
             }
-            class mc extends dc {
+            class pc extends cc {
                 get x() {
                     return this[0]
                 }
                 set x(t) {
-                    this[0] = pc(t)
+                    this[0] = hc(t)
                 }
                 get y() {
                     return this[1]
                 }
                 set y(t) {
-                    this[1] = pc(t)
+                    this[1] = hc(t)
                 }
                 len() {
                     return Math.sqrt(this.lengthSquared())
                 }
                 magnitude() {
                     return this.len()
                 }
@@ -8260,20 +8329,20 @@
                 }
                 distanceSquared(t) {
                     let e = 0;
                     for (let n = 0; n < this.ELEMENTS; ++n) {
                         const i = this[n] - t[n];
                         e += i * i
                     }
-                    return pc(e)
+                    return hc(e)
                 }
                 dot(t) {
                     let e = 0;
                     for (let n = 0; n < this.ELEMENTS; ++n) e += this[n] * t[n];
-                    return pc(e)
+                    return hc(e)
                 }
                 normalize() {
                     const t = this.magnitude();
                     if (0 !== t)
                         for (let e = 0; e < this.ELEMENTS; ++e) this[e] /= t;
                     return this.check()
                 }
@@ -8293,75 +8362,75 @@
                 distanceTo(t) {
                     return this.distance(t)
                 }
                 distanceToSquared(t) {
                     return this.distanceSquared(t)
                 }
                 getComponent(t) {
-                    return gc(t >= 0 && t < this.ELEMENTS, "index is out of range"), pc(this[t])
+                    return dc(t >= 0 && t < this.ELEMENTS, "index is out of range"), hc(this[t])
                 }
                 setComponent(t, e) {
-                    return gc(t >= 0 && t < this.ELEMENTS, "index is out of range"), this[t] = e, this.check()
+                    return dc(t >= 0 && t < this.ELEMENTS, "index is out of range"), this[t] = e, this.check()
                 }
                 addVectors(t, e) {
                     return this.copy(t).add(e)
                 }
                 subVectors(t, e) {
                     return this.copy(t).subtract(e)
                 }
                 multiplyVectors(t, e) {
                     return this.copy(t).multiply(e)
                 }
                 addScaledVector(t, e) {
                     return this.add(new this.constructor(t).multiplyScalar(e))
                 }
             }
-            var vc = 1e-6,
-                bc = "undefined" != typeof Float32Array ? Float32Array : Array;
+            var fc = 1e-6,
+                gc = "undefined" != typeof Float32Array ? Float32Array : Array;
 
-            function yc() {
-                var t = new bc(3);
-                return bc != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t
+            function mc() {
+                var t = new gc(3);
+                return gc != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t
             }
 
-            function _c(t, e, n) {
-                var i = new bc(3);
+            function vc(t, e, n) {
+                var i = new gc(3);
                 return i[0] = t, i[1] = e, i[2] = n, i
             }
 
-            function xc(t, e) {
+            function bc(t, e) {
                 return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
             }
 
-            function wc(t, e, n) {
+            function yc(t, e, n) {
                 var i = e[0],
                     r = e[1],
                     s = e[2],
                     o = n[0],
                     a = n[1],
                     l = n[2];
                 return t[0] = r * l - s * a, t[1] = s * o - i * l, t[2] = i * a - r * o, t
             }
 
-            function Ec(t, e, n) {
+            function _c(t, e, n) {
                 var i = e[0],
                     r = e[1],
                     s = e[2],
                     o = n[3] * i + n[7] * r + n[11] * s + n[15];
                 return o = o || 1, t[0] = (n[0] * i + n[4] * r + n[8] * s + n[12]) / o, t[1] = (n[1] * i + n[5] * r + n[9] * s + n[13]) / o, t[2] = (n[2] * i + n[6] * r + n[10] * s + n[14]) / o, t
             }
 
-            function Pc(t, e, n) {
+            function xc(t, e, n) {
                 var i = e[0],
                     r = e[1],
                     s = e[2];
                 return t[0] = i * n[0] + r * n[3] + s * n[6], t[1] = i * n[1] + r * n[4] + s * n[7], t[2] = i * n[2] + r * n[5] + s * n[8], t
             }
 
-            function Sc(t, e, n) {
+            function wc(t, e, n) {
                 var i = n[0],
                     r = n[1],
                     s = n[2],
                     o = n[3],
                     a = e[0],
                     l = e[1],
                     c = e[2],
@@ -8374,173 +8443,163 @@
                     m = 2 * o;
                 return h *= m, u *= m, d *= m, p *= 2, f *= 2, g *= 2, t[0] = a + h + p, t[1] = l + u + f, t[2] = c + d + g, t
             }
             Math.random, Math.PI, Math.hypot || (Math.hypot = function() {
                 for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];
                 return Math.sqrt(t)
             });
-            var Cc = function(t, e, n) {
+            var Ec = function(t, e, n) {
                     return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t
                 },
-                Tc = function(t) {
+                Pc = function(t) {
                     var e = t[0],
                         n = t[1],
                         i = t[2];
                     return Math.hypot(e, n, i)
                 },
-                Ac = function(t) {
+                Sc = function(t) {
                     var e = t[0],
                         n = t[1],
                         i = t[2];
                     return e * e + n * n + i * i
                 };
 
-            function Mc(t, e, n) {
+            function Cc(t, e, n) {
                 const i = e[0],
                     r = e[1],
                     s = e[2],
                     o = n[3] * i + n[7] * r + n[11] * s || 1;
                 return t[0] = (n[0] * i + n[4] * r + n[8] * s) / o, t[1] = (n[1] * i + n[5] * r + n[9] * s) / o, t[2] = (n[2] * i + n[6] * r + n[10] * s) / o, t
             }
 
-            function Oc(t, e, n) {
+            function Tc(t, e, n) {
                 const i = e[0],
                     r = e[1],
                     s = e[2];
                 return t[0] = n[0] * i + n[3] * r + n[6] * s, t[1] = n[1] * i + n[4] * r + n[7] * s, t[2] = n[2] * i + n[5] * r + n[8] * s, t[3] = e[3], t
             }
-            yc();
-            const Lc = [0, 0, 0];
-            let Rc;
-            class Ic extends mc {
+            mc();
+            const Ac = [0, 0, 0];
+            let Mc;
+            class Oc extends pc {
                 static get ZERO() {
-                    return Rc || (Rc = new Ic(0, 0, 0), Object.freeze(Rc)), Rc
+                    return Mc || (Mc = new Oc(0, 0, 0), Object.freeze(Mc)), Mc
                 }
                 constructor(t = 0, e = 0, n = 0) {
-                    super(-0, -0, -0), 1 === arguments.length && lc(t) ? this.copy(t) : (oc.debug && (pc(t), pc(e), pc(n)), this[0] = t, this[1] = e, this[2] = n)
+                    super(-0, -0, -0), 1 === arguments.length && sc(t) ? this.copy(t) : (ic.debug && (hc(t), hc(e), hc(n)), this[0] = t, this[1] = e, this[2] = n)
                 }
                 set(t, e, n) {
                     return this[0] = t, this[1] = e, this[2] = n, this.check()
                 }
                 copy(t) {
                     return this[0] = t[0], this[1] = t[1], this[2] = t[2], this.check()
                 }
                 fromObject(t) {
-                    return oc.debug && (pc(t.x), pc(t.y), pc(t.z)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this.check()
+                    return ic.debug && (hc(t.x), hc(t.y), hc(t.z)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this.check()
                 }
                 toObject(t) {
                     return t.x = this[0], t.y = this[1], t.z = this[2], t
                 }
                 get ELEMENTS() {
                     return 3
                 }
                 get z() {
                     return this[2]
                 }
                 set z(t) {
-                    this[2] = pc(t)
+                    this[2] = hc(t)
                 }
                 angle(t) {
-                    return n = t, i = (e = this)[0], r = e[1], s = e[2], o = n[0], a = n[1], l = n[2], h = (c = Math.sqrt(i * i + r * r + s * s) * Math.sqrt(o * o + a * a + l * l)) && xc(e, n) / c, Math.acos(Math.min(Math.max(h, -1), 1));
+                    return n = t, i = (e = this)[0], r = e[1], s = e[2], o = n[0], a = n[1], l = n[2], h = (c = Math.sqrt(i * i + r * r + s * s) * Math.sqrt(o * o + a * a + l * l)) && bc(e, n) / c, Math.acos(Math.min(Math.max(h, -1), 1));
                     var e, n, i, r, s, o, a, l, c, h
                 }
                 cross(t) {
-                    return wc(this, this, t), this.check()
+                    return yc(this, this, t), this.check()
                 }
                 rotateX({
                     radians: t,
-                    origin: e = Lc
+                    origin: e = Ac
                 }) {
                     var n, i, r, s, o;
                     return n = this, i = e, r = t, o = [], (s = [])[0] = this[0] - i[0], s[1] = this[1] - i[1], s[2] = this[2] - i[2], o[0] = s[0], o[1] = s[1] * Math.cos(r) - s[2] * Math.sin(r), o[2] = s[1] * Math.sin(r) + s[2] * Math.cos(r), n[0] = o[0] + i[0], n[1] = o[1] + i[1], n[2] = o[2] + i[2], this.check()
                 }
                 rotateY({
                     radians: t,
-                    origin: e = Lc
+                    origin: e = Ac
                 }) {
                     var n, i, r, s, o;
                     return n = this, i = e, r = t, o = [], (s = [])[0] = this[0] - i[0], s[1] = this[1] - i[1], s[2] = this[2] - i[2], o[0] = s[2] * Math.sin(r) + s[0] * Math.cos(r), o[1] = s[1], o[2] = s[2] * Math.cos(r) - s[0] * Math.sin(r), n[0] = o[0] + i[0], n[1] = o[1] + i[1], n[2] = o[2] + i[2], this.check()
                 }
                 rotateZ({
                     radians: t,
-                    origin: e = Lc
+                    origin: e = Ac
                 }) {
                     var n, i, r, s, o;
                     return n = this, i = e, r = t, o = [], (s = [])[0] = this[0] - i[0], s[1] = this[1] - i[1], s[2] = this[2] - i[2], o[0] = s[0] * Math.cos(r) - s[1] * Math.sin(r), o[1] = s[0] * Math.sin(r) + s[1] * Math.cos(r), o[2] = s[2], n[0] = o[0] + i[0], n[1] = o[1] + i[1], n[2] = o[2] + i[2], this.check()
                 }
                 transform(t) {
                     return this.transformAsPoint(t)
                 }
                 transformAsPoint(t) {
-                    return Ec(this, this, t), this.check()
+                    return _c(this, this, t), this.check()
                 }
                 transformAsVector(t) {
-                    return Mc(this, this, t), this.check()
+                    return Cc(this, this, t), this.check()
                 }
                 transformByMatrix3(t) {
-                    return Pc(this, this, t), this.check()
+                    return xc(this, this, t), this.check()
                 }
                 transformByMatrix2(t) {
                     return function(t, e, n) {
                         const i = e[0],
                             r = e[1];
                         t[0] = n[0] * i + n[2] * r, t[1] = n[1] * i + n[3] * r, t[2] = e[2]
                     }(this, this, t), this.check()
                 }
                 transformByQuaternion(t) {
-                    return Sc(this, this, t), this.check()
+                    return wc(this, this, t), this.check()
                 }
             }
-            const kc = new Ic;
+            const Lc = new Oc;
 
-            function jc(t, e, n, i) {
-                kc.set(t, e, n);
-                const r = kc.len();
+            function kc(t, e, n, i) {
+                Lc.set(t, e, n);
+                const r = Lc.len();
                 return {
                     distance: i / r,
-                    normal: new Ic(-t / r, -e / r, -n / r)
+                    normal: new Oc(-t / r, -e / r, -n / r)
                 }
             }
-            let Fc;
+            let Rc;
 
-            function zc(t, e) {
+            function Ic(t, e) {
                 const {
                     size: n = 1,
                     startIndex: i = 0
                 } = e, r = void 0 !== e.endIndex ? e.endIndex : t.length, s = (r - i) / n;
-                Fc = sc.allocate(Fc, s, {
+                Rc = nc.allocate(Rc, s, {
                     type: Float32Array,
                     size: 2 * n
                 });
                 let o = i,
                     a = 0;
                 for (; o < r;) {
                     for (let e = 0; e < n; e++) {
                         const i = t[o++];
-                        Fc[a + e] = i, Fc[a + e + n] = (l = i) - Math.fround(l)
+                        Rc[a + e] = i, Rc[a + e + n] = (l = i) - Math.fround(l)
                     }
                     a += 2 * n
                 }
                 var l;
-                return Fc.subarray(0, s * n * 2)
-            }
-
-            function Bc(t) {
-                let e = null,
-                    n = !1;
-                for (const i of t) i && (e ? (n || (e = [
-                    [e[0][0], e[0][1]],
-                    [e[1][0], e[1][1]]
-                ], n = !0), e[0][0] = Math.min(e[0][0], i[0][0]), e[0][1] = Math.min(e[0][1], i[0][1]), e[1][0] = Math.max(e[1][0], i[1][0]), e[1][1] = Math.max(e[1][1], i[1][1])) : e = i);
-                return e
+                return Rc.subarray(0, s * n * 2)
             }
-            class Dc extends dc {
+            class jc extends cc {
                 toString() {
                     let t = "[";
-                    if (oc.printRowMajor) {
+                    if (ic.printRowMajor) {
                         t += "row-major:";
                         for (let e = 0; e < this.RANK; ++e)
                             for (let n = 0; n < this.RANK; ++n) t += " ".concat(this[n * this.RANK + e])
                     } else {
                         t += "column-major:";
                         for (let e = 0; e < this.ELEMENTS; ++e) t += " ".concat(this[e])
                     }
@@ -8549,29 +8608,29 @@
                 getElementIndex(t, e) {
                     return e * this.RANK + t
                 }
                 getElement(t, e) {
                     return this[e * this.RANK + t]
                 }
                 setElement(t, e, n) {
-                    return this[e * this.RANK + t] = pc(n), this
+                    return this[e * this.RANK + t] = hc(n), this
                 }
                 getColumn(t, e = new Array(this.RANK).fill(-0)) {
                     const n = t * this.RANK;
                     for (let t = 0; t < this.RANK; ++t) e[t] = this[n + t];
                     return e
                 }
                 setColumn(t, e) {
                     const n = t * this.RANK;
                     for (let t = 0; t < this.RANK; ++t) this[n + t] = e[t];
                     return this
                 }
             }
 
-            function Nc(t, e) {
+            function Fc(t, e) {
                 var n = e[0],
                     i = e[1],
                     r = e[2],
                     s = e[3],
                     o = e[4],
                     a = e[5],
                     l = e[6],
@@ -8596,15 +8655,15 @@
                     T = u * m - d * g,
                     A = u * v - p * g,
                     M = d * v - p * m,
                     O = b * M - y * A + _ * T + x * C - w * S + E * P;
                 return O ? (O = 1 / O, t[0] = (a * M - l * A + c * T) * O, t[1] = (r * A - i * M - s * T) * O, t[2] = (g * E - m * w + v * x) * O, t[3] = (d * w - u * E - p * x) * O, t[4] = (l * C - o * M - c * S) * O, t[5] = (n * M - r * C + s * S) * O, t[6] = (m * _ - f * E - v * y) * O, t[7] = (h * E - d * _ + p * y) * O, t[8] = (o * A - a * C + c * P) * O, t[9] = (i * C - n * A - s * P) * O, t[10] = (f * w - g * _ + v * b) * O, t[11] = (u * _ - h * w - p * b) * O, t[12] = (a * S - o * T - l * P) * O, t[13] = (n * T - i * S + r * P) * O, t[14] = (g * y - f * x - m * b) * O, t[15] = (h * x - u * y + d * b) * O, t) : null
             }
 
-            function Vc(t, e, n) {
+            function zc(t, e, n) {
                 var i = e[0],
                     r = e[1],
                     s = e[2],
                     o = e[3],
                     a = e[4],
                     l = e[5],
                     c = e[6],
@@ -8620,112 +8679,112 @@
                     y = n[0],
                     _ = n[1],
                     x = n[2],
                     w = n[3];
                 return t[0] = y * i + _ * a + x * u + w * g, t[1] = y * r + _ * l + x * d + w * m, t[2] = y * s + _ * c + x * p + w * v, t[3] = y * o + _ * h + x * f + w * b, y = n[4], _ = n[5], x = n[6], w = n[7], t[4] = y * i + _ * a + x * u + w * g, t[5] = y * r + _ * l + x * d + w * m, t[6] = y * s + _ * c + x * p + w * v, t[7] = y * o + _ * h + x * f + w * b, y = n[8], _ = n[9], x = n[10], w = n[11], t[8] = y * i + _ * a + x * u + w * g, t[9] = y * r + _ * l + x * d + w * m, t[10] = y * s + _ * c + x * p + w * v, t[11] = y * o + _ * h + x * f + w * b, y = n[12], _ = n[13], x = n[14], w = n[15], t[12] = y * i + _ * a + x * u + w * g, t[13] = y * r + _ * l + x * d + w * m, t[14] = y * s + _ * c + x * p + w * v, t[15] = y * o + _ * h + x * f + w * b, t
             }
 
-            function Uc(t, e, n) {
+            function Bc(t, e, n) {
                 var i, r, s, o, a, l, c, h, u, d, p, f, g = n[0],
                     m = n[1],
                     v = n[2];
                 return e === t ? (t[12] = e[0] * g + e[4] * m + e[8] * v + e[12], t[13] = e[1] * g + e[5] * m + e[9] * v + e[13], t[14] = e[2] * g + e[6] * m + e[10] * v + e[14], t[15] = e[3] * g + e[7] * m + e[11] * v + e[15]) : (i = e[0], r = e[1], s = e[2], o = e[3], a = e[4], l = e[5], c = e[6], h = e[7], u = e[8], d = e[9], p = e[10], f = e[11], t[0] = i, t[1] = r, t[2] = s, t[3] = o, t[4] = a, t[5] = l, t[6] = c, t[7] = h, t[8] = u, t[9] = d, t[10] = p, t[11] = f, t[12] = i * g + a * m + u * v + e[12], t[13] = r * g + l * m + d * v + e[13], t[14] = s * g + c * m + p * v + e[14], t[15] = o * g + h * m + f * v + e[15]), t
             }
 
-            function Gc(t, e, n) {
+            function Dc(t, e, n) {
                 var i = n[0],
                     r = n[1],
                     s = n[2];
                 return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t[4] = e[4] * r, t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, t[8] = e[8] * s, t[9] = e[9] * s, t[10] = e[10] * s, t[11] = e[11] * s, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
             }
 
-            function Wc(t, e, n) {
+            function Nc(t, e, n) {
                 var i = Math.sin(n),
                     r = Math.cos(n),
                     s = e[4],
                     o = e[5],
                     a = e[6],
                     l = e[7],
                     c = e[8],
                     h = e[9],
                     u = e[10],
                     d = e[11];
                 return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = s * r + c * i, t[5] = o * r + h * i, t[6] = a * r + u * i, t[7] = l * r + d * i, t[8] = c * r - s * i, t[9] = h * r - o * i, t[10] = u * r - a * i, t[11] = d * r - l * i, t
             }
 
-            function Hc(t, e, n) {
+            function Vc(t, e, n) {
                 var i = Math.sin(n),
                     r = Math.cos(n),
                     s = e[0],
                     o = e[1],
                     a = e[2],
                     l = e[3],
                     c = e[4],
                     h = e[5],
                     u = e[6],
                     d = e[7];
                 return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * r + c * i, t[1] = o * r + h * i, t[2] = a * r + u * i, t[3] = l * r + d * i, t[4] = c * r - s * i, t[5] = h * r - o * i, t[6] = u * r - a * i, t[7] = d * r - l * i, t
             }
-            var Zc;
+            var Uc;
 
-            function qc(t, e, n) {
+            function Gc(t, e, n) {
                 return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t
             }
 
-            function Xc(t, e) {
+            function Wc(t, e) {
                 return t[0] = -e[0], t[1] = -e[1], t
             }
 
-            function Yc(t, e, n, i) {
+            function Hc(t, e, n, i) {
                 var r = e[0],
                     s = e[1];
                 return t[0] = r + i * (n[0] - r), t[1] = s + i * (n[1] - s), t
             }
 
-            function Kc(t, e, n) {
+            function Zc(t, e, n) {
                 return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t
             }
 
-            function Qc(t, e, n) {
+            function qc(t, e, n) {
                 var i = e[0],
                     r = e[1],
                     s = e[2],
                     o = e[3];
                 return t[0] = n[0] * i + n[4] * r + n[8] * s + n[12] * o, t[1] = n[1] * i + n[5] * r + n[9] * s + n[13] * o, t[2] = n[2] * i + n[6] * r + n[10] * s + n[14] * o, t[3] = n[3] * i + n[7] * r + n[11] * s + n[15] * o, t
             }! function() {
                 var t;
-                t = new bc(2), bc != Float32Array && (t[0] = 0, t[1] = 0)
+                t = new gc(2), gc != Float32Array && (t[0] = 0, t[1] = 0)
             }(),
             function() {
                 var t;
-                t = new bc(4), bc != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0)
+                t = new gc(4), gc != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0)
             }(),
             function(t) {
                 t[t.COL0ROW0 = 0] = "COL0ROW0", t[t.COL0ROW1 = 1] = "COL0ROW1", t[t.COL0ROW2 = 2] = "COL0ROW2", t[t.COL0ROW3 = 3] = "COL0ROW3", t[t.COL1ROW0 = 4] = "COL1ROW0", t[t.COL1ROW1 = 5] = "COL1ROW1", t[t.COL1ROW2 = 6] = "COL1ROW2", t[t.COL1ROW3 = 7] = "COL1ROW3", t[t.COL2ROW0 = 8] = "COL2ROW0", t[t.COL2ROW1 = 9] = "COL2ROW1", t[t.COL2ROW2 = 10] = "COL2ROW2", t[t.COL2ROW3 = 11] = "COL2ROW3", t[t.COL3ROW0 = 12] = "COL3ROW0", t[t.COL3ROW1 = 13] = "COL3ROW1", t[t.COL3ROW2 = 14] = "COL3ROW2", t[t.COL3ROW3 = 15] = "COL3ROW3"
-            }(Zc || (Zc = {}));
-            const Jc = 45 * Math.PI / 180,
-                $c = 1,
-                th = .1,
-                eh = 500,
-                nh = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
-            class ih extends Dc {
+            }(Uc || (Uc = {}));
+            const Xc = 45 * Math.PI / 180,
+                Yc = 1,
+                Kc = .1,
+                Qc = 500,
+                Jc = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
+            class $c extends jc {
                 static get IDENTITY() {
-                    return sh || (sh = new ih, Object.freeze(sh)), sh
+                    return eh || (eh = new $c, Object.freeze(eh)), eh
                 }
                 static get ZERO() {
-                    return rh || (rh = new ih([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(rh)), rh
+                    return th || (th = new $c([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(th)), th
                 }
                 get ELEMENTS() {
                     return 16
                 }
                 get RANK() {
                     return 4
                 }
                 get INDICES() {
-                    return Zc
+                    return Uc
                 }
                 constructor(t) {
                     super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), 1 === arguments.length && Array.isArray(t) ? this.copy(t) : this.identity()
                 }
                 copy(t) {
                     return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this[9] = t[9], this[10] = t[10], this[11] = t[11], this[12] = t[12], this[13] = t[13], this[14] = t[14], this[15] = t[15], this.check()
                 }
@@ -8735,31 +8794,31 @@
                 setRowMajor(t, e, n, i, r, s, o, a, l, c, h, u, d, p, f, g) {
                     return this[0] = t, this[1] = r, this[2] = l, this[3] = d, this[4] = e, this[5] = s, this[6] = c, this[7] = p, this[8] = n, this[9] = o, this[10] = h, this[11] = f, this[12] = i, this[13] = a, this[14] = u, this[15] = g, this.check()
                 }
                 toRowMajor(t) {
                     return t[0] = this[0], t[1] = this[4], t[2] = this[8], t[3] = this[12], t[4] = this[1], t[5] = this[5], t[6] = this[9], t[7] = this[13], t[8] = this[2], t[9] = this[6], t[10] = this[10], t[11] = this[14], t[12] = this[3], t[13] = this[7], t[14] = this[11], t[15] = this[15], t
                 }
                 identity() {
-                    return this.copy(nh)
+                    return this.copy(Jc)
                 }
                 fromObject(t) {
                     return this.check()
                 }
                 fromQuaternion(t) {
                     var e, n, i, r, s, o, a, l, c, h, u, d, p, f, g, m, v, b;
                     return e = this, h = (i = (n = t)[0]) * (a = i + i), u = (r = n[1]) * a, d = r * (l = r + r), p = (s = n[2]) * a, f = s * l, g = s * (c = s + s), m = (o = n[3]) * a, v = o * l, b = o * c, e[0] = 1 - d - g, e[1] = u + b, e[2] = p - v, e[3] = 0, e[4] = u - b, e[5] = 1 - h - g, e[6] = f + m, e[7] = 0, e[8] = p + v, e[9] = f - m, e[10] = 1 - h - d, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this.check()
                 }
                 frustum(t) {
                     const {
                         left: e,
                         right: n,
                         bottom: i,
                         top: r,
-                        near: s = th,
-                        far: o = eh
+                        near: s = Kc,
+                        far: o = Qc
                     } = t;
                     return o === 1 / 0 ? function(t, e, n, i, r, s) {
                         const o = 2 * s / (n - e),
                             a = 2 * s / (r - i),
                             l = (n + e) / (n - e),
                             c = (r + i) / (r - i),
                             h = -2 * s;
@@ -8783,44 +8842,44 @@
                             m = e[2],
                             v = i[0],
                             b = i[1],
                             y = i[2],
                             _ = n[0],
                             x = n[1],
                             w = n[2];
-                        Math.abs(f - _) < vc && Math.abs(g - x) < vc && Math.abs(m - w) < vc ? function(t) {
+                        Math.abs(f - _) < fc && Math.abs(g - x) < fc && Math.abs(m - w) < fc ? function(t) {
                             t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1
                         }(t) : (h = f - _, u = g - x, d = m - w, r = b * (d *= p = 1 / Math.hypot(h, u, d)) - y * (u *= p), s = y * (h *= p) - v * d, o = v * u - b * h, (p = Math.hypot(r, s, o)) ? (r *= p = 1 / p, s *= p, o *= p) : (r = 0, s = 0, o = 0), a = u * o - d * s, l = d * r - h * o, c = h * s - u * r, (p = Math.hypot(a, l, c)) ? (a *= p = 1 / p, l *= p, c *= p) : (a = 0, l = 0, c = 0), t[0] = r, t[1] = a, t[2] = h, t[3] = 0, t[4] = s, t[5] = l, t[6] = u, t[7] = 0, t[8] = o, t[9] = c, t[10] = d, t[11] = 0, t[12] = -(r * f + s * g + o * m), t[13] = -(a * f + l * g + c * m), t[14] = -(h * f + u * g + d * m), t[15] = 1)
                     }(this, e, n, i), this.check()
                 }
                 ortho(t) {
                     const {
                         left: e,
                         right: n,
                         bottom: i,
                         top: r,
-                        near: s = th,
-                        far: o = eh
+                        near: s = Kc,
+                        far: o = Qc
                     } = t;
                     return function(t, e, n, i, r, s, o) {
                         var a = 1 / (e - n),
                             l = 1 / (i - r),
                             c = 1 / (s - o);
                         t[0] = -2 * a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * c, t[11] = 0, t[12] = (e + n) * a, t[13] = (r + i) * l, t[14] = (o + s) * c, t[15] = 1
                     }(this, e, n, i, r, s, o), this.check()
                 }
                 orthographic(t) {
                     const {
-                        fovy: e = Jc,
-                        aspect: n = $c,
+                        fovy: e = Xc,
+                        aspect: n = Yc,
                         focalDistance: i = 1,
-                        near: r = th,
-                        far: s = eh
+                        near: r = Kc,
+                        far: s = Qc
                     } = t;
-                    oh(e);
+                    nh(e);
                     const o = e / 2,
                         a = i * Math.tan(o),
                         l = a * n;
                     return this.ortho({
                         left: -l,
                         right: l,
                         bottom: -a,
@@ -8832,15 +8891,15 @@
                 perspective(t) {
                     const {
                         fovy: e = 45 * Math.PI / 180,
                         aspect: n = 1,
                         near: i = .1,
                         far: r = 500
                     } = t;
-                    return oh(e),
+                    return nh(e),
                         function(t, e, n, i, r) {
                             var s, o = 1 / Math.tan(e / 2);
                             t[0] = o / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != r && r !== 1 / 0 ? (s = 1 / (i - r), t[10] = (r + i) * s, t[14] = 2 * r * i * s) : (t[10] = -1, t[14] = -2 * i)
                         }(this, e, n, i, r), this.check()
                 }
                 determinant() {
                     return e = (t = this)[0], n = t[1], i = t[2], r = t[3], s = t[4], o = t[5], a = t[6], l = t[7], c = t[8], h = t[9], u = t[10], d = t[11], p = t[12], f = t[13], g = t[14], (e * o - n * s) * (u * (m = t[15]) - d * g) - (e * a - i * s) * (h * m - d * f) + (e * l - r * s) * (h * g - u * f) + (n * a - i * o) * (c * m - d * p) - (n * l - r * o) * (c * g - u * p) + (i * l - r * a) * (c * f - h * p);
@@ -8878,52 +8937,52 @@
                                 o = e[7],
                                 a = e[11];
                             t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = n, t[6] = e[9], t[7] = e[13], t[8] = i, t[9] = s, t[11] = e[14], t[12] = r, t[13] = o, t[14] = a
                         } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15]
                     }(this, this), this.check()
                 }
                 invert() {
-                    return Nc(this, this), this.check()
+                    return Fc(this, this), this.check()
                 }
                 multiplyLeft(t) {
-                    return Vc(this, t, this), this.check()
+                    return zc(this, t, this), this.check()
                 }
                 multiplyRight(t) {
-                    return Vc(this, this, t), this.check()
+                    return zc(this, this, t), this.check()
                 }
                 rotateX(t) {
-                    return Wc(this, this, t), this.check()
+                    return Nc(this, this, t), this.check()
                 }
                 rotateY(t) {
                     var e, n, i, r, s, o, a, l, c, h, u, d, p;
                     return e = this, n = this, i = t, r = Math.sin(i), s = Math.cos(i), o = n[0], a = n[1], l = n[2], c = n[3], h = n[8], u = n[9], d = n[10], p = n[11], n !== e && (e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15]), e[0] = o * s - h * r, e[1] = a * s - u * r, e[2] = l * s - d * r, e[3] = c * s - p * r, e[8] = o * r + h * s, e[9] = a * r + u * s, e[10] = l * r + d * s, e[11] = c * r + p * s, this.check()
                 }
                 rotateZ(t) {
-                    return Hc(this, this, t), this.check()
+                    return Vc(this, this, t), this.check()
                 }
                 rotateXYZ(t) {
                     return this.rotateX(t[0]).rotateY(t[1]).rotateZ(t[2])
                 }
                 rotateAxis(t, e) {
                     return function(t, e, n, i) {
                         var r, s, o, a, l, c, h, u, d, p, f, g, m, v, b, y, _, x, w, E, P, S, C, T, A = i[0],
                             M = i[1],
                             O = i[2],
                             L = Math.hypot(A, M, O);
-                        L < vc || (A *= L = 1 / L, M *= L, O *= L, r = Math.sin(n), o = 1 - (s = Math.cos(n)), a = e[0], l = e[1], c = e[2], h = e[3], u = e[4], d = e[5], p = e[6], f = e[7], g = e[8], m = e[9], v = e[10], b = e[11], y = A * A * o + s, _ = M * A * o + O * r, x = O * A * o - M * r, w = A * M * o - O * r, E = M * M * o + s, P = O * M * o + A * r, S = A * O * o + M * r, C = M * O * o - A * r, T = O * O * o + s, t[0] = a * y + u * _ + g * x, t[1] = l * y + d * _ + m * x, t[2] = c * y + p * _ + v * x, t[3] = h * y + f * _ + b * x, t[4] = a * w + u * E + g * P, t[5] = l * w + d * E + m * P, t[6] = c * w + p * E + v * P, t[7] = h * w + f * E + b * P, t[8] = a * S + u * C + g * T, t[9] = l * S + d * C + m * T, t[10] = c * S + p * C + v * T, t[11] = h * S + f * C + b * T, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]))
+                        L < fc || (A *= L = 1 / L, M *= L, O *= L, r = Math.sin(n), o = 1 - (s = Math.cos(n)), a = e[0], l = e[1], c = e[2], h = e[3], u = e[4], d = e[5], p = e[6], f = e[7], g = e[8], m = e[9], v = e[10], b = e[11], y = A * A * o + s, _ = M * A * o + O * r, x = O * A * o - M * r, w = A * M * o - O * r, E = M * M * o + s, P = O * M * o + A * r, S = A * O * o + M * r, C = M * O * o - A * r, T = O * O * o + s, t[0] = a * y + u * _ + g * x, t[1] = l * y + d * _ + m * x, t[2] = c * y + p * _ + v * x, t[3] = h * y + f * _ + b * x, t[4] = a * w + u * E + g * P, t[5] = l * w + d * E + m * P, t[6] = c * w + p * E + v * P, t[7] = h * w + f * E + b * P, t[8] = a * S + u * C + g * T, t[9] = l * S + d * C + m * T, t[10] = c * S + p * C + v * T, t[11] = h * S + f * C + b * T, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]))
                     }(this, this, t, e), this.check()
                 }
                 scale(t) {
-                    return Gc(this, this, Array.isArray(t) ? t : [t, t, t]), this.check()
+                    return Dc(this, this, Array.isArray(t) ? t : [t, t, t]), this.check()
                 }
                 translate(t) {
-                    return Uc(this, this, t), this.check()
+                    return Bc(this, this, t), this.check()
                 }
                 transform(t, e) {
-                    return 4 === t.length ? (fc(e = Qc(e || [-0, -0, -0, -0], t, this), 4), e) : this.transformAsPoint(t, e)
+                    return 4 === t.length ? (uc(e = qc(e || [-0, -0, -0, -0], t, this), 4), e) : this.transformAsPoint(t, e)
                 }
                 transformAsPoint(t, e) {
                     const {
                         length: n
                     } = t;
                     let i;
                     switch (n) {
@@ -8931,39 +8990,39 @@
                             i = function(t, e, n) {
                                 var i = e[0],
                                     r = e[1];
                                 return t[0] = n[0] * i + n[4] * r + n[12], t[1] = n[1] * i + n[5] * r + n[13], t
                             }(e || [-0, -0], t, this);
                             break;
                         case 3:
-                            i = Ec(e || [-0, -0, -0], t, this);
+                            i = _c(e || [-0, -0, -0], t, this);
                             break;
                         default:
                             throw new Error("Illegal vector")
                     }
-                    return fc(i, t.length), i
+                    return uc(i, t.length), i
                 }
                 transformAsVector(t, e) {
                     let n;
                     switch (t.length) {
                         case 2:
                             n = function(t, e, n) {
                                 const i = e[0],
                                     r = e[1],
                                     s = n[3] * i + n[7] * r || 1;
                                 return t[0] = (n[0] * i + n[4] * r) / s, t[1] = (n[1] * i + n[5] * r) / s, t
                             }(e || [-0, -0], t, this);
                             break;
                         case 3:
-                            n = Mc(e || [-0, -0, -0], t, this);
+                            n = Cc(e || [-0, -0, -0], t, this);
                             break;
                         default:
                             throw new Error("Illegal vector")
                     }
-                    return fc(n, t.length), n
+                    return uc(n, t.length), n
                 }
                 transformPoint(t, e) {
                     return this.transformAsPoint(t, e)
                 }
                 transformVector(t, e) {
                     return this.transformAsPoint(t, e)
                 }
@@ -8973,247 +9032,274 @@
                 makeRotationX(t) {
                     return this.identity().rotateX(t)
                 }
                 makeTranslation(t, e, n) {
                     return this.identity().translate([t, e, n])
                 }
             }
-            let rh, sh;
+            let th, eh;
 
-            function oh(t) {
+            function nh(t) {
                 if (t > 2 * Math.PI) throw Error("expected radians")
             }
 
-            function ah(t, e) {
-                const n = Qc([], e, t);
-                return Kc(n, n, 1 / n[3]), n
+            function ih(t, e) {
+                const n = qc([], e, t);
+                return Zc(n, n, 1 / n[3]), n
             }
 
-            function lh(t, e) {
+            function rh(t, e) {
                 const n = t % e;
                 return n < 0 ? e + n : n
             }
 
-            function ch(t, e, n) {
+            function sh(t, e, n) {
                 return t < e ? e : t > n ? n : t
             }
-            const hh = Math.log2 || function(t) {
+            const oh = Math.log2 || function(t) {
                 return Math.log(t) * Math.LOG2E
             };
 
-            function uh(t, e) {
+            function ah(t, e) {
                 if (!t) throw new Error(e || "@math.gl/web-mercator: assertion failed.")
             }
-            const dh = Math.PI,
-                ph = dh / 4,
-                fh = dh / 180,
-                gh = 180 / dh,
-                mh = 512,
-                vh = 4003e4,
-                bh = 85.051129,
-                yh = 1.5;
+            const lh = Math.PI,
+                ch = lh / 4,
+                hh = lh / 180,
+                uh = 180 / lh,
+                dh = 512,
+                ph = 4003e4,
+                fh = 85.051129,
+                gh = 1.5;
 
-            function _h(t) {
+            function mh(t) {
                 const [e, n] = t;
-                uh(Number.isFinite(e)), uh(Number.isFinite(n) && n >= -90 && n <= 90, "invalid latitude");
-                const i = n * fh;
-                return [mh * (e * fh + dh) / (2 * dh), mh * (dh + Math.log(Math.tan(ph + .5 * i))) / (2 * dh)]
-            }
-
-            function xh(t) {
-                const [e, n] = t, i = e / mh * (2 * dh) - dh, r = 2 * (Math.atan(Math.exp(n / mh * (2 * dh) - dh)) - ph);
-                return [i * gh, r * gh]
+                ah(Number.isFinite(e)), ah(Number.isFinite(n) && n >= -90 && n <= 90, "invalid latitude");
+                const i = n * hh;
+                return [dh * (e * hh + lh) / (2 * lh), dh * (lh + Math.log(Math.tan(ch + .5 * i))) / (2 * lh)]
             }
 
-            function wh(t) {
-                const e = Math.cos(t * fh);
-                return mh / vh / e
+            function vh(t) {
+                const [e, n] = t, i = e / dh * (2 * lh) - lh, r = 2 * (Math.atan(Math.exp(n / dh * (2 * lh) - lh)) - ch);
+                return [i * uh, r * uh]
             }
 
-            function Eh(t) {
+            function bh(t) {
                 const {
                     latitude: e,
                     longitude: n,
                     highPrecision: i = !1
                 } = t;
-                uh(Number.isFinite(e) && Number.isFinite(n));
-                const r = mh,
-                    s = Math.cos(e * fh),
+                ah(Number.isFinite(e) && Number.isFinite(n));
+                const r = dh,
+                    s = Math.cos(e * hh),
                     o = r / 360,
                     a = o / s,
-                    l = r / vh / s,
+                    l = r / ph / s,
                     c = {
                         unitsPerMeter: [l, l, l],
                         metersPerUnit: [1 / l, 1 / l, 1 / l],
                         unitsPerDegree: [o, a, l],
                         degreesPerUnit: [1 / o, 1 / a, 1 / l]
                     };
                 if (i) {
-                    const t = fh * Math.tan(e * fh) / s,
+                    const t = hh * Math.tan(e * hh) / s,
                         n = o * t / 2,
-                        i = r / vh * t,
+                        i = r / ph * t,
                         h = i / a * l;
                     c.unitsPerDegree2 = [0, n, i], c.unitsPerMeter2 = [h, 0, h]
                 }
                 return c
             }
 
-            function Ph(t, e) {
+            function yh(t, e) {
                 const [n, i, r] = t, [s, o, a] = e, {
                     unitsPerMeter: l,
                     unitsPerMeter2: c
-                } = Eh({
+                } = bh({
                     longitude: n,
                     latitude: i,
                     highPrecision: !0
-                }), h = _h(t);
+                }), h = mh(t);
                 h[0] += s * (l[0] + c[0] * o), h[1] += o * (l[1] + c[1] * o);
-                const u = xh(h),
+                const u = vh(h),
                     d = (r || 0) + (a || 0);
                 return Number.isFinite(r) || Number.isFinite(a) ? [u[0], u[1], d] : u
             }
 
-            function Sh(t) {
-                return 2 * Math.atan(.5 / t) * gh
+            function _h(t) {
+                return 2 * Math.atan(.5 / t) * uh
             }
 
-            function Ch(t) {
-                return .5 / Math.tan(.5 * t * fh)
+            function xh(t) {
+                return .5 / Math.tan(.5 * t * hh)
             }
 
-            function Th(t, e) {
+            function wh(t, e) {
                 const [n, i, r = 0] = t;
-                return uh(Number.isFinite(n) && Number.isFinite(i) && Number.isFinite(r)), ah(e, [n, i, r, 1])
+                return ah(Number.isFinite(n) && Number.isFinite(i) && Number.isFinite(r)), ih(e, [n, i, r, 1])
             }
 
-            function Ah(t, e, n = 0) {
+            function Eh(t, e, n = 0) {
                 const [i, r, s] = t;
-                if (uh(Number.isFinite(i) && Number.isFinite(r), "invalid pixel coordinate"), Number.isFinite(s)) return ah(e, [i, r, s, 1]);
-                const o = ah(e, [i, r, 0, 1]),
-                    a = ah(e, [i, r, 1, 1]),
+                if (ah(Number.isFinite(i) && Number.isFinite(r), "invalid pixel coordinate"), Number.isFinite(s)) return ih(e, [i, r, s, 1]);
+                const o = ih(e, [i, r, 0, 1]),
+                    a = ih(e, [i, r, 1, 1]),
                     l = o[2],
                     c = a[2];
-                return Yc([], o, a, l === c ? 0 : ((n || 0) - l) / (c - l))
+                return Hc([], o, a, l === c ? 0 : ((n || 0) - l) / (c - l))
+            }
+
+            function Ph(t) {
+                const {
+                    width: e,
+                    height: n,
+                    bounds: i,
+                    minExtent: r = 0,
+                    maxZoom: s = 24,
+                    offset: o = [0, 0]
+                } = t, [
+                    [a, l],
+                    [c, h]
+                ] = i, u = function(t = 0) {
+                    return "number" == typeof t ? {
+                        top: t,
+                        bottom: t,
+                        left: t,
+                        right: t
+                    } : (ah(Number.isFinite(t.top) && Number.isFinite(t.bottom) && Number.isFinite(t.left) && Number.isFinite(t.right)), t)
+                }(t.padding), d = mh([a, sh(h, -85.051129, fh)]), p = mh([c, sh(l, -85.051129, fh)]), f = [Math.max(Math.abs(p[0] - d[0]), r), Math.max(Math.abs(p[1] - d[1]), r)], g = [e - u.left - u.right - 2 * Math.abs(o[0]), n - u.top - u.bottom - 2 * Math.abs(o[1])];
+                ah(g[0] > 0 && g[1] > 0);
+                const m = g[0] / f[0],
+                    v = g[1] / f[1],
+                    b = (u.right - u.left) / 2 / m,
+                    y = (u.top - u.bottom) / 2 / v,
+                    _ = vh([(p[0] + d[0]) / 2 + b, (p[1] + d[1]) / 2 + y]),
+                    x = Math.min(s, oh(Math.abs(Math.min(m, v))));
+                return ah(Number.isFinite(x)), {
+                    longitude: _[0],
+                    latitude: _[1],
+                    zoom: x
+                }
             }
-            const Mh = Math.PI / 180;
+            const Sh = Math.PI / 180;
 
-            function Oh(t, e, n) {
+            function Ch(t, e, n) {
                 const {
                     pixelUnprojectionMatrix: i
-                } = t, r = ah(i, [e, 0, 1, 1]), s = ah(i, [e, t.height, 1, 1]), o = xh(Yc([], r, s, (n * t.distanceScales.unitsPerMeter[2] - r[2]) / (s[2] - r[2])));
+                } = t, r = ih(i, [e, 0, 1, 1]), s = ih(i, [e, t.height, 1, 1]), o = vh(Hc([], r, s, (n * t.distanceScales.unitsPerMeter[2] - r[2]) / (s[2] - r[2])));
                 return o.push(n), o
             }
-            const Lh = {
+            const Th = {
                 DEFAULT: -1,
                 LNGLAT: 1,
                 METER_OFFSETS: 2,
                 LNGLAT_OFFSETS: 3,
                 CARTESIAN: 0
             };
-            Object.defineProperty(Lh, "IDENTITY", {
-                get: () => (na.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
+            Object.defineProperty(Th, "IDENTITY", {
+                get: () => (ta.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
             });
-            const Rh = {
+            const Ah = {
                     WEB_MERCATOR: 1,
                     GLOBE: 2,
                     WEB_MERCATOR_AUTO_OFFSET: 4,
                     IDENTITY: 0
                 },
-                Ih = {
+                Mh = {
                     common: 0,
                     meters: 1,
                     pixels: 2
                 },
-                kh = {
+                Oh = {
                     click: {
                         handler: "onClick"
                     },
                     panstart: {
                         handler: "onDragStart"
                     },
                     panmove: {
                         handler: "onDrag"
                     },
                     panend: {
                         handler: "onDragEnd"
                     }
                 },
-                jh = Math.PI / 180,
-                Fh = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
-                zh = [0, 0, 0],
-                Bh = {
+                Lh = "draw",
+                kh = "mask",
+                Rh = Math.PI / 180,
+                Ih = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
+                jh = [0, 0, 0],
+                Fh = {
                     unitsPerMeter: [1, 1, 1],
                     metersPerUnit: [1, 1, 1]
                 };
-            class Dh {
+            class zh {
                 constructor(t = {}) {
-                    wo(this, "id", void 0), wo(this, "x", void 0), wo(this, "y", void 0), wo(this, "width", void 0), wo(this, "height", void 0), wo(this, "padding", void 0), wo(this, "isGeospatial", void 0), wo(this, "zoom", void 0), wo(this, "focalDistance", void 0), wo(this, "position", void 0), wo(this, "modelMatrix", void 0), wo(this, "distanceScales", void 0), wo(this, "scale", void 0), wo(this, "center", void 0), wo(this, "cameraPosition", void 0), wo(this, "projectionMatrix", void 0), wo(this, "viewMatrix", void 0), wo(this, "viewMatrixUncentered", void 0), wo(this, "viewMatrixInverse", void 0), wo(this, "viewProjectionMatrix", void 0), wo(this, "pixelProjectionMatrix", void 0), wo(this, "pixelUnprojectionMatrix", void 0), wo(this, "resolution", void 0), wo(this, "_frustumPlanes", {}), this.id = t.id || this.constructor.displayName || "viewport", this.x = t.x || 0, this.y = t.y || 0, this.width = t.width || 1, this.height = t.height || 1, this.zoom = t.zoom || 0, this.padding = t.padding, this.distanceScales = t.distanceScales || Bh, this.focalDistance = t.focalDistance || 1, this.position = t.position || zh, this.modelMatrix = t.modelMatrix || null;
+                    wo(this, "id", void 0), wo(this, "x", void 0), wo(this, "y", void 0), wo(this, "width", void 0), wo(this, "height", void 0), wo(this, "isGeospatial", void 0), wo(this, "zoom", void 0), wo(this, "focalDistance", void 0), wo(this, "position", void 0), wo(this, "modelMatrix", void 0), wo(this, "distanceScales", void 0), wo(this, "scale", void 0), wo(this, "center", void 0), wo(this, "cameraPosition", void 0), wo(this, "projectionMatrix", void 0), wo(this, "viewMatrix", void 0), wo(this, "viewMatrixUncentered", void 0), wo(this, "viewMatrixInverse", void 0), wo(this, "viewProjectionMatrix", void 0), wo(this, "pixelProjectionMatrix", void 0), wo(this, "pixelUnprojectionMatrix", void 0), wo(this, "resolution", void 0), wo(this, "_frustumPlanes", {}), this.id = t.id || this.constructor.displayName || "viewport", this.x = t.x || 0, this.y = t.y || 0, this.width = t.width || 1, this.height = t.height || 1, this.zoom = t.zoom || 0, this.distanceScales = t.distanceScales || Fh, this.focalDistance = t.focalDistance || 1, this.position = t.position || jh, this.modelMatrix = t.modelMatrix || null;
                     const {
                         longitude: e,
                         latitude: n
                     } = t;
                     this.isGeospatial = Number.isFinite(n) && Number.isFinite(e), this._initProps(t), this._initMatrices(t), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this)
                 }
-                get subViewports() {
-                    return null
-                }
                 get metersPerPixel() {
                     return this.distanceScales.metersPerUnit[2] / this.scale
                 }
                 get projectionMode() {
-                    return this.isGeospatial ? this.zoom < 12 ? Rh.WEB_MERCATOR : Rh.WEB_MERCATOR_AUTO_OFFSET : Rh.IDENTITY
+                    return this.isGeospatial ? this.zoom < 12 ? Ah.WEB_MERCATOR : Ah.WEB_MERCATOR_AUTO_OFFSET : Ah.IDENTITY
                 }
                 equals(t) {
-                    return t instanceof Dh && (this === t || t.width === this.width && t.height === this.height && t.scale === this.scale && uc(t.projectionMatrix, this.projectionMatrix) && uc(t.viewMatrix, this.viewMatrix))
+                    return t instanceof zh && (this === t || t.width === this.width && t.height === this.height && t.scale === this.scale && lc(t.projectionMatrix, this.projectionMatrix) && lc(t.viewMatrix, this.viewMatrix))
                 }
                 project(t, {
                     topLeft: e = !0
                 } = {}) {
-                    const n = Th(this.projectPosition(t), this.pixelProjectionMatrix),
+                    const n = wh(this.projectPosition(t), this.pixelProjectionMatrix),
                         [i, r] = n,
                         s = e ? r : this.height - r;
                     return 2 === t.length ? [i, s] : [i, s, n[2]]
                 }
                 unproject(t, {
                     topLeft: e = !0,
                     targetZ: n
                 } = {}) {
-                    const [i, r, s] = t, o = e ? r : this.height - r, a = n && n * this.distanceScales.unitsPerMeter[2], l = Ah([i, o, s], this.pixelUnprojectionMatrix, a), [c, h, u] = this.unprojectPosition(l);
+                    const [i, r, s] = t, o = e ? r : this.height - r, a = n && n * this.distanceScales.unitsPerMeter[2], l = Eh([i, o, s], this.pixelUnprojectionMatrix, a), [c, h, u] = this.unprojectPosition(l);
                     return Number.isFinite(s) ? [c, h, u] : Number.isFinite(n) ? [c, h, n] : [c, h]
                 }
                 projectPosition(t) {
                     const [e, n] = this.projectFlat(t);
                     return [e, n, (t[2] || 0) * this.distanceScales.unitsPerMeter[2]]
                 }
                 unprojectPosition(t) {
                     const [e, n] = this.unprojectFlat(t);
                     return [e, n, (t[2] || 0) * this.distanceScales.metersPerUnit[2]]
                 }
                 projectFlat(t) {
                     if (this.isGeospatial) {
-                        const e = _h(t);
-                        return e[1] = cc(e[1], -318, 830), e
+                        const e = mh(t);
+                        return e[1] = oc(e[1], -318, 830), e
                     }
                     return t
                 }
                 unprojectFlat(t) {
-                    return this.isGeospatial ? xh(t) : t
+                    return this.isGeospatial ? vh(t) : t
                 }
                 getBounds(t = {}) {
                     const e = {
                             targetZ: t.z || 0
                         },
                         n = this.unproject([0, 0], e),
                         i = this.unproject([this.width, 0], e),
                         r = this.unproject([0, this.height], e),
                         s = this.unproject([this.width, this.height], e);
                     return [Math.min(n[0], i[0], r[0], s[0]), Math.min(n[1], i[1], r[1], s[1]), Math.max(n[0], i[0], r[0], s[0]), Math.max(n[1], i[1], r[1], s[1])]
                 }
                 getDistanceScales(t) {
-                    return t ? Eh({
+                    return t ? bh({
                         longitude: t[0],
                         latitude: t[1],
                         highPrecision: !0
                     }) : this.distanceScales
                 }
                 containsPixel({
                     x: t,
@@ -9221,168 +9307,168 @@
                     width: n = 1,
                     height: i = 1
                 }) {
                     return t < this.x + this.width && this.x < t + n && e < this.y + this.height && this.y < e + i
                 }
                 getFrustumPlanes() {
                     return this._frustumPlanes.near || Object.assign(this._frustumPlanes, {
-                        left: jc((t = this.viewProjectionMatrix)[3] + t[0], t[7] + t[4], t[11] + t[8], t[15] + t[12]),
-                        right: jc(t[3] - t[0], t[7] - t[4], t[11] - t[8], t[15] - t[12]),
-                        bottom: jc(t[3] + t[1], t[7] + t[5], t[11] + t[9], t[15] + t[13]),
-                        top: jc(t[3] - t[1], t[7] - t[5], t[11] - t[9], t[15] - t[13]),
-                        near: jc(t[3] + t[2], t[7] + t[6], t[11] + t[10], t[15] + t[14]),
-                        far: jc(t[3] - t[2], t[7] - t[6], t[11] - t[10], t[15] - t[14])
+                        left: kc((t = this.viewProjectionMatrix)[3] + t[0], t[7] + t[4], t[11] + t[8], t[15] + t[12]),
+                        right: kc(t[3] - t[0], t[7] - t[4], t[11] - t[8], t[15] - t[12]),
+                        bottom: kc(t[3] + t[1], t[7] + t[5], t[11] + t[9], t[15] + t[13]),
+                        top: kc(t[3] - t[1], t[7] - t[5], t[11] - t[9], t[15] - t[13]),
+                        near: kc(t[3] + t[2], t[7] + t[6], t[11] + t[10], t[15] + t[14]),
+                        far: kc(t[3] - t[2], t[7] - t[6], t[11] - t[10], t[15] - t[14])
                     }), this._frustumPlanes;
                     var t
                 }
                 panByPosition(t, e) {
                     return null
                 }
                 _initProps(t) {
                     const e = t.longitude,
                         n = t.latitude;
                     this.isGeospatial && (Number.isFinite(t.zoom) || (this.zoom = function(t) {
                         const {
                             latitude: e
                         } = t;
-                        uh(Number.isFinite(e));
-                        const n = Math.cos(e * fh);
-                        return hh(vh * n) - 9
+                        ah(Number.isFinite(e));
+                        const n = Math.cos(e * hh);
+                        return oh(ph * n) - 9
                     }({
                         latitude: n
-                    }) + Math.log2(this.focalDistance)), this.distanceScales = t.distanceScales || Eh({
+                    }) + Math.log2(this.focalDistance)), this.distanceScales = t.distanceScales || bh({
                         latitude: n,
                         longitude: e
                     }));
                     const i = Math.pow(2, this.zoom);
                     this.scale = i;
                     const {
                         position: r,
                         modelMatrix: s
                     } = t;
-                    let o = zh;
-                    if (r && (o = s ? new ih(s).transformAsVector(r, []) : r), this.isGeospatial) {
+                    let o = jh;
+                    if (r && (o = s ? new $c(s).transformAsVector(r, []) : r), this.isGeospatial) {
                         const t = this.projectPosition([e, n, 0]);
-                        this.center = new Ic(o).scale(this.distanceScales.unitsPerMeter).add(t)
+                        this.center = new Oc(o).scale(this.distanceScales.unitsPerMeter).add(t)
                     } else this.center = this.projectPosition(o)
                 }
                 _initMatrices(t) {
                     const {
-                        viewMatrix: e = Fh,
+                        viewMatrix: e = Ih,
                         projectionMatrix: n = null,
                         orthographic: i = !1,
                         fovyRadians: r,
                         fovy: s = 75,
                         near: o = .1,
                         far: a = 1e3,
                         padding: l = null,
                         focalDistance: c = 1
                     } = t;
-                    this.viewMatrixUncentered = e, this.viewMatrix = (new ih).multiplyRight(e).translate(new Ic(this.center).negate()), this.projectionMatrix = n || function({
+                    this.viewMatrixUncentered = e, this.viewMatrix = (new $c).multiplyRight(e).translate(new Oc(this.center).negate()), this.projectionMatrix = n || function({
                         width: t,
                         height: e,
                         orthographic: n,
                         fovyRadians: i,
                         focalDistance: r,
                         padding: s,
                         near: o,
                         far: a
                     }) {
                         const l = t / e,
-                            c = n ? (new ih).orthographic({
+                            c = n ? (new $c).orthographic({
                                 fovy: i,
                                 aspect: l,
                                 focalDistance: r,
                                 near: o,
                                 far: a
-                            }) : (new ih).perspective({
+                            }) : (new $c).perspective({
                                 fovy: i,
                                 aspect: l,
                                 near: o,
                                 far: a
                             });
                         if (s) {
                             const {
                                 left: n = 0,
                                 right: i = 0,
                                 top: r = 0,
                                 bottom: o = 0
-                            } = s, a = cc((n + t - i) / 2, 0, t) - t / 2, l = cc((r + e - o) / 2, 0, e) - e / 2;
+                            } = s, a = oc((n + t - i) / 2, 0, t) - t / 2, l = oc((r + e - o) / 2, 0, e) - e / 2;
                             c[8] -= 2 * a / t, c[9] += 2 * l / e
                         }
                         return c
                     }({
                         width: this.width,
                         height: this.height,
                         orthographic: i,
-                        fovyRadians: r || s * jh,
+                        fovyRadians: r || s * Rh,
                         focalDistance: c,
                         padding: l,
                         near: o,
                         far: a
                     });
                     const h = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                     var u;
-                    Vc(h, h, this.projectionMatrix), Vc(h, h, this.viewMatrix), this.viewProjectionMatrix = h, this.viewMatrixInverse = Nc([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = [(u = this.viewMatrixInverse)[12], u[13], u[14]];
+                    zc(h, h, this.projectionMatrix), zc(h, h, this.viewMatrix), this.viewProjectionMatrix = h, this.viewMatrixInverse = Fc([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = [(u = this.viewMatrixInverse)[12], u[13], u[14]];
                     const d = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                         p = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
-                    Gc(d, d, [this.width / 2, -this.height / 2, 1]), Uc(d, d, [1, -1, 0]), Vc(p, d, this.viewProjectionMatrix), this.pixelProjectionMatrix = p, this.pixelUnprojectionMatrix = Nc([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || na.warn("Pixel project matrix not invertible")()
+                    Dc(d, d, [this.width / 2, -this.height / 2, 1]), Bc(d, d, [1, -1, 0]), zc(p, d, this.viewProjectionMatrix), this.pixelProjectionMatrix = p, this.pixelUnprojectionMatrix = Fc([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || ta.warn("Pixel project matrix not invertible")()
                 }
             }
-            wo(Dh, "displayName", "Viewport");
-            const Nh = "vs",
-                Vh = "fs";
+            wo(zh, "displayName", "Viewport");
+            const Bh = "vs",
+                Dh = "fs";
 
-            function Uh(t, e) {
+            function Nh(t, e) {
                 if (!t) throw new Error(e || "shadertools: assertion failed.")
             }
-            const Gh = {
+            const Vh = {
                 number: {
                     validate: (t, e) => Number.isFinite(t) && (!("max" in e) || t <= e.max) && (!("min" in e) || t >= e.min)
                 },
                 array: {
                     validate: (t, e) => Array.isArray(t) || ArrayBuffer.isView(t)
                 }
             };
 
-            function Wh(t) {
-                let e = Hh(t);
-                return "object" === e ? t ? "type" in t ? Object.assign({}, t, Gh[t.type]) : "value" in t ? (e = Hh(t.value), Object.assign({
+            function Uh(t) {
+                let e = Gh(t);
+                return "object" === e ? t ? "type" in t ? Object.assign({}, t, Vh[t.type]) : "value" in t ? (e = Gh(t.value), Object.assign({
                     type: e
-                }, t, Gh[e])) : {
+                }, t, Vh[e])) : {
                     type: "object",
                     value: t
                 } : {
                     type: "object",
                     value: null
                 } : Object.assign({
                     type: e,
                     value: t
-                }, Gh[e])
+                }, Vh[e])
             }
 
-            function Hh(t) {
+            function Gh(t) {
                 return Array.isArray(t) || ArrayBuffer.isView(t) ? "array" : typeof t
             }
-            class Zh {
+            class Wh {
                 constructor(t) {
                     let {
                         name: e,
                         vs: n,
                         fs: i,
                         dependencies: r = [],
                         uniforms: s,
                         getUniforms: o,
                         deprecations: a = [],
                         defines: l = {},
                         inject: c = {},
                         vertexShader: h,
                         fragmentShader: u
                     } = t;
-                    Uh("string" == typeof e), this.name = e, this.vs = n || h, this.fs = i || u, this.getModuleUniforms = o, this.dependencies = r, this.deprecations = this._parseDeprecationDefinitions(a), this.defines = l, this.injections = function(t) {
+                    Nh("string" == typeof e), this.name = e, this.vs = n || h, this.fs = i || u, this.getModuleUniforms = o, this.dependencies = r, this.deprecations = this._parseDeprecationDefinitions(a), this.defines = l, this.injections = function(t) {
                         const e = {
                             vs: {},
                             fs: {}
                         };
                         for (const n in t) {
                             let i = t[n];
                             "string" == typeof i && (i = {
@@ -9390,15 +9476,15 @@
                                 injection: i
                             }), e[n.slice(0, 2)][n] = i
                         }
                         return e
                     }(c), s && (this.uniforms = function(t) {
                         const e = {};
                         for (const n in t) {
-                            const i = Wh(t[n]);
+                            const i = Uh(t[n]);
                             e[n] = i
                         }
                         return e
                     }(s))
                 }
                 getModuleSource(t) {
                     let e;
@@ -9406,15 +9492,15 @@
                         case "vs":
                             e = this.vs || "";
                             break;
                         case "fs":
                             e = this.fs || "";
                             break;
                         default:
-                            Uh(!1)
+                            Nh(!1)
                     }
                     return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), "\n").concat(e, "// END MODULE_").concat(this.name, "\n\n")
                 }
                 getUniforms(t, e) {
                     return this.getModuleUniforms ? this.getModuleUniforms(t, e) : this.uniforms ? this._defaultGetUniforms(t) : {}
                 }
                 getDefines() {
@@ -9432,202 +9518,202 @@
                 }
                 _defaultGetUniforms() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const e = {},
                         n = this.uniforms;
                     for (const i in n) {
                         const r = n[i];
-                        i in t && !r.private ? (r.validate && Uh(r.validate(t[i], r), "".concat(this.name, ": invalid ").concat(i)), e[i] = t[i]) : e[i] = r.value
+                        i in t && !r.private ? (r.validate && Nh(r.validate(t[i], r), "".concat(this.name, ": invalid ").concat(i)), e[i] = t[i]) : e[i] = r.value
                     }
                     return e
                 }
             }
 
-            function qh(t) {
+            function Hh(t) {
                 return function(t) {
                     const e = {},
                         n = {};
-                    return Xh({
+                    return Zh({
                         modules: t,
                         level: 0,
                         moduleMap: e,
                         moduleDepth: n
                     }), Object.keys(n).sort(((t, e) => n[e] - n[t])).map((t => e[t]))
-                }(Yh(t))
+                }(qh(t))
             }
 
-            function Xh(t) {
+            function Zh(t) {
                 let {
                     modules: e,
                     level: n,
                     moduleMap: i,
                     moduleDepth: r
                 } = t;
                 if (n >= 5) throw new Error("Possible loop in shader dependency graph");
                 for (const t of e) i[t.name] = t, (void 0 === r[t.name] || r[t.name] < n) && (r[t.name] = n);
-                for (const t of e) t.dependencies && Xh({
+                for (const t of e) t.dependencies && Zh({
                     modules: t.dependencies,
                     level: n + 1,
                     moduleMap: i,
                     moduleDepth: r
                 })
             }
 
-            function Yh(t, e) {
-                return t.map((t => (t instanceof Zh || (Uh("string" != typeof t, "Shader module use by name is deprecated. Import shader module '".concat(t, "' and use it directly.")), Uh(t.name, "shader module has no name"), (t = new Zh(t)).dependencies = Yh(t.dependencies)), t)))
+            function qh(t, e) {
+                return t.map((t => (t instanceof Wh || (Nh("string" != typeof t, "Shader module use by name is deprecated. Import shader module '".concat(t, "' and use it directly.")), Nh(t.name, "shader module has no name"), (t = new Wh(t)).dependencies = qh(t.dependencies)), t)))
             }
-            const Kh = 7936,
-                Qh = 7937,
-                Jh = 7938,
-                $h = 35724,
-                tu = {
+            const Xh = 7936,
+                Yh = 7937,
+                Kh = 7938,
+                Qh = 35724,
+                Jh = {
                     GLSL_FRAG_DATA: ["WEBGL_draw_buffers", !0],
                     GLSL_FRAG_DEPTH: ["EXT_frag_depth", !0],
                     GLSL_DERIVATIVES: ["OES_standard_derivatives", !0],
                     GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", !0]
                 },
-                eu = {};
-            Object.keys(tu).forEach((t => {
-                eu[t] = t
+                $h = {};
+            Object.keys(Jh).forEach((t => {
+                $h[t] = t
             }));
-            const nu = {};
+            const tu = {};
 
-            function iu(t, e) {
+            function eu(t, e) {
                 let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
-                const i = tu[e];
-                if (Uh(i, e), ! function() {
+                const i = Jh[e];
+                if (Nh(i, e), ! function() {
                         let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                         const e = "undefined" != typeof window && window.navigator || {},
                             n = t.userAgent || e.userAgent || "",
                             i = -1 !== n.indexOf("MSIE "),
                             r = -1 !== n.indexOf("Trident/");
                         return i || r
                     }(n)) return !0;
-                if (e in nu) return nu[e];
+                if (e in tu) return tu[e];
                 const r = i[0],
                     s = n.behavior || "enable",
                     o = "#extension GL_".concat(r, " : ").concat(s, "\nvoid main(void) {}"),
                     a = t.createShader(35633);
                 t.shaderSource(a, o), t.compileShader(a);
                 const l = t.getShaderParameter(a, 35713);
-                return t.deleteShader(a), nu[e] = l, l
+                return t.deleteShader(a), tu[e] = l, l
             }
 
-            function ru(t, e) {
+            function nu(t, e) {
                 return (e = Array.isArray(e) ? e : [e]).every((e => function(t, e) {
-                    const n = tu[e];
-                    Uh(n, e);
+                    const n = Jh[e];
+                    Nh(n, e);
                     const i = function(t) {
                             return "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || Boolean(t && 2 === t._version)
                         }(t) && n[1] || n[0],
                         r = "string" == typeof i ? Boolean(t.getExtension(i)) : i;
-                    return Uh(!1 === r || !0 === r), r
+                    return Nh(!1 === r || !0 === r), r
                 }(t, e)))
             }
-            const su = {
-                    [Nh]: "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n",
-                    [Vh]: "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n"
-                },
-                ou = "__LUMA_INJECT_DECLARATIONS__",
-                au = /void\s+main\s*\([^)]*\)\s*\{\n?/,
-                lu = /}\n?[^{}]*$/,
-                cu = [];
+            const iu = {
+                    [Bh]: "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n",
+                    [Dh]: "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n"
+                },
+                ru = "__LUMA_INJECT_DECLARATIONS__",
+                su = /void\s+main\s*\([^)]*\)\s*\{\n?/,
+                ou = /}\n?[^{}]*$/,
+                au = [];
 
-            function hu(t, e, n) {
+            function lu(t, e, n) {
                 let i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
-                const r = e === Nh;
+                const r = e === Bh;
                 for (const e in n) {
                     const i = n[e];
-                    i.sort(((t, e) => t.order - e.order)), cu.length = i.length;
-                    for (let t = 0, e = i.length; t < e; ++t) cu[t] = i[t].injection;
-                    const s = "".concat(cu.join("\n"), "\n");
+                    i.sort(((t, e) => t.order - e.order)), au.length = i.length;
+                    for (let t = 0, e = i.length; t < e; ++t) au[t] = i[t].injection;
+                    const s = "".concat(au.join("\n"), "\n");
                     switch (e) {
                         case "vs:#decl":
-                            r && (t = t.replace(ou, s));
+                            r && (t = t.replace(ru, s));
                             break;
                         case "vs:#main-start":
-                            r && (t = t.replace(au, (t => t + s)));
+                            r && (t = t.replace(su, (t => t + s)));
                             break;
                         case "vs:#main-end":
-                            r && (t = t.replace(lu, (t => s + t)));
+                            r && (t = t.replace(ou, (t => s + t)));
                             break;
                         case "fs:#decl":
-                            r || (t = t.replace(ou, s));
+                            r || (t = t.replace(ru, s));
                             break;
                         case "fs:#main-start":
-                            r || (t = t.replace(au, (t => t + s)));
+                            r || (t = t.replace(su, (t => t + s)));
                             break;
                         case "fs:#main-end":
-                            r || (t = t.replace(lu, (t => s + t)));
+                            r || (t = t.replace(ou, (t => s + t)));
                             break;
                         default:
                             t = t.replace(e, (t => t + s))
                     }
                 }
-                return t = t.replace(ou, ""), i && (t = t.replace(/\}\s*$/, (t => t + su[e]))), t
+                return t = t.replace(ru, ""), i && (t = t.replace(/\}\s*$/, (t => t + iu[e]))), t
             }
 
-            function uu(t) {
+            function cu(t) {
                 const e = {};
-                return Uh(Array.isArray(t) && t.length > 1), t.forEach((t => {
+                return Nh(Array.isArray(t) && t.length > 1), t.forEach((t => {
                     for (const n in t) e[n] = e[n] ? "".concat(e[n], "\n").concat(t[n]) : t[n]
                 })), e
             }
 
-            function du(t) {
+            function hu(t) {
                 return new RegExp("\\b".concat(t, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g")
             }
-            const pu = [
+            const uu = [
                     [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"],
                     [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
                     [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
                 ],
-                fu = [...pu, [du("attribute"), "in $1"],
-                    [du("varying"), "out $1"]
+                du = [...uu, [hu("attribute"), "in $1"],
+                    [hu("varying"), "out $1"]
                 ],
-                gu = [...pu, [du("varying"), "in $1"]],
-                mu = [
+                pu = [...uu, [hu("varying"), "in $1"]],
+                fu = [
                     [/^#version[ \t]+300[ \t]+es/, "#version 100"],
                     [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("],
                     [/\btexture\(/g, "texture2D("],
                     [/\btextureLod\(/g, "texture2DLodEXT("]
                 ],
-                vu = [...mu, [du("in"), "attribute $1"],
-                    [du("out"), "varying $1"]
+                gu = [...fu, [hu("in"), "attribute $1"],
+                    [hu("out"), "varying $1"]
                 ],
-                bu = [...mu, [du("in"), "varying $1"]],
-                yu = "gl_FragColor",
-                _u = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/,
-                xu = /void\s+main\s*\([^)]*\)\s*\{\n?/;
+                mu = [...fu, [hu("in"), "varying $1"]],
+                vu = "gl_FragColor",
+                bu = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/,
+                yu = /void\s+main\s*\([^)]*\)\s*\{\n?/;
 
-            function wu(t, e) {
+            function _u(t, e) {
                 for (const [n, i] of e) t = t.replace(n, i);
                 return t
             }
-            const Eu = "\n\n".concat(ou, "\n\n"),
-                Pu = {
-                    [Nh]: "vertex",
-                    [Vh]: "fragment"
+            const xu = "\n\n".concat(ru, "\n\n"),
+                wu = {
+                    [Bh]: "vertex",
+                    [Dh]: "fragment"
                 };
 
-            function Su(t, e) {
+            function Eu(t, e) {
                 let {
                     id: n,
                     source: i,
                     type: r,
                     modules: s,
                     defines: o = {},
                     hookFunctions: a = [],
                     inject: l = {},
                     transpileToGLSL100: c = !1,
                     prologue: h = !0,
                     log: u
                 } = e;
-                Uh("string" == typeof i, "shader source must be a string");
-                const d = r === Nh,
+                Nh("string" == typeof i, "shader source must be a string");
+                const d = r === Bh,
                     p = i.split("\n");
                 let f = 100,
                     g = "",
                     m = i;
                 0 === p[0].indexOf("#version ") ? (f = 300, g = p[0], m = p.slice(1).join("\n")) : g = "#version ".concat(f);
                 const v = {};
                 s.forEach((t => {
@@ -9635,56 +9721,56 @@
                 })), Object.assign(v, o);
                 let b = h ? "".concat(g, "\n").concat(function(t) {
                     let {
                         id: e,
                         source: n,
                         type: i
                     } = t;
-                    return e && "string" == typeof e && -1 === n.indexOf("SHADER_NAME") ? "\n#define SHADER_NAME ".concat(e, "_").concat(Pu[i], "\n\n") : ""
+                    return e && "string" == typeof e && -1 === n.indexOf("SHADER_NAME") ? "\n#define SHADER_NAME ".concat(e, "_").concat(wu[i], "\n\n") : ""
                 }({
                     id: n,
                     source: i,
                     type: r
                 }), "\n").concat(function(t) {
                     let {
                         type: e
                     } = t;
-                    return "\n#define SHADER_TYPE_".concat(Pu[e].toUpperCase(), "\n")
+                    return "\n#define SHADER_TYPE_".concat(wu[e].toUpperCase(), "\n")
                 }({
                     type: r
                 }), "\n").concat(function(t) {
                     const e = function(t) {
                         const e = t.getExtension("WEBGL_debug_renderer_info"),
-                            n = t.getParameter(e && e.UNMASKED_VENDOR_WEBGL || Kh),
-                            i = t.getParameter(e && e.UNMASKED_RENDERER_WEBGL || Qh);
+                            n = t.getParameter(e && e.UNMASKED_VENDOR_WEBGL || Xh),
+                            i = t.getParameter(e && e.UNMASKED_RENDERER_WEBGL || Yh);
                         return {
                             gpuVendor: function(t, e) {
                                 return t.match(/NVIDIA/i) || e.match(/NVIDIA/i) ? "NVIDIA" : t.match(/INTEL/i) || e.match(/INTEL/i) ? "INTEL" : t.match(/AMD/i) || e.match(/AMD/i) || t.match(/ATI/i) || e.match(/ATI/i) ? "AMD" : "UNKNOWN GPU"
                             }(n, i),
                             vendor: n,
                             renderer: i,
-                            version: t.getParameter(Jh),
-                            shadingLanguageVersion: t.getParameter($h)
+                            version: t.getParameter(Kh),
+                            shadingLanguageVersion: t.getParameter(Qh)
                         }
                     }(t);
                     switch (e.gpuVendor.toLowerCase()) {
                         case "nvidia":
                             return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
                         case "intel":
                             return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
                         case "amd":
                             return "#define AMD_GPU\n";
                         default:
                             return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n"
                     }
                 }(t), "\n").concat(function(t, e, n) {
                     let i = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
-                    return ru(t, eu.GLSL_FRAG_DEPTH) && (i += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n"), ru(t, eu.GLSL_DERIVATIVES) && iu(t, eu.GLSL_DERIVATIVES) && (i += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n"), ru(t, eu.GLSL_FRAG_DATA) && iu(t, eu.GLSL_FRAG_DATA, {
+                    return nu(t, $h.GLSL_FRAG_DEPTH) && (i += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n"), nu(t, $h.GLSL_DERIVATIVES) && eu(t, $h.GLSL_DERIVATIVES) && (i += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n"), nu(t, $h.GLSL_FRAG_DATA) && eu(t, $h.GLSL_FRAG_DATA, {
                         behavior: "require"
-                    }) && (i += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n"), ru(t, eu.GLSL_TEXTURE_LOD) && (i += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n"), i
+                    }) && (i += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n"), nu(t, $h.GLSL_TEXTURE_LOD) && (i += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n"), i
                 }(t), "\n").concat(function() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                         e = 0,
                         n = "";
                     for (const i in t) {
                         0 === e && (n += "\n// APPLICATION DEFINES\n"), e++;
                         const r = t[i];
@@ -9728,105 +9814,105 @@
                         const n = t.match(/^(v|f)s:#([\w-]+)$/);
                         if (n) {
                             const i = "decl" === n[2] ? x : w;
                             i[t] = i[t] || [], i[t].push(e[t])
                         } else _[t] = _[t] || [], _[t].push(e[t])
                     }
                 }
-                return b += Eu, b = hu(b, r, x), b += function(t, e) {
+                return b += xu, b = lu(b, r, x), b += function(t, e) {
                     let n = "";
                     for (const i in t) {
                         const r = t[i];
                         if (n += "void ".concat(r.signature, " {\n"), r.header && (n += "  ".concat(r.header)), e[i]) {
                             const t = e[i];
                             t.sort(((t, e) => t.order - e.order));
                             for (const e of t) n += "  ".concat(e.injection, "\n")
                         }
                         r.footer && (n += "  ".concat(r.footer)), n += "}\n"
                     }
                     return n
-                }(y[r], _), b += m, b = hu(b, r, w), b = function(t, e, n) {
+                }(y[r], _), b += m, b = lu(b, r, w), b = function(t, e, n) {
                     switch (e) {
                         case 300:
-                            return n ? wu(t, fu) : function(t) {
-                                const e = (t = wu(t, gu)).match(_u);
+                            return n ? _u(t, du) : function(t) {
+                                const e = (t = _u(t, pu)).match(bu);
                                 if (e) {
                                     const n = e[1];
-                                    t = t.replace(new RegExp("\\b".concat(yu, "\\b"), "g"), n)
+                                    t = t.replace(new RegExp("\\b".concat(vu, "\\b"), "g"), n)
                                 } else {
                                     const e = "fragmentColor";
-                                    t = t.replace(xu, (t => "out vec4 ".concat(e, ";\n").concat(t))).replace(new RegExp("\\b".concat(yu, "\\b"), "g"), e)
+                                    t = t.replace(yu, (t => "out vec4 ".concat(e, ";\n").concat(t))).replace(new RegExp("\\b".concat(vu, "\\b"), "g"), e)
                                 }
                                 return t
                             }(t);
                         case 100:
-                            return n ? wu(t, vu) : function(t) {
-                                const e = (t = wu(t, bu)).match(_u);
+                            return n ? _u(t, gu) : function(t) {
+                                const e = (t = _u(t, mu)).match(bu);
                                 if (e) {
                                     const n = e[1];
-                                    t = t.replace(_u, "").replace(new RegExp("\\b".concat(n, "\\b"), "g"), yu)
+                                    t = t.replace(bu, "").replace(new RegExp("\\b".concat(n, "\\b"), "g"), vu)
                                 }
                                 return t
                             }(t);
                         default:
                             throw new Error("unknown GLSL version ".concat(e))
                     }
                 }(b, c ? 100 : f, d), b
             }
 
-            function Cu(t) {
+            function Pu(t) {
                 return function(e) {
                     const n = {};
                     for (const i of t) {
                         const t = i.getUniforms(e, n);
                         Object.assign(n, t)
                     }
                     return n
                 }
             }
-            const Tu = new Jo({
+            const Su = new Ko({
                 id: "luma.gl"
             });
 
-            function Au(t, e) {
+            function Cu(t, e) {
                 if (!t) throw new Error(e || "luma.gl: assertion failed.")
             }
-            const Mu = "Requires WebGL2";
+            const Tu = "Requires WebGL2";
 
-            function Ou(t) {
+            function Au(t) {
                 return "undefined" != typeof WebGLRenderingContext && t instanceof WebGLRenderingContext || "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || Boolean(t && Number.isFinite(t._version))
             }
 
-            function Lu(t) {
+            function Mu(t) {
                 return "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || Boolean(t && 2 === t._version)
             }
 
-            function Ru(t) {
-                return Au(Ou(t), "Invalid WebGLRenderingContext"), t
+            function Ou(t) {
+                return Cu(Au(t), "Invalid WebGLRenderingContext"), t
             }
 
-            function Iu(t) {
-                return Au(Lu(t), Mu), t
+            function Lu(t) {
+                return Cu(Mu(t), Tu), t
             }
             const ku = {};
-            const ju = function t(e) {
+            const Ru = function t(e) {
                 const n = e.gl;
                 this.ext = e, this.isAlive = !0, this.hasBeenBound = !1, this.elementArrayBuffer = null, this.attribs = new Array(e.maxVertexAttribs);
                 for (let e = 0; e < this.attribs.length; e++) {
                     const i = new t.VertexAttrib(n);
                     this.attribs[e] = i
                 }
                 this.maxAttrib = 0
             };
-            (ju.VertexAttrib = function(t) {
+            (Ru.VertexAttrib = function(t) {
                 this.enabled = !1, this.buffer = null, this.size = 4, this.type = 5126, this.normalized = !1, this.stride = 16, this.offset = 0, this.cached = "", this.recache()
             }).prototype.recache = function() {
                 this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":")
             };
-            const Fu = function(t) {
+            const Iu = function(t) {
                 const e = this;
                 this.gl = t,
                     function(t) {
                         const e = t.getError;
                         t.getError = function() {
                             let n;
                             do {
@@ -9885,27 +9971,27 @@
                     l.maxAttrib = Math.max(l.maxAttrib, t);
                     const c = l.attribs[t];
                     return c.buffer = e.currentArrayBuffer, c.size = i, c.type = r, c.normalized = s, c.stride = o, c.offset = a, c.recache(), n.vertexAttribPointer.apply(this, arguments)
                 }, t.instrumentExtension && t.instrumentExtension(this, "OES_vertex_array_object"), t.canvas && t.canvas.addEventListener("webglcontextrestored", (() => {
                     globalThis.console && globalThis.console.log && globalThis.console.log("OESVertexArrayObject emulation library context restored"), e.reset_()
                 }), !0), this.reset_()
             };
-            Fu.prototype.VERTEX_ARRAY_BINDING_OES = 34229, Fu.prototype.reset_ = function() {
+            Iu.prototype.VERTEX_ARRAY_BINDING_OES = 34229, Iu.prototype.reset_ = function() {
                 if (void 0 !== this.vertexArrayObjects)
                     for (let t = 0; t < this.vertexArrayObjects.length; ++t) this.vertexArrayObjects.isAlive = !1;
                 const t = this.gl;
-                this.maxVertexAttribs = t.getParameter(34921), this.defaultVertexArrayObject = new ju(this), this.currentVertexArrayObject = null, this.currentArrayBuffer = null, this.vertexArrayObjects = [this.defaultVertexArrayObject], this.bindVertexArrayOES(null)
-            }, Fu.prototype.createVertexArrayOES = function() {
-                const t = new ju(this);
+                this.maxVertexAttribs = t.getParameter(34921), this.defaultVertexArrayObject = new Ru(this), this.currentVertexArrayObject = null, this.currentArrayBuffer = null, this.vertexArrayObjects = [this.defaultVertexArrayObject], this.bindVertexArrayOES(null)
+            }, Iu.prototype.createVertexArrayOES = function() {
+                const t = new Ru(this);
                 return this.vertexArrayObjects.push(t), t
-            }, Fu.prototype.deleteVertexArrayOES = function(t) {
+            }, Iu.prototype.deleteVertexArrayOES = function(t) {
                 t.isAlive = !1, this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(t), 1), this.currentVertexArrayObject === t && this.bindVertexArrayOES(null)
-            }, Fu.prototype.isVertexArrayOES = function(t) {
-                return !!(t && t instanceof ju && t.hasBeenBound && t.ext === this)
-            }, Fu.prototype.bindVertexArrayOES = function(t) {
+            }, Iu.prototype.isVertexArrayOES = function(t) {
+                return !!(t && t instanceof Ru && t.hasBeenBound && t.ext === this)
+            }, Iu.prototype.bindVertexArrayOES = function(t) {
                 const e = this.gl;
                 if (t && !t.isAlive) return n = "bindVertexArrayOES: attempt to bind deleted arrayObject", ku[1282] = !0, void(void 0 !== n && (i = n, globalThis.console && globalThis.console.error && globalThis.console.error(i)));
                 var n, i;
                 const r = this.original,
                     s = this.currentVertexArrayObject;
                 this.currentVertexArrayObject = t || this.defaultVertexArrayObject, this.currentVertexArrayObject.hasBeenBound = !0;
                 const o = this.currentVertexArrayObject;
@@ -9919,193 +10005,193 @@
                     if (s && n.enabled === i.enabled || (n.enabled ? r.enableVertexAttribArray.call(e, t) : r.disableVertexAttribArray.call(e, t)), n.enabled) {
                         let o = !1;
                         s && n.buffer === i.buffer || (a !== n.buffer && (r.bindBuffer.call(e, 34962, n.buffer), a = n.buffer), o = !0), (o || n.cached !== i.cached) && r.vertexAttribPointer.call(e, t, n.size, n.type, n.normalized, n.stride, n.offset)
                     }
                 }
                 this.currentArrayBuffer !== a && r.bindBuffer.call(e, 34962, this.currentArrayBuffer)
             };
-            const zu = "OES_element_index",
-                Bu = "WEBGL_draw_buffers",
-                Du = "WEBGL_debug_renderer_info",
-                Nu = t => Lu(t) ? void 0 : 0,
-                Vu = {
-                    3074: t => Lu(t) ? void 0 : 36064,
-                    35723: t => Lu(t) ? void 0 : 4352,
-                    35977: Nu,
-                    32937: Nu,
+            const ju = "OES_element_index",
+                Fu = "WEBGL_draw_buffers",
+                zu = "WEBGL_debug_renderer_info",
+                Bu = t => Mu(t) ? void 0 : 0,
+                Du = {
+                    3074: t => Mu(t) ? void 0 : 36064,
+                    35723: t => Mu(t) ? void 0 : 4352,
+                    35977: Bu,
+                    32937: Bu,
                     36795: (t, e) => {
-                        const n = Lu(t) ? t.getExtension("EXT_disjoint_timer_query_webgl2") : t.getExtension("EXT_disjoint_timer_query");
+                        const n = Mu(t) ? t.getExtension("EXT_disjoint_timer_query_webgl2") : t.getExtension("EXT_disjoint_timer_query");
                         return n && n.GPU_DISJOINT_EXT ? e(n.GPU_DISJOINT_EXT) : 0
                     },
                     37445: (t, e) => {
-                        const n = t.getExtension(Du);
+                        const n = t.getExtension(zu);
                         return e(n && n.UNMASKED_VENDOR_WEBGL || 7936)
                     },
                     37446: (t, e) => {
-                        const n = t.getExtension(Du);
+                        const n = t.getExtension(zu);
                         return e(n && n.UNMASKED_RENDERER_WEBGL || 7937)
                     },
                     34047: (t, e) => {
                         const n = t.luma.extensions.EXT_texture_filter_anisotropic;
                         return n ? e(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1
                     },
-                    32883: Nu,
-                    35071: Nu,
-                    37447: Nu,
+                    32883: Bu,
+                    35071: Bu,
+                    37447: Bu,
                     36063: (t, e) => {
-                        if (!Lu(t)) {
-                            const n = t.getExtension(Bu);
+                        if (!Mu(t)) {
+                            const n = t.getExtension(Fu);
                             return n ? e(n.MAX_COLOR_ATTACHMENTS_WEBGL) : 0
                         }
                     },
-                    35379: Nu,
-                    35374: Nu,
-                    35377: Nu,
+                    35379: Bu,
+                    35374: Bu,
+                    35377: Bu,
                     34852: t => {
-                        if (!Lu(t)) {
-                            const e = t.getExtension(Bu);
+                        if (!Mu(t)) {
+                            const e = t.getExtension(Fu);
                             return e ? e.MAX_DRAW_BUFFERS_WEBGL : 0
                         }
                     },
-                    36203: t => t.getExtension(zu) ? 2147483647 : 65535,
-                    33001: t => t.getExtension(zu) ? 16777216 : 65535,
+                    36203: t => t.getExtension(ju) ? 2147483647 : 65535,
+                    33001: t => t.getExtension(ju) ? 16777216 : 65535,
                     33e3: t => 16777216,
-                    37157: Nu,
-                    35373: Nu,
-                    35657: Nu,
-                    36183: Nu,
-                    37137: Nu,
-                    34045: Nu,
-                    35978: Nu,
-                    35979: Nu,
-                    35968: Nu,
-                    35376: Nu,
-                    35375: Nu,
-                    35659: Nu,
-                    37154: Nu,
-                    35371: Nu,
-                    35658: Nu,
-                    35076: Nu,
-                    35077: Nu,
-                    35380: Nu
+                    37157: Bu,
+                    35373: Bu,
+                    35657: Bu,
+                    36183: Bu,
+                    37137: Bu,
+                    34045: Bu,
+                    35978: Bu,
+                    35979: Bu,
+                    35968: Bu,
+                    35376: Bu,
+                    35375: Bu,
+                    35659: Bu,
+                    37154: Bu,
+                    35371: Bu,
+                    35658: Bu,
+                    35076: Bu,
+                    35077: Bu,
+                    35380: Bu
                 },
-                Uu = "ANGLE_instanced_arrays",
-                Gu = {
+                Nu = "ANGLE_instanced_arrays",
+                Vu = {
                     OES_vertex_array_object: {
                         meta: {
                             suffix: "OES"
                         },
                         createVertexArray: () => {
-                            Au(!1, "VertexArray requires WebGL2 or OES_vertex_array_object extension")
+                            Cu(!1, "VertexArray requires WebGL2 or OES_vertex_array_object extension")
                         },
                         deleteVertexArray: () => {},
                         bindVertexArray: () => {},
                         isVertexArray: () => !1
                     },
-                    [Uu]: {
+                    [Nu]: {
                         meta: {
                             suffix: "ANGLE"
                         },
                         vertexAttribDivisor(t, e) {
-                            Au(0 === e, "WebGL instanced rendering not supported")
+                            Cu(0 === e, "WebGL instanced rendering not supported")
                         },
                         drawElementsInstanced: () => {},
                         drawArraysInstanced: () => {}
                     },
                     WEBGL_draw_buffers: {
                         meta: {
                             suffix: "WEBGL"
                         },
                         drawBuffers: () => {
-                            Au(!1)
+                            Cu(!1)
                         }
                     },
                     EXT_disjoint_timer_query: {
                         meta: {
                             suffix: "EXT"
                         },
                         createQuery: () => {
-                            Au(!1)
+                            Cu(!1)
                         },
                         deleteQuery: () => {
-                            Au(!1)
+                            Cu(!1)
                         },
                         beginQuery: () => {
-                            Au(!1)
+                            Cu(!1)
                         },
                         endQuery: () => {},
                         getQuery(t, e) {
                             return this.getQueryObject(t, e)
                         },
                         getQueryParameter(t, e) {
                             return this.getQueryObject(t, e)
                         },
                         getQueryObject: () => {}
                     }
                 },
-                Wu = {
+                Uu = {
                     readBuffer: (t, e, n) => {
-                        Lu(t) && e(n)
+                        Mu(t) && e(n)
                     },
                     getVertexAttrib: (t, e, n, i) => {
                         const {
                             webgl2: r,
                             ext: s
                         } = function(t, e) {
                             return {
-                                webgl2: Lu(t),
+                                webgl2: Mu(t),
                                 ext: t.getExtension(e)
                             }
-                        }(t, Uu);
+                        }(t, Nu);
                         let o;
                         switch (i) {
                             case 35069:
                                 o = !!r && void 0;
                                 break;
                             case 35070:
                                 o = r || s ? void 0 : 0
                         }
                         return void 0 !== o ? o : e(n, i)
                     },
                     getProgramParameter: (t, e, n, i) => {
-                        if (!Lu(t)) switch (i) {
+                        if (!Mu(t)) switch (i) {
                             case 35967:
                                 return 35981;
                             case 35971:
                             case 35382:
                                 return 0
                         }
                         return e(n, i)
                     },
-                    getInternalformatParameter: (t, e, n, i, r) => Lu(t) || 32937 !== r ? t.getInternalformatParameter(n, i, r) : new Int32Array([0]),
+                    getInternalformatParameter: (t, e, n, i, r) => Mu(t) || 32937 !== r ? t.getInternalformatParameter(n, i, r) : new Int32Array([0]),
                     getTexParameter(t, e, n, i) {
                         if (34046 === i) {
                             const {
                                 extensions: e
                             } = t.luma, n = e.EXT_texture_filter_anisotropic;
                             i = n && n.TEXTURE_MAX_ANISOTROPY_EXT || 34046
                         }
                         return e(n, i)
                     },
                     getParameter: function(t, e, n) {
-                        const i = Vu[n],
+                        const i = Du[n],
                             r = "function" == typeof i ? i(t, e, n) : i;
                         return void 0 !== r ? r : e(n)
                     },
                     hint: (t, e, n, i) => e(n, i)
                 };
 
-            function Hu(t, e) {
+            function Gu(t, e) {
                 let {
                     extension: n,
                     target: i,
                     target2: r
                 } = e;
-                const s = Gu[n];
-                Au(s);
+                const s = Vu[n];
+                Cu(s);
                 const {
                     meta: o = {}
                 } = s, {
                     suffix: a = ""
                 } = o, l = t.getExtension(n);
                 for (const e of Object.keys(s)) {
                     const n = "".concat(e).concat(a);
@@ -10125,44 +10211,44 @@
                     const e = t.getSupportedExtensions;
                     t.getSupportedExtensions = function() {
                         const t = e.call(this) || [];
                         return t.indexOf("OES_vertex_array_object") < 0 && t.push("OES_vertex_array_object"), t
                     };
                     const n = t.getExtension;
                     t.getExtension = function(e) {
-                        return n.call(this, e) || ("OES_vertex_array_object" !== e ? null : (t.__OESVertexArrayObject || (this.__OESVertexArrayObject = new Fu(this)), this.__OESVertexArrayObject))
+                        return n.call(this, e) || ("OES_vertex_array_object" !== e ? null : (t.__OESVertexArrayObject || (this.__OESVertexArrayObject = new Iu(this)), this.__OESVertexArrayObject))
                     }
                 }(t), function(t) {
                     t.luma.extensions = {};
                     const e = t.getSupportedExtensions() || [];
                     for (const n of e) t.luma[n] = t.getExtension(n)
                 }(t), function(t, e) {
-                    for (const n of Object.getOwnPropertyNames(e)) "overrides" !== n && Hu(t, {
+                    for (const n of Object.getOwnPropertyNames(e)) "overrides" !== n && Gu(t, {
                         extension: n,
                         target: t.luma,
                         target2: t
                     })
-                }(t, Gu), function(t, e) {
+                }(t, Vu), function(t, e) {
                     let {
                         target: n,
                         target2: i
                     } = e;
-                    Object.keys(Wu).forEach((e => {
-                        if ("function" == typeof Wu[e]) {
+                    Object.keys(Uu).forEach((e => {
+                        if ("function" == typeof Uu[e]) {
                             const r = t[e] ? t[e].bind(t) : () => {},
-                                s = Wu[e].bind(null, t, r);
+                                s = Uu[e].bind(null, t, r);
                             n[e] = s, i[e] = s
                         }
                     }))
                 }(t, {
                     target: e,
                     target2: t
                 }), e.polyfilled = !0), t
             };
-            const Zu = {
+            const Wu = {
                     3042: !1,
                     32773: new Float32Array([0, 0, 0, 0]),
                     32777: 32774,
                     34877: 32774,
                     32969: 1,
                     32968: 0,
                     32971: 1,
@@ -10218,57 +10304,57 @@
                     3331: 0,
                     3314: 0,
                     32878: 0,
                     3316: 0,
                     3315: 0,
                     32877: 0
                 },
-                qu = (t, e, n) => e ? t.enable(n) : t.disable(n),
-                Xu = (t, e, n) => t.hint(n, e),
-                Yu = (t, e, n) => t.pixelStorei(n, e);
+                Hu = (t, e, n) => e ? t.enable(n) : t.disable(n),
+                Zu = (t, e, n) => t.hint(n, e),
+                qu = (t, e, n) => t.pixelStorei(n, e);
 
-            function Ku(t) {
+            function Xu(t) {
                 return Array.isArray(t) || ArrayBuffer.isView(t)
             }
-            const Qu = {
-                3042: qu,
+            const Yu = {
+                3042: Hu,
                 32773: (t, e) => t.blendColor(...e),
                 32777: "blendEquation",
                 34877: "blendEquation",
                 32969: "blendFunc",
                 32968: "blendFunc",
                 32971: "blendFunc",
                 32970: "blendFunc",
                 3106: (t, e) => t.clearColor(...e),
                 3107: (t, e) => t.colorMask(...e),
-                2884: qu,
+                2884: Hu,
                 2885: (t, e) => t.cullFace(e),
-                2929: qu,
+                2929: Hu,
                 2931: (t, e) => t.clearDepth(e),
                 2932: (t, e) => t.depthFunc(e),
                 2928: (t, e) => t.depthRange(...e),
                 2930: (t, e) => t.depthMask(e),
-                3024: qu,
-                35723: Xu,
+                3024: Hu,
+                35723: Zu,
                 36006: (t, e) => {
-                    const n = Lu(t) ? 36009 : 36160;
+                    const n = Mu(t) ? 36009 : 36160;
                     return t.bindFramebuffer(n, e)
                 },
                 2886: (t, e) => t.frontFace(e),
-                33170: Xu,
+                33170: Zu,
                 2849: (t, e) => t.lineWidth(e),
-                32823: qu,
+                32823: Hu,
                 32824: "polygonOffset",
                 10752: "polygonOffset",
-                35977: qu,
+                35977: Hu,
                 32938: "sampleCoverage",
                 32939: "sampleCoverage",
-                3089: qu,
+                3089: Hu,
                 3088: (t, e) => t.scissor(...e),
-                2960: qu,
+                2960: Hu,
                 2961: (t, e) => t.clearStencil(e),
                 2968: (t, e) => t.stencilMaskSeparate(1028, e),
                 36005: (t, e) => t.stencilMaskSeparate(1029, e),
                 2962: "stencilFuncFront",
                 2967: "stencilFuncFront",
                 2963: "stencilFuncFront",
                 34816: "stencilFuncBack",
@@ -10277,39 +10363,39 @@
                 2964: "stencilOpFront",
                 2965: "stencilOpFront",
                 2966: "stencilOpFront",
                 34817: "stencilOpBack",
                 34818: "stencilOpBack",
                 34819: "stencilOpBack",
                 2978: (t, e) => t.viewport(...e),
-                3333: Yu,
-                3317: Yu,
-                37440: Yu,
-                37441: Yu,
-                37443: Yu,
-                3330: Yu,
-                3332: Yu,
-                3331: Yu,
+                3333: qu,
+                3317: qu,
+                37440: qu,
+                37441: qu,
+                37443: qu,
+                3330: qu,
+                3332: qu,
+                3331: qu,
                 36010: (t, e) => t.bindFramebuffer(36008, e),
-                3314: Yu,
-                32878: Yu,
-                3316: Yu,
-                3315: Yu,
-                32877: Yu,
+                3314: qu,
+                32878: qu,
+                3316: qu,
+                3315: qu,
+                32877: qu,
                 framebuffer: (t, e) => {
                     const n = e && "handle" in e ? e.handle : e;
                     return t.bindFramebuffer(36160, n)
                 },
                 blend: (t, e) => e ? t.enable(3042) : t.disable(3042),
                 blendColor: (t, e) => t.blendColor(...e),
                 blendEquation: (t, e) => {
-                    e = Ku(e) ? e : [e, e], t.blendEquationSeparate(...e)
+                    e = Xu(e) ? e : [e, e], t.blendEquationSeparate(...e)
                 },
                 blendFunc: (t, e) => {
-                    e = Ku(e) && 2 === e.length ? [...e, ...e] : e, t.blendFuncSeparate(...e)
+                    e = Xu(e) && 2 === e.length ? [...e, ...e] : e, t.blendFuncSeparate(...e)
                 },
                 clearColor: (t, e) => t.clearColor(...e),
                 clearDepth: (t, e) => t.clearDepth(e),
                 clearStencil: (t, e) => t.clearStencil(e),
                 colorMask: (t, e) => t.colorMask(...e),
                 cull: (t, e) => e ? t.enable(2884) : t.disable(2884),
                 cullFace: (t, e) => t.cullFace(e),
@@ -10327,45 +10413,45 @@
                 polygonOffsetFill: (t, e) => e ? t.enable(32823) : t.disable(32823),
                 polygonOffset: (t, e) => t.polygonOffset(...e),
                 sampleCoverage: (t, e) => t.sampleCoverage(...e),
                 scissorTest: (t, e) => e ? t.enable(3089) : t.disable(3089),
                 scissor: (t, e) => t.scissor(...e),
                 stencilTest: (t, e) => e ? t.enable(2960) : t.disable(2960),
                 stencilMask: (t, e) => {
-                    e = Ku(e) ? e : [e, e];
+                    e = Xu(e) ? e : [e, e];
                     const [n, i] = e;
                     t.stencilMaskSeparate(1028, n), t.stencilMaskSeparate(1029, i)
                 },
                 stencilFunc: (t, e) => {
-                    e = Ku(e) && 3 === e.length ? [...e, ...e] : e;
+                    e = Xu(e) && 3 === e.length ? [...e, ...e] : e;
                     const [n, i, r, s, o, a] = e;
                     t.stencilFuncSeparate(1028, n, i, r), t.stencilFuncSeparate(1029, s, o, a)
                 },
                 stencilOp: (t, e) => {
-                    e = Ku(e) && 3 === e.length ? [...e, ...e] : e;
+                    e = Xu(e) && 3 === e.length ? [...e, ...e] : e;
                     const [n, i, r, s, o, a] = e;
                     t.stencilOpSeparate(1028, n, i, r), t.stencilOpSeparate(1029, s, o, a)
                 },
                 viewport: (t, e) => t.viewport(...e)
             };
 
-            function Ju(t, e, n) {
+            function Ku(t, e, n) {
                 return void 0 !== e[t] ? e[t] : n[t]
             }
-            const $u = {
-                    blendEquation: (t, e, n) => t.blendEquationSeparate(Ju(32777, e, n), Ju(34877, e, n)),
-                    blendFunc: (t, e, n) => t.blendFuncSeparate(Ju(32969, e, n), Ju(32968, e, n), Ju(32971, e, n), Ju(32970, e, n)),
-                    polygonOffset: (t, e, n) => t.polygonOffset(Ju(32824, e, n), Ju(10752, e, n)),
-                    sampleCoverage: (t, e, n) => t.sampleCoverage(Ju(32938, e, n), Ju(32939, e, n)),
-                    stencilFuncFront: (t, e, n) => t.stencilFuncSeparate(1028, Ju(2962, e, n), Ju(2967, e, n), Ju(2963, e, n)),
-                    stencilFuncBack: (t, e, n) => t.stencilFuncSeparate(1029, Ju(34816, e, n), Ju(36003, e, n), Ju(36004, e, n)),
-                    stencilOpFront: (t, e, n) => t.stencilOpSeparate(1028, Ju(2964, e, n), Ju(2965, e, n), Ju(2966, e, n)),
-                    stencilOpBack: (t, e, n) => t.stencilOpSeparate(1029, Ju(34817, e, n), Ju(34818, e, n), Ju(34819, e, n))
+            const Qu = {
+                    blendEquation: (t, e, n) => t.blendEquationSeparate(Ku(32777, e, n), Ku(34877, e, n)),
+                    blendFunc: (t, e, n) => t.blendFuncSeparate(Ku(32969, e, n), Ku(32968, e, n), Ku(32971, e, n), Ku(32970, e, n)),
+                    polygonOffset: (t, e, n) => t.polygonOffset(Ku(32824, e, n), Ku(10752, e, n)),
+                    sampleCoverage: (t, e, n) => t.sampleCoverage(Ku(32938, e, n), Ku(32939, e, n)),
+                    stencilFuncFront: (t, e, n) => t.stencilFuncSeparate(1028, Ku(2962, e, n), Ku(2967, e, n), Ku(2963, e, n)),
+                    stencilFuncBack: (t, e, n) => t.stencilFuncSeparate(1029, Ku(34816, e, n), Ku(36003, e, n), Ku(36004, e, n)),
+                    stencilOpFront: (t, e, n) => t.stencilOpSeparate(1028, Ku(2964, e, n), Ku(2965, e, n), Ku(2966, e, n)),
+                    stencilOpBack: (t, e, n) => t.stencilOpSeparate(1029, Ku(34817, e, n), Ku(34818, e, n), Ku(34819, e, n))
                 },
-                td = {
+                Ju = {
                     enable: (t, e) => t({
                         [e]: !0
                     }),
                     disable: (t, e) => t({
                         [e]: !1
                     }),
                     pixelStorei: (t, e, n) => t({
@@ -10490,228 +10576,229 @@
                         [1028 === e ? 2965 : 34818]: i,
                         [1028 === e ? 2966 : 34819]: r
                     }),
                     viewport: (t, e, n, i, r) => t({
                         2978: [e, n, i, r]
                     })
                 },
-                ed = (t, e) => t.isEnabled(e),
-                nd = {
-                    3042: ed,
-                    2884: ed,
-                    2929: ed,
-                    3024: ed,
-                    32823: ed,
-                    32926: ed,
-                    32928: ed,
-                    3089: ed,
-                    2960: ed,
-                    35977: ed
+                $u = (t, e) => t.isEnabled(e),
+                td = {
+                    3042: $u,
+                    2884: $u,
+                    2929: $u,
+                    3024: $u,
+                    32823: $u,
+                    32926: $u,
+                    32928: $u,
+                    3089: $u,
+                    2960: $u,
+                    35977: $u
                 };
 
-            function id(t) {
+            function ed(t) {
                 for (const e in t) return !1;
                 return !0
             }
 
-            function rd(t, e) {
+            function nd(t, e) {
                 if (t === e) return !0;
                 const n = Array.isArray(t) || ArrayBuffer.isView(t),
                     i = Array.isArray(e) || ArrayBuffer.isView(e);
                 if (n && i && t.length === e.length) {
                     for (let n = 0; n < t.length; ++n)
                         if (t[n] !== e[n]) return !1;
                     return !0
                 }
                 return !1
             }
 
-            function sd(t, e) {
+            function id(t, e) {
                 const n = t[e].bind(t);
                 t[e] = function() {
                     const e = arguments.length <= 0 ? void 0 : arguments[0];
                     return e in t.state.cache && t.state.enable ? t.state.cache[e] : n(...arguments)
                 }, Object.defineProperty(t[e], "name", {
                     value: "".concat(e, "-from-cache"),
                     configurable: !1
                 })
             }
 
-            function od(t, e, n) {
+            function rd(t, e, n) {
                 const i = t[e].bind(t);
                 t[e] = function() {
                     for (var e = arguments.length, r = new Array(e), s = 0; s < e; s++) r[s] = arguments[s];
                     const {
                         valueChanged: o,
                         oldValue: a
                     } = n(t.state._updateCache, ...r);
                     return o && i(...r), a
                 }, Object.defineProperty(t[e], "name", {
                     value: "".concat(e, "-to-cache"),
                     configurable: !1
                 })
             }
-            class ad {
+            class sd {
                 constructor(t) {
                     let {
                         copyState: e = !1,
                         log: n = (() => {})
                     } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     this.gl = t, this.program = null, this.stateStack = [], this.enable = !0, this.cache = e ? function(t, e) {
-                        if ("number" == typeof(e = e || Zu)) {
+                        if ("number" == typeof(e = e || Wu)) {
                             const n = e,
-                                i = nd[n];
+                                i = td[n];
                             return i ? i(t, n) : t.getParameter(n)
                         }
                         const n = Array.isArray(e) ? e : Object.keys(e),
                             i = {};
                         for (const e of n) {
-                            const n = nd[e];
+                            const n = td[e];
                             i[e] = n ? n(t, Number(e)) : t.getParameter(Number(e))
                         }
                         return i
-                    }(t) : Object.assign({}, Zu), this.log = n, this._updateCache = this._updateCache.bind(this), Object.seal(this)
+                    }(t) : Object.assign({}, Wu), this.log = n, this._updateCache = this._updateCache.bind(this), Object.seal(this)
                 }
                 push() {
                     this.stateStack.push({})
                 }
                 pop() {
-                    Au(this.stateStack.length > 0);
+                    Cu(this.stateStack.length > 0);
                     const t = this.stateStack[this.stateStack.length - 1];
-                    hd(this.gl, t), this.stateStack.pop()
+                    ld(this.gl, t), this.stateStack.pop()
                 }
                 _updateCache(t) {
                     let e, n = !1;
                     const i = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
                     for (const r in t) {
-                        Au(void 0 !== r);
+                        Cu(void 0 !== r);
                         const s = t[r],
                             o = this.cache[r];
-                        rd(s, o) || (n = !0, e = o, i && !(r in i) && (i[r] = o), this.cache[r] = s)
+                        nd(s, o) || (n = !0, e = o, i && !(r in i) && (i[r] = o), this.cache[r] = s)
                     }
                     return {
                         valueChanged: n,
                         oldValue: e
                     }
                 }
             }
 
-            function ld(t) {
+            function od(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                 const {
                     enable: n = !0,
                     copyState: i
                 } = e;
-                if (Au(void 0 !== i), !t.state) {
+                if (Cu(void 0 !== i), !t.state) {
                     const {
                         polyfillContext: e
                     } = globalThis;
-                    e && e(t), t.state = new ad(t, {
+                    e && e(t), t.state = new sd(t, {
                             copyState: i
                         }),
                         function(t) {
                             const e = t.useProgram.bind(t);
                             t.useProgram = function(n) {
                                 t.state.program !== n && (e(n), t.state.program = n)
                             }
                         }(t);
-                    for (const e in td) od(t, e, td[e]);
-                    sd(t, "getParameter"), sd(t, "isEnabled")
+                    for (const e in Ju) rd(t, e, Ju[e]);
+                    id(t, "getParameter"), id(t, "isEnabled")
                 }
                 return t.state.enable = n, t
             }
 
-            function cd(t) {
-                Au(t.state), t.state.pop()
+            function ad(t) {
+                Cu(t.state), t.state.pop()
             }
 
-            function hd(t, e) {
-                if (Au(Ou(t), "setParameters requires a WebGL context"), id(e)) return;
+            function ld(t, e) {
+                if (Cu(Au(t), "setParameters requires a WebGL context"), ed(e)) return;
                 const n = {};
                 for (const i in e) {
                     const r = Number(i),
-                        s = Qu[i];
+                        s = Yu[i];
                     s && ("string" == typeof s ? n[s] = !0 : s(t, e[i], r))
                 }
                 const i = t.state && t.state.cache;
                 if (i)
-                    for (const r in n)(0, $u[r])(t, e, i)
+                    for (const r in n)(0, Qu[r])(t, e, i)
             }
 
-            function ud(t, e, n) {
-                if (id(e)) return n(t);
+            function cd(t, e, n) {
+                if (ed(e)) return n(t);
                 const {
                     nocatch: i = !0
                 } = e;
                 let r;
                 if (function(t) {
-                        t.state || ld(t, {
+                        t.state || od(t, {
                             copyState: !1
                         }), t.state.push()
-                    }(t), hd(t, e), i) r = n(t), cd(t);
+                    }(t), ld(t, e), i) r = n(t), ad(t);
                 else try {
                     r = n(t)
                 } finally {
-                    cd(t)
+                    ad(t)
                 }
                 return r
             }
 
-            function dd(t) {
+            function hd(t) {
                 const {
                     luma: e
                 } = t;
                 if (t.canvas && e) {
-                    const n = e.canvasSizeInfo,
-                        i = "clientWidth" in n ? n.clientWidth : t.canvas.clientWidth;
-                    return i ? t.drawingBufferWidth / i : 1
+                    const {
+                        clientWidth: n
+                    } = e.canvasSizeInfo;
+                    return n ? t.drawingBufferWidth / n : 1
                 }
                 return 1
             }
 
-            function pd(t, e) {
+            function ud(t, e) {
                 let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                 return function(t, e, n, i, r) {
-                    const s = fd(t[0], e, n);
-                    let o = gd(t[1], e, i, r),
-                        a = fd(t[0] + 1, e, n);
+                    const s = dd(t[0], e, n);
+                    let o = pd(t[1], e, i, r),
+                        a = dd(t[0] + 1, e, n);
                     const l = a === n - 1 ? a : a - 1;
                     let c;
-                    return a = gd(t[1] + 1, e, i, r), r ? (a = 0 === a ? a : a + 1, c = o, o = a) : c = a === i - 1 ? a : a - 1, {
+                    return a = pd(t[1] + 1, e, i, r), r ? (a = 0 === a ? a : a + 1, c = o, o = a) : c = a === i - 1 ? a : a - 1, {
                         x: s,
                         y: o,
                         width: Math.max(l - s + 1, 1),
                         height: Math.max(c - o + 1, 1)
                     }
-                }(e, dd(t), t.drawingBufferWidth, t.drawingBufferHeight, n)
+                }(e, hd(t), t.drawingBufferWidth, t.drawingBufferHeight, n)
             }
 
-            function fd(t, e, n) {
+            function dd(t, e, n) {
                 return Math.min(Math.round(t * e), n - 1)
             }
 
-            function gd(t, e, n, i) {
+            function pd(t, e, n, i) {
                 return i ? Math.max(0, n - 1 - Math.round(t * e)) : Math.min(Math.round(t * e), n - 1)
             }
-            const md = jo(),
-                vd = md && "undefined" != typeof document,
-                bd = {
+            const fd = Ro(),
+                gd = fd && "undefined" != typeof document,
+                md = {
                     webgl2: !0,
                     webgl1: !0,
                     throwOnError: !0,
                     manageState: !0,
                     canvas: null,
                     debug: !1,
                     width: 800,
                     height: 600
                 };
 
-            function yd() {
+            function vd() {
                 let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                Au(md, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils"), t = Object.assign({}, bd, t);
+                Cu(fd, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils"), t = Object.assign({}, md, t);
                 const {
                     width: e,
                     height: n
                 } = t;
 
                 function i(e) {
                     if (t.throwOnError) throw new Error(e);
@@ -10724,15 +10811,15 @@
                 } = t, o = function(t) {
                     let e, {
                         canvas: n,
                         width: i = 800,
                         height: r = 600,
                         onError: s
                     } = t;
-                    return "string" == typeof n ? (vd && "complete" === document.readyState || s("createGLContext called on canvas '".concat(n, "' before page was loaded")), e = document.getElementById(n)) : n ? e = n : (e = document.createElement("canvas"), e.id = "lumagl-canvas", e.style.width = Number.isFinite(i) ? "".concat(i, "px") : "100%", e.style.height = Number.isFinite(r) ? "".concat(r, "px") : "100%", document.body.insertBefore(e, document.body.firstChild)), e
+                    return "string" == typeof n ? (gd && "complete" === document.readyState || s("createGLContext called on canvas '".concat(n, "' before page was loaded")), e = document.getElementById(n)) : n ? e = n : (e = document.createElement("canvas"), e.id = "lumagl-canvas", e.style.width = Number.isFinite(i) ? "".concat(i, "px") : "100%", e.style.height = Number.isFinite(r) ? "".concat(r, "px") : "100%", document.body.insertBefore(e, document.body.firstChild)), e
                 }({
                     canvas: s,
                     width: e,
                     height: n,
                     onError: i
                 });
                 return r = function(t, e) {
@@ -10744,16 +10831,16 @@
                     t.addEventListener("webglcontextcreationerror", r, !1);
                     const {
                         webgl1: s = !0,
                         webgl2: o = !0
                     } = e;
                     let a = null;
                     return o && (a = a || t.getContext("webgl2", e), a = a || t.getContext("experimental-webgl2", e)), s && (a = a || t.getContext("webgl", e), a = a || t.getContext("experimental-webgl", e)), t.removeEventListener("webglcontextcreationerror", r, !1), a ? (e.onContextLost && t.addEventListener("webglcontextlost", e.onContextLost, !1), e.onContextRestored && t.addEventListener("webglcontextrestored", e.onContextRestored, !1), a) : n("Failed to create ".concat(o && !s ? "WebGL2" : "WebGL", " context: ").concat(i || "Unknown error"))
-                }(o, t), r ? (r = _d(r, t), function(t) {
-                    const e = Lu(t) ? "WebGL2" : "WebGL1",
+                }(o, t), r ? (r = bd(r, t), function(t) {
+                    const e = Mu(t) ? "WebGL2" : "WebGL1",
                         n = function(t) {
                             const e = t.getParameter(7936),
                                 n = t.getParameter(7937),
                                 i = t.getExtension("WEBGL_debug_renderer_info");
                             return {
                                 vendor: i && t.getParameter(i.UNMASKED_VENDOR_WEBGL || 7936) || e,
                                 renderer: i && t.getParameter(i.UNMASKED_RENDERER_WEBGL || 7937) || n,
@@ -10761,121 +10848,122 @@
                                 rendererMasked: n,
                                 version: t.getParameter(7938),
                                 shadingLanguageVersion: t.getParameter(35724)
                             }
                         }(t),
                         i = n ? "(".concat(n.vendor, ",").concat(n.renderer, ")") : "",
                         r = t.debug ? " debug" : "";
-                    Tu.info(1, "".concat(e).concat(r, " context ").concat(i))()
+                    Su.info(1, "".concat(e).concat(r, " context ").concat(i))()
                 }(r), r) : null
             }
 
-            function _d(t) {
+            function bd(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                 if (!t || t._instrumented) return t;
                 t._version = t._version || function(t) {
                     return "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext ? 2 : 1
-                }(t), t.luma = t.luma || {}, t.luma.canvasSizeInfo = t.luma.canvasSizeInfo || {}, e = Object.assign({}, bd, e);
+                }(t), t.luma = t.luma || {}, t.luma.canvasSizeInfo = t.luma.canvasSizeInfo || {}, e = Object.assign({}, md, e);
                 const {
                     manageState: n,
                     debug: i
                 } = e;
-                return n && ld(t, {
+                return n && od(t, {
                     copyState: !1,
                     log: function() {
                         for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
-                        return Tu.log(1, ...e)()
+                        return Su.log(1, ...e)()
                     }
-                }), md && i && (globalThis.makeDebugContext ? (t = globalThis.makeDebugContext(t, e), Tu.level = Math.max(Tu.level, 1)) : Tu.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')()), t._instrumented = !0, t
+                }), fd && i && (globalThis.makeDebugContext ? (t = globalThis.makeDebugContext(t, e), Su.level = Math.max(Su.level, 1)) : Su.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')()), t._instrumented = !0, t
             }
-            const xd = "8.5.20",
-                wd = new class {
-                    constructor() {
-                        this.stats = new Map
-                    }
-                    get(t) {
-                        return this.stats.has(t) || this.stats.set(t, new da({
-                            id: t
-                        })), this.stats.get(t)
-                    }
-                };
-            if (globalThis.luma && globalThis.luma.VERSION !== xd) throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(xd));
+            const yd = "8.5.16";
+            class _d {
+                constructor() {
+                    this.stats = new Map
+                }
+                get(t) {
+                    return this.stats.has(t) || this.stats.set(t, new ca({
+                        id: t
+                    })), this.stats.get(t)
+                }
+            }
+            const xd = new _d;
+            if (globalThis.luma && globalThis.luma.VERSION !== yd) throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(yd));
 
-            function Ed(t, e) {
+            function wd(t, e) {
                 if (!t) throw new Error(e || "luma.gl: assertion failed.")
             }
 
-            function Pd(t, e) {
+            function Ed(t, e) {
                 if ("string" != typeof e) return e;
                 const n = Number(e);
                 if (!isNaN(n)) return n;
                 const i = t[e = e.replace(/^.*\./, "")];
-                return Ed(void 0 !== i, "Accessing undefined constant GL.".concat(e)), i
+                return wd(void 0 !== i, "Accessing undefined constant GL.".concat(e)), i
             }
 
-            function Sd(t, e) {
+            function Pd(t, e) {
                 e = Number(e);
                 for (const n in t)
                     if (t[n] === e) return "GL.".concat(n);
                 return String(e)
             }
-            globalThis.luma || (jo() && Tu.log(1, "luma.gl ".concat(xd, " - ").concat("set luma.log.level=1 (or higher) to trace rendering"))(), globalThis.luma = globalThis.luma || {
-                VERSION: xd,
-                version: xd,
-                log: Tu,
-                stats: wd,
+            globalThis.luma || (Ro() && Su.log(1, "luma.gl ".concat(yd, " - ").concat("set luma.log.level=1 (or higher) to trace rendering"))(), globalThis.luma = globalThis.luma || {
+                VERSION: yd,
+                version: yd,
+                log: Su,
+                stats: xd,
                 globals: {
                     modules: {},
                     nodeIO: {}
                 }
             }), globalThis.luma;
-            const Cd = {};
+            const Sd = {};
 
-            function Td() {
+            function Cd() {
                 let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "id";
-                Cd[t] = Cd[t] || 1;
-                const e = Cd[t]++;
+                Sd[t] = Sd[t] || 1;
+                const e = Sd[t]++;
                 return "".concat(t, "-").concat(e)
             }
 
-            function Ad(t) {
-                return Ed("number" == typeof t, "Input must be a number"), t && 0 == (t & t - 1)
+            function Td(t) {
+                return wd("number" == typeof t, "Input must be a number"), t && 0 == (t & t - 1)
             }
 
-            function Md(t) {
+            function Ad(t) {
                 let e = !0;
                 for (const n in t) {
                     e = !1;
                     break
                 }
                 return e
             }
 
-            function Od(t, e, n, i) {
+            function Md(t, e, n, i) {
                 const r = "See luma.gl ".concat(n, " Upgrade Guide at https://luma.gl/docs/upgrade-guide"),
                     s = Object.getPrototypeOf(t);
                 i.forEach((t => {
                     s.methodName || (s[t] = () => {
-                        throw Tu.removed("Calling removed method ".concat(e, ".").concat(t, ": "), r)(), new Error(t)
+                        throw Su.removed("Calling removed method ".concat(e, ".").concat(t, ": "), r)(), new Error(t)
                     })
                 }))
             }
-            const Ld = "Resource subclass must define virtual methods";
-            class Rd {
+            const Od = "Resource subclass must define virtual methods";
+            class Ld {
                 get[Symbol.toStringTag]() {
                     return "Resource"
                 }
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
-                    Ru(t);
+                    Ou(t);
                     const {
                         id: n,
                         userData: i = {}
                     } = e;
-                    this.gl = t, this.gl2 = t, this.id = n || Td(this[Symbol.toStringTag]), this.userData = i, this._bound = !1, this._handle = e.handle, void 0 === this._handle && (this._handle = this._createHandle()), this.byteLength = 0, this._addStats()
+                    this.gl = t, this.gl2 = t, this.id = n || Cd(this[Symbol.toStringTag]), this.userData = i, this._bound = !1, this._handle = e.handle, void 0 === this._handle && (this._handle = this._createHandle()), this.byteLength = 0, this._initStats(), this._addStats()
                 }
                 toString() {
                     return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")")
                 }
                 get handle() {
                     return this._handle
                 }
@@ -10891,113 +10979,114 @@
                     return "function" != typeof e ? (this._bindHandle(e), this) : (this._bound ? t = e() : (this._bindHandle(this.handle), this._bound = !0, t = e(), this._bound = !1, this._bindHandle(null)), t)
                 }
                 unbind() {
                     this.bind(null)
                 }
                 getParameter(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
-                    Ed(t = Pd(this.gl, t));
+                    wd(t = Ed(this.gl, t));
                     const n = (this.constructor.PARAMETERS || {})[t];
                     if (n) {
-                        const t = Lu(this.gl);
+                        const t = Mu(this.gl);
                         if ("webgl2" in n && !t || "extension" in n && !this.gl.getExtension(n.extension)) {
                             const e = n.webgl1,
                                 i = "webgl2" in n ? n.webgl2 : n.webgl1;
                             return t ? i : e
                         }
                     }
                     return this._getParameter(t, e)
                 }
                 getParameters() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const {
                         parameters: e,
                         keys: n
-                    } = t, i = this.constructor.PARAMETERS || {}, r = Lu(this.gl), s = {}, o = e || Object.keys(i);
+                    } = t, i = this.constructor.PARAMETERS || {}, r = Mu(this.gl), s = {}, o = e || Object.keys(i);
                     for (const e of o) {
                         const o = i[e];
                         if (o && (!("webgl2" in o) || r) && (!("extension" in o) || this.gl.getExtension(o.extension))) {
-                            const i = n ? Sd(this.gl, e) : e;
-                            s[i] = this.getParameter(e, t), n && "GLenum" === o.type && (s[i] = Sd(this.gl, s[i]))
+                            const i = n ? Pd(this.gl, e) : e;
+                            s[i] = this.getParameter(e, t), n && "GLenum" === o.type && (s[i] = Pd(this.gl, s[i]))
                         }
                     }
                     return s
                 }
                 setParameter(t, e) {
-                    Ed(t = Pd(this.gl, t));
+                    wd(t = Ed(this.gl, t));
                     const n = (this.constructor.PARAMETERS || {})[t];
                     if (n) {
-                        const t = Lu(this.gl);
+                        const t = Mu(this.gl);
                         if ("webgl2" in n && !t || "extension" in n && !this.gl.getExtension(n.extension)) throw new Error("Parameter not available on this platform");
-                        "GLenum" === n.type && (e = Pd(e))
+                        "GLenum" === n.type && (e = Ed(e))
                     }
                     return this._setParameter(t, e), this
                 }
                 setParameters(t) {
                     for (const e in t) this.setParameter(e, t[e]);
                     return this
                 }
                 stubRemovedMethods(t, e, n) {
-                    return Od(this, t, e, n)
+                    return Md(this, t, e, n)
                 }
                 initialize(t) {}
                 _createHandle() {
-                    throw new Error(Ld)
+                    throw new Error(Od)
                 }
                 _deleteHandle() {
-                    throw new Error(Ld)
+                    throw new Error(Od)
                 }
                 _bindHandle(t) {
-                    throw new Error(Ld)
+                    throw new Error(Od)
                 }
                 _getOptsFromHandle() {
-                    throw new Error(Ld)
+                    throw new Error(Od)
                 }
                 _getParameter(t, e) {
-                    throw new Error(Ld)
+                    throw new Error(Od)
                 }
                 _setParameter(t, e) {
-                    throw new Error(Ld)
+                    throw new Error(Od)
                 }
                 _context() {
                     return this.gl.luma = this.gl.luma || {}, this.gl.luma
                 }
+                _initStats() {
+                    this.gl.stats = this.gl.stats || new _d
+                }
                 _addStats() {
                     const t = this[Symbol.toStringTag],
-                        e = wd.get("Resource Counts");
+                        e = xd.get("Resource Counts");
                     e.get("Resources Created").incrementCount(), e.get("".concat(t, "s Created")).incrementCount(), e.get("".concat(t, "s Active")).incrementCount()
                 }
                 _removeStats() {
                     const t = this[Symbol.toStringTag];
-                    wd.get("Resource Counts").get("".concat(t, "s Active")).decrementCount()
+                    xd.get("Resource Counts").get("".concat(t, "s Active")).decrementCount()
                 }
                 _trackAllocatedMemory(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this[Symbol.toStringTag];
-                    this._trackAllocatedMemoryForContext(t, e), this._trackAllocatedMemoryForContext(t, e, this.gl.canvas && this.gl.canvas.id), this.byteLength = t
+                    this._doTrackAllocatedMemory(t, e), this._doTrackAllocatedMemory(t, e, this.gl.stats.get("Memory Usage"))
                 }
-                _trackAllocatedMemoryForContext(t) {
+                _doTrackAllocatedMemory(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this[Symbol.toStringTag],
-                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
-                    const i = wd.get("Memory Usage".concat(n));
-                    i.get("GPU Memory").addCount(t), i.get("".concat(e, " Memory")).addCount(t)
+                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : xd.get("Memory Usage");
+                    n.get("GPU Memory").addCount(t), n.get("".concat(e, " Memory")).addCount(t), this.byteLength = t
                 }
                 _trackDeallocatedMemory() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this[Symbol.toStringTag];
-                    this._trackDeallocatedMemoryForContext(t), this._trackDeallocatedMemoryForContext(t, this.gl.canvas && this.gl.canvas.id), this.byteLength = 0
+                    this._doTrackDeallocatedMemory(t), this._doTrackDeallocatedMemory(t, this.gl.stats.get("Memory Usage"))
                 }
-                _trackDeallocatedMemoryForContext() {
+                _doTrackDeallocatedMemory() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this[Symbol.toStringTag],
-                        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
-                    const n = wd.get("Memory Usage".concat(e));
-                    n.get("GPU Memory").subtractCount(this.byteLength), n.get("".concat(t, " Memory")).subtractCount(this.byteLength)
+                        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : xd.get("Memory Usage");
+                    e.get("GPU Memory").subtractCount(this.byteLength), e.get("".concat(t, " Memory")).subtractCount(this.byteLength), this.byteLength = 0
                 }
             }
-            const Id = "Failed to deduce GL constant from typed array";
+            const kd = "Failed to deduce GL constant from typed array";
 
-            function kd(t) {
+            function Rd(t) {
                 switch (ArrayBuffer.isView(t) ? t.constructor : t) {
                     case Float32Array:
                         return 5126;
                     case Uint16Array:
                         return 5123;
                     case Uint32Array:
                         return 5125;
@@ -11007,19 +11096,19 @@
                     case Int8Array:
                         return 5120;
                     case Int16Array:
                         return 5122;
                     case Int32Array:
                         return 5124;
                     default:
-                        throw new Error(Id)
+                        throw new Error(kd)
                 }
             }
 
-            function jd(t) {
+            function Id(t) {
                 let {
                     clamped: e = !0
                 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                 switch (t) {
                     case 5126:
                         return Float32Array;
                     case 5123:
@@ -11038,15 +11127,15 @@
                     case 5124:
                         return Int32Array;
                     default:
                         throw new Error("Failed to deduce typed array type from GL constant")
                 }
             }
 
-            function Fd(t) {
+            function jd(t) {
                 let {
                     data: e,
                     width: n,
                     height: i
                 } = t;
                 const r = Math.round(n / 2),
                     s = Math.round(i / 2),
@@ -11057,129 +11146,129 @@
                 return {
                     data: o,
                     width: r,
                     height: s
                 }
             }
 
-            function zd(t, e, n) {
+            function Fd(t, e, n) {
                 const {
                     removedProps: i = {},
                     deprecatedProps: r = {},
                     replacedProps: s = {}
                 } = n;
                 for (const n in i)
                     if (n in e) {
                         const e = i[n] ? "".concat(t, ".").concat(i[n]) : "N/A";
-                        Tu.removed("".concat(t, ".").concat(n), e)()
+                        Su.removed("".concat(t, ".").concat(n), e)()
                     } for (const n in r)
                     if (n in e) {
                         const e = r[n];
-                        Tu.deprecated("".concat(t, ".").concat(n), "".concat(t, ".").concat(e))()
+                        Su.deprecated("".concat(t, ".").concat(n), "".concat(t, ".").concat(e))()
                     } let o = null;
                 for (const n in s)
                     if (n in e) {
                         const i = s[n];
-                        Tu.deprecated("".concat(t, ".").concat(n), "".concat(t, ".").concat(i))(), o = o || Object.assign({}, e), o[i] = e[n], delete o[n]
+                        Su.deprecated("".concat(t, ".").concat(n), "".concat(t, ".").concat(i))(), o = o || Object.assign({}, e), o[i] = e[n], delete o[n]
                     } return o || e
             }
-            const Bd = {
+            const zd = {
                     offset: 0,
                     stride: 0,
                     type: 5126,
                     size: 1,
                     divisor: 0,
                     normalized: !1,
                     integer: !1
                 },
-                Dd = {
+                Bd = {
                     deprecatedProps: {
                         instanced: "divisor",
                         isInstanced: "divisor"
                     }
                 };
-            class Nd {
+            class Dd {
                 static getBytesPerElement(t) {
-                    return jd(t.type || 5126).BYTES_PER_ELEMENT
+                    return Id(t.type || 5126).BYTES_PER_ELEMENT
                 }
                 static getBytesPerVertex(t) {
-                    return Ed(t.size), jd(t.type || 5126).BYTES_PER_ELEMENT * t.size
+                    return wd(t.size), Id(t.type || 5126).BYTES_PER_ELEMENT * t.size
                 }
                 static resolve() {
                     for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
-                    return new Nd(...[Bd, ...e])
+                    return new Dd(...[zd, ...e])
                 }
                 constructor() {
                     for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                     e.forEach((t => this._assign(t))), Object.freeze(this)
                 }
                 toString() {
                     return JSON.stringify(this)
                 }
                 get BYTES_PER_ELEMENT() {
-                    return Nd.getBytesPerElement(this)
+                    return Dd.getBytesPerElement(this)
                 }
                 get BYTES_PER_VERTEX() {
-                    return Nd.getBytesPerVertex(this)
+                    return Dd.getBytesPerVertex(this)
                 }
                 _assign() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                    return t = zd("Accessor", t, Dd), void 0 !== t.type && (this.type = t.type, 5124 !== t.type && 5125 !== t.type || (this.integer = !0)), void 0 !== t.size && (this.size = t.size), void 0 !== t.offset && (this.offset = t.offset), void 0 !== t.stride && (this.stride = t.stride), void 0 !== t.normalized && (this.normalized = t.normalized), void 0 !== t.integer && (this.integer = t.integer), void 0 !== t.divisor && (this.divisor = t.divisor), void 0 !== t.buffer && (this.buffer = t.buffer), void 0 !== t.index && ("boolean" == typeof t.index ? this.index = t.index ? 1 : 0 : this.index = t.index), void 0 !== t.instanced && (this.divisor = t.instanced ? 1 : 0), void 0 !== t.isInstanced && (this.divisor = t.isInstanced ? 1 : 0), this
+                    return t = Fd("Accessor", t, Bd), void 0 !== t.type && (this.type = t.type, 5124 !== t.type && 5125 !== t.type || (this.integer = !0)), void 0 !== t.size && (this.size = t.size), void 0 !== t.offset && (this.offset = t.offset), void 0 !== t.stride && (this.stride = t.stride), void 0 !== t.normalized && (this.normalized = t.normalized), void 0 !== t.integer && (this.integer = t.integer), void 0 !== t.divisor && (this.divisor = t.divisor), void 0 !== t.buffer && (this.buffer = t.buffer), void 0 !== t.index && ("boolean" == typeof t.index ? this.index = t.index ? 1 : 0 : this.index = t.index), void 0 !== t.instanced && (this.divisor = t.instanced ? 1 : 0), void 0 !== t.isInstanced && (this.divisor = t.isInstanced ? 1 : 0), this
                 }
             }
-            const Vd = {
+            const Nd = {
                     offset: "accessor.offset",
                     stride: "accessor.stride",
                     type: "accessor.type",
                     size: "accessor.size",
                     divisor: "accessor.divisor",
                     normalized: "accessor.normalized",
                     integer: "accessor.integer",
                     instanced: "accessor.divisor",
                     isInstanced: "accessor.divisor"
                 },
-                Ud = {
+                Vd = {
                     removedProps: {},
                     replacedProps: {
                         bytes: "byteLength"
                     },
-                    deprecatedProps: Vd
+                    deprecatedProps: Nd
                 },
-                Gd = {
-                    removedProps: Vd
+                Ud = {
+                    removedProps: Nd
                 };
-            class Wd extends Rd {
+            class Gd extends Ld {
                 get[Symbol.toStringTag]() {
                     return "Buffer"
                 }
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     super(t, e), this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]), this.target = e.target || (this.gl.webgl2 ? 36662 : 34962), this.initialize(e), Object.seal(this)
                 }
                 getElementCount() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.accessor;
-                    return Math.round(this.byteLength / Nd.getBytesPerElement(t))
+                    return Math.round(this.byteLength / Dd.getBytesPerElement(t))
                 }
                 getVertexCount() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.accessor;
-                    return Math.round(this.byteLength / Nd.getBytesPerVertex(t))
+                    return Math.round(this.byteLength / Dd.getBytesPerVertex(t))
                 }
                 initialize() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     return ArrayBuffer.isView(t) && (t = {
                         data: t
                     }), Number.isFinite(t) && (t = {
                         byteLength: t
-                    }), t = zd("Buffer", t, Ud), this.usage = t.usage || 35044, this.debugData = null, this.setAccessor(Object.assign({}, t, t.accessor)), t.data ? this._setData(t.data, t.offset, t.byteLength) : this._setByteLength(t.byteLength || 0), this
+                    }), t = Fd("Buffer", t, Vd), this.usage = t.usage || 35044, this.debugData = null, this.setAccessor(Object.assign({}, t, t.accessor)), t.data ? this._setData(t.data, t.offset, t.byteLength) : this._setByteLength(t.byteLength || 0), this
                 }
                 setProps(t) {
-                    return "accessor" in (t = zd("Buffer", t, Gd)) && this.setAccessor(t.accessor), this
+                    return "accessor" in (t = Fd("Buffer", t, Ud)) && this.setAccessor(t.accessor), this
                 }
                 setAccessor(t) {
-                    return delete(t = Object.assign({}, t)).buffer, this.accessor = new Nd(t), this
+                    return delete(t = Object.assign({}, t)).buffer, this.accessor = new Dd(t), this
                 }
                 reallocate(t) {
                     return t > this.byteLength ? (this._setByteLength(t), !0) : (this.bytesUsed = t, !1)
                 }
                 setData(t) {
                     return this.initialize(t)
                 }
@@ -11188,56 +11277,56 @@
                         data: t
                     });
                     const {
                         data: e,
                         offset: n = 0,
                         srcOffset: i = 0
                     } = t, r = t.byteLength || t.length;
-                    Ed(e);
+                    wd(e);
                     const s = this.gl.webgl2 ? 36663 : this.target;
-                    return this.gl.bindBuffer(s, this.handle), 0 !== i || void 0 !== r ? (Iu(this.gl), this.gl.bufferSubData(this.target, n, e, i, r)) : this.gl.bufferSubData(s, n, e), this.gl.bindBuffer(s, null), this.debugData = null, this._inferType(e), this
+                    return this.gl.bindBuffer(s, this.handle), 0 !== i || void 0 !== r ? (Lu(this.gl), this.gl.bufferSubData(this.target, n, e, i, r)) : this.gl.bufferSubData(s, n, e), this.gl.bindBuffer(s, null), this.debugData = null, this._inferType(e), this
                 }
                 copyData(t) {
                     let {
                         sourceBuffer: e,
                         readOffset: n = 0,
                         writeOffset: i = 0,
                         size: r
                     } = t;
                     const {
                         gl: s
                     } = this;
-                    return Iu(s), s.bindBuffer(36662, e.handle), s.bindBuffer(36663, this.handle), s.copyBufferSubData(36662, 36663, n, i, r), s.bindBuffer(36662, null), s.bindBuffer(36663, null), this.debugData = null, this
+                    return Lu(s), s.bindBuffer(36662, e.handle), s.bindBuffer(36663, this.handle), s.copyBufferSubData(36662, 36663, n, i, r), s.bindBuffer(36662, null), s.bindBuffer(36663, null), this.debugData = null, this
                 }
                 getData() {
                     let {
                         dstData: t = null,
                         srcByteOffset: e = 0,
                         dstOffset: n = 0,
                         length: i = 0
                     } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                    Iu(this.gl);
-                    const r = jd(this.accessor.type || 5126, {
+                    Lu(this.gl);
+                    const r = Id(this.accessor.type || 5126, {
                             clamped: !1
                         }),
                         s = this._getAvailableElementCount(e),
                         o = n;
                     let a, l;
                     t ? (l = t.length, a = l - o) : (a = Math.min(s, i || s), l = o + a);
                     const c = Math.min(s, a);
-                    return i = i || c, Ed(i <= c), t = t || new r(l), this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, e, t, n, i), this.gl.bindBuffer(36662, null), t
+                    return i = i || c, wd(i <= c), t = t || new r(l), this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, e, t, n, i), this.gl.bindBuffer(36662, null), t
                 }
                 bind() {
                     let {
                         target: t = this.target,
                         index: e = this.accessor && this.accessor.index,
                         offset: n = 0,
                         size: i
                     } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                    return 35345 === t || 35982 === t ? void 0 !== i ? this.gl.bindBufferRange(t, e, this.handle, n, i) : (Ed(0 === n), this.gl.bindBufferBase(t, e, this.handle)) : this.gl.bindBuffer(t, this.handle), this
+                    return 35345 === t || 35982 === t ? void 0 !== i ? this.gl.bindBufferRange(t, e, this.handle, n, i) : (wd(0 === n), this.gl.bindBufferBase(t, e, this.handle)) : this.gl.bindBuffer(t, this.handle), this
                 }
                 unbind() {
                     let {
                         target: t = this.target,
                         index: e = this.accessor && this.accessor.index
                     } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     return 35345 === t || 35982 === t ? this.gl.bindBufferBase(t, e, null) : this.gl.bindBuffer(t, null), this
@@ -11255,69 +11344,69 @@
                 }
                 invalidateDebugData() {
                     this.debugData = null
                 }
                 _setData(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                         n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t.byteLength + e;
-                    Ed(ArrayBuffer.isView(t)), this._trackDeallocatedMemory();
+                    wd(ArrayBuffer.isView(t)), this._trackDeallocatedMemory();
                     const i = this._getTarget();
                     this.gl.bindBuffer(i, this.handle), this.gl.bufferData(i, n, this.usage), this.gl.bufferSubData(i, e, t), this.gl.bindBuffer(i, null), this.debugData = t.slice(0, 10), this.bytesUsed = n, this._trackAllocatedMemory(n);
-                    const r = kd(t);
-                    return Ed(r), this.setAccessor(new Nd(this.accessor, {
+                    const r = Rd(t);
+                    return wd(r), this.setAccessor(new Dd(this.accessor, {
                         type: r
                     })), this
                 }
                 _setByteLength(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.usage;
-                    Ed(t >= 0), this._trackDeallocatedMemory();
+                    wd(t >= 0), this._trackDeallocatedMemory();
                     let n = t;
                     0 === t && (n = new Float32Array(0));
                     const i = this._getTarget();
                     return this.gl.bindBuffer(i, this.handle), this.gl.bufferData(i, n, e), this.gl.bindBuffer(i, null), this.usage = e, this.debugData = null, this.bytesUsed = t, this._trackAllocatedMemory(t), this
                 }
                 _getTarget() {
                     return this.gl.webgl2 ? 36663 : this.target
                 }
                 _getAvailableElementCount(t) {
-                    const e = t / jd(this.accessor.type || 5126, {
+                    const e = t / Id(this.accessor.type || 5126, {
                         clamped: !1
                     }).BYTES_PER_ELEMENT;
                     return this.getElementCount() - e
                 }
                 _inferType(t) {
-                    this.accessor.type || this.setAccessor(new Nd(this.accessor, {
-                        type: kd(t)
+                    this.accessor.type || this.setAccessor(new Dd(this.accessor, {
+                        type: Rd(t)
                     }))
                 }
                 _createHandle() {
                     return this.gl.createBuffer()
                 }
                 _deleteHandle() {
                     this.gl.deleteBuffer(this.handle), this._trackDeallocatedMemory()
                 }
                 _getParameter(t) {
                     this.gl.bindBuffer(this.target, this.handle);
                     const e = this.gl.getBufferParameter(this.target, t);
                     return this.gl.bindBuffer(this.target, null), e
                 }
                 get type() {
-                    return Tu.deprecated("Buffer.type", "Buffer.accessor.type")(), this.accessor.type
+                    return Su.deprecated("Buffer.type", "Buffer.accessor.type")(), this.accessor.type
                 }
                 get bytes() {
-                    return Tu.deprecated("Buffer.bytes", "Buffer.byteLength")(), this.byteLength
+                    return Su.deprecated("Buffer.bytes", "Buffer.byteLength")(), this.byteLength
                 }
                 setByteLength(t) {
-                    return Tu.deprecated("setByteLength", "reallocate")(), this.reallocate(t)
+                    return Su.deprecated("setByteLength", "reallocate")(), this.reallocate(t)
                 }
                 updateAccessor(t) {
-                    return Tu.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")(), this.accessor = new Nd(this.accessor, t), this
+                    return Su.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")(), this.accessor = new Dd(this.accessor, t), this
                 }
             }
-            const Hd = {
+            const Wd = {
                     6407: {
                         dataFormat: 6407,
                         types: [5121, 33635]
                     },
                     6408: {
                         dataFormat: 6408,
                         types: [5121, 32819, 32820]
@@ -11351,73 +11440,73 @@
                     },
                     34836: {
                         dataFormat: 6408,
                         types: [5126],
                         gl2: !0
                     }
                 },
-                Zd = {
+                Hd = {
                     6403: 1,
                     36244: 1,
                     33319: 2,
                     33320: 2,
                     6407: 3,
                     36248: 3,
                     6408: 4,
                     36249: 4,
                     6402: 1,
                     34041: 1,
                     6406: 1,
                     6409: 1,
                     6410: 2
                 },
-                qd = {
+                Zd = {
                     5126: 4,
                     5125: 4,
                     5124: 4,
                     5123: 2,
                     5122: 2,
                     5131: 2,
                     5120: 1,
                     5121: 1
                 },
-                Xd = [9729, 9728],
-                Yd = globalThis.WebGLBuffer || function() {};
-            class Kd extends Rd {
+                qd = [9729, 9728],
+                Xd = globalThis.WebGLBuffer || function() {};
+            class Yd extends Ld {
                 get[Symbol.toStringTag]() {
                     return "Texture"
                 }
                 static isSupported(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     const {
                         format: n,
                         linearFiltering: i
                     } = e;
                     let r = !0;
                     return n && (r = r && function(t, e) {
-                        const n = Hd[e];
+                        const n = Wd[e];
                         if (!n) return !1;
                         if (void 0 === n.gl1 && void 0 === n.gl2) return !0;
-                        const i = Lu(t) && n.gl2 || n.gl1;
+                        const i = Mu(t) && n.gl2 || n.gl1;
                         return "string" == typeof i ? t.getExtension(i) : i
                     }(t, n), r = r && (!i || function(t, e) {
-                        const n = Hd[e];
+                        const n = Wd[e];
                         switch (n && n.types[0]) {
                             case 5126:
                                 return t.getExtension("OES_texture_float_linear");
                             case 5131:
                                 return t.getExtension("OES_texture_half_float_linear");
                             default:
                                 return !0
                         }
                     }(t, n))), r
                 }
                 constructor(t, e) {
                     const {
-                        id: n = Td("texture"),
+                        id: n = Cd("texture"),
                         handle: i,
                         target: r
                     } = e;
                     super(t, {
                         id: n,
                         handle: i
                     }), this.target = r, this.textureUnit = void 0, this.loaded = !1, this.width = void 0, this.height = void 0, this.depth = void 0, this.format = void 0, this.type = void 0, this.dataFormat = void 0, this.border = void 0, this.textureUnit = void 0, this.mipmaps = void 0
@@ -11465,15 +11554,15 @@
                         format: r,
                         type: p,
                         dataFormat: d,
                         compressed: f,
                         data: e,
                         width: h,
                         height: u
-                    })), this.width = h, this.height = u, this.depth = m, this.format = r, this.type = p, this.dataFormat = d, this.border = s, this.textureUnit = c, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), g && this._isNPOT() && (Tu.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))(), g = !1, this._updateForNPOT(a)), this.mipmaps = g, this.setImageData({
+                    })), this.width = h, this.height = u, this.depth = m, this.format = r, this.type = p, this.dataFormat = d, this.border = s, this.textureUnit = c, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), g && this._isNPOT() && (Su.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))(), g = !1, this._updateForNPOT(a)), this.mipmaps = g, this.setImageData({
                         data: e,
                         width: h,
                         height: u,
                         depth: m,
                         format: r,
                         type: p,
                         dataFormat: d,
@@ -11515,15 +11604,15 @@
                         dataFormat: this.dataFormat,
                         border: this.border,
                         mipmaps: i
                     }) : this
                 }
                 generateMipmap() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                    return this._isNPOT() ? (Tu.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))(), this) : (this.mipmaps = !0, this.gl.bindTexture(this.target, this.handle), ud(this.gl, t, (() => {
+                    return this._isNPOT() ? (Su.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))(), this) : (this.mipmaps = !0, this.gl.bindTexture(this.target, this.handle), cd(this.gl, t, (() => {
                         this.gl.generateMipmap(this.target)
                     })), this.gl.bindTexture(this.target, null), this)
                 }
                 setImageData(t) {
                     this._trackDeallocatedMemory("Texture");
                     const {
                         target: e = this.target,
@@ -11566,39 +11655,39 @@
                         data: l,
                         dataType: m
                     } = this._getDataType({
                         data: l,
                         compressed: p
                     }));
                     let v = 0;
-                    if (ud(this.gl, a, (() => {
+                    if (cd(this.gl, a, (() => {
                             switch (m) {
                                 case "null":
                                     f.texImage2D(e, i, r, h, u, s, d, c, l);
                                     break;
                                 case "typed-array":
                                     f.texImage2D(e, i, r, h, u, s, d, c, l, o);
                                     break;
                                 case "buffer":
-                                    g = Iu(f), g.bindBuffer(35052, l.handle || l), g.texImage2D(e, i, r, h, u, s, d, c, o), g.bindBuffer(35052, null);
+                                    g = Lu(f), g.bindBuffer(35052, l.handle || l), g.texImage2D(e, i, r, h, u, s, d, c, o), g.bindBuffer(35052, null);
                                     break;
                                 case "browser-object":
-                                    Lu(f) ? f.texImage2D(e, i, r, h, u, s, d, c, l) : f.texImage2D(e, i, r, d, c, l);
+                                    Mu(f) ? f.texImage2D(e, i, r, h, u, s, d, c, l) : f.texImage2D(e, i, r, d, c, l);
                                     break;
                                 case "compressed":
                                     for (const [t, n] of l.entries()) f.compressedTexImage2D(e, t, n.format, n.width, n.height, s, n.data), v += n.levelSize;
                                     break;
                                 default:
-                                    Ed(!1, "Unknown image data type")
+                                    wd(!1, "Unknown image data type")
                             }
                         })), "compressed" === m) this._trackAllocatedMemory(v, "Texture");
                     else if (l && l.byteLength) this._trackAllocatedMemory(l.byteLength, "Texture");
                     else {
-                        const t = Zd[this.dataFormat] || 4,
-                            e = qd[this.type] || 1;
+                        const t = Hd[this.dataFormat] || 4,
+                            e = Zd[this.type] || 1;
                         this._trackAllocatedMemory(this.width * this.height * t * e, "Texture")
                     }
                     return this.loaded = !0, this
                 }
                 setSubImageData(t) {
                     let {
                         target: e = this.target,
@@ -11627,30 +11716,30 @@
                             format: c,
                             type: h,
                             dataFormat: u,
                             compressed: d,
                             data: i,
                             width: o,
                             height: a
-                        })), Ed(0 === this.depth, "texSubImage not supported for 3D textures"), i || (i = n), i && i.data) {
+                        })), wd(0 === this.depth, "texSubImage not supported for 3D textures"), i || (i = n), i && i.data) {
                         const t = i;
                         i = t.data, o = t.shape[0], a = t.shape[1]
                     }
-                    i instanceof Wd && (i = i.handle), this.gl.bindTexture(this.target, this.handle), ud(this.gl, g, (() => {
+                    i instanceof Gd && (i = i.handle), this.gl.bindTexture(this.target, this.handle), cd(this.gl, g, (() => {
                         if (d) this.gl.compressedTexSubImage2D(e, l, r, s, o, a, c, i);
                         else if (null === i) this.gl.texSubImage2D(e, l, r, s, o, a, u, h, null);
                         else if (ArrayBuffer.isView(i)) this.gl.texSubImage2D(e, l, r, s, o, a, u, h, i, p);
-                        else if (i instanceof Yd) {
-                            const t = Iu(this.gl);
+                        else if (i instanceof Xd) {
+                            const t = Lu(this.gl);
                             t.bindBuffer(35052, i), t.texSubImage2D(e, l, r, s, o, a, u, h, p), t.bindBuffer(35052, null)
-                        } else Lu(this.gl) ? Iu(this.gl).texSubImage2D(e, l, r, s, o, a, u, h, i) : this.gl.texSubImage2D(e, l, r, s, u, h, i)
+                        } else Mu(this.gl) ? Lu(this.gl).texSubImage2D(e, l, r, s, o, a, u, h, i) : this.gl.texSubImage2D(e, l, r, s, u, h, i)
                     })), this.gl.bindTexture(this.target, null)
                 }
                 copyFramebuffer() {
-                    return Tu.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null
+                    return Su.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null
                 }
                 getActiveUnit() {
                     return this.gl.getParameter(34016) - 33984
                 }
                 bind() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.textureUnit;
                     const {
@@ -11675,18 +11764,18 @@
                         dataType: "compressed"
                     } : null === e ? {
                         data: e,
                         dataType: "null"
                     } : ArrayBuffer.isView(e) ? {
                         data: e,
                         dataType: "typed-array"
-                    } : e instanceof Wd ? {
+                    } : e instanceof Gd ? {
                         data: e.handle,
                         dataType: "buffer"
-                    } : e instanceof Yd ? {
+                    } : e instanceof Xd ? {
                         data: e,
                         dataType: "buffer"
                     } : {
                         data: e,
                         dataType: "browser-object"
                     }
                 }
@@ -11698,15 +11787,15 @@
                     let {
                         width: i,
                         height: r,
                         dataFormat: s,
                         type: o,
                         compressed: a
                     } = t;
-                    const l = Hd[e];
+                    const l = Wd[e];
                     return s = s || l && l.dataFormat, o = o || l && l.types[0], a = a || l && l.compressed, ({
                         width: i,
                         height: r
                     } = this._deduceImageSize(n, i, r)), {
                         dataFormat: s,
                         type: o,
                         compressed: a,
@@ -11732,15 +11821,15 @@
                         height: t.videoHeight
                     } : t ? {
                         width: e,
                         height: n
                     } : {
                         width: e >= 0 ? e : 1,
                         height: n >= 0 ? n : 1
-                    }, Ed(i, "Could not deduced texture size"), Ed(void 0 === e || i.width === e, "Deduced texture width does not match supplied width"), Ed(void 0 === n || i.height === n, "Deduced texture height does not match supplied height"), i
+                    }, wd(i, "Could not deduced texture size"), wd(void 0 === e || i.width === e, "Deduced texture width does not match supplied width"), wd(void 0 === n || i.height === n, "Deduced texture height does not match supplied height"), i
                 }
                 _createHandle() {
                     return this.gl.createTexture()
                 }
                 _deleteHandle() {
                     this.gl.deleteTexture(this.handle), this._trackDeallocatedMemory("Texture")
                 }
@@ -11760,67 +11849,67 @@
                     switch (this.gl.bindTexture(this.target, this.handle), e = this._getNPOTParam(t, e), t) {
                         case 33082:
                         case 33083:
                             this.gl.texParameterf(this.handle, t, e);
                             break;
                         case 4096:
                         case 4097:
-                            Ed(!1);
+                            wd(!1);
                             break;
                         default:
                             this.gl.texParameteri(this.target, t, e)
                     }
                     return this.gl.bindTexture(this.target, null), this
                 }
                 _isNPOT() {
-                    return !(Lu(this.gl) || !this.width || !this.height || Ad(this.width) && Ad(this.height))
+                    return !(Mu(this.gl) || !this.width || !this.height || Td(this.width) && Td(this.height))
                 }
                 _updateForNPOT(t) {
                     void 0 === t[this.gl.TEXTURE_MIN_FILTER] && (t[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR), void 0 === t[this.gl.TEXTURE_WRAP_S] && (t[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE), void 0 === t[this.gl.TEXTURE_WRAP_T] && (t[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE)
                 }
                 _getNPOTParam(t, e) {
                     if (this._isNPOT()) switch (t) {
                         case 10241:
-                            -1 === Xd.indexOf(e) && (e = 9729);
+                            -1 === qd.indexOf(e) && (e = 9729);
                             break;
                         case 10242:
                         case 10243:
                             33071 !== e && (e = 33071)
                     }
                     return e
                 }
             }
-            class Qd extends Kd {
+            class Kd extends Yd {
                 get[Symbol.toStringTag]() {
                     return "Texture2D"
                 }
                 static isSupported(t, e) {
-                    return Kd.isSupported(t, e)
+                    return Yd.isSupported(t, e)
                 }
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     var n;
-                    Ru(t), (e instanceof Promise || "string" == typeof e) && (e = {
+                    Ou(t), (e instanceof Promise || "string" == typeof e) && (e = {
                         data: e
                     }), "string" == typeof e.data && (e = Object.assign({}, e, {
-                        data: (n = e.data, Ed("string" == typeof n), n = "" + n, new Promise(((t, e) => {
+                        data: (n = e.data, wd("string" == typeof n), n = "" + n, new Promise(((t, e) => {
                             try {
                                 const i = new Image;
                                 i.onload = () => t(i), i.onerror = () => e(new Error("Could not load image ".concat(n, "."))), i.crossOrigin = "anonymous", i.src = n
                             } catch (t) {
                                 e(t)
                             }
                         })))
                     })), super(t, Object.assign({}, e, {
                         target: 3553
                     })), this.initialize(e), Object.seal(this)
                 }
             }
-            const Jd = "EXT_color_buffer_float",
-                $d = {
+            const Qd = "EXT_color_buffer_float",
+                Jd = {
                     33189: {
                         bpp: 2
                     },
                     33190: {
                         gl2: !0,
                         bpp: 3
                     },
@@ -11944,58 +12033,58 @@
                         bpp: 16
                     },
                     36208: {
                         gl2: !0,
                         bpp: 16
                     },
                     33325: {
-                        gl2: Jd,
+                        gl2: Qd,
                         bpp: 2
                     },
                     33327: {
-                        gl2: Jd,
+                        gl2: Qd,
                         bpp: 4
                     },
                     34842: {
-                        gl2: Jd,
+                        gl2: Qd,
                         bpp: 8
                     },
                     33326: {
-                        gl2: Jd,
+                        gl2: Qd,
                         bpp: 4
                     },
                     33328: {
-                        gl2: Jd,
+                        gl2: Qd,
                         bpp: 8
                     },
                     34836: {
-                        gl2: Jd,
+                        gl2: Qd,
                         bpp: 16
                     },
                     35898: {
-                        gl2: Jd,
+                        gl2: Qd,
                         bpp: 4
                     }
                 };
-            class tp extends Rd {
+            class $d extends Ld {
                 get[Symbol.toStringTag]() {
                     return "Renderbuffer"
                 }
                 static isSupported(t) {
                     let {
                         format: e
                     } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                         format: null
                     };
                     return !e || function(t, e, n) {
                         const i = n[e];
                         if (!i) return !1;
-                        const r = Lu(t) && i.gl2 || i.gl1;
+                        const r = Mu(t) && i.gl2 || i.gl1;
                         return "string" == typeof r ? t.getExtension(r) : r
-                    }(t, e, $d)
+                    }(t, e, Jd)
                 }
                 static getSamplesForFormat(t, e) {
                     let {
                         format: n
                     } = e;
                     return t.getInternalformatParameter(36161, n, 32937)
                 }
@@ -12006,15 +12095,15 @@
                 initialize(t) {
                     let {
                         format: e,
                         width: n = 1,
                         height: i = 1,
                         samples: r = 0
                     } = t;
-                    return Ed(e, "Needs format"), this._trackDeallocatedMemory(), this.gl.bindRenderbuffer(36161, this.handle), 0 !== r && Lu(this.gl) ? this.gl.renderbufferStorageMultisample(36161, r, e, n, i) : this.gl.renderbufferStorage(36161, e, n, i), this.format = e, this.width = n, this.height = i, this.samples = r, this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * $d[this.format].bpp), this
+                    return wd(e, "Needs format"), this._trackDeallocatedMemory(), this.gl.bindRenderbuffer(36161, this.handle), 0 !== r && Mu(this.gl) ? this.gl.renderbufferStorageMultisample(36161, r, e, n, i) : this.gl.renderbufferStorage(36161, e, n, i), this.format = e, this.width = n, this.height = i, this.samples = r, this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * Jd[this.format].bpp), this
                 }
                 resize(t) {
                     let {
                         width: e,
                         height: n
                     } = t;
                     return e !== this.width || n !== this.height ? this.initialize({
@@ -12036,39 +12125,39 @@
                 _syncHandle(t) {
                     this.format = this.getParameter(36164), this.width = this.getParameter(36162), this.height = this.getParameter(36163), this.samples = this.getParameter(36011)
                 }
                 _getParameter(t) {
                     return this.gl.bindRenderbuffer(36161, this.handle), this.gl.getRenderbufferParameter(36161, t)
                 }
             }
-            const ep = 6144,
-                np = "clear: bad arguments";
+            const tp = 6144,
+                ep = "clear: bad arguments";
 
-            function ip(t) {
+            function np(t) {
                 let {
                     framebuffer: e = null,
                     color: n = null,
                     depth: i = null,
                     stencil: r = null
                 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                 const s = {};
                 e && (s.framebuffer = e);
                 let o = 0;
-                n && (o |= 16384, !0 !== n && (s.clearColor = n)), i && (o |= 256, !0 !== i && (s.clearDepth = i)), r && (o |= 1024, !0 !== i && (s.clearStencil = i)), Ed(0 !== o, np), ud(t, s, (() => {
+                n && (o |= 16384, !0 !== n && (s.clearColor = n)), i && (o |= 256, !0 !== i && (s.clearDepth = i)), r && (o |= 1024, !0 !== i && (s.clearStencil = i)), wd(0 !== o, ep), cd(t, s, (() => {
                     t.clear(o)
                 }))
             }
-            const rp = [34069, 34070, 34071, 34072, 34073, 34074];
-            class sp extends Kd {
+            const ip = [34069, 34070, 34071, 34072, 34073, 34074];
+            class rp extends Yd {
                 get[Symbol.toStringTag]() {
                     return "TextureCube"
                 }
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
-                    Ru(t), super(t, Object.assign({}, e, {
+                    Ou(t), super(t, Object.assign({}, e, {
                         target: 34067
                     })), this.initialize(e), Object.seal(this)
                 }
                 initialize() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const {
                         mipmaps: e = !0,
@@ -12102,20 +12191,20 @@
                         data: r,
                         border: s = 0,
                         format: o = 6408,
                         type: a = 5121
                     } = t;
                     const {
                         gl: l
-                    } = this, c = i || r, h = await Promise.all(rp.map((t => {
+                    } = this, c = i || r, h = await Promise.all(ip.map((t => {
                         const e = c[t];
                         return Promise.all(Array.isArray(e) ? e : [e])
                     })));
-                    this.bind(), rp.forEach(((t, i) => {
-                        h[i].length > 1 && !1 !== this.opts.mipmaps && Tu.warn("".concat(this.id, " has mipmap and multiple LODs."))(), h[i].forEach(((i, r) => {
+                    this.bind(), ip.forEach(((t, i) => {
+                        h[i].length > 1 && !1 !== this.opts.mipmaps && Su.warn("".concat(this.id, " has mipmap and multiple LODs."))(), h[i].forEach(((i, r) => {
                             e && n ? l.texImage2D(t, r, o, e, n, s, o, a, i) : l.texImage2D(t, r, o, o, a, i)
                         }))
                     })), this.unbind()
                 }
                 setImageDataForFace(t) {
                     const {
                         face: e,
@@ -12132,25 +12221,25 @@
                     return this.bind(), h instanceof Promise ? h.then((n => this.setImageDataForFace(Object.assign({}, t, {
                         face: e,
                         data: n,
                         pixels: n
                     })))) : this.width || this.height ? c.texImage2D(e, 0, a, n, i, o, a, l, h) : c.texImage2D(e, 0, a, a, l, h), this
                 }
             }
-            sp.FACES = rp;
-            class op extends Kd {
+            rp.FACES = ip;
+            class sp extends Yd {
                 get[Symbol.toStringTag]() {
                     return "Texture3D"
                 }
                 static isSupported(t) {
-                    return Lu(t)
+                    return Mu(t)
                 }
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
-                    Iu(t), e = Object.assign({
+                    Lu(t), e = Object.assign({
                         depth: 1
                     }, e, {
                         target: 32879,
                         unpackFlipY: !1
                     }), super(t, e), this.initialize(e), Object.seal(this)
                 }
                 setImageData(t) {
@@ -12163,44 +12252,44 @@
                         border: o = 0,
                         format: a,
                         type: l = 5121,
                         offset: c = 0,
                         data: h,
                         parameters: u = {}
                     } = t;
-                    if (this._trackDeallocatedMemory("Texture"), this.gl.bindTexture(this.target, this.handle), ud(this.gl, u, (() => {
-                            ArrayBuffer.isView(h) && this.gl.texImage3D(this.target, e, n, i, r, s, o, a, l, h), h instanceof Wd && (this.gl.bindBuffer(35052, h.handle), this.gl.texImage3D(this.target, e, n, i, r, s, o, a, l, c))
+                    if (this._trackDeallocatedMemory("Texture"), this.gl.bindTexture(this.target, this.handle), cd(this.gl, u, (() => {
+                            ArrayBuffer.isView(h) && this.gl.texImage3D(this.target, e, n, i, r, s, o, a, l, h), h instanceof Gd && (this.gl.bindBuffer(35052, h.handle), this.gl.texImage3D(this.target, e, n, i, r, s, o, a, l, c))
                         })), h && h.byteLength) this._trackAllocatedMemory(h.byteLength, "Texture");
                     else {
-                        const t = Zd[this.dataFormat] || 4,
-                            e = qd[this.type] || 1;
+                        const t = Hd[this.dataFormat] || 4,
+                            e = Zd[this.type] || 1;
                         this._trackAllocatedMemory(this.width * this.height * this.depth * t * e, "Texture")
                     }
                     return this.loaded = !0, this
                 }
             }
 
-            function ap(t, e) {
+            function op(t, e) {
                 const {
                     gl: n,
                     width: i,
                     height: r,
                     id: s
                 } = t;
-                return new bp(n, Object.assign({}, e, {
+                return new vp(n, Object.assign({}, e, {
                     id: "framebuffer-for-".concat(s),
                     width: i,
                     height: r,
                     attachments: {
                         36064: t
                     }
                 }))
             }
 
-            function lp(t) {
+            function ap(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                 const {
                     sourceX: n = 0,
                     sourceY: i = 0,
                     sourceFormat: r = 6408
                 } = e;
                 let {
@@ -12209,24 +12298,24 @@
                     sourceWidth: a,
                     sourceHeight: l,
                     sourceType: c
                 } = e;
                 const {
                     framebuffer: h,
                     deleteFramebuffer: u
-                } = hp(t);
-                Ed(h);
+                } = cp(t);
+                wd(h);
                 const {
                     gl: d,
                     handle: p,
                     attachments: f
                 } = h;
-                a = a || h.width, l = l || h.height, 36064 === s && null === p && (s = 1028), Ed(f[s]), c = c || f[s].type, o = function(t, e, n, i, r) {
+                a = a || h.width, l = l || h.height, 36064 === s && null === p && (s = 1028), wd(f[s]), c = c || f[s].type, o = function(t, e, n, i, r) {
                     if (t) return t;
-                    const s = jd(e = e || 5121, {
+                    const s = Id(e = e || 5121, {
                             clamped: !1
                         }),
                         o = function(t) {
                             switch (t) {
                                 case 6406:
                                 case 33326:
                                 case 6403:
@@ -12237,38 +12326,38 @@
                                 case 6407:
                                 case 34837:
                                     return 3;
                                 case 6408:
                                 case 34836:
                                     return 4;
                                 default:
-                                    return Ed(!1), 0
+                                    return wd(!1), 0
                             }
                         }(n);
                     return new s(i * r * o)
-                }(o, c, r, a, l), c = c || kd(o);
+                }(o, c, r, a, l), c = c || Rd(o);
                 const g = d.bindFramebuffer(36160, p);
                 return d.readPixels(n, i, a, l, r, c, o), d.bindFramebuffer(36160, g || null), u && h.delete(), o
             }
 
-            function cp(t) {
+            function lp(t) {
                 let {
                     sourceAttachment: e = 36064,
                     targetMaxHeight: n = Number.MAX_SAFE_INTEGER
-                } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = lp(t, {
+                } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = ap(t, {
                     sourceAttachment: e
                 }), {
                     width: r,
                     height: s
                 } = t;
                 for (; s > n;)({
                     data: i,
                     width: r,
                     height: s
-                } = Fd({
+                } = jd({
                     data: i,
                     width: r,
                     height: s
                 }));
                 ! function(t) {
                     let {
                         data: e,
@@ -12292,48 +12381,48 @@
                 const o = document.createElement("canvas");
                 o.width = r, o.height = s;
                 const a = o.getContext("2d"),
                     l = a.createImageData(r, s);
                 return l.data.set(i), a.putImageData(l, 0, 0), o.toDataURL()
             }
 
-            function hp(t) {
-                return t instanceof bp ? {
+            function cp(t) {
+                return t instanceof vp ? {
                     framebuffer: t,
                     deleteFramebuffer: !1
                 } : {
-                    framebuffer: ap(t),
+                    framebuffer: op(t),
                     deleteFramebuffer: !0
                 }
             }
-            const up = "TIMER_QUERY",
-                dp = "ELEMENT_INDEX_UINT32",
-                pp = {
+            const hp = "TIMER_QUERY",
+                up = "ELEMENT_INDEX_UINT32",
+                dp = {
                     WEBGL2: [!1, !0],
                     VERTEX_ARRAY_OBJECT: ["OES_vertex_array_object", !0],
-                    [up]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
+                    [hp]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
                     INSTANCED_RENDERING: ["ANGLE_instanced_arrays", !0],
                     MULTIPLE_RENDER_TARGETS: ["WEBGL_draw_buffers", !0],
-                    [dp]: ["OES_element_index_uint", !0],
+                    [up]: ["OES_element_index_uint", !0],
                     BLEND_EQUATION_MINMAX: ["EXT_blend_minmax", !0],
                     FLOAT_BLEND: ["EXT_float_blend"],
                     COLOR_ENCODING_SRGB: ["EXT_sRGB", !0],
                     TEXTURE_DEPTH: ["WEBGL_depth_texture", !0],
                     TEXTURE_FLOAT: ["OES_texture_float", !0],
                     TEXTURE_HALF_FLOAT: ["OES_texture_half_float", !0],
                     TEXTURE_FILTER_LINEAR_FLOAT: ["OES_texture_float_linear"],
                     TEXTURE_FILTER_LINEAR_HALF_FLOAT: ["OES_texture_half_float_linear"],
                     TEXTURE_FILTER_ANISOTROPIC: ["EXT_texture_filter_anisotropic"],
                     COLOR_ATTACHMENT_RGBA32F: [function(t) {
-                        const e = new Qd(t, {
+                        const e = new Kd(t, {
                                 format: 6408,
                                 type: 5126,
                                 dataFormat: 6408
                             }),
-                            n = new bp(t, {
+                            n = new vp(t, {
                                 id: "test-framebuffer",
                                 check: !1,
                                 attachments: {
                                     36064: e
                                 }
                             }),
                             i = n.getStatus();
@@ -12342,61 +12431,61 @@
                     COLOR_ATTACHMENT_FLOAT: [!1, "EXT_color_buffer_float"],
                     COLOR_ATTACHMENT_HALF_FLOAT: ["EXT_color_buffer_half_float"],
                     GLSL_FRAG_DATA: ["WEBGL_draw_buffers", !0],
                     GLSL_FRAG_DEPTH: ["EXT_frag_depth", !0],
                     GLSL_DERIVATIVES: ["OES_standard_derivatives", !0],
                     GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", !0]
                 },
-                fp = 2;
+                pp = 2;
 
-            function gp(t, e) {
-                return (e = Array.isArray(e) ? e : [e]).every((e => mp(t, e)))
+            function fp(t, e) {
+                return (e = Array.isArray(e) ? e : [e]).every((e => gp(t, e)))
             }
 
-            function mp(t, e) {
+            function gp(t, e) {
                 return t.luma = t.luma || {}, t.luma.caps = t.luma.caps || {}, void 0 === t.luma.caps[e] && (t.luma.caps[e] = function(t, e) {
-                    const n = pp[e];
+                    const n = dp[e];
                     let i;
-                    Ed(n, e);
-                    const r = Lu(t) && n[1] || n[0];
+                    wd(n, e);
+                    const r = Mu(t) && n[1] || n[0];
                     if ("function" == typeof r) i = r(t);
                     else if (Array.isArray(r)) {
                         i = !0;
                         for (const e of r) i = i && Boolean(t.getExtension(e))
-                    } else "string" == typeof r ? i = Boolean(t.getExtension(r)) : "boolean" == typeof r ? i = r : Ed(!1);
+                    } else "string" == typeof r ? i = Boolean(t.getExtension(r)) : "boolean" == typeof r ? i = r : wd(!1);
                     return i
-                }(t, e)), t.luma.caps[e] || Tu.log(fp, "Feature: ".concat(e, " not supported"))(), t.luma.caps[e]
+                }(t, e)), t.luma.caps[e] || Su.log(pp, "Feature: ".concat(e, " not supported"))(), t.luma.caps[e]
             }
-            const vp = "Multiple render targets not supported";
-            class bp extends Rd {
+            const mp = "Multiple render targets not supported";
+            class vp extends Ld {
                 get[Symbol.toStringTag]() {
                     return "Framebuffer"
                 }
                 static isSupported(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     const {
                         colorBufferFloat: n,
                         colorBufferHalfFloat: i
                     } = e;
                     let r = !0;
                     return n && (r = Boolean(t.getExtension("EXT_color_buffer_float") || t.getExtension("WEBGL_color_buffer_float") || t.getExtension("OES_texture_float"))), i && (r = r && Boolean(t.getExtension("EXT_color_buffer_float") || t.getExtension("EXT_color_buffer_half_float"))), r
                 }
                 static getDefaultFramebuffer(t) {
-                    return t.luma = t.luma || {}, t.luma.defaultFramebuffer = t.luma.defaultFramebuffer || new bp(t, {
+                    return t.luma = t.luma || {}, t.luma.defaultFramebuffer = t.luma.defaultFramebuffer || new vp(t, {
                         id: "default-framebuffer",
                         handle: null,
                         attachments: {}
                     }), t.luma.defaultFramebuffer
                 }
                 get MAX_COLOR_ATTACHMENTS() {
-                    const t = Iu(this.gl);
+                    const t = Lu(this.gl);
                     return t.getParameter(t.MAX_COLOR_ATTACHMENTS)
                 }
                 get MAX_DRAW_BUFFERS() {
-                    const t = Iu(this.gl);
+                    const t = Lu(this.gl);
                     return t.getParameter(t.MAX_DRAW_BUFFERS)
                 }
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     super(t, e), this.width = null, this.height = null, this.attachments = {}, this.readBuffer = 36064, this.drawBuffers = [36064], this.ownResources = [], this.initialize(e), Object.seal(this)
                 }
                 get color() {
@@ -12419,15 +12508,15 @@
                         color: r = !0,
                         depth: s = !0,
                         stencil: o = !1,
                         check: a = !0,
                         readBuffer: l,
                         drawBuffers: c
                     } = t;
-                    if (Ed(e >= 0 && n >= 0, "Width and height need to be integers"), this.width = e, this.height = n, i)
+                    if (wd(e >= 0 && n >= 0, "Width and height need to be integers"), this.width = e, this.height = n, i)
                         for (const t in i) {
                             const r = i[t];
                             (Array.isArray(r) ? r[0] : r).resize({
                                 width: e,
                                 height: n
                             })
                         } else i = this._createDefaultAttachments(r, s, o, e, n);
@@ -12461,16 +12550,16 @@
                 }
                 resize() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                         {
                             width: e,
                             height: n
                         } = t;
-                    if (null === this.handle) return Ed(void 0 === e && void 0 === n), this.width = this.gl.drawingBufferWidth, this.height = this.gl.drawingBufferHeight, this;
-                    void 0 === e && (e = this.gl.drawingBufferWidth), void 0 === n && (n = this.gl.drawingBufferHeight), e !== this.width && n !== this.height && Tu.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(e, "x").concat(n))();
+                    if (null === this.handle) return wd(void 0 === e && void 0 === n), this.width = this.gl.drawingBufferWidth, this.height = this.gl.drawingBufferHeight, this;
+                    void 0 === e && (e = this.gl.drawingBufferWidth), void 0 === n && (n = this.gl.drawingBufferHeight), e !== this.width && n !== this.height && Su.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(e, "x").concat(n))();
                     for (const t in this.attachments) this.attachments[t].resize({
                         width: e,
                         height: n
                     });
                     return this.width = e, this.height = n, this
                 }
                 attach(t) {
@@ -12480,20 +12569,20 @@
                     } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     const i = {};
                     e && Object.keys(this.attachments).forEach((t => {
                         i[t] = null
                     })), Object.assign(i, t);
                     const r = this.gl.bindFramebuffer(36160, this.handle);
                     for (const t in i) {
-                        Ed(void 0 !== t, "Misspelled framebuffer binding point?");
+                        wd(void 0 !== t, "Misspelled framebuffer binding point?");
                         const e = Number(t),
                             r = i[e];
                         let s = r;
                         if (s)
-                            if (s instanceof tp) this._attachRenderbuffer({
+                            if (s instanceof $d) this._attachRenderbuffer({
                                 attachment: e,
                                 renderbuffer: s
                             });
                             else if (Array.isArray(r)) {
                             const [t, n = 0, i = 0] = r;
                             s = t, this._attachTexture({
                                 attachment: e,
@@ -12518,15 +12607,15 @@
                     }))
                 }
                 checkStatus() {
                     const {
                         gl: t
                     } = this, e = this.getStatus();
                     if (36053 !== e) throw new Error(function(t) {
-                        return (bp.STATUS || {})[t] || "Framebuffer error ".concat(t)
+                        return (vp.STATUS || {})[t] || "Framebuffer error ".concat(t)
                     }(e));
                     return this
                 }
                 getStatus() {
                     const {
                         gl: t
                     } = this, e = t.bindFramebuffer(36160, this.handle), n = t.checkFramebufferStatus(36160);
@@ -12536,31 +12625,31 @@
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const {
                         color: e,
                         depth: n,
                         stencil: i,
                         drawBuffers: r = []
                     } = t, s = this.gl.bindFramebuffer(36160, this.handle);
-                    return (e || n || i) && ip(this.gl, {
+                    return (e || n || i) && np(this.gl, {
                         color: e,
                         depth: n,
                         stencil: i
                     }), r.forEach(((t, e) => {
                         ! function(t) {
                             let {
                                 framebuffer: e = null,
-                                buffer: n = ep,
+                                buffer: n = tp,
                                 drawBuffer: i = 0,
                                 value: r = [0, 0, 0, 0]
                             } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
-                            Iu(t), ud(t, {
+                            Lu(t), cd(t, {
                                 framebuffer: e
                             }, (() => {
                                 switch (n) {
-                                    case ep:
+                                    case tp:
                                         switch (r.constructor) {
                                             case Int32Array:
                                                 t.clearBufferiv(n, i, r);
                                                 break;
                                             case Uint32Array:
                                                 t.clearBufferuiv(n, i, r);
                                                 break;
@@ -12576,87 +12665,87 @@
                                         t.clearBufferiv(6146, 0, [r]);
                                         break;
                                     case 34041:
                                         const [e, s] = r;
                                         t.clearBufferfi(34041, 0, e, s);
                                         break;
                                     default:
-                                        Ed(!1, np)
+                                        wd(!1, ep)
                                 }
                             }))
                         }(this.gl, {
                             drawBuffer: e,
                             value: t
                         })
                     })), this.gl.bindFramebuffer(36160, s || null), this
                 }
                 readPixels() {
-                    return Tu.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")(), null
+                    return Su.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")(), null
                 }
                 readPixelsToBuffer() {
-                    return Tu.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")(), null
+                    return Su.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")(), null
                 }
                 copyToDataUrl() {
-                    return Tu.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")(), null
+                    return Su.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")(), null
                 }
                 copyToImage() {
-                    return Tu.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")(), null
+                    return Su.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")(), null
                 }
                 copyToTexture() {
-                    return Tu.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null
+                    return Su.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null
                 }
                 blit() {
-                    return Tu.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")(), null
+                    return Su.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")(), null
                 }
                 invalidate(t) {
                     let {
                         attachments: e = [],
                         x: n = 0,
                         y: i = 0,
                         width: r,
                         height: s
                     } = t;
-                    const o = Iu(this.gl),
+                    const o = Lu(this.gl),
                         a = o.bindFramebuffer(36008, this.handle);
                     return 0 === n && 0 === i && void 0 === r && void 0 === s ? o.invalidateFramebuffer(36008, e) : o.invalidateFramebuffer(36008, e, n, i, r, s), o.bindFramebuffer(36008, a), this
                 }
                 getAttachmentParameter(t, e, n) {
                     let i = this._getAttachmentParameterFallback(e);
-                    return null === i && (this.gl.bindFramebuffer(36160, this.handle), i = this.gl.getFramebufferAttachmentParameter(36160, t, e), this.gl.bindFramebuffer(36160, null)), n && i > 1e3 && (i = Sd(this.gl, i)), i
+                    return null === i && (this.gl.bindFramebuffer(36160, this.handle), i = this.gl.getFramebufferAttachmentParameter(36160, t, e), this.gl.bindFramebuffer(36160, null)), n && i > 1e3 && (i = Pd(this.gl, i)), i
                 }
                 getAttachmentParameters() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 36064,
                         e = arguments.length > 1 ? arguments[1] : void 0,
                         n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
                     const i = {};
-                    for (const r of n) i[e ? Sd(this.gl, r) : r] = this.getAttachmentParameter(t, r, e);
+                    for (const r of n) i[e ? Pd(this.gl, r) : r] = this.getAttachmentParameter(t, r, e);
                     return i
                 }
                 getParameters() {
                     let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                     const e = Object.keys(this.attachments),
                         n = {};
                     for (const i of e) {
                         const e = Number(i);
-                        n[t ? Sd(this.gl, e) : e] = this.getAttachmentParameters(e, t)
+                        n[t ? Pd(this.gl, e) : e] = this.getAttachmentParameters(e, t)
                     }
                     return n
                 }
                 show() {
-                    return "undefined" != typeof window && window.open(cp(this), "luma-debug-texture"), this
+                    return "undefined" != typeof window && window.open(lp(this), "luma-debug-texture"), this
                 }
                 log() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                         e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
-                    if (t > Tu.level || "undefined" == typeof window) return this;
+                    if (t > Su.level || "undefined" == typeof window) return this;
                     e = e || "Framebuffer ".concat(this.id);
-                    const n = cp(this, {
+                    const n = lp(this, {
                         targetMaxHeight: 100
                     });
-                    return Tu.image({
+                    return Su.image({
                         logLevel: t,
                         message: e,
                         image: n
                     }, e)(), this
                 }
                 bind() {
                     let {
@@ -12668,43 +12757,43 @@
                     let {
                         target: t = 36160
                     } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     return this.gl.bindFramebuffer(t, null), this
                 }
                 _createDefaultAttachments(t, e, n, i, r) {
                     let s = null;
-                    return t && (s = s || {}, s[36064] = new Qd(this.gl, {
+                    return t && (s = s || {}, s[36064] = new Kd(this.gl, {
                         id: "".concat(this.id, "-color0"),
                         pixels: null,
                         format: 6408,
                         type: 5121,
                         width: i,
                         height: r,
                         mipmaps: !1,
                         parameters: {
                             10241: 9729,
                             10240: 9729,
                             10242: 33071,
                             10243: 33071
                         }
-                    }), this.ownResources.push(s[36064])), e && n ? (s = s || {}, s[33306] = new tp(this.gl, {
+                    }), this.ownResources.push(s[36064])), e && n ? (s = s || {}, s[33306] = new $d(this.gl, {
                         id: "".concat(this.id, "-depth-stencil"),
                         format: 35056,
                         width: i,
                         height: 111
-                    }), this.ownResources.push(s[33306])) : e ? (s = s || {}, s[36096] = new tp(this.gl, {
+                    }), this.ownResources.push(s[33306])) : e ? (s = s || {}, s[36096] = new $d(this.gl, {
                         id: "".concat(this.id, "-depth"),
                         format: 33189,
                         width: i,
                         height: r
-                    }), this.ownResources.push(s[36096])) : n && Ed(!1), s
+                    }), this.ownResources.push(s[36096])) : n && wd(!1), s
                 }
                 _unattach(t) {
                     const e = this.attachments[t];
-                    e && (e instanceof tp ? this.gl.framebufferRenderbuffer(36160, t, 36161, null) : this.gl.framebufferTexture2D(36160, t, 3553, null, 0), delete this.attachments[t])
+                    e && (e instanceof $d ? this.gl.framebufferRenderbuffer(36160, t, 36161, null) : this.gl.framebufferTexture2D(36160, t, 3553, null, 0), delete this.attachments[t])
                 }
                 _attachRenderbuffer(t) {
                     let {
                         attachment: e = 36064,
                         renderbuffer: n
                     } = t;
                     const {
@@ -12721,50 +12810,50 @@
                     } = t;
                     const {
                         gl: s
                     } = this;
                     switch (s.bindTexture(n.target, n.handle), n.target) {
                         case 35866:
                         case 32879:
-                            Iu(s).framebufferTextureLayer(36160, e, n.target, r, i);
+                            Lu(s).framebufferTextureLayer(36160, e, n.target, r, i);
                             break;
                         case 34067:
                             const t = function(t) {
                                 return t < 34069 ? t + 34069 : t
                             }(i);
                             s.framebufferTexture2D(36160, e, t, n.handle, r);
                             break;
                         case 3553:
                             s.framebufferTexture2D(36160, e, 3553, n.handle, r);
                             break;
                         default:
-                            Ed(!1, "Illegal texture type")
+                            wd(!1, "Illegal texture type")
                     }
                     s.bindTexture(n.target, null), this.attachments[e] = n
                 }
                 _setReadBuffer(t) {
-                    const e = Lu(n = this.gl) ? n : null;
+                    const e = Mu(n = this.gl) ? n : null;
                     var n;
-                    e ? e.readBuffer(t) : Ed(36064 === t || 1029 === t, vp), this.readBuffer = t
+                    e ? e.readBuffer(t) : wd(36064 === t || 1029 === t, mp), this.readBuffer = t
                 }
                 _setDrawBuffers(t) {
                     const {
                         gl: e
-                    } = this, n = Iu(e);
+                    } = this, n = Lu(e);
                     if (n) n.drawBuffers(t);
                     else {
                         const n = e.getExtension("WEBGL_draw_buffers");
-                        n ? n.drawBuffersWEBGL(t) : Ed(1 === t.length && (36064 === t[0] || 1029 === t[0]), vp)
+                        n ? n.drawBuffersWEBGL(t) : wd(1 === t.length && (36064 === t[0] || 1029 === t[0]), mp)
                     }
                     this.drawBuffers = t
                 }
                 _getAttachmentParameterFallback(t) {
                     const e = function(t) {
                         t.luma = t.luma || {}, t.luma.caps = t.luma.caps || {};
-                        for (const e in pp) void 0 === t.luma.caps[e] && (t.luma.caps[e] = mp(t, e));
+                        for (const e in dp) void 0 === t.luma.caps[e] && (t.luma.caps[e] = gp(t, e));
                         return t.luma.caps
                     }(this.gl);
                     switch (t) {
                         case 36052:
                             return e.WEBGL2 ? null : 0;
                         case 33298:
                         case 33299:
@@ -12787,223 +12876,223 @@
                 _deleteHandle() {
                     this.gl.deleteFramebuffer(this.handle)
                 }
                 _bindHandle(t) {
                     return this.gl.bindFramebuffer(36160, t)
                 }
             }
-            bp.ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
-            const yp = {
-                    5126: Ip.bind(null, "uniform1fv", Sp, 1, kp),
-                    35664: Ip.bind(null, "uniform2fv", Sp, 2, kp),
-                    35665: Ip.bind(null, "uniform3fv", Sp, 3, kp),
-                    35666: Ip.bind(null, "uniform4fv", Sp, 4, kp),
-                    5124: Ip.bind(null, "uniform1iv", Cp, 1, kp),
-                    35667: Ip.bind(null, "uniform2iv", Cp, 2, kp),
-                    35668: Ip.bind(null, "uniform3iv", Cp, 3, kp),
-                    35669: Ip.bind(null, "uniform4iv", Cp, 4, kp),
-                    35670: Ip.bind(null, "uniform1iv", Cp, 1, kp),
-                    35671: Ip.bind(null, "uniform2iv", Cp, 2, kp),
-                    35672: Ip.bind(null, "uniform3iv", Cp, 3, kp),
-                    35673: Ip.bind(null, "uniform4iv", Cp, 4, kp),
-                    35674: Ip.bind(null, "uniformMatrix2fv", Sp, 4, jp),
-                    35675: Ip.bind(null, "uniformMatrix3fv", Sp, 9, jp),
-                    35676: Ip.bind(null, "uniformMatrix4fv", Sp, 16, jp),
-                    35678: Rp,
-                    35680: Rp,
-                    5125: Ip.bind(null, "uniform1uiv", Tp, 1, kp),
-                    36294: Ip.bind(null, "uniform2uiv", Tp, 2, kp),
-                    36295: Ip.bind(null, "uniform3uiv", Tp, 3, kp),
-                    36296: Ip.bind(null, "uniform4uiv", Tp, 4, kp),
-                    35685: Ip.bind(null, "uniformMatrix2x3fv", Sp, 6, jp),
-                    35686: Ip.bind(null, "uniformMatrix2x4fv", Sp, 8, jp),
-                    35687: Ip.bind(null, "uniformMatrix3x2fv", Sp, 6, jp),
-                    35688: Ip.bind(null, "uniformMatrix3x4fv", Sp, 12, jp),
-                    35689: Ip.bind(null, "uniformMatrix4x2fv", Sp, 8, jp),
-                    35690: Ip.bind(null, "uniformMatrix4x3fv", Sp, 12, jp),
-                    35678: Rp,
-                    35680: Rp,
-                    35679: Rp,
-                    35682: Rp,
-                    36289: Rp,
-                    36292: Rp,
-                    36293: Rp,
-                    36298: Rp,
-                    36299: Rp,
-                    36300: Rp,
-                    36303: Rp,
-                    36306: Rp,
-                    36307: Rp,
-                    36308: Rp,
-                    36311: Rp
+            vp.ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
+            const bp = {
+                    5126: kp.bind(null, "uniform1fv", Pp, 1, Rp),
+                    35664: kp.bind(null, "uniform2fv", Pp, 2, Rp),
+                    35665: kp.bind(null, "uniform3fv", Pp, 3, Rp),
+                    35666: kp.bind(null, "uniform4fv", Pp, 4, Rp),
+                    5124: kp.bind(null, "uniform1iv", Sp, 1, Rp),
+                    35667: kp.bind(null, "uniform2iv", Sp, 2, Rp),
+                    35668: kp.bind(null, "uniform3iv", Sp, 3, Rp),
+                    35669: kp.bind(null, "uniform4iv", Sp, 4, Rp),
+                    35670: kp.bind(null, "uniform1iv", Sp, 1, Rp),
+                    35671: kp.bind(null, "uniform2iv", Sp, 2, Rp),
+                    35672: kp.bind(null, "uniform3iv", Sp, 3, Rp),
+                    35673: kp.bind(null, "uniform4iv", Sp, 4, Rp),
+                    35674: kp.bind(null, "uniformMatrix2fv", Pp, 4, Ip),
+                    35675: kp.bind(null, "uniformMatrix3fv", Pp, 9, Ip),
+                    35676: kp.bind(null, "uniformMatrix4fv", Pp, 16, Ip),
+                    35678: Lp,
+                    35680: Lp,
+                    5125: kp.bind(null, "uniform1uiv", Cp, 1, Rp),
+                    36294: kp.bind(null, "uniform2uiv", Cp, 2, Rp),
+                    36295: kp.bind(null, "uniform3uiv", Cp, 3, Rp),
+                    36296: kp.bind(null, "uniform4uiv", Cp, 4, Rp),
+                    35685: kp.bind(null, "uniformMatrix2x3fv", Pp, 6, Ip),
+                    35686: kp.bind(null, "uniformMatrix2x4fv", Pp, 8, Ip),
+                    35687: kp.bind(null, "uniformMatrix3x2fv", Pp, 6, Ip),
+                    35688: kp.bind(null, "uniformMatrix3x4fv", Pp, 12, Ip),
+                    35689: kp.bind(null, "uniformMatrix4x2fv", Pp, 8, Ip),
+                    35690: kp.bind(null, "uniformMatrix4x3fv", Pp, 12, Ip),
+                    35678: Lp,
+                    35680: Lp,
+                    35679: Lp,
+                    35682: Lp,
+                    36289: Lp,
+                    36292: Lp,
+                    36293: Lp,
+                    36298: Lp,
+                    36299: Lp,
+                    36300: Lp,
+                    36303: Lp,
+                    36306: Lp,
+                    36307: Lp,
+                    36308: Lp,
+                    36311: Lp
                 },
+                yp = {},
                 _p = {},
                 xp = {},
-                wp = {},
-                Ep = [0];
+                wp = [0];
 
-            function Pp(t, e, n, i) {
-                1 === e && "boolean" == typeof t && (t = t ? 1 : 0), Number.isFinite(t) && (Ep[0] = t, t = Ep);
+            function Ep(t, e, n, i) {
+                1 === e && "boolean" == typeof t && (t = t ? 1 : 0), Number.isFinite(t) && (wp[0] = t, t = wp);
                 const r = t.length;
-                if (r % e && Tu.warn("Uniform size should be multiples of ".concat(e), t)(), t instanceof n) return t;
+                if (r % e && Su.warn("Uniform size should be multiples of ".concat(e), t)(), t instanceof n) return t;
                 let s = i[r];
                 s || (s = new n(r), i[r] = s);
                 for (let e = 0; e < r; e++) s[e] = t[e];
                 return s
             }
 
-            function Sp(t, e) {
-                return Pp(t, e, Float32Array, _p)
+            function Pp(t, e) {
+                return Ep(t, e, Float32Array, yp)
             }
 
-            function Cp(t, e) {
-                return Pp(t, e, Int32Array, xp)
+            function Sp(t, e) {
+                return Ep(t, e, Int32Array, _p)
             }
 
-            function Tp(t, e) {
-                return Pp(t, e, Uint32Array, wp)
+            function Cp(t, e) {
+                return Ep(t, e, Uint32Array, xp)
             }
 
-            function Ap(t, e, n) {
-                const i = yp[n.type];
+            function Tp(t, e, n) {
+                const i = bp[n.type];
                 if (!i) throw new Error("Unknown GLSL uniform type ".concat(n.type));
                 return i().bind(null, t, e)
             }
 
-            function Mp(t) {
+            function Ap(t) {
                 if ("]" !== t[t.length - 1]) return {
                     name: t,
                     length: 1,
                     isArray: !1
                 };
                 const e = t.match(/([^[]*)(\[[0-9]+\])?/);
                 if (!e || e.length < 2) throw new Error("Failed to parse GLSL uniform name ".concat(t));
                 return {
                     name: e[1],
                     length: e[2] || 1,
                     isArray: Boolean(e[2])
                 }
             }
 
-            function Op(t) {
+            function Mp(t) {
                 return Array.isArray(t) || ArrayBuffer.isView(t) ? function(t) {
                     if (0 === t.length) return !1;
                     const e = Math.min(t.length, 16);
                     for (let n = 0; n < e; ++n)
                         if (!Number.isFinite(t[n])) return !1;
                     return !0
-                }(t) : !!isFinite(t) || !0 === t || !1 === t || t instanceof Kd || t instanceof tp || t instanceof bp && Boolean(t.texture)
+                }(t) : !!isFinite(t) || !0 === t || !1 === t || t instanceof Yd || t instanceof $d || t instanceof vp && Boolean(t.texture)
             }
 
-            function Lp(t, e, n) {
+            function Op(t, e, n) {
                 if (Array.isArray(n) || ArrayBuffer.isView(n))
                     if (t[e]) {
                         const i = t[e];
                         for (let t = 0, e = n.length; t < e; ++t) i[t] = n[t]
                     } else t[e] = n.slice();
                 else t[e] = n
             }
 
-            function Rp() {
+            function Lp() {
                 let t = null;
                 return (e, n, i) => {
                     const r = t !== i;
                     return r && (e.uniform1i(n, i), t = i), r
                 }
             }
 
-            function Ip(t, e, n, i) {
+            function kp(t, e, n, i) {
                 let r = null,
                     s = null;
                 return (o, a, l) => {
                     const c = e(l, n),
                         h = c.length;
                     let u = !1;
                     if (null === r) r = new Float32Array(h), s = h, u = !0;
                     else {
-                        Ed(s === h, "Uniform length cannot change.");
+                        wd(s === h, "Uniform length cannot change.");
                         for (let t = 0; t < h; ++t)
                             if (c[t] !== r[t]) {
                                 u = !0;
                                 break
                             }
                     }
                     return u && (i(o, t, a, c), r.set(c)), u
                 }
             }
 
-            function kp(t, e, n, i) {
+            function Rp(t, e, n, i) {
                 t[e](n, i)
             }
 
-            function jp(t, e, n, i) {
+            function Ip(t, e, n, i) {
                 t[e](n, !1, i)
             }
 
-            function Fp(t) {
+            function jp(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "unnamed";
                 const n = t.match(/#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/);
                 return n ? n[1] : e
             }
 
-            function zp(t, e) {
+            function Fp(t, e) {
                 let n = "";
                 for (let i = 0; i < e.length; i++) {
                     const r = e[i];
                     if ((t[i + 3] || t[i + 2] || t[i + 1]) && (n += "".concat(r, "\n"), t[i + 1])) {
                         const e = t[i + 1],
                             r = e.split(":", 3),
                             s = r[0],
                             o = parseInt(r[1], 10) || 0,
                             a = e.substring(r.join(":").length + 1).trim();
-                        n += Bp("^^^ ".concat(s, ": ").concat(a, "\n\n"), o)
+                        n += zp("^^^ ".concat(s, ": ").concat(a, "\n\n"), o)
                     }
                 }
                 return n
             }
 
-            function Bp(t, e) {
+            function zp(t, e) {
                 let n = "";
                 for (let t = 0; t < e; ++t) n += " ";
                 return "".concat(n).concat(t)
             }
-            class Dp extends Rd {
+            class Bp extends Ld {
                 get[Symbol.toStringTag]() {
                     return "Shader"
                 }
                 static getTypeName(t) {
                     switch (t) {
                         case 35633:
                             return "vertex-shader";
                         case 35632:
                             return "fragment-shader";
                         default:
-                            return Ed(!1), "unknown"
+                            return wd(!1), "unknown"
                     }
                 }
                 constructor(t, e) {
-                    Ru(t), Ed("string" == typeof e.source, "Shader: GLSL source code must be a JavaScript string"), super(t, {
-                        id: Fp(e.source, null) || e.id || Td("unnamed ".concat(Dp.getTypeName(e.shaderType)))
+                    Ou(t), wd("string" == typeof e.source, "Shader: GLSL source code must be a JavaScript string"), super(t, {
+                        id: jp(e.source, null) || e.id || Cd("unnamed ".concat(Bp.getTypeName(e.shaderType)))
                     }), this.shaderType = e.shaderType, this.source = e.source, this.initialize(e)
                 }
                 initialize(t) {
                     let {
                         source: e
                     } = t;
-                    const n = Fp(e, null);
-                    n && (this.id = Td(n)), this._compile(e)
+                    const n = jp(e, null);
+                    n && (this.id = Cd(n)), this._compile(e)
                 }
                 getParameter(t) {
                     return this.gl.getShaderParameter(this.handle, t)
                 }
                 toString() {
-                    return "".concat(Dp.getTypeName(this.shaderType), ":").concat(this.id)
+                    return "".concat(Bp.getTypeName(this.shaderType), ":").concat(this.id)
                 }
                 getName() {
-                    return Fp(this.source) || "unnamed-shader"
+                    return jp(this.source) || "unnamed-shader"
                 }
                 getSource() {
                     return this.gl.getShaderSource(this.handle)
                 }
                 getTranslatedSource() {
                     const t = this.gl.getExtension("WEBGL_debug_shaders");
                     return t ? t.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented"
@@ -13016,15 +13105,15 @@
                                 shaderName: e,
                                 errors: n,
                                 warnings: i
                             } = function(t, e, n, i) {
                                 const r = t.split(/\r?\n/),
                                     s = {},
                                     o = {},
-                                    a = i || Fp(e) || "(unnamed)",
+                                    a = i || jp(e) || "(unnamed)",
                                     l = "".concat(function(t) {
                                         switch (t) {
                                             case 35632:
                                                 return "fragment";
                                             case 35633:
                                                 return "vertex";
                                             default:
@@ -13044,129 +13133,129 @@
                                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                                         n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ": ";
                                     const i = t.split(/\r?\n/),
                                         r = String(i.length + e - 1).length;
                                     return i.map(((t, i) => {
                                         const s = String(i + e),
                                             o = s.length;
-                                        return Bp(s, r - o) + n + t
+                                        return zp(s, r - o) + n + t
                                     }))
                                 }(e);
                                 return {
                                     shaderName: l,
-                                    errors: zp(s, c),
-                                    warnings: zp(o, c)
+                                    errors: Fp(s, c),
+                                    warnings: Fp(o, c)
                                 }
                             }(t, this.source, this.shaderType, this.id);
-                        throw Tu.error("GLSL compilation errors in ".concat(e, "\n").concat(n))(), Tu.warn("GLSL compilation warnings in ".concat(e, "\n").concat(i))(), new Error("GLSL compilation errors in ".concat(e))
+                        throw Su.error("GLSL compilation errors in ".concat(e, "\n").concat(n))(), Su.warn("GLSL compilation warnings in ".concat(e, "\n").concat(i))(), new Error("GLSL compilation errors in ".concat(e))
                     }
                 }
                 _deleteHandle() {
                     this.gl.deleteShader(this.handle)
                 }
                 _getOptsFromHandle() {
                     return {
                         type: this.getParameter(35663),
                         source: this.getSource()
                     }
                 }
             }
-            class Np extends Dp {
+            class Dp extends Bp {
                 get[Symbol.toStringTag]() {
                     return "VertexShader"
                 }
                 constructor(t, e) {
                     "string" == typeof e && (e = {
                         source: e
                     }), super(t, Object.assign({}, e, {
                         shaderType: 35633
                     }))
                 }
                 _createHandle() {
                     return this.gl.createShader(35633)
                 }
             }
-            class Vp extends Dp {
+            class Np extends Bp {
                 get[Symbol.toStringTag]() {
                     return "FragmentShader"
                 }
                 constructor(t, e) {
                     "string" == typeof e && (e = {
                         source: e
                     }), super(t, Object.assign({}, e, {
                         shaderType: 35632
                     }))
                 }
                 _createHandle() {
                     return this.gl.createShader(35632)
                 }
             }
-            const Up = 5120,
-                Gp = 5121,
-                Wp = 5122,
-                Hp = 5123,
-                Zp = 5126,
-                qp = 5124,
-                Xp = 5125,
-                Yp = {
-                    [Zp]: [Zp, 1, "float"],
-                    35664: [Zp, 2, "vec2"],
-                    35665: [Zp, 3, "vec3"],
-                    35666: [Zp, 4, "vec4"],
-                    [qp]: [qp, 1, "int"],
-                    35667: [qp, 2, "ivec2"],
-                    35668: [qp, 3, "ivec3"],
-                    35669: [qp, 4, "ivec4"],
-                    [Xp]: [Xp, 1, "uint"],
-                    36294: [Xp, 2, "uvec2"],
-                    36295: [Xp, 3, "uvec3"],
-                    36296: [Xp, 4, "uvec4"],
-                    35670: [Zp, 1, "bool"],
-                    35671: [Zp, 2, "bvec2"],
-                    35672: [Zp, 3, "bvec3"],
-                    35673: [Zp, 4, "bvec4"],
-                    35674: [Zp, 8, "mat2"],
-                    35685: [Zp, 8, "mat2x3"],
-                    35686: [Zp, 8, "mat2x4"],
-                    35675: [Zp, 12, "mat3"],
-                    35687: [Zp, 12, "mat3x2"],
-                    35688: [Zp, 12, "mat3x4"],
-                    35676: [Zp, 16, "mat4"],
-                    35689: [Zp, 16, "mat4x2"],
-                    35690: [Zp, 16, "mat4x3"]
+            const Vp = 5120,
+                Up = 5121,
+                Gp = 5122,
+                Wp = 5123,
+                Hp = 5126,
+                Zp = 5124,
+                qp = 5125,
+                Xp = {
+                    [Hp]: [Hp, 1, "float"],
+                    35664: [Hp, 2, "vec2"],
+                    35665: [Hp, 3, "vec3"],
+                    35666: [Hp, 4, "vec4"],
+                    [Zp]: [Zp, 1, "int"],
+                    35667: [Zp, 2, "ivec2"],
+                    35668: [Zp, 3, "ivec3"],
+                    35669: [Zp, 4, "ivec4"],
+                    [qp]: [qp, 1, "uint"],
+                    36294: [qp, 2, "uvec2"],
+                    36295: [qp, 3, "uvec3"],
+                    36296: [qp, 4, "uvec4"],
+                    35670: [Hp, 1, "bool"],
+                    35671: [Hp, 2, "bvec2"],
+                    35672: [Hp, 3, "bvec3"],
+                    35673: [Hp, 4, "bvec4"],
+                    35674: [Hp, 8, "mat2"],
+                    35685: [Hp, 8, "mat2x3"],
+                    35686: [Hp, 8, "mat2x4"],
+                    35675: [Hp, 12, "mat3"],
+                    35687: [Hp, 12, "mat3x2"],
+                    35688: [Hp, 12, "mat3x4"],
+                    35676: [Hp, 16, "mat4"],
+                    35689: [Hp, 16, "mat4x2"],
+                    35690: [Hp, 16, "mat4x3"]
                 };
 
-            function Kp(t) {
-                const e = Yp[t];
+            function Yp(t) {
+                const e = Xp[t];
                 if (!e) return null;
                 const [n, i] = e;
                 return {
                     type: n,
                     components: i
                 }
             }
 
-            function Qp(t, e) {
+            function Kp(t, e) {
                 switch (t) {
+                    case Vp:
                     case Up:
                     case Gp:
                     case Wp:
-                    case Hp:
-                        t = Zp
+                        t = Hp
                 }
-                for (const n in Yp) {
-                    const [i, r, s] = Yp[n];
+                for (const n in Xp) {
+                    const [i, r, s] = Xp[n];
                     if (i === t && r === e) return {
                         glType: n,
                         name: s
                     }
                 }
                 return null
             }
-            class Jp {
+            class Qp {
                 constructor(t) {
                     this.id = t.id, this.attributeInfos = [], this.attributeInfosByName = {}, this.attributeInfosByLocation = [], this.varyingInfos = [], this.varyingInfosByName = {}, Object.seal(this), this._readAttributesFromProgram(t), this._readVaryingsFromProgram(t)
                 }
                 getAttributeInfo(t) {
                     const e = Number(t);
                     return Number.isFinite(e) ? this.attributeInfosByLocation[e] : this.attributeInfosByName[t] || null
                 }
@@ -13204,15 +13293,15 @@
                     }
                     this.attributeInfos.sort(((t, e) => t.location - e.location))
                 }
                 _readVaryingsFromProgram(t) {
                     const {
                         gl: e
                     } = t;
-                    if (!Lu(e)) return;
+                    if (!Mu(e)) return;
                     const n = e.getProgramParameter(t.handle, 35971);
                     for (let i = 0; i < n; i++) {
                         const {
                             name: n,
                             type: r,
                             size: s
                         } = e.getTransformFeedbackVarying(t.handle, i);
@@ -13220,70 +13309,70 @@
                     }
                     this.varyingInfos.sort(((t, e) => t.location - e.location))
                 }
                 _addAttribute(t, e, n, i) {
                     const {
                         type: r,
                         components: s
-                    } = Kp(n), o = {
+                    } = Yp(n), o = {
                         type: r,
                         size: i * s
                     };
                     this._inferProperties(t, e, o);
                     const a = {
                         location: t,
                         name: e,
-                        accessor: new Nd(o)
+                        accessor: new Dd(o)
                     };
                     this.attributeInfos.push(a), this.attributeInfosByLocation[t] = a, this.attributeInfosByName[a.name] = a
                 }
                 _inferProperties(t, e, n) {
                     /instance/i.test(e) && (n.divisor = 1)
                 }
                 _addVarying(t, e, n, i) {
                     const {
                         type: r,
                         components: s
-                    } = Kp(n), o = {
+                    } = Yp(n), o = {
                         location: t,
                         name: e,
-                        accessor: new Nd({
+                        accessor: new Dd({
                             type: r,
                             size: i * s
                         })
                     };
                     this.varyingInfos.push(o), this.varyingInfosByName[o.name] = o
                 }
             }
-            const $p = 35981,
-                tf = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
-            class ef extends Rd {
+            const Jp = 35981,
+                $p = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
+            class tf extends Ld {
                 get[Symbol.toStringTag]() {
                     return "Program"
                 }
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
-                    super(t, e), this.stubRemovedMethods("Program", "v6.0", tf), this._isCached = !1, this.initialize(e), Object.seal(this), this._setId(e.id)
+                    super(t, e), this.stubRemovedMethods("Program", "v6.0", $p), this._isCached = !1, this.initialize(e), Object.seal(this), this._setId(e.id)
                 }
                 initialize() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const {
                         hash: e,
                         vs: n,
                         fs: i,
                         varyings: r,
-                        bufferMode: s = $p
+                        bufferMode: s = Jp
                     } = t;
-                    return this.hash = e || "", this.vs = "string" == typeof n ? new Np(this.gl, {
+                    return this.hash = e || "", this.vs = "string" == typeof n ? new Dp(this.gl, {
                         id: "".concat(t.id, "-vs"),
                         source: n
-                    }) : n, this.fs = "string" == typeof i ? new Vp(this.gl, {
+                    }) : n, this.fs = "string" == typeof i ? new Np(this.gl, {
                         id: "".concat(t.id, "-fs"),
                         source: i
-                    }) : i, Ed(this.vs instanceof Np), Ed(this.fs instanceof Vp), this.uniforms = {}, this._textureUniforms = {}, r && r.length > 0 && (Iu(this.gl), this.varyings = r, this.gl2.transformFeedbackVaryings(this.handle, r, s)), this._compileAndLink(), this._readUniformLocationsFromLinkedProgram(), this.configuration = new Jp(this), this.setProps(t)
+                    }) : i, wd(this.vs instanceof Dp), wd(this.fs instanceof Np), this.uniforms = {}, this._textureUniforms = {}, r && r.length > 0 && (Lu(this.gl), this.varyings = r, this.gl2.transformFeedbackVaryings(this.handle, r, s)), this._compileAndLink(), this._readUniformLocationsFromLinkedProgram(), this.configuration = new Qp(this), this.setProps(t)
                 }
                 delete() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     return this._isCached ? this : super.delete(t)
                 }
                 setProps(t) {
                     return "uniforms" in t && this.setUniforms(t.uniforms), this
@@ -13303,20 +13392,20 @@
                         vertexArray: u = null,
                         transformFeedback: d,
                         framebuffer: p,
                         parameters: f = {},
                         uniforms: g,
                         samplers: m
                     } = t;
-                    if ((g || m) && (Tu.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")(), this.setUniforms(g || {})), Tu.priority >= e) {
+                    if ((g || m) && (Su.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")(), this.setUniforms(g || {})), Su.priority >= e) {
                         const t = p ? p.id : "default",
-                            r = "mode=".concat(Sd(this.gl, n), " verts=").concat(i, " ") + "instances=".concat(c, " indexType=").concat(Sd(this.gl, l), " ") + "isInstanced=".concat(h, " isIndexed=").concat(a, " ") + "Framebuffer=".concat(t);
-                        Tu.log(e, r)()
+                            r = "mode=".concat(Pd(this.gl, n), " verts=").concat(i, " ") + "instances=".concat(c, " indexType=").concat(Pd(this.gl, l), " ") + "isInstanced=".concat(h, " isIndexed=").concat(a, " ") + "Framebuffer=".concat(t);
+                        Su.log(e, r)()
                     }
-                    return Ed(u), this.gl.useProgram(this.handle), !(!this._areTexturesRenderable() || 0 === i || h && 0 === c || (u.bindForDraw(i, c, (() => {
+                    return wd(u), this.gl.useProgram(this.handle), !(!this._areTexturesRenderable() || 0 === i || h && 0 === c || (u.bindForDraw(i, c, (() => {
                         if (void 0 !== p && (f = Object.assign({}, f, {
                                 framebuffer: p
                             })), d) {
                             const t = function(t) {
                                 switch (t) {
                                     case 0:
                                         return 0;
@@ -13325,49 +13414,49 @@
                                     case 2:
                                         return 1;
                                     case 4:
                                     case 5:
                                     case 6:
                                         return 4;
                                     default:
-                                        return Ed(!1), 0
+                                        return wd(!1), 0
                                 }
                             }(n);
                             d.begin(t)
                         }
-                        this._bindTextures(), ud(this.gl, f, (() => {
-                            a && h ? this.gl2.drawElementsInstanced(n, i, l, r, c) : a && Lu(this.gl) && !isNaN(s) && !isNaN(o) ? this.gl2.drawRangeElements(n, s, o, i, l, r) : a ? this.gl.drawElements(n, i, l, r) : h ? this.gl2.drawArraysInstanced(n, r, i, c) : this.gl.drawArrays(n, r, i)
+                        this._bindTextures(), cd(this.gl, f, (() => {
+                            a && h ? this.gl2.drawElementsInstanced(n, i, l, r, c) : a && Mu(this.gl) && !isNaN(s) && !isNaN(o) ? this.gl2.drawRangeElements(n, s, o, i, l, r) : a ? this.gl.drawElements(n, i, l, r) : h ? this.gl2.drawArraysInstanced(n, r, i, c) : this.gl.drawArrays(n, r, i)
                         })), d && d.end()
                     })), 0))
                 }
                 setUniforms() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                    Tu.priority >= 2 && function(t, e, n) {
+                    Su.priority >= 2 && function(t, e, n) {
                         for (const i in t) {
                             const r = t[i];
-                            if ((!n || Boolean(n[i])) && !Op(r)) throw e = e ? "".concat(e, " ") : "", console.error("".concat(e, " Bad uniform ").concat(i), r), new Error("".concat(e, " Bad uniform ").concat(i))
+                            if ((!n || Boolean(n[i])) && !Mp(r)) throw e = e ? "".concat(e, " ") : "", console.error("".concat(e, " Bad uniform ").concat(i), r), new Error("".concat(e, " Bad uniform ").concat(i))
                         }
                     }(t, this.id, this._uniformSetters), this.gl.useProgram(this.handle);
                     for (const e in t) {
                         const n = t[e],
                             i = this._uniformSetters[e];
                         if (i) {
                             let t = n,
                                 r = !1;
-                            if (t instanceof bp && (t = t.texture), t instanceof Kd)
+                            if (t instanceof vp && (t = t.texture), t instanceof Yd)
                                 if (r = this.uniforms[e] !== n, r) {
                                     void 0 === i.textureIndex && (i.textureIndex = this._textureIndexCounter++);
                                     const n = t,
                                         {
                                             textureIndex: r
                                         } = i;
                                     n.bind(r), t = r, this._textureUniforms[e] = n
                                 } else t = i.textureIndex;
                             else this._textureUniforms[e] && delete this._textureUniforms[e];
-                            (i(t) || r) && Lp(this.uniforms, e, n)
+                            (i(t) || r) && Op(this.uniforms, e, n)
                         }
                     }
                     return this
                 }
                 _areTexturesRenderable() {
                     let t = !0;
                     for (const e in this._textureUniforms) {
@@ -13389,60 +13478,60 @@
                     this.gl.deleteProgram(this.handle)
                 }
                 _getOptionsFromHandle(t) {
                     const e = this.gl.getAttachedShaders(t),
                         n = {};
                     for (const t of e) switch (this.gl.getShaderParameter(this.handle, 35663)) {
                         case 35633:
-                            n.vs = new Np({
+                            n.vs = new Dp({
                                 handle: t
                             });
                             break;
                         case 35632:
-                            n.fs = new Vp({
+                            n.fs = new Np({
                                 handle: t
                             })
                     }
                     return n
                 }
                 _getParameter(t) {
                     return this.gl.getProgramParameter(this.handle, t)
                 }
                 _setId(t) {
                     if (!t) {
                         const t = this._getName();
-                        this.id = Td(t)
+                        this.id = Cd(t)
                     }
                 }
                 _getName() {
                     let t = this.vs.getName() || this.fs.getName();
                     return t = t.replace(/shader/i, ""), t = t ? "".concat(t, "-program") : "program", t
                 }
                 _compileAndLink() {
                     const {
                         gl: t
                     } = this;
-                    if (t.attachShader(this.handle, this.vs.handle), t.attachShader(this.handle, this.fs.handle), Tu.time(4, "linkProgram for ".concat(this._getName()))(), t.linkProgram(this.handle), Tu.timeEnd(4, "linkProgram for ".concat(this._getName()))(), t.debug || Tu.level > 0) {
+                    if (t.attachShader(this.handle, this.vs.handle), t.attachShader(this.handle, this.fs.handle), Su.time(4, "linkProgram for ".concat(this._getName()))(), t.linkProgram(this.handle), Su.timeEnd(4, "linkProgram for ".concat(this._getName()))(), t.debug || Su.level > 0) {
                         if (!t.getProgramParameter(this.handle, 35714)) throw new Error("Error linking: ".concat(t.getProgramInfoLog(this.handle)));
                         if (t.validateProgram(this.handle), !t.getProgramParameter(this.handle, 35715)) throw new Error("Error validating: ".concat(t.getProgramInfoLog(this.handle)))
                     }
                 }
                 _readUniformLocationsFromLinkedProgram() {
                     const {
                         gl: t
                     } = this;
                     this._uniformSetters = {}, this._uniformCount = this._getParameter(35718);
                     for (let e = 0; e < this._uniformCount; e++) {
                         const n = this.gl.getActiveUniform(this.handle, e),
                             {
                                 name: i
-                            } = Mp(n.name);
+                            } = Ap(n.name);
                         let r = t.getUniformLocation(this.handle, i);
-                        if (this._uniformSetters[i] = Ap(t, r, n), n.size > 1)
-                            for (let e = 0; e < n.size; e++) r = t.getUniformLocation(this.handle, "".concat(i, "[").concat(e, "]")), this._uniformSetters["".concat(i, "[").concat(e, "]")] = Ap(t, r, n)
+                        if (this._uniformSetters[i] = Tp(t, r, n), n.size > 1)
+                            for (let e = 0; e < n.size; e++) r = t.getUniformLocation(this.handle, "".concat(i, "[").concat(e, "]")), this._uniformSetters["".concat(i, "[").concat(e, "]")] = Tp(t, r, n)
                     }
                     this._textureIndexCounter = 0
                 }
                 getActiveUniforms(t, e) {
                     return this.gl2.getActiveUniforms(this.handle, t, e)
                 }
                 getUniformBlockIndex(t) {
@@ -13451,17 +13540,17 @@
                 getActiveUniformBlockParameter(t, e) {
                     return this.gl2.getActiveUniformBlockParameter(this.handle, t, e)
                 }
                 uniformBlockBinding(t, e) {
                     this.gl2.uniformBlockBinding(this.handle, t, e)
                 }
             }
-            class nf {
+            class ef {
                 static getDefaultProgramManager(t) {
-                    return t.luma = t.luma || {}, t.luma.defaultProgramManager = t.luma.defaultProgramManager || new nf(t), t.luma.defaultProgramManager
+                    return t.luma = t.luma || {}, t.luma.defaultProgramManager = t.luma.defaultProgramManager || new ef(t), t.luma.defaultProgramManager
                 }
                 constructor(t) {
                     this.gl = t, this._programCache = {}, this._getUniforms = {}, this._registeredModules = {}, this._hookFunctions = [], this._defaultModules = [], this._hashes = {}, this._hashCounter = 0, this.stateHash = 0, this._useCounts = {}
                 }
                 addDefaultModule(t) {
                     this._defaultModules.find((e => e.name === t.name)) || this._defaultModules.push(t), this.stateHash++
                 }
@@ -13489,39 +13578,39 @@
                     for (const t of f) m.push(this._getHash(t)), m.push(this._getHash(r[t]));
                     const v = "".concat(c, "/").concat(h, "D").concat(g.join("/"), "M").concat(u.join("/"), "I").concat(m.join("/"), "V").concat(d.join("/"), "H").concat(this.stateHash, "B").concat(o).concat(a ? "T" : "");
                     if (!this._programCache[v]) {
                         const t = function(t, e) {
                             const {
                                 vs: n,
                                 fs: i
-                            } = e, r = qh(e.modules || []);
+                            } = e, r = Hh(e.modules || []);
                             return {
                                 gl: t,
-                                vs: Su(t, Object.assign({}, e, {
+                                vs: Eu(t, Object.assign({}, e, {
                                     source: n,
-                                    type: Nh,
+                                    type: Bh,
                                     modules: r
                                 })),
-                                fs: Su(t, Object.assign({}, e, {
+                                fs: Eu(t, Object.assign({}, e, {
                                     source: i,
-                                    type: Vh,
+                                    type: Dh,
                                     modules: r
                                 })),
-                                getUniforms: Cu(r)
+                                getUniforms: Pu(r)
                             }
                         }(this.gl, {
                             vs: e,
                             fs: n,
                             modules: l,
                             inject: r,
                             defines: i,
                             hookFunctions: this._hookFunctions,
                             transpileToGLSL100: a
                         });
-                        this._programCache[v] = new ef(this.gl, {
+                        this._programCache[v] = new tf(this.gl, {
                             hash: v,
                             vs: t.vs,
                             fs: t.fs,
                             varyings: s,
                             bufferMode: o
                         }), this._getUniforms[v] = t.getUniforms || (t => {}), this._useCounts[v] = 0
                     }
@@ -13551,53 +13640,53 @@
                         const s = t[r],
                             o = s.name;
                         n[o] || (e[i++] = s, n[o] = !0)
                     }
                     return e.length = i, e
                 }
             }
-            const rf = "#define SMOOTH_EDGE_RADIUS 0.5",
-                sf = {
+            const nf = "#define SMOOTH_EDGE_RADIUS 0.5",
+                rf = {
                     name: "geometry",
-                    vs: "\n".concat(rf, "\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n"),
-                    fs: "\n".concat(rf, "\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n")
+                    vs: "\n".concat(nf, "\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n"),
+                    fs: "\n".concat(nf, "\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n")
                 },
-                of = Object.keys(Lh).map((t => "const int COORDINATE_SYSTEM_".concat(t, " = ").concat(Lh[t], ";"))).join(""),
-                af = Object.keys(Rh).map((t => "const int PROJECTION_MODE_".concat(t, " = ").concat(Rh[t], ";"))).join(""),
-                lf = Object.keys(Ih).map((t => "const int UNIT_".concat(t.toUpperCase(), " = ").concat(Ih[t], ";"))).join(""),
-                cf = "".concat(of, "\n").concat(af, "\n").concat(lf, "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size_at_latitude(float lat) {\n  float y = clamp(lat, -89.9, 89.9);\n  return 1.0 / cos(radians(y));\n}\n\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      return project_size_at_latitude(geometry.worldPosition.y);\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n\nfloat project_size_at_latitude(float meters, float lat) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size_at_latitude(position_world.z, position_world.y),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n");
+                sf = Object.keys(Th).map((t => "const int COORDINATE_SYSTEM_".concat(t, " = ").concat(Th[t], ";"))).join(""),
+                of = Object.keys(Ah).map((t => "const int PROJECTION_MODE_".concat(t, " = ").concat(Ah[t], ";"))).join(""),
+                af = Object.keys(Mh).map((t => "const int UNIT_".concat(t.toUpperCase(), " = ").concat(Mh[t], ";"))).join(""),
+                lf = "".concat(sf, "\n").concat(of, "\n").concat(af, '\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0; // meters\nconst float GLOBE_RADIUS = 256.0;\n\n// returns an adjustment factor for uCommonUnitsPerMeter\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n\n    // uCommonUnitsPerMeter in low-zoom Web Mercator is non-linear\n    // Adjust by 1 / cos(latitude)\n    // If geometry.position (vertex in common space) is populated, use it\n    // Otherwise use geometry.worldPosition (anchor in world space)\n    \n    if (geometry.position.w == 0.0) {\n      float y = clamp(geometry.worldPosition.y, -89.9, 89.9);\n      return 1.0 / cos(radians(y));\n    }\n\n    // latitude from common y: 2.0 * (atan(exp(y / TILE_SIZE * 2.0 * PI - PI)) - PI / 4.0)\n    // Taylor series of 1 / cos(latitude)\n    // Max error < 0.003\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n//\n// Scaling offsets - scales meters to "world distance"\n// Note the scalar version of project_size is for scaling the z component only\n//\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\n\n// Get rotation matrix that aligns the z axis with the given up vector\n// Find 3 unit vectors ux, uy, uz that are perpendicular to each other and uz == up\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  // Tangent on XY plane\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\n\n//\n// Projecting normal - transform deltas from current coordinate system to\n// normals in the worldspace\n//\nvec3 project_normal(vec3 vector) {\n  // Apply model matrix\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\n\n//\n// Projecting positions - non-linear projection: lnglats => unit tile [0-1, 0-1]\n//\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\n\n//\n// Projects positions (defined by project_uCoordinateSystem) to common space (defined by project_uProjectionMode)\n//\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n\n  // Work around for a Mac+NVIDIA bug https://github.com/visgl/deck.gl/issues/4145\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size(position_world.z),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        // Too far from the projection center for offset mode to be accurate\n        // Only use high parts\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    // Subtract high part of 64 bit value. Convert remainder to float32, preserving precision.\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n\n  // Translation is already added to the high parts\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\n\n//\n// Projects from common space coordinates to clip space.\n// Uses project_uViewProjectionMatrix\n//\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\n\n// Returns a clip space offset that corresponds to a given number of screen pixels\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  // UNIT_PIXELS\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n');
 
-            function hf(t, e) {
+            function cf(t, e) {
                 if (t === e) return !0;
                 if (Array.isArray(t)) {
                     const n = t.length;
                     if (!e || e.length !== n) return !1;
                     for (let i = 0; i < n; i++)
                         if (t[i] !== e[i]) return !1;
                     return !0
                 }
                 return !1
             }
 
-            function uf(t) {
+            function hf(t) {
                 let e, n = {};
                 return i => {
                     for (const r in i)
-                        if (!hf(i[r], n[r])) {
+                        if (!cf(i[r], n[r])) {
                             e = t(i), n = i;
                             break
                         } return e
                 }
             }
-            const df = [0, 0, 0, 0],
-                pf = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
-                ff = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
+            const uf = [0, 0, 0, 0],
+                df = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
+                pf = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
+                ff = [0, 0, 0],
                 gf = [0, 0, 0],
-                mf = [0, 0, 0],
-                vf = uf((function({
+                mf = hf((function({
                     viewport: t,
                     devicePixelRatio: e,
                     coordinateSystem: n,
                     coordinateOrigin: i
                 }) {
                     const {
                         projectionCenter: r,
@@ -13610,152 +13699,152 @@
                         const {
                             viewMatrixUncentered: i,
                             projectionMatrix: r
                         } = t;
                         let {
                             viewMatrix: s,
                             viewProjectionMatrix: o
-                        } = t, a = df, l = df, c = t.cameraPosition;
+                        } = t, a = uf, l = uf, c = t.cameraPosition;
                         const {
                             geospatialOrigin: h,
                             shaderCoordinateOrigin: u,
                             offsetMode: d
-                        } = bf(t, e, n);
-                        return d && (l = t.projectPosition(h || u), c = [c[0] - l[0], c[1] - l[1], c[2] - l[2]], l[3] = 1, a = Qc([], l, o), s = i || s, o = Vc([], r, s), o = Vc([], o, pf)), {
+                        } = vf(t, e, n);
+                        return d && (l = t.projectPosition(h || u), c = [c[0] - l[0], c[1] - l[1], c[2] - l[2]], l[3] = 1, a = qc([], l, o), s = i || s, o = zc([], r, s), o = zc([], o, df)), {
                             viewMatrix: s,
                             viewProjectionMatrix: o,
                             projectionCenter: a,
                             originCommon: l,
                             cameraPosCommon: c,
                             shaderCoordinateOrigin: u,
                             geospatialOrigin: h
                         }
-                    }(t, n, i), h = t.getDistanceScales(), u = [t.width * e, t.height * e], d = Qc([], [0, 0, -t.focalDistance, 1], t.projectionMatrix)[3] || 1, p = {
+                    }(t, n, i), h = t.getDistanceScales(), u = [t.width * e, t.height * e], d = qc([], [0, 0, -t.focalDistance, 1], t.projectionMatrix)[3] || 1, p = {
                         project_uCoordinateSystem: n,
                         project_uProjectionMode: t.projectionMode,
                         project_uCoordinateOrigin: l,
                         project_uCommonOrigin: o.slice(0, 3),
                         project_uCenter: r,
                         project_uPseudoMeters: Boolean(t._pseudoMeters),
                         project_uViewportSize: u,
                         project_uDevicePixelRatio: e,
                         project_uFocalDistance: d,
                         project_uCommonUnitsPerMeter: h.unitsPerMeter,
                         project_uCommonUnitsPerWorldUnit: h.unitsPerMeter,
-                        project_uCommonUnitsPerWorldUnit2: gf,
+                        project_uCommonUnitsPerWorldUnit2: ff,
                         project_uScale: t.scale,
                         project_uWrapLongitude: !1,
                         project_uViewProjectionMatrix: s,
-                        project_uModelMatrix: ff,
+                        project_uModelMatrix: pf,
                         project_uCameraPosition: a
                     };
                     if (c) {
                         const e = t.getDistanceScales(c);
                         switch (n) {
-                            case Lh.METER_OFFSETS:
+                            case Th.METER_OFFSETS:
                                 p.project_uCommonUnitsPerWorldUnit = e.unitsPerMeter, p.project_uCommonUnitsPerWorldUnit2 = e.unitsPerMeter2;
                                 break;
-                            case Lh.LNGLAT:
-                            case Lh.LNGLAT_OFFSETS:
+                            case Th.LNGLAT:
+                            case Th.LNGLAT_OFFSETS:
                                 t._pseudoMeters || (p.project_uCommonUnitsPerMeter = e.unitsPerMeter), p.project_uCommonUnitsPerWorldUnit = e.unitsPerDegree, p.project_uCommonUnitsPerWorldUnit2 = e.unitsPerDegree2;
                                 break;
-                            case Lh.CARTESIAN:
+                            case Th.CARTESIAN:
                                 p.project_uCommonUnitsPerWorldUnit = [1, 1, e.unitsPerMeter[2]], p.project_uCommonUnitsPerWorldUnit2 = [0, 0, e.unitsPerMeter2[2]]
                         }
                     }
                     return p
                 }));
 
-            function bf(t, e, n = mf) {
+            function vf(t, e, n = gf) {
                 n.length < 3 && (n = [n[0], n[1], 0]);
                 let i, r = n,
                     s = !0;
-                switch (i = e === Lh.LNGLAT_OFFSETS || e === Lh.METER_OFFSETS ? n : t.isGeospatial ? [Math.fround(t.longitude), Math.fround(t.latitude), 0] : null, t.projectionMode) {
-                    case Rh.WEB_MERCATOR:
-                        e !== Lh.LNGLAT && e !== Lh.CARTESIAN || (i = [0, 0, 0], s = !1);
+                switch (i = e === Th.LNGLAT_OFFSETS || e === Th.METER_OFFSETS ? n : t.isGeospatial ? [Math.fround(t.longitude), Math.fround(t.latitude), 0] : null, t.projectionMode) {
+                    case Ah.WEB_MERCATOR:
+                        e !== Th.LNGLAT && e !== Th.CARTESIAN || (i = [0, 0, 0], s = !1);
                         break;
-                    case Rh.WEB_MERCATOR_AUTO_OFFSET:
-                        e === Lh.LNGLAT ? r = i : e === Lh.CARTESIAN && (r = [Math.fround(t.center[0]), Math.fround(t.center[1]), 0], i = t.unprojectPosition(r), r[0] -= n[0], r[1] -= n[1], r[2] -= n[2]);
+                    case Ah.WEB_MERCATOR_AUTO_OFFSET:
+                        e === Th.LNGLAT ? r = i : e === Th.CARTESIAN && (r = [Math.fround(t.center[0]), Math.fround(t.center[1]), 0], i = t.unprojectPosition(r), r[0] -= n[0], r[1] -= n[1], r[2] -= n[2]);
                         break;
-                    case Rh.IDENTITY:
+                    case Ah.IDENTITY:
                         r = t.position.map(Math.fround), r[2] = r[2] || 0;
                         break;
-                    case Rh.GLOBE:
+                    case Ah.GLOBE:
                         s = !1, i = null;
                         break;
                     default:
                         s = !1
                 }
                 return {
                     geospatialOrigin: i,
                     shaderCoordinateOrigin: r,
                     offsetMode: s
                 }
             }
-            const yf = {},
-                _f = {
+            const bf = {},
+                yf = {
                     name: "project",
                     dependencies: [{
                         name: "fp32",
                         vs: "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n",
                         fs: null
-                    }, sf],
-                    vs: cf,
-                    getUniforms: function(t = yf) {
+                    }, rf],
+                    vs: lf,
+                    getUniforms: function(t = bf) {
                         return "viewport" in t ? function({
                             viewport: t,
                             devicePixelRatio: e = 1,
                             modelMatrix: n = null,
-                            coordinateSystem: i = Lh.DEFAULT,
-                            coordinateOrigin: r = mf,
+                            coordinateSystem: i = Th.DEFAULT,
+                            coordinateOrigin: r = gf,
                             autoWrapLongitude: s = !1
                         }) {
-                            i === Lh.DEFAULT && (i = t.isGeospatial ? Lh.LNGLAT : Lh.CARTESIAN);
-                            const o = vf({
+                            i === Th.DEFAULT && (i = t.isGeospatial ? Th.LNGLAT : Th.CARTESIAN);
+                            const o = mf({
                                 viewport: t,
                                 devicePixelRatio: e,
                                 coordinateSystem: i,
                                 coordinateOrigin: r
                             });
-                            return o.project_uWrapLongitude = s, o.project_uModelMatrix = n || ff, o
+                            return o.project_uWrapLongitude = s, o.project_uModelMatrix = n || pf, o
                         }(t) : {}
                     }
                 },
-                xf = [_f],
-                wf = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
+                _f = [yf],
+                xf = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
 
-            function Ef(t) {
-                const e = nf.getDefaultProgramManager(t);
-                for (const t of xf) e.addDefaultModule(t);
-                for (const t of wf) e.addShaderHook(t);
+            function wf(t) {
+                const e = ef.getDefaultProgramManager(t);
+                for (const t of _f) e.addDefaultModule(t);
+                for (const t of xf) e.addShaderHook(t);
                 return e
             }
-            class Pf {
+            class Ef {
                 constructor(t, {
                     deck: e,
                     stats: n,
                     viewport: i,
                     timeline: r
                 } = {}) {
                     wo(this, "layers", void 0), wo(this, "context", void 0), wo(this, "resourceManager", void 0), wo(this, "_lastRenderedLayers", []), wo(this, "_needsRedraw", !1), wo(this, "_needsUpdate", !1), wo(this, "_nextLayers", null), wo(this, "_debug", !1), wo(this, "activateViewport", (t => {
-                        sa("layerManager.activateViewport", this, t), t && (this.context.viewport = t)
-                    })), this.layers = [], this.resourceManager = new rc({
+                        na("layerManager.activateViewport", this, t), t && (this.context.viewport = t)
+                    })), this.layers = [], this.resourceManager = new ec({
                         gl: t,
                         protocol: "deck://"
                     }), this.context = {
                         mousePosition: null,
                         userData: {},
                         layerManager: this,
                         gl: t,
                         deck: e,
-                        programManager: t && Ef(t),
-                        stats: n || new da({
+                        programManager: t && wf(t),
+                        stats: n || new ca({
                             id: "deck.gl"
                         }),
-                        viewport: i || new Dh({
+                        viewport: i || new zh({
                             id: "DEFAULT-INITIAL-VIEWPORT"
                         }),
                         timeline: r || new So,
                         resourceManager: this.resourceManager,
                         onError: void 0
                     }, Object.seal(this)
                 }
@@ -13788,43 +13877,43 @@
                 } = {}) {
                     return t ? this.layers.filter((e => t.find((t => 0 === e.id.indexOf(t))))) : this.layers
                 }
                 setProps(t) {
                     "debug" in t && (this._debug = t.debug), "userData" in t && (this.context.userData = t.userData), "layers" in t && (this._nextLayers = t.layers), "onError" in t && (this.context.onError = t.onError)
                 }
                 setLayers(t, e) {
-                    sa("layerManager.setLayers", this, e, t), this._lastRenderedLayers = t;
-                    const n = oa(t, Boolean);
+                    na("layerManager.setLayers", this, e, t), this._lastRenderedLayers = t;
+                    const n = ia(t, Boolean);
                     for (const t of n) t.context = this.context;
                     this._updateLayers(this.layers, n)
                 }
                 updateLayers() {
                     const t = this.needsUpdate();
                     t && (this.setNeedsRedraw("updating layers: ".concat(t)), this.setLayers(this._nextLayers || this._lastRenderedLayers, t)), this._nextLayers = null
                 }
                 _handleError(t, e, n) {
                     n.raiseError(e, "".concat(t, " of ").concat(n))
                 }
                 _updateLayers(t, e) {
                     const n = {};
-                    for (const e of t) n[e.id] ? na.warn("Multiple old layers with same id ".concat(e.id))() : n[e.id] = e;
+                    for (const e of t) n[e.id] ? ta.warn("Multiple old layers with same id ".concat(e.id))() : n[e.id] = e;
                     const i = [];
                     this._updateSublayersRecursively(e, n, i), this._finalizeOldLayers(n);
                     let r = !1;
                     for (const t of i)
                         if (t.hasUniformTransition()) {
                             r = "Uniform transition in ".concat(t);
                             break
                         } this._needsUpdate = r, this.layers = i
                 }
                 _updateSublayersRecursively(t, e, n) {
                     for (const i of t) {
                         i.context = this.context;
                         const t = e[i.id];
-                        null === t && na.warn("Multiple new layers with same id ".concat(i.id))(), e[i.id] = null;
+                        null === t && ta.warn("Multiple new layers with same id ".concat(i.id))(), e[i.id] = null;
                         let r = null;
                         try {
                             this._debug && t !== i && i.validateProps(), t ? (this._transferLayerState(t, i), this._updateLayer(i)) : this._initializeLayer(i), n.push(i), r = i.isComposite ? i.getSubLayers() : null
                         } catch (t) {
                             this._handleError("matching", t, i)
                         }
                         r && this._updateSublayersRecursively(r, e, n)
@@ -13859,37 +13948,25 @@
                         t._finalize(), t.lifecycle = "Finalized! Awaiting garbage collection"
                     } catch (e) {
                         this._handleError("finalization", e, t)
                     }
                 }
             }
 
-            function Sf(t, e, n) {
+            function Pf(t, e) {
                 if (t === e) return !0;
-                if (!n || !t || !e) return !1;
-                if (Array.isArray(t)) {
-                    if (!Array.isArray(e) || t.length !== e.length) return !1;
-                    for (let i = 0; i < t.length; i++)
-                        if (!Sf(t[i], e[i], n - 1)) return !1;
-                    return !0
-                }
-                if (Array.isArray(e)) return !1;
-                if ("object" == typeof t && "object" == typeof e) {
-                    const i = Object.keys(t),
-                        r = Object.keys(e);
-                    if (i.length !== r.length) return !1;
-                    for (const r of i) {
-                        if (!e.hasOwnProperty(r)) return !1;
-                        if (!Sf(t[r], e[r], n - 1)) return !1
-                    }
-                    return !0
+                if (!t || !e) return !1;
+                for (const n in t) {
+                    const i = t[n],
+                        r = e[n];
+                    if (!(i === r || Array.isArray(i) && Array.isArray(r) && Pf(i, r))) return !1
                 }
-                return !1
+                return !0
             }
-            class Cf {
+            class Sf {
                 constructor(t) {
                     wo(this, "width", void 0), wo(this, "height", void 0), wo(this, "views", void 0), wo(this, "viewState", void 0), wo(this, "controllers", void 0), wo(this, "timeline", void 0), wo(this, "_viewports", void 0), wo(this, "_viewportMap", void 0), wo(this, "_isUpdating", void 0), wo(this, "_needsRedraw", void 0), wo(this, "_needsUpdate", void 0), wo(this, "_eventManager", void 0), wo(this, "_eventCallbacks", void 0), this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = t.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = t.eventManager, this._eventCallbacks = {
                         onViewStateChange: t.onViewStateChange,
                         onInteractionStateChange: t.onInteractionStateChange
                     }, Object.seal(this), this.setProps(t)
                 }
                 finalize() {
@@ -13955,18 +14032,18 @@
                 _update() {
                     this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1
                 }
                 _setSize(t, e) {
                     t === this.width && e === this.height || (this.width = t, this.height = e, this.setNeedsUpdate("Size changed"))
                 }
                 _setViews(t) {
-                    t = oa(t, Boolean), this._diffViews(t, this.views) && this.setNeedsUpdate("views changed"), this.views = t
+                    t = ia(t, Boolean), this._diffViews(t, this.views) && this.setNeedsUpdate("views changed"), this.views = t
                 }
                 _setViewState(t) {
-                    t ? (!Sf(t, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = t) : na.warn("missing `viewState` or `initialViewState`")()
+                    t ? (!Pf(t, this.viewState) && this.setNeedsUpdate("viewState changed"), this.viewState = t) : ta.warn("missing `viewState` or `initialViewState`")()
                 }
                 _onViewStateChange(t, e) {
                     this._eventCallbacks.onViewStateChange && this._eventCallbacks.onViewStateChange({
                         ...e,
                         viewId: t
                     })
                 }
@@ -13984,15 +14061,15 @@
                                 height: this.height
                             })
                         }
                     })
                 }
                 _updateController(t, e, n, i) {
                     const r = t.controller;
-                    if (r && n) {
+                    if (r) {
                         const s = {
                             ...e,
                             ...r,
                             id: t.id,
                             x: n.x,
                             y: n.y,
                             width: n.width,
@@ -14014,15 +14091,15 @@
                             o = r.makeViewport({
                                 viewState: s,
                                 width: this.width,
                                 height: this.height
                             });
                         let a = e[r.id];
                         const l = Boolean(r.controller);
-                        l && !a && (n = !0), !n && l || !a || (a.finalize(), a = null), this.controllers[r.id] = this._updateController(r, s, o, a), o && this._viewports.unshift(o)
+                        l && !a && (n = !0), !n && l || !a || (a.finalize(), a = null), this.controllers[r.id] = this._updateController(r, s, o, a), this._viewports.unshift(o)
                     }
                     for (const t in e) {
                         const n = e[t];
                         n && !this.controllers[t] && n.finalize()
                     }
                     this._buildViewportMap()
                 }
@@ -14031,85 +14108,85 @@
                         t.id && (this._viewportMap[t.id] = this._viewportMap[t.id] || t)
                     }))
                 }
                 _diffViews(t, e) {
                     return t.length !== e.length || t.some(((n, i) => !t[i].equals(e[i])))
                 }
             }
-            const Tf = /([0-9]+\.?[0-9]*)(%|px)/;
+            const Cf = /([0-9]+\.?[0-9]*)(%|px)/;
 
-            function Af(t) {
+            function Tf(t) {
                 switch (typeof t) {
                     case "number":
                         return {
                             position: t, relative: !1
                         };
                     case "string":
-                        const e = Tf.exec(t);
+                        const e = Cf.exec(t);
                         if (e && e.length >= 3) {
                             const t = "%" === e[2],
                                 n = parseFloat(e[1]);
                             return {
                                 position: t ? n / 100 : n,
                                 relative: t
                             }
                         }
                     default:
                         throw new Error("Could not parse position string ".concat(t))
                 }
             }
 
-            function Mf(t, e) {
+            function Af(t, e) {
                 return t.relative ? Math.round(t.position * e) : t.position
             }
 
-            function Of(t, e) {
+            function Mf(t, e) {
                 if (!t) throw new Error(e || "deck.gl: assertion failed.")
             }
-            class Lf {
+            class Of {
                 constructor(t) {
                     wo(this, "id", void 0), wo(this, "viewportInstance", void 0), wo(this, "_x", void 0), wo(this, "_y", void 0), wo(this, "_width", void 0), wo(this, "_height", void 0), wo(this, "_padding", void 0), wo(this, "props", void 0);
                     const {
                         id: e,
                         x: n = 0,
                         y: i = 0,
                         width: r = "100%",
                         height: s = "100%",
                         padding: o = null,
                         viewportInstance: a
                     } = t || {};
-                    Of(!a || a instanceof Dh), this.viewportInstance = a, this.id = e || this.constructor.displayName || "view", this.props = {
+                    Mf(!a || a instanceof zh), this.viewportInstance = a, this.id = e || this.constructor.displayName || "view", this.props = {
                         ...t,
                         id: this.id
-                    }, this._x = Af(n), this._y = Af(i), this._width = Af(r), this._height = Af(s), this._padding = o && {
-                        left: Af(o.left || 0),
-                        right: Af(o.right || 0),
-                        top: Af(o.top || 0),
-                        bottom: Af(o.bottom || 0)
+                    }, this._x = Tf(n), this._y = Tf(i), this._width = Tf(r), this._height = Tf(s), this._padding = o && {
+                        left: Tf(o.left || 0),
+                        right: Tf(o.right || 0),
+                        top: Tf(o.top || 0),
+                        bottom: Tf(o.bottom || 0)
                     }, this.equals = this.equals.bind(this), Object.seal(this)
                 }
                 equals(t) {
-                    return this === t || (this.viewportInstance ? !!t.viewportInstance && this.viewportInstance.equals(t.viewportInstance) : this.ViewportType === t.ViewportType && Sf(this.props, t.props, 2))
+                    return this === t || (this.viewportInstance ? !!t.viewportInstance && this.viewportInstance.equals(t.viewportInstance) : this.ViewportType === t.ViewportType && Pf(this.props, t.props))
                 }
                 makeViewport({
                     width: t,
                     height: e,
                     viewState: n
                 }) {
                     if (this.viewportInstance) return this.viewportInstance;
                     n = this.filterViewState(n);
                     const i = this.getDimensions({
                         width: t,
                         height: e
                     });
-                    return i.height && i.width ? new this.ViewportType({
+                    return new this.ViewportType({
                         ...n,
                         ...this.props,
                         ...i
-                    }) : null
+                    })
                 }
                 getViewStateId() {
                     const {
                         viewState: t
                     } = this.props;
                     return "string" == typeof t ? t : (null == t ? void 0 : t.id) || this.id
                 }
@@ -14125,151 +14202,140 @@
                     return t
                 }
                 getDimensions({
                     width: t,
                     height: e
                 }) {
                     const n = {
-                        x: Mf(this._x, t),
-                        y: Mf(this._y, e),
-                        width: Mf(this._width, t),
-                        height: Mf(this._height, e)
+                        x: Af(this._x, t),
+                        y: Af(this._y, e),
+                        width: Af(this._width, t),
+                        height: Af(this._height, e)
                     };
                     return this._padding && (n.padding = {
-                        left: Mf(this._padding.left, t),
-                        top: Mf(this._padding.top, e),
-                        right: Mf(this._padding.right, t),
-                        bottom: Mf(this._padding.bottom, e)
+                        left: Af(this._padding.left, t),
+                        top: Af(this._padding.top, e),
+                        right: Af(this._padding.right, t),
+                        bottom: Af(this._padding.bottom, e)
                     }), n
                 }
                 get controller() {
                     const t = this.props.controller;
                     return t ? !0 === t ? {
                         type: this.ControllerType
                     } : "function" == typeof t ? {
                         type: t
                     } : {
                         type: this.ControllerType,
                         ...t
                     } : null
                 }
             }
-            class Rf extends Dh {
+            const Lf = Math.PI / 180;
+
+            function kf(t) {
+                return 512 / 4003e4 / Math.cos(t * Lf)
+            }
+            class Rf extends zh {
                 constructor(t = {}) {
                     const {
                         latitude: e = 0,
                         longitude: n = 0,
                         zoom: i = 0,
                         pitch: r = 0,
                         bearing: s = 0,
                         nearZMultiplier: o = .1,
                         farZMultiplier: a = 1.01,
                         orthographic: l = !1,
                         projectionMatrix: c,
                         repeat: h = !1,
                         worldOffset: u = 0,
-                        position: d,
-                        padding: p,
-                        legacyMeterSizes: f = !1
+                        legacyMeterSizes: d = !1
                     } = t;
                     let {
-                        width: g,
-                        height: m,
-                        altitude: v = 1.5
-                    } = t;
-                    const b = Math.pow(2, i);
-                    let y;
-                    g = g || 1, m = m || 1;
-                    let _ = null;
-                    if (c) v = c[5] / 2, y = Sh(v);
-                    else {
-                        let n;
-                        if (t.fovy ? (y = t.fovy, v = Ch(y)) : y = Sh(v), p) {
-                            const {
-                                top: t = 0,
-                                bottom: e = 0
-                            } = p;
-                            n = [0, cc((t + m - e) / 2, 0, m) - m / 2]
+                        width: p,
+                        height: f,
+                        altitude: g = 1.5
+                    } = t;
+                    const m = Math.pow(2, i);
+                    let v;
+                    p = p || 1, f = f || 1;
+                    let b = null;
+                    c ? (g = c[5] / 2, v = _h(g)) : (t.fovy ? (v = t.fovy, g = xh(v)) : v = _h(g), b = function(t) {
+                        const {
+                            width: e,
+                            height: n,
+                            altitude: i,
+                            pitch: r = 0,
+                            offset: s,
+                            center: o,
+                            scale: a,
+                            nearZMultiplier: l = 1,
+                            farZMultiplier: c = 1
+                        } = t;
+                        let {
+                            fovy: h = _h(gh)
+                        } = t;
+                        void 0 !== i && (h = _h(i));
+                        const u = h * hh,
+                            d = r * hh,
+                            p = xh(h);
+                        let f = p;
+                        o && (f += o[2] * a / Math.cos(d) / n);
+                        const g = u * (.5 + (s ? s[1] : 0) / n),
+                            m = Math.sin(g) * f / Math.sin(sh(Math.PI / 2 - d - g, .01, Math.PI - .01)),
+                            v = Math.sin(d) * m + f,
+                            b = 10 * f;
+                        return {
+                            fov: u,
+                            aspect: e / n,
+                            focalDistance: p,
+                            near: l,
+                            far: Math.min(v * c, b)
                         }
-                        _ = function(t) {
-                            const {
-                                width: e,
-                                height: n,
-                                altitude: i,
-                                pitch: r = 0,
-                                offset: s,
-                                center: o,
-                                scale: a,
-                                nearZMultiplier: l = 1,
-                                farZMultiplier: c = 1
-                            } = t;
-                            let {
-                                fovy: h = Sh(yh)
-                            } = t;
-                            void 0 !== i && (h = Sh(i));
-                            const u = h * fh,
-                                d = r * fh,
-                                p = Ch(h);
-                            let f = p;
-                            o && (f += o[2] * a / Math.cos(d) / n);
-                            const g = u * (.5 + (s ? s[1] : 0) / n),
-                                m = Math.sin(g) * f / Math.sin(ch(Math.PI / 2 - d - g, .01, Math.PI - .01)),
-                                v = Math.sin(d) * m + f,
-                                b = 10 * f;
-                            return {
-                                fov: u,
-                                aspect: e / n,
-                                focalDistance: p,
-                                near: l,
-                                far: Math.min(v * c, b)
-                            }
-                        }({
-                            width: g,
-                            height: m,
-                            scale: b,
-                            center: d && [0, 0, d[2] * wh(e)],
-                            offset: n,
-                            pitch: r,
-                            fovy: y,
-                            nearZMultiplier: o,
-                            farZMultiplier: a
-                        })
-                    }
-                    let x = function(t) {
+                    }({
+                        width: p,
+                        height: f,
+                        pitch: r,
+                        fovy: v,
+                        nearZMultiplier: o,
+                        farZMultiplier: a
+                    }));
+                    let y = function(t) {
                         const {
                             height: e,
                             pitch: n,
                             bearing: i,
                             altitude: r,
                             scale: s,
                             center: o
                         } = t, a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
-                        Uc(a, a, [0, 0, -r]), Wc(a, a, -n * fh), Hc(a, a, i * fh);
+                        Bc(a, a, [0, 0, -r]), Nc(a, a, -n * hh), Vc(a, a, i * hh);
                         const l = s / e;
                         var c, h;
-                        return Gc(a, a, [l, l, l]), o && Uc(a, a, ((c = [])[0] = -(h = o)[0], c[1] = -h[1], c[2] = -h[2], c)), a
+                        return Dc(a, a, [l, l, l]), o && Bc(a, a, ((c = [])[0] = -(h = o)[0], c[1] = -h[1], c[2] = -h[2], c)), a
                     }({
-                        height: m,
+                        height: f,
                         pitch: r,
                         bearing: s,
-                        scale: b,
-                        altitude: v
+                        scale: m,
+                        altitude: g
                     });
-                    u && (x = (new ih).translate([512 * u, 0, 0]).multiplyLeft(x)), super({
+                    u && (y = (new $c).translate([512 * u, 0, 0]).multiplyLeft(y)), super({
                         ...t,
-                        width: g,
-                        height: m,
-                        viewMatrix: x,
+                        width: p,
+                        height: f,
+                        viewMatrix: y,
                         longitude: n,
                         latitude: e,
                         zoom: i,
-                        ..._,
-                        fovy: y,
-                        focalDistance: v
-                    }), wo(this, "longitude", void 0), wo(this, "latitude", void 0), wo(this, "pitch", void 0), wo(this, "bearing", void 0), wo(this, "altitude", void 0), wo(this, "fovy", void 0), wo(this, "orthographic", void 0), wo(this, "_subViewports", void 0), wo(this, "_pseudoMeters", void 0), this.latitude = e, this.longitude = n, this.zoom = i, this.pitch = r, this.bearing = s, this.altitude = v, this.fovy = y, this.orthographic = l, this._subViewports = h ? [] : null, this._pseudoMeters = f, Object.freeze(this)
+                        ...b,
+                        fovy: v,
+                        focalDistance: g
+                    }), wo(this, "longitude", void 0), wo(this, "latitude", void 0), wo(this, "pitch", void 0), wo(this, "bearing", void 0), wo(this, "altitude", void 0), wo(this, "fovy", void 0), wo(this, "orthographic", void 0), wo(this, "_subViewports", void 0), wo(this, "_pseudoMeters", void 0), this.latitude = e, this.longitude = n, this.zoom = i, this.pitch = r, this.bearing = s, this.altitude = g, this.fovy = v, this.orthographic = l, this._subViewports = h ? [] : null, this._pseudoMeters = d, Object.freeze(this)
                 }
                 get subViewports() {
                     if (this._subViewports && !this._subViewports.length) {
                         const t = this.getBounds(),
                             e = Math.floor((t[0] + 180) / 360),
                             n = Math.ceil((t[2] - 180) / 360);
                         for (let t = e; t <= n; t++) {
@@ -14281,28 +14347,28 @@
                         }
                     }
                     return this._subViewports
                 }
                 projectPosition(t) {
                     if (this._pseudoMeters) return super.projectPosition(t);
                     const [e, n] = this.projectFlat(t);
-                    return [e, n, (t[2] || 0) * wh(t[1])]
+                    return [e, n, (t[2] || 0) * kf(t[1])]
                 }
                 unprojectPosition(t) {
                     if (this._pseudoMeters) return super.unprojectPosition(t);
                     const [e, n] = this.unprojectFlat(t);
-                    return [e, n, (t[2] || 0) / wh(n)]
+                    return [e, n, (t[2] || 0) / kf(n)]
                 }
                 addMetersToLngLat(t, e) {
-                    return Ph(t, e)
+                    return yh(t, e)
                 }
                 panByPosition(t, e) {
-                    const n = Ah(e, this.pixelUnprojectionMatrix),
-                        i = qc([], this.projectFlat(t), Xc([], n)),
-                        r = qc([], this.center, i),
+                    const n = Eh(e, this.pixelUnprojectionMatrix),
+                        i = Gc([], this.projectFlat(t), Wc([], n)),
+                        r = Gc([], this.center, i),
                         [s, o] = this.unprojectFlat(r);
                     return {
                         longitude: s,
                         latitude: o
                     }
                 }
                 getBounds(t = {}) {
@@ -14311,58 +14377,27 @@
                             width: n,
                             height: i,
                             unproject: r
                         } = t, s = {
                             targetZ: e
                         }, o = r([0, i], s), a = r([n, i], s);
                         let l, c;
-                        return (t.fovy ? .5 * t.fovy * Mh : Math.atan(.5 / t.altitude)) > (90 - t.pitch) * Mh - .01 ? (l = Oh(t, 0, e), c = Oh(t, n, e)) : (l = r([0, 0], s), c = r([n, 0], s)), [o, a, c, l]
+                        return (t.fovy ? .5 * t.fovy * Sh : Math.atan(.5 / t.altitude)) > (90 - t.pitch) * Sh - .01 ? (l = Ch(t, 0, e), c = Ch(t, n, e)) : (l = r([0, 0], s), c = r([n, 0], s)), [o, a, c, l]
                     }(this, t.z || 0);
                     return [Math.min(e[0][0], e[1][0], e[2][0], e[3][0]), Math.min(e[0][1], e[1][1], e[2][1], e[3][1]), Math.max(e[0][0], e[1][0], e[2][0], e[3][0]), Math.max(e[0][1], e[1][1], e[2][1], e[3][1])]
                 }
                 fitBounds(t, e = {}) {
                     const {
                         width: n,
                         height: i
                     } = this, {
                         longitude: r,
                         latitude: s,
                         zoom: o
-                    } = function(t) {
-                        const {
-                            width: e,
-                            height: n,
-                            bounds: i,
-                            minExtent: r = 0,
-                            maxZoom: s = 24,
-                            offset: o = [0, 0]
-                        } = t, [
-                            [a, l],
-                            [c, h]
-                        ] = i, u = function(t = 0) {
-                            return "number" == typeof t ? {
-                                top: t,
-                                bottom: t,
-                                left: t,
-                                right: t
-                            } : (uh(Number.isFinite(t.top) && Number.isFinite(t.bottom) && Number.isFinite(t.left) && Number.isFinite(t.right)), t)
-                        }(t.padding), d = _h([a, ch(h, -85.051129, bh)]), p = _h([c, ch(l, -85.051129, bh)]), f = [Math.max(Math.abs(p[0] - d[0]), r), Math.max(Math.abs(p[1] - d[1]), r)], g = [e - u.left - u.right - 2 * Math.abs(o[0]), n - u.top - u.bottom - 2 * Math.abs(o[1])];
-                        uh(g[0] > 0 && g[1] > 0);
-                        const m = g[0] / f[0],
-                            v = g[1] / f[1],
-                            b = (u.right - u.left) / 2 / m,
-                            y = (u.top - u.bottom) / 2 / v,
-                            _ = xh([(p[0] + d[0]) / 2 + b, (p[1] + d[1]) / 2 + y]),
-                            x = Math.min(s, hh(Math.abs(Math.min(m, v))));
-                        return uh(Number.isFinite(x)), {
-                            longitude: _[0],
-                            latitude: _[1],
-                            zoom: x
-                        }
-                    }({
+                    } = Ph({
                         width: n,
                         height: i,
                         bounds: t,
                         ...e
                     });
                     return new Rf({
                         width: n,
@@ -14408,17 +14443,17 @@
                             duration: e.duration
                         })
                     }
                     return this.time = this._timeline.getTime(this._handle), this._onUpdate(), null === (t = (e = this.settings).onUpdate) || void 0 === t || t.call(e, this), this._timeline.isFinished(this._handle) && this.end(), !0
                 }
                 _onUpdate() {}
             }
-            const kf = () => {},
-                jf = t => t;
-            class Ff {
+            const jf = () => {},
+                Ff = t => t;
+            class zf {
                 constructor(t) {
                     wo(this, "getControllerState", void 0), wo(this, "props", void 0), wo(this, "propsInTransition", void 0), wo(this, "transition", void 0), wo(this, "onViewStateChange", void 0), wo(this, "onStateChange", void 0), wo(this, "_onTransitionUpdate", (t => {
                         const {
                             time: e,
                             settings: {
                                 interpolator: n,
                                 startProps: i,
@@ -14430,15 +14465,15 @@
                         this.propsInTransition = this.getControllerState({
                             ...this.props,
                             ...l
                         }).getViewportProps(), this.onViewStateChange({
                             viewState: this.propsInTransition,
                             oldViewState: this.props
                         })
-                    })), this.getControllerState = t.getControllerState, this.propsInTransition = null, this.transition = new If(t.timeline), this.onViewStateChange = t.onViewStateChange || kf, this.onStateChange = t.onStateChange || kf
+                    })), this.getControllerState = t.getControllerState, this.propsInTransition = null, this.transition = new If(t.timeline), this.onViewStateChange = t.onViewStateChange || jf, this.onStateChange = t.onStateChange || jf
                 }
                 finalize() {
                     this.transition.cancel()
                 }
                 getViewportInTransition() {
                     return this.propsInTransition
                 }
@@ -14484,15 +14519,15 @@
                         r = e.transitionInterpolator,
                         s = r.getDuration ? r.getDuration(t, e) : e.transitionDuration;
                     if (0 === s) return;
                     const o = r.initializeProps(t, i);
                     this.propsInTransition = {};
                     const a = {
                         duration: s,
-                        easing: e.transitionEasing || jf,
+                        easing: e.transitionEasing || Ff,
                         interpolator: r,
                         interruption: e.transitionInterruption || 1,
                         startProps: o.start,
                         endProps: o.end,
                         onStart: e.onTransitionStart,
                         onUpdate: this._onTransitionUpdate,
                         onInterrupt: this._onTransitionEnd(e.onTransitionInterrupt),
@@ -14509,27 +14544,27 @@
                             isZooming: !1,
                             isPanning: !1,
                             isRotating: !1
                         }), null == t || t(e)
                     }
                 }
             }
-            class zf {
+            class Bf {
                 constructor(t) {
                     wo(this, "_propsToCompare", void 0), wo(this, "_propsToExtract", void 0), wo(this, "_requiredProps", void 0);
                     const {
                         compare: e,
                         extract: n,
                         required: i
                     } = t;
                     this._propsToCompare = e, this._propsToExtract = n || e, this._requiredProps = i
                 }
                 arePropsEqual(t, e) {
                     for (const n of this._propsToCompare)
-                        if (!(n in t) || !(n in e) || !uc(t[n], e[n])) return !1;
+                        if (!(n in t) || !(n in e) || !lc(t[n], e[n])) return !1;
                     return !0
                 }
                 initializeProps(t, e) {
                     const n = {},
                         i = {};
                     for (const r of this._propsToExtract)(r in t || r in e) && (n[r] = t[r], i[r] = e[r]);
                     return this._checkRequiredProps(n), this._checkRequiredProps(i), {
@@ -14539,30 +14574,30 @@
                 }
                 getDuration(t, e) {
                     return e.transitionDuration
                 }
                 _checkRequiredProps(t) {
                     this._requiredProps && this._requiredProps.forEach((e => {
                         const n = t[e];
-                        Of(Number.isFinite(n) || Array.isArray(n), "".concat(e, " is required for transition"))
+                        Mf(Number.isFinite(n) || Array.isArray(n), "".concat(e, " is required for transition"))
                     }))
                 }
             }
-            const Bf = ["longitude", "latitude", "zoom", "bearing", "pitch"],
-                Df = ["longitude", "latitude", "zoom"];
-            class Nf extends zf {
+            const Df = ["longitude", "latitude", "zoom", "bearing", "pitch"],
+                Nf = ["longitude", "latitude", "zoom"];
+            class Vf extends Bf {
                 constructor(t = {}) {
                     const e = Array.isArray(t) ? t : t.transitionProps,
                         n = Array.isArray(t) ? {} : t;
                     n.transitionProps = Array.isArray(e) ? {
                         compare: e,
                         required: e
                     } : e || {
-                        compare: Bf,
-                        required: Df
+                        compare: Df,
+                        required: Nf
                     }, super(n.transitionProps), wo(this, "opts", void 0), this.opts = n
                 }
                 initializeProps(t, e) {
                     const n = super.initializeProps(t, e),
                         {
                             makeViewport: i,
                             around: r
@@ -14578,41 +14613,41 @@
                             height: e.height
                         })
                     }
                     return n
                 }
                 interpolateProps(t, e, n) {
                     const i = {};
-                    for (const r of this._propsToExtract) i[r] = hc(t[r] || 0, e[r] || 0, n);
+                    for (const r of this._propsToExtract) i[r] = ac(t[r] || 0, e[r] || 0, n);
                     if (e.aroundPosition && this.opts.makeViewport) {
                         const r = this.opts.makeViewport({
                             ...e,
                             ...i
                         });
-                        Object.assign(i, r.panByPosition(e.aroundPosition, hc(t.around, e.around, n)))
+                        Object.assign(i, r.panByPosition(e.aroundPosition, ac(t.around, e.around, n)))
                     }
                     return i
                 }
             }
-            const Vf = {
+            const Uf = {
                     transitionDuration: 0
                 },
-                Uf = t => 1 - (1 - t) * (1 - t),
-                Gf = ["wheel"],
-                Wf = ["panstart", "panmove", "panend"],
-                Hf = ["pinchstart", "pinchmove", "pinchend"],
-                Zf = ["tripanstart", "tripanmove", "tripanend"],
-                qf = ["doubletap"],
-                Xf = ["keydown"],
-                Yf = {};
-            class Kf {
+                Gf = t => 1 - (1 - t) * (1 - t),
+                Wf = ["wheel"],
+                Hf = ["panstart", "panmove", "panend"],
+                Zf = ["pinchstart", "pinchmove", "pinchend"],
+                qf = ["tripanstart", "tripanmove", "tripanend"],
+                Xf = ["doubletap"],
+                Yf = ["keydown"],
+                Kf = {};
+            class Qf {
                 constructor(t) {
                     wo(this, "props", void 0), wo(this, "state", {}), wo(this, "transitionManager", void 0), wo(this, "eventManager", void 0), wo(this, "onViewStateChange", void 0), wo(this, "onStateChange", void 0), wo(this, "makeViewport", void 0), wo(this, "_controllerState", void 0), wo(this, "_events", {}), wo(this, "_interactionState", {
                         isDragging: !1
-                    }), wo(this, "_customEvents", []), wo(this, "_eventStartBlocked", null), wo(this, "_panMove", !1), wo(this, "invertPan", !1), wo(this, "dragMode", "rotate"), wo(this, "inertia", 0), wo(this, "scrollZoom", !0), wo(this, "dragPan", !0), wo(this, "dragRotate", !0), wo(this, "doubleClickZoom", !0), wo(this, "touchZoom", !0), wo(this, "touchRotate", !1), wo(this, "keyboard", !0), this.transitionManager = new Ff({
+                    }), wo(this, "_customEvents", []), wo(this, "_eventStartBlocked", null), wo(this, "_panMove", !1), wo(this, "invertPan", !1), wo(this, "dragMode", "rotate"), wo(this, "inertia", 0), wo(this, "scrollZoom", !0), wo(this, "dragPan", !0), wo(this, "dragRotate", !0), wo(this, "doubleClickZoom", !0), wo(this, "touchZoom", !0), wo(this, "touchRotate", !1), wo(this, "keyboard", !0), this.transitionManager = new zf({
                         ...t,
                         getControllerState: t => new this.ControllerState(t),
                         onViewStateChange: this._onTransition.bind(this),
                         onStateChange: this._setInteractionState.bind(this)
                     }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = t.eventManager, this.onViewStateChange = t.onViewStateChange || (() => {}), this.onStateChange = t.onStateChange || (() => {}), this.makeViewport = t.makeViewport
                 }
                 set events(t) {
@@ -14708,15 +14743,15 @@
                         dragPan: i = !0,
                         dragRotate: r = !0,
                         doubleClickZoom: s = !0,
                         touchZoom: o = !0,
                         touchRotate: a = !1,
                         keyboard: l = !0
                     } = t, c = Boolean(this.onViewStateChange);
-                    this.toggleEvents(Gf, c && n), this.toggleEvents(Wf, c && (i || r)), this.toggleEvents(Hf, c && (o || a)), this.toggleEvents(Zf, c && a), this.toggleEvents(qf, c && s), this.toggleEvents(Xf, c && l), this.scrollZoom = n, this.dragPan = i, this.dragRotate = r, this.doubleClickZoom = s, this.touchZoom = o, this.touchRotate = a, this.keyboard = l
+                    this.toggleEvents(Wf, c && n), this.toggleEvents(Hf, c && (i || r)), this.toggleEvents(Zf, c && (o || a)), this.toggleEvents(qf, c && a), this.toggleEvents(Xf, c && s), this.toggleEvents(Yf, c && l), this.scrollZoom = n, this.dragPan = i, this.dragRotate = r, this.doubleClickZoom = s, this.touchZoom = o, this.touchRotate = a, this.keyboard = l
                 }
                 updateTransition() {
                     this.transitionManager.updateTransition()
                 }
                 toggleEvents(t, e) {
                     this.eventManager && t.forEach((t => {
                         this._events[t] !== e && (this._events[t] = e, e ? this.eventManager.on(t, this.handleEvent) : this.eventManager.off(t, this.handleEvent))
@@ -14750,15 +14785,15 @@
                     const e = this.getCenter(t);
                     if (!this.isPointInBounds(e, t)) return !1;
                     let n = this.isFunctionKeyPressed(t) || t.rightButton || !1;
                     (this.invertPan || "pan" === this.dragMode) && (n = !n);
                     const i = this.controllerState[n ? "panStart" : "rotateStart"]({
                         pos: e
                     });
-                    return this._panMove = n, this.updateViewport(i, Vf, {
+                    return this._panMove = n, this.updateViewport(i, Uf, {
                         isDragging: !0
                     }), !0
                 }
                 _onPan(t) {
                     return !!this.isDragging() && (this._panMove ? this._onPanMove(t) : this._onPanRotate(t))
                 }
                 _onPanEnd(t) {
@@ -14766,15 +14801,15 @@
                 }
                 _onPanMove(t) {
                     if (!this.dragPan) return !1;
                     const e = this.getCenter(t),
                         n = this.controllerState.pan({
                             pos: e
                         });
-                    return this.updateViewport(n, Vf, {
+                    return this.updateViewport(n, Uf, {
                         isDragging: !0,
                         isPanning: !0
                     }), !0
                 }
                 _onPanMoveEnd(t) {
                     const {
                         inertia: e
@@ -14784,15 +14819,15 @@
                             i = [n[0] + t.velocityX * e / 2, n[1] + t.velocityY * e / 2],
                             r = this.controllerState.pan({
                                 pos: i
                             }).panEnd();
                         this.updateViewport(r, {
                             ...this._getTransitionProps(),
                             transitionDuration: e,
-                            transitionEasing: Uf
+                            transitionEasing: Gf
                         }, {
                             isDragging: !1,
                             isPanning: !0
                         })
                     } else {
                         const t = this.controllerState.panEnd();
                         this.updateViewport(t, null, {
@@ -14804,15 +14839,15 @@
                 }
                 _onPanRotate(t) {
                     if (!this.dragRotate) return !1;
                     const e = this.getCenter(t),
                         n = this.controllerState.rotate({
                             pos: e
                         });
-                    return this.updateViewport(n, Vf, {
+                    return this.updateViewport(n, Uf, {
                         isDragging: !0,
                         isRotating: !0
                     }), !0
                 }
                 _onPanRotateEnd(t) {
                     const {
                         inertia: e
@@ -14822,15 +14857,15 @@
                             i = [n[0] + t.velocityX * e / 2, n[1] + t.velocityY * e / 2],
                             r = this.controllerState.rotate({
                                 pos: i
                             }).rotateEnd();
                         this.updateViewport(r, {
                             ...this._getTransitionProps(),
                             transitionDuration: e,
-                            transitionEasing: Uf
+                            transitionEasing: Gf
                         }, {
                             isDragging: !1,
                             isRotating: !0
                         })
                     } else {
                         const t = this.controllerState.rotateEnd();
                         this.updateViewport(t, null, {
@@ -14869,27 +14904,27 @@
                 }
                 _onTriplePanStart(t) {
                     const e = this.getCenter(t);
                     if (!this.isPointInBounds(e, t)) return !1;
                     const n = this.controllerState.rotateStart({
                         pos: e
                     });
-                    return this.updateViewport(n, Vf, {
+                    return this.updateViewport(n, Uf, {
                         isDragging: !0
                     }), !0
                 }
                 _onTriplePan(t) {
                     if (!this.touchRotate) return !1;
                     if (!this.isDragging()) return !1;
                     const e = this.getCenter(t);
                     e[0] -= t.deltaX;
                     const n = this.controllerState.rotate({
                         pos: e
                     });
-                    return this.updateViewport(n, Vf, {
+                    return this.updateViewport(n, Uf, {
                         isDragging: !0,
                         isRotating: !0
                     }), !0
                 }
                 _onTriplePanEnd(t) {
                     if (!this.isDragging()) return !1;
                     const {
@@ -14900,15 +14935,15 @@
                             i = [n[0], n[1] += t.velocityY * e / 2],
                             r = this.controllerState.rotate({
                                 pos: i
                             });
                         this.updateViewport(r, {
                             ...this._getTransitionProps(),
                             transitionDuration: e,
-                            transitionEasing: Uf
+                            transitionEasing: Gf
                         }, {
                             isDragging: !1,
                             isRotating: !0
                         }), this.blockEvents(e)
                     } else {
                         const t = this.controllerState.rotateEnd();
                         this.updateViewport(t, null, {
@@ -14922,15 +14957,15 @@
                     const e = this.getCenter(t);
                     if (!this.isPointInBounds(e, t)) return !1;
                     const n = this.controllerState.zoomStart({
                         pos: e
                     }).rotateStart({
                         pos: e
                     });
-                    return Yf._startPinchRotation = t.rotation, Yf._lastPinchEvent = t, this.updateViewport(n, Vf, {
+                    return Kf._startPinchRotation = t.rotation, Kf._lastPinchEvent = t, this.updateViewport(n, Uf, {
                         isDragging: !0
                     }), !0
                 }
                 _onPinch(t) {
                     if (!this.touchZoom && !this.touchRotate) return !1;
                     if (!this.isDragging()) return !1;
                     let e = this.controllerState;
@@ -14944,46 +14979,46 @@
                         })
                     }
                     if (this.touchRotate) {
                         const {
                             rotation: n
                         } = t;
                         e = e.rotate({
-                            deltaAngleX: Yf._startPinchRotation - n
+                            deltaAngleX: Kf._startPinchRotation - n
                         })
                     }
-                    return this.updateViewport(e, Vf, {
+                    return this.updateViewport(e, Uf, {
                         isDragging: !0,
                         isPanning: this.touchZoom,
                         isZooming: this.touchZoom,
                         isRotating: this.touchRotate
-                    }), Yf._lastPinchEvent = t, !0
+                    }), Kf._lastPinchEvent = t, !0
                 }
                 _onPinchEnd(t) {
                     if (!this.isDragging()) return !1;
                     const {
                         inertia: e
                     } = this, {
                         _lastPinchEvent: n
-                    } = Yf;
+                    } = Kf;
                     if (this.touchZoom && e && n && t.scale !== n.scale) {
                         const i = this.getCenter(t);
                         let r = this.controllerState.rotateEnd();
                         const s = Math.log2(t.scale),
                             o = (s - Math.log2(n.scale)) / (t.deltaTime - n.deltaTime),
                             a = Math.pow(2, s + o * e / 2);
                         r = r.zoom({
                             pos: i,
                             scale: a
                         }).zoomEnd(), this.updateViewport(r, {
                             ...this._getTransitionProps({
                                 around: i
                             }),
                             transitionDuration: e,
-                            transitionEasing: Uf
+                            transitionEasing: Gf
                         }, {
                             isDragging: !1,
                             isPanning: this.touchZoom,
                             isZooming: this.touchZoom,
                             isRotating: !1
                         }), this.blockEvents(e)
                     } else {
@@ -14991,15 +15026,15 @@
                         this.updateViewport(t, null, {
                             isDragging: !1,
                             isPanning: !1,
                             isZooming: !1,
                             isRotating: !1
                         })
                     }
-                    return Yf._startPinchRotation = null, Yf._lastPinchEvent = null, !0
+                    return Kf._startPinchRotation = null, Kf._lastPinchEvent = null, !0
                 }
                 _onDoubleTap(t) {
                     if (!this.doubleClickZoom) return !1;
                     const e = this.getCenter(t);
                     if (!this.isPointInBounds(e, t)) return !1;
                     const n = this.isFunctionKeyPressed(t),
                         i = this.controllerState.zoom({
@@ -15053,34 +15088,34 @@
                 }
                 _getTransitionProps(t) {
                     const {
                         transition: e
                     } = this;
                     return e && e.transitionInterpolator ? t ? {
                         ...e,
-                        transitionInterpolator: new Nf({
+                        transitionInterpolator: new Vf({
                             ...t,
                             ...e.transitionInterpolator.opts,
                             makeViewport: this.controllerState.makeViewport
                         })
-                    } : e : Vf
+                    } : e : Uf
                 }
             }
-            class Qf {
+            class Jf {
                 constructor(t, e) {
                     wo(this, "_viewportProps", void 0), wo(this, "_state", void 0), this._viewportProps = this.applyConstraints(t), this._state = e
                 }
                 getViewportProps() {
                     return this._viewportProps
                 }
                 getState() {
                     return this._state
                 }
             }
-            class Jf extends Qf {
+            class $f extends Jf {
                 constructor(t) {
                     const {
                         width: e,
                         height: n,
                         latitude: i,
                         longitude: r,
                         zoom: s,
@@ -15096,15 +15131,15 @@
                         startZoomLngLat: g,
                         startRotatePos: m,
                         startBearing: v,
                         startPitch: b,
                         startZoom: y,
                         normalize: _ = !0
                     } = t;
-                    Of(Number.isFinite(r)), Of(Number.isFinite(i)), Of(Number.isFinite(s)), super({
+                    Mf(Number.isFinite(r)), Mf(Number.isFinite(i)), Mf(Number.isFinite(s)), super({
                         width: e,
                         height: n,
                         latitude: i,
                         longitude: r,
                         zoom: s,
                         bearing: o,
                         pitch: a,
@@ -15196,15 +15231,15 @@
                     } = this.getState();
                     if (r || (i = this.getViewportProps().zoom, r = this._unproject(e) || this._unproject(t)), !r) return this;
                     const {
                         maxZoom: s,
                         minZoom: o
                     } = this.getViewportProps();
                     let a = i + Math.log2(n);
-                    a = cc(a, o, s);
+                    a = oc(a, o, s);
                     const l = this.makeViewport({
                         ...this.getViewportProps(),
                         zoom: a
                     });
                     return this._getUpdatedState({
                         zoom: a,
                         ...l.panByPosition(r, t)
@@ -15267,21 +15302,21 @@
                 }
                 applyConstraints(t) {
                     const {
                         maxZoom: e,
                         minZoom: n,
                         zoom: i
                     } = t;
-                    t.zoom = cc(i, n, e);
+                    t.zoom = oc(i, n, e);
                     const {
                         maxPitch: r,
                         minPitch: s,
                         pitch: o
                     } = t;
-                    t.pitch = cc(o, s, r);
+                    t.pitch = oc(o, s, r);
                     const {
                         normalize: a = !0
                     } = t;
                     return a && Object.assign(t, function(t) {
                         const {
                             width: e,
                             height: n,
@@ -15289,23 +15324,23 @@
                         } = t;
                         let {
                             longitude: r,
                             latitude: s,
                             zoom: o,
                             bearing: a = 0
                         } = t;
-                        (r < -180 || r > 180) && (r = lh(r + 180, 360) - 180), (a < -180 || a > 180) && (a = lh(a + 180, 360) - 180);
-                        const l = hh(n / 512);
+                        (r < -180 || r > 180) && (r = rh(r + 180, 360) - 180), (a < -180 || a > 180) && (a = rh(a + 180, 360) - 180);
+                        const l = oh(n / 512);
                         if (o <= l) o = l, s = 0;
                         else {
                             const t = n / 2 / Math.pow(2, o),
-                                e = xh([0, t])[1];
+                                e = vh([0, t])[1];
                             if (s < e) s = e;
                             else {
-                                const e = xh([0, 512 - t])[1];
+                                const e = vh([0, 512 - t])[1];
                                 s > e && (s = e)
                             }
                         }
                         return {
                             width: e,
                             height: n,
                             longitude: r,
@@ -15355,31 +15390,31 @@
                         a = e[1],
                         {
                             width: l,
                             height: c
                         } = this.getViewportProps(),
                         h = r / l;
                     let u = 0;
-                    s > 0 ? Math.abs(c - a) > 5 && (u = s / (a - c) * 1.2) : s < 0 && a > 5 && (u = 1 - o / a), u = cc(u, -1, 1);
+                    s > 0 ? Math.abs(c - a) > 5 && (u = s / (a - c) * 1.2) : s < 0 && a > 5 && (u = 1 - o / a), u = oc(u, -1, 1);
                     const {
                         minPitch: d,
                         maxPitch: p
                     } = this.getViewportProps();
                     let f = n;
                     return u > 0 ? f = n + u * (p - n) : u < 0 && (f = n - u * (d - n)), {
                         pitch: f,
                         bearing: i + 180 * h
                     }
                 }
             }
-            class $f extends Kf {
+            class tg extends Qf {
                 constructor(...t) {
-                    super(...t), wo(this, "ControllerState", Jf), wo(this, "transition", {
+                    super(...t), wo(this, "ControllerState", $f), wo(this, "transition", {
                         transitionDuration: 300,
-                        transitionInterpolator: new Nf({
+                        transitionInterpolator: new Vf({
                             transitionProps: {
                                 compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
                                 required: ["longitude", "latitude", "zoom"]
                             }
                         })
                     }), wo(this, "dragMode", "pan")
                 }
@@ -15389,60 +15424,60 @@
                     super.setProps(t), (!e || e.height !== t.height) && this.updateViewport(new this.ControllerState({
                         makeViewport: this.makeViewport,
                         ...t,
                         ...this.state
                     }))
                 }
             }
-            class tg extends Lf {
+            class eg extends Of {
                 get ViewportType() {
                     return Rf
                 }
                 get ControllerType() {
-                    return $f
+                    return tg
                 }
             }
-            wo(tg, "displayName", "MapView");
-            const eg = [255, 255, 255],
-                ng = 1;
-            let ig = 0;
-            class rg {
+            wo(eg, "displayName", "MapView");
+            const ng = [255, 255, 255],
+                ig = 1;
+            let rg = 0;
+            class sg {
                 constructor(t = {}) {
                     wo(this, "id", void 0), wo(this, "color", void 0), wo(this, "intensity", void 0), wo(this, "type", "ambient");
                     const {
-                        color: e = eg
+                        color: e = ng
                     } = t, {
-                        intensity: n = ng
+                        intensity: n = ig
                     } = t;
-                    this.id = t.id || "ambient-".concat(ig++), this.color = e, this.intensity = n
+                    this.id = t.id || "ambient-".concat(rg++), this.color = e, this.intensity = n
                 }
             }
-            const sg = [255, 255, 255],
-                og = 1,
-                ag = [0, 0, -1];
-            let lg = 0;
-            class cg {
+            const og = [255, 255, 255],
+                ag = 1,
+                lg = [0, 0, -1];
+            let cg = 0;
+            class hg {
                 constructor(t = {}) {
                     wo(this, "id", void 0), wo(this, "color", void 0), wo(this, "intensity", void 0), wo(this, "type", "directional"), wo(this, "direction", void 0), wo(this, "shadow", void 0);
                     const {
-                        color: e = sg
+                        color: e = og
                     } = t, {
-                        intensity: n = og
+                        intensity: n = ag
                     } = t, {
-                        direction: i = ag
+                        direction: i = lg
                     } = t, {
                         _shadow: r = !1
                     } = t;
-                    this.id = t.id || "directional-".concat(lg++), this.color = e, this.intensity = n, this.type = "directional", this.direction = new Ic(i).normalize().toArray(), this.shadow = r
+                    this.id = t.id || "directional-".concat(cg++), this.color = e, this.intensity = n, this.type = "directional", this.direction = new Oc(i).normalize().toArray(), this.shadow = r
                 }
                 getProjectedLight(t) {
                     return this
                 }
             }
-            class hg {
+            class ug {
                 constructor(t, e = {
                     id: "pass"
                 }) {
                     wo(this, "id", void 0), wo(this, "gl", void 0), wo(this, "props", void 0);
                     const {
                         id: n
                     } = e;
@@ -15452,20 +15487,20 @@
                 }
                 setProps(t) {
                     Object.assign(this.props, t)
                 }
                 render(t) {}
                 cleanup() {}
             }
-            class ug extends hg {
+            class dg extends ug {
                 constructor(...t) {
                     super(...t), wo(this, "_lastRenderIndex", -1)
                 }
                 render(t) {
-                    return hd(this.gl, {
+                    return ld(this.gl, {
                         framebuffer: t.target
                     }), this._drawLayers(t)
                 }
                 _drawLayers(t) {
                     const {
                         target: e,
                         moduleParameters: n,
@@ -15473,23 +15508,23 @@
                         views: r,
                         onViewportActive: s,
                         clearStack: o = !0,
                         clearCanvas: a = !0
                     } = t;
                     t.pass = t.pass || "unknown";
                     const l = this.gl;
-                    a && function(t, e) {
-                        hd(t, {
-                            viewport: [0, 0, e ? e.width : t.drawingBufferWidth, e ? e.height : t.drawingBufferHeight]
+                    a && function(t) {
+                        ld(t, {
+                            viewport: [0, 0, t.drawingBufferWidth, t.drawingBufferHeight]
                         }), t.clear(16640)
-                    }(l, e), o && (this._lastRenderIndex = -1);
+                    }(l), o && (this._lastRenderIndex = -1);
                     const c = [];
                     for (const o of i) {
                         const i = r && r[o.id];
-                        null == s || s(o);
+                        s(o);
                         const a = this._getDrawLayerParams(o, t),
                             h = o.subViewports || [o];
                         for (const r of h) {
                             const s = this._drawLayersInViewport(l, {
                                 target: e,
                                 moduleParameters: n,
                                 viewport: r,
@@ -15501,39 +15536,38 @@
                         }
                     }
                     return c
                 }
                 _getDrawLayerParams(t, {
                     layers: e,
                     pass: n,
-                    isPicking: i = !1,
-                    layerFilter: r,
-                    cullRect: s,
-                    effects: o,
-                    moduleParameters: a
-                }, l = !1) {
-                    const c = [],
-                        h = dg(this._lastRenderIndex + 1),
-                        u = {
+                    layerFilter: i,
+                    cullRect: r,
+                    effects: s,
+                    moduleParameters: o
+                }) {
+                    const a = [],
+                        l = pg(this._lastRenderIndex + 1),
+                        c = {
                             layer: e[0],
                             viewport: t,
-                            isPicking: i,
+                            isPicking: n.startsWith("picking"),
                             renderPass: n,
-                            cullRect: s
+                            cullRect: r
                         },
-                        d = {};
-                    for (let i = 0; i < e.length; i++) {
-                        const s = e[i],
-                            p = this._shouldDrawLayer(s, u, r, d),
-                            f = {
-                                shouldDrawLayer: p
+                        h = {};
+                    for (let r = 0; r < e.length; r++) {
+                        const u = e[r],
+                            d = this._shouldDrawLayer(u, c, i, h),
+                            p = {
+                                shouldDrawLayer: d
                             };
-                        p && !l && (f.layerRenderIndex = h(s, p), f.moduleParameters = this._getModuleParameters(s, o, n, a), f.layerParameters = this.getLayerParameters(s, i, t)), c[i] = f
+                        d && (p.layerRenderIndex = l(u, d), p.moduleParameters = this._getModuleParameters(u, s, n, o), p.layerParameters = this.getLayerParameters(u, r, t)), a[r] = p
                     }
-                    return c
+                    return a
                 }
                 _drawLayersInViewport(t, {
                     layers: e,
                     moduleParameters: n,
                     pass: i,
                     target: r,
                     viewport: s,
@@ -15541,40 +15575,40 @@
                 }, a) {
                     const l = function(t, {
                         moduleParameters: e,
                         target: n,
                         viewport: i
                     }) {
                         const r = n && "default-framebuffer" !== n.id,
-                            s = e && e.devicePixelRatio || dd(t),
+                            s = e && e.devicePixelRatio || hd(t),
                             o = r ? n.height : t.drawingBufferHeight,
                             a = i;
                         return [a.x * s, o - (a.y + a.height) * s, a.width * s, a.height * s]
                     }(t, {
                         moduleParameters: n,
                         target: r,
                         viewport: s
                     });
                     if (o && o.props.clear) {
                         const e = !0 === o.props.clear ? {
                             color: !0,
                             depth: !0
                         } : o.props.clear;
-                        ud(t, {
+                        cd(t, {
                             scissorTest: !0,
                             scissor: l
-                        }, (() => ip(t, e)))
+                        }, (() => np(t, e)))
                     }
                     const c = {
                         totalCount: e.length,
                         visibleCount: 0,
                         compositeCount: 0,
                         pickableCount: 0
                     };
-                    hd(t, {
+                    ld(t, {
                         viewport: l
                     });
                     for (let t = 0; t < e.length; t++) {
                         const n = e[t],
                             {
                                 shouldDrawLayer: r,
                                 layerRenderIndex: o,
@@ -15625,75 +15659,75 @@
                 _getModuleParameters(t, e, n, i) {
                     var r;
                     const s = Object.assign(Object.create((null === (r = t.internalState) || void 0 === r ? void 0 : r.propsInTransition) || t.props), {
                         autoWrapLongitude: t.wrapLongitude,
                         viewport: t.context.viewport,
                         mousePosition: t.context.mousePosition,
                         pickingActive: 0,
-                        devicePixelRatio: dd(this.gl)
+                        devicePixelRatio: hd(this.gl)
                     });
                     if (e)
                         for (const n of e) {
                             var o;
                             Object.assign(s, null === (o = n.getModuleParameters) || void 0 === o ? void 0 : o.call(n, t))
                         }
                     return Object.assign(s, this.getModuleParameters(t, e), i)
                 }
             }
 
-            function dg(t = 0, e = {}) {
+            function pg(t = 0, e = {}) {
                 const n = {},
                     i = (r, s) => {
                         const o = r.props._offset,
                             a = r.id,
                             l = r.parent && r.parent.id;
                         let c;
                         if (l && !(l in e) && i(r.parent, !1), l in n) {
-                            const t = n[l] = n[l] || dg(e[l], e);
+                            const t = n[l] = n[l] || pg(e[l], e);
                             c = t(r, s), n[a] = t
                         } else Number.isFinite(o) ? (c = o + (e[l] || 0), n[a] = null) : c = t;
                         return s && c >= t && (t = c + 1), e[a] = c, c
                     };
                 return i
             }
-            class pg extends ug {
+            class fg extends dg {
                 constructor(t, e) {
-                    super(t, e), wo(this, "shadowMap", void 0), wo(this, "depthBuffer", void 0), wo(this, "fbo", void 0), this.shadowMap = new Qd(t, {
+                    super(t, e), wo(this, "shadowMap", void 0), wo(this, "depthBuffer", void 0), wo(this, "fbo", void 0), this.shadowMap = new Kd(t, {
                         width: 1,
                         height: 1,
                         parameters: {
                             10241: 9729,
                             10240: 9729,
                             10242: 33071,
                             10243: 33071
                         }
-                    }), this.depthBuffer = new tp(t, {
+                    }), this.depthBuffer = new $d(t, {
                         format: 33189,
                         width: 1,
                         height: 1
-                    }), this.fbo = new bp(t, {
+                    }), this.fbo = new vp(t, {
                         id: "shadowmap",
                         width: 1,
                         height: 1,
                         attachments: {
                             36064: this.shadowMap,
                             36096: this.depthBuffer
                         }
                     })
                 }
                 render(t) {
                     const e = this.fbo;
-                    ud(this.gl, {
+                    cd(this.gl, {
                         depthRange: [0, 1],
                         depthTest: !0,
                         blend: !1,
                         clearColor: [1, 1, 1, 1]
                     }, (() => {
                         const n = t.viewports[0],
-                            i = dd(this.gl),
+                            i = hd(this.gl),
                             r = n.width * i,
                             s = n.height * i;
                         r === e.width && s === e.height || e.resize({
                             width: r,
                             height: s
                         }), super.render({
                             ...t,
@@ -15710,21 +15744,21 @@
                         drawToShadowMap: !0
                     }
                 }
                 delete() {
                     this.fbo && (this.fbo.delete(), this.fbo = null), this.shadowMap && (this.shadowMap.delete(), this.shadowMap = null), this.depthBuffer && (this.depthBuffer.delete(), this.depthBuffer = null)
                 }
             }
-            const fg = uf((function({
+            const gg = hf((function({
                     viewport: t,
                     center: e
                 }) {
-                    return new ih(t.viewProjectionMatrix).invert().transform(e)
+                    return new $c(t.viewProjectionMatrix).invert().transform(e)
                 })),
-                gg = uf((function({
+                mg = hf((function({
                     viewport: t,
                     shadowMatrices: e
                 }) {
                     const n = [],
                         i = t.pixelUnprojectionMatrix,
                         r = t.isGeospatial ? void 0 : 1,
                         s = [
@@ -15733,37 +15767,37 @@
                             [0, t.height, r],
                             [t.width, t.height, r],
                             [0, 0, -1],
                             [t.width, 0, -1],
                             [0, t.height, -1],
                             [t.width, t.height, -1]
                         ].map((t => function(t, e) {
-                            const [n, i, r] = t, s = Ah([n, i, r], e);
+                            const [n, i, r] = t, s = Eh([n, i, r], e);
                             return Number.isFinite(r) ? s : [s[0], s[1], 0]
                         }(t, i)));
                     for (const i of e) {
-                        const e = i.clone().translate(new Ic(t.center).negate()),
+                        const e = i.clone().translate(new Oc(t.center).negate()),
                             r = s.map((t => e.transform(t))),
-                            o = (new ih).ortho({
+                            o = (new $c).ortho({
                                 left: Math.min(...r.map((t => t[0]))),
                                 right: Math.max(...r.map((t => t[0]))),
                                 bottom: Math.min(...r.map((t => t[1]))),
                                 top: Math.max(...r.map((t => t[1]))),
                                 near: Math.min(...r.map((t => -t[2]))),
                                 far: Math.max(...r.map((t => -t[2])))
                             });
                         n.push(o.multiplyRight(i))
                     }
                     return n
                 })),
-                mg = [0, 0, 0, 1],
-                vg = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
-                bg = {
+                vg = [0, 0, 0, 1],
+                bg = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
+                yg = {
                     name: "shadow",
-                    dependencies: [_f],
+                    dependencies: [yf],
                     vs: "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n",
                     fs: "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n",
                     inject: {
                         "vs:DECKGL_FILTER_GL_POSITION": "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
                         "fs:DECKGL_FILTER_COLOR": "\n    color = shadow_filterShadowColor(color);\n    "
                     },
                     getUniforms: (t = {}, e = {}) => "viewport" in t && (t.drawToShadowMap || t.shadowMaps && t.shadowMaps.length > 0) ? function(t, e) {
@@ -15773,80 +15807,77 @@
                         if (!n || !t.shadowMatrices || !t.shadowMatrices.length) return {
                             shadow_uDrawShadowMap: !1,
                             shadow_uUseShadowMap: !1
                         };
                         const i = {
                                 shadow_uDrawShadowMap: Boolean(t.drawToShadowMap),
                                 shadow_uUseShadowMap: !!t.shadowMaps && t.shadowMaps.length > 0,
-                                shadow_uColor: t.shadowColor || mg,
+                                shadow_uColor: t.shadowColor || vg,
                                 shadow_uLightId: t.shadowLightId || 0,
                                 shadow_uLightCount: t.shadowMatrices.length
                             },
-                            r = fg({
+                            r = gg({
                                 viewport: t.viewport,
                                 center: e.project_uCenter
                             }),
                             s = [],
-                            o = gg({
+                            o = mg({
                                 shadowMatrices: t.shadowMatrices,
                                 viewport: t.viewport
                             }).slice();
                         for (let n = 0; n < t.shadowMatrices.length; n++) {
                             const i = o[n],
-                                a = i.clone().translate(new Ic(t.viewport.center).negate());
-                            e.project_uCoordinateSystem === Lh.LNGLAT && e.project_uProjectionMode === Rh.WEB_MERCATOR ? (o[n] = a, s[n] = r) : (o[n] = i.clone().multiplyRight(vg), s[n] = a.transform(r))
+                                a = i.clone().translate(new Oc(t.viewport.center).negate());
+                            e.project_uCoordinateSystem === Th.LNGLAT && e.project_uProjectionMode === Ah.WEB_MERCATOR ? (o[n] = a, s[n] = r) : (o[n] = i.clone().multiplyRight(bg), s[n] = a.transform(r))
                         }
                         for (let e = 0; e < o.length; e++) i["shadow_uViewProjectionMatrices[".concat(e, "]")] = o[e], i["shadow_uProjectCenters[".concat(e, "]")] = s[e], t.shadowMaps && t.shadowMaps.length > 0 ? i["shadow_uShadowMap".concat(e)] = t.shadowMaps[e] : i["shadow_uShadowMap".concat(e)] = t.dummyShadowMap;
                         return i
                     }(t, e) : {}
                 },
-                yg = {
+                _g = {
                     color: [255, 255, 255],
                     intensity: 1
                 },
-                _g = [{
+                xg = [{
                     color: [255, 255, 255],
                     intensity: 1,
                     direction: [-1, 3, -1]
                 }, {
                     color: [255, 255, 255],
                     intensity: .9,
                     direction: [1, -8, -2.5]
                 }],
-                xg = [0, 0, 0, 200 / 255];
-            class wg {
+                wg = [0, 0, 0, 200 / 255];
+            class Eg {
                 constructor(t = {}) {
-                    wo(this, "id", "lighting-effect"), wo(this, "props", void 0), wo(this, "shadowColor", xg), wo(this, "shadow", void 0), wo(this, "ambientLight", void 0), wo(this, "directionalLights", void 0), wo(this, "pointLights", void 0), wo(this, "shadowPasses", []), wo(this, "shadowMaps", []), wo(this, "dummyShadowMap", null), wo(this, "programManager", void 0), wo(this, "shadowMatrices", void 0), this.setProps(t)
-                }
-                setProps(t) {
-                    this.ambientLight = null, this.directionalLights = [], this.pointLights = [];
+                    wo(this, "id", "lighting-effect"), wo(this, "props", null), wo(this, "shadowColor", wg), wo(this, "shadow", void 0), wo(this, "ambientLight", null), wo(this, "directionalLights", []), wo(this, "pointLights", []), wo(this, "shadowPasses", []), wo(this, "shadowMaps", []), wo(this, "dummyShadowMap", null), wo(this, "programManager", void 0), wo(this, "shadowMatrices", void 0);
                     for (const e in t) {
                         const n = t[e];
                         switch (n.type) {
                             case "ambient":
                                 this.ambientLight = n;
                                 break;
                             case "directional":
                                 this.directionalLights.push(n);
                                 break;
                             case "point":
                                 this.pointLights.push(n)
                         }
                     }
-                    this._applyDefaultLights(), this.shadow = this.directionalLights.some((t => t.shadow)), this.props = t
+                    this._applyDefaultLights(), this.shadow = this.directionalLights.some((t => t.shadow))
                 }
                 preRender(t, {
                     layers: e,
                     layerFilter: n,
                     viewports: i,
                     onViewportActive: r,
                     views: s
                 }) {
                     if (this.shadow) {
-                        this.shadowMatrices = this._calculateMatrices(), 0 === this.shadowPasses.length && this._createShadowPasses(t), this.programManager || (this.programManager = nf.getDefaultProgramManager(t), bg && this.programManager.addDefaultModule(bg)), this.dummyShadowMap || (this.dummyShadowMap = new Qd(t, {
+                        this.shadowMatrices = this._calculateMatrices(), 0 === this.shadowPasses.length && this._createShadowPasses(t), this.programManager || (this.programManager = ef.getDefaultProgramManager(t), yg && this.programManager.addDefaultModule(yg)), this.dummyShadowMap || (this.dummyShadowMap = new Kd(t, {
                             width: 1,
                             height: 1
                         }));
                         for (let t = 0; t < this.shadowPasses.length; t++) this.shadowPasses[t].render({
                             layers: e,
                             layerFilter: n,
                             viewports: i,
@@ -15875,102 +15906,700 @@
                         pointLights: this.pointLights.map((e => e.getProjectedLight({
                             layer: t
                         })))
                     }, e
                 }
                 cleanup() {
                     for (const t of this.shadowPasses) t.delete();
-                    this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.delete(), this.dummyShadowMap = null), this.shadow && this.programManager && (this.programManager.removeDefaultModule(bg), this.programManager = null)
+                    this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.delete(), this.dummyShadowMap = null), this.shadow && this.programManager && (this.programManager.removeDefaultModule(yg), this.programManager = null)
                 }
                 _calculateMatrices() {
                     const t = [];
                     for (const e of this.directionalLights) {
-                        const n = (new ih).lookAt({
-                            eye: new Ic(e.direction).negate()
+                        const n = (new $c).lookAt({
+                            eye: new Oc(e.direction).negate()
                         });
                         t.push(n)
                     }
                     return t
                 }
                 _createShadowPasses(t) {
                     for (let e = 0; e < this.directionalLights.length; e++) {
-                        const n = new pg(t);
+                        const n = new fg(t);
                         this.shadowPasses[e] = n, this.shadowMaps[e] = n.shadowMap
                     }
                 }
                 _applyDefaultLights() {
                     const {
                         ambientLight: t,
                         pointLights: e,
                         directionalLights: n
                     } = this;
-                    t || 0 !== e.length || 0 !== n.length || (this.ambientLight = new rg(yg), this.directionalLights.push(new cg(_g[0]), new cg(_g[1])))
+                    t || 0 !== e.length || 0 !== n.length || (this.ambientLight = new sg(_g), this.directionalLights.push(new hg(xg[0]), new hg(xg[1])))
                 }
             }
-            const Eg = new wg;
-            class Pg {
+            class Pg extends dg {
+                constructor(t, e) {
+                    super(t, e), wo(this, "maskMap", void 0), wo(this, "fbo", void 0);
+                    const {
+                        mapSize: n = 2048
+                    } = e;
+                    this.maskMap = new Kd(t, {
+                        width: n,
+                        height: n,
+                        parameters: {
+                            10241: 9729,
+                            10240: 9729,
+                            10242: 33071,
+                            10243: 33071
+                        }
+                    }), this.fbo = new vp(t, {
+                        id: "maskmap",
+                        width: n,
+                        height: n,
+                        attachments: {
+                            36064: this.maskMap
+                        }
+                    })
+                }
+                render(t) {
+                    const e = this.gl,
+                        n = [!1, !1, !1, !1];
+                    return n[t.channel] = !0, cd(e, {
+                        clearColor: [255, 255, 255, 255],
+                        blend: !0,
+                        blendFunc: [0, 1],
+                        blendEquation: 32778,
+                        colorMask: n,
+                        depthTest: !1
+                    }, (() => super.render({
+                        ...t,
+                        target: this.fbo,
+                        pass: "mask"
+                    })))
+                }
+                shouldDrawLayer(t) {
+                    return t.props.operation === kh
+                }
+                delete() {
+                    this.fbo.delete(), this.maskMap.delete()
+                }
+            }
+            const Sg = (new $c).lookAt({
+                eye: [0, 0, 1]
+            });
+
+            function Cg({
+                width: t,
+                height: e,
+                near: n,
+                far: i,
+                padding: r
+            }) {
+                let s = -t / 2,
+                    o = t / 2,
+                    a = -e / 2,
+                    l = e / 2;
+                if (r) {
+                    const {
+                        left: n = 0,
+                        right: i = 0,
+                        top: c = 0,
+                        bottom: h = 0
+                    } = r, u = oc((n + t - i) / 2, 0, t) - t / 2, d = oc((c + e - h) / 2, 0, e) - e / 2;
+                    s -= u, o -= u, a += d, l += d
+                }
+                return (new $c).ortho({
+                    left: s,
+                    right: o,
+                    bottom: a,
+                    top: l,
+                    near: n,
+                    far: i
+                })
+            }
+            class Tg extends zh {
+                constructor(t) {
+                    const {
+                        width: e,
+                        height: n,
+                        near: i = .1,
+                        far: r = 1e3,
+                        zoom: s = 0,
+                        target: o = [0, 0, 0],
+                        padding: a = null,
+                        flipY: l = !0
+                    } = t, c = Array.isArray(s) ? s[0] : s, h = Array.isArray(s) ? s[1] : s, u = Math.min(c, h), d = Math.pow(2, u);
+                    let p;
+                    if (c !== h) {
+                        const t = Math.pow(2, c),
+                            e = Math.pow(2, h);
+                        p = {
+                            unitsPerMeter: [t / d, e / d, 1],
+                            metersPerUnit: [d / t, d / e, 1]
+                        }
+                    }
+                    super({
+                        ...t,
+                        longitude: void 0,
+                        position: o,
+                        viewMatrix: Sg.clone().scale([d, d * (l ? -1 : 1), d]),
+                        projectionMatrix: Cg({
+                            width: e || 1,
+                            height: n || 1,
+                            padding: a,
+                            near: i,
+                            far: r
+                        }),
+                        zoom: u,
+                        distanceScales: p
+                    })
+                }
+                projectFlat([t, e]) {
+                    const {
+                        unitsPerMeter: n
+                    } = this.distanceScales;
+                    return [t * n[0], e * n[1]]
+                }
+                unprojectFlat([t, e]) {
+                    const {
+                        metersPerUnit: n
+                    } = this.distanceScales;
+                    return [t * n[0], e * n[1]]
+                }
+                panByPosition(t, e) {
+                    const n = Eh(e, this.pixelUnprojectionMatrix),
+                        i = Gc([], this.projectFlat(t), Wc([], n)),
+                        r = Gc([], this.center, i);
+                    return {
+                        target: this.unprojectFlat(r)
+                    }
+                }
+            }
+            class Ag extends Jf {
+                constructor(t) {
+                    const {
+                        width: e,
+                        height: n,
+                        rotationX: i = 0,
+                        rotationOrbit: r = 0,
+                        target: s = [0, 0, 0],
+                        zoom: o = 0,
+                        minRotationX: a = -90,
+                        maxRotationX: l = 90,
+                        minZoom: c = -1 / 0,
+                        maxZoom: h = 1 / 0,
+                        startPanPosition: u,
+                        startRotatePos: d,
+                        startRotationX: p,
+                        startRotationOrbit: f,
+                        startZoomPosition: g,
+                        startZoom: m
+                    } = t;
+                    super({
+                        width: e,
+                        height: n,
+                        rotationX: i,
+                        rotationOrbit: r,
+                        target: s,
+                        zoom: o,
+                        minRotationX: a,
+                        maxRotationX: l,
+                        minZoom: c,
+                        maxZoom: h
+                    }, {
+                        startPanPosition: u,
+                        startRotatePos: d,
+                        startRotationX: p,
+                        startRotationOrbit: f,
+                        startZoomPosition: g,
+                        startZoom: m
+                    }), wo(this, "makeViewport", void 0), this.makeViewport = t.makeViewport
+                }
+                panStart({
+                    pos: t
+                }) {
+                    return this._getUpdatedState({
+                        startPanPosition: this._unproject(t)
+                    })
+                }
+                pan({
+                    pos: t,
+                    startPosition: e
+                }) {
+                    const n = this.getState().startPanPosition || e;
+                    if (!n) return this;
+                    const i = this.makeViewport(this.getViewportProps()).panByPosition(n, t);
+                    return this._getUpdatedState(i)
+                }
+                panEnd() {
+                    return this._getUpdatedState({
+                        startPanPosition: null
+                    })
+                }
+                rotateStart({
+                    pos: t
+                }) {
+                    return this._getUpdatedState({
+                        startRotatePos: t,
+                        startRotationX: this.getViewportProps().rotationX,
+                        startRotationOrbit: this.getViewportProps().rotationOrbit
+                    })
+                }
+                rotate({
+                    pos: t,
+                    deltaAngleX: e = 0,
+                    deltaAngleY: n = 0
+                }) {
+                    const {
+                        startRotatePos: i,
+                        startRotationX: r,
+                        startRotationOrbit: s
+                    } = this.getState(), {
+                        width: o,
+                        height: a
+                    } = this.getViewportProps();
+                    if (!i || void 0 === r || void 0 === s) return this;
+                    let l;
+                    if (t) {
+                        let e = (t[0] - i[0]) / o;
+                        (r < -90 || r > 90) && (e *= -1), l = {
+                            rotationX: r + (t[1] - i[1]) / a * 180,
+                            rotationOrbit: s + 180 * e
+                        }
+                    } else l = {
+                        rotationX: r + n,
+                        rotationOrbit: s + e
+                    };
+                    return this._getUpdatedState(l)
+                }
+                rotateEnd() {
+                    return this._getUpdatedState({
+                        startRotationX: null,
+                        startRotationOrbit: null
+                    })
+                }
+                shortestPathFrom(t) {
+                    const e = t.getViewportProps(),
+                        n = {
+                            ...this.getViewportProps()
+                        },
+                        {
+                            rotationOrbit: i
+                        } = n;
+                    return Math.abs(i - e.rotationOrbit) > 180 && (n.rotationOrbit = i < 0 ? i + 360 : i - 360), n
+                }
+                zoomStart({
+                    pos: t
+                }) {
+                    return this._getUpdatedState({
+                        startZoomPosition: this._unproject(t),
+                        startZoom: this.getViewportProps().zoom
+                    })
+                }
+                zoom({
+                    pos: t,
+                    startPos: e,
+                    scale: n
+                }) {
+                    let {
+                        startZoom: i,
+                        startZoomPosition: r
+                    } = this.getState();
+                    if (r || (i = this.getViewportProps().zoom, r = this._unproject(e) || this._unproject(t)), !r) return this;
+                    const s = this._calculateNewZoom({
+                            scale: n,
+                            startZoom: i
+                        }),
+                        o = this.makeViewport({
+                            ...this.getViewportProps(),
+                            zoom: s
+                        });
+                    return this._getUpdatedState({
+                        zoom: s,
+                        ...o.panByPosition(r, t)
+                    })
+                }
+                zoomEnd() {
+                    return this._getUpdatedState({
+                        startZoomPosition: null,
+                        startZoom: null
+                    })
+                }
+                zoomIn(t = 2) {
+                    return this._getUpdatedState({
+                        zoom: this._calculateNewZoom({
+                            scale: t
+                        })
+                    })
+                }
+                zoomOut(t = 2) {
+                    return this._getUpdatedState({
+                        zoom: this._calculateNewZoom({
+                            scale: 1 / t
+                        })
+                    })
+                }
+                moveLeft(t = 50) {
+                    return this._panFromCenter([-t, 0])
+                }
+                moveRight(t = 50) {
+                    return this._panFromCenter([t, 0])
+                }
+                moveUp(t = 50) {
+                    return this._panFromCenter([0, -t])
+                }
+                moveDown(t = 50) {
+                    return this._panFromCenter([0, t])
+                }
+                rotateLeft(t = 15) {
+                    return this._getUpdatedState({
+                        rotationOrbit: this.getViewportProps().rotationOrbit - t
+                    })
+                }
+                rotateRight(t = 15) {
+                    return this._getUpdatedState({
+                        rotationOrbit: this.getViewportProps().rotationOrbit + t
+                    })
+                }
+                rotateUp(t = 10) {
+                    return this._getUpdatedState({
+                        rotationX: this.getViewportProps().rotationX - t
+                    })
+                }
+                rotateDown(t = 10) {
+                    return this._getUpdatedState({
+                        rotationX: this.getViewportProps().rotationX + t
+                    })
+                }
+                _unproject(t) {
+                    const e = this.makeViewport(this.getViewportProps());
+                    return t && e.unproject(t)
+                }
+                _calculateNewZoom({
+                    scale: t,
+                    startZoom: e
+                }) {
+                    const {
+                        maxZoom: n,
+                        minZoom: i
+                    } = this.getViewportProps();
+                    return void 0 === e && (e = this.getViewportProps().zoom), oc(e + Math.log2(t), i, n)
+                }
+                _panFromCenter(t) {
+                    const {
+                        width: e,
+                        height: n,
+                        target: i
+                    } = this.getViewportProps();
+                    return this.pan({
+                        startPosition: i,
+                        pos: [e / 2 + t[0], n / 2 + t[1]]
+                    })
+                }
+                _getUpdatedState(t) {
+                    return new this.constructor({
+                        makeViewport: this.makeViewport,
+                        ...this.getViewportProps(),
+                        ...this.getState(),
+                        ...t
+                    })
+                }
+                applyConstraints(t) {
+                    const {
+                        maxZoom: e,
+                        minZoom: n,
+                        zoom: i,
+                        maxRotationX: r,
+                        minRotationX: s,
+                        rotationOrbit: o
+                    } = t;
+                    return t.zoom = Array.isArray(i) ? [oc(i[0], n, e), oc(i[1], n, e)] : oc(i, n, e), t.rotationX = oc(t.rotationX, s, r), (o < -180 || o > 180) && (t.rotationOrbit = function(t, e) {
+                        const n = t % 360;
+                        return n < 0 ? 360 + n : n
+                    }(o + 180) - 180), t
+                }
+            }
+            class Mg extends Ag {
+                constructor(t) {
+                    super(t), wo(this, "zoomAxis", void 0), this.zoomAxis = t.zoomAxis || "all"
+                }
+                _calculateNewZoom({
+                    scale: t,
+                    startZoom: e
+                }) {
+                    const {
+                        maxZoom: n,
+                        minZoom: i
+                    } = this.getViewportProps();
+                    void 0 === e && (e = this.getViewportProps().zoom);
+                    let r = Math.log2(t);
+                    if (Array.isArray(e)) {
+                        let [t, s] = e;
+                        switch (this.zoomAxis) {
+                            case "X":
+                                t = oc(t + r, i, n);
+                                break;
+                            case "Y":
+                                s = oc(s + r, i, n);
+                                break;
+                            default:
+                                let e = Math.min(t + r, s + r);
+                                e < i && (r += i - e), e = Math.max(t + r, s + r), e > n && (r += n - e), t += r, s += r
+                        }
+                        return [t, s]
+                    }
+                    return oc(e + r, i, n)
+                }
+            }
+            class Og extends Qf {
+                constructor(...t) {
+                    super(...t), wo(this, "ControllerState", Mg), wo(this, "transition", {
+                        transitionDuration: 300,
+                        transitionInterpolator: new Vf(["target", "zoom"])
+                    }), wo(this, "dragMode", "pan")
+                }
+                _onPanRotate() {
+                    return !1
+                }
+            }
+            class Lg extends Of {
+                get ViewportType() {
+                    return Tg
+                }
+                get ControllerType() {
+                    return Og
+                }
+            }
+            wo(Lg, "displayName", "OrthographicView");
+            class kg {
                 constructor() {
-                    wo(this, "effects", void 0), wo(this, "_resolvedEffects", []), wo(this, "_defaultEffects", []), wo(this, "_needsRedraw", void 0), this.effects = [], this._needsRedraw = "Initial render", this._setEffects([])
+                    wo(this, "id", "mask-effect"), wo(this, "props", null), wo(this, "useInPicking", !0), wo(this, "dummyMaskMap", void 0), wo(this, "channels", []), wo(this, "masks", null), wo(this, "maskPass", void 0), wo(this, "maskMap", void 0), wo(this, "lastViewport", void 0)
                 }
-                addDefaultEffect(t) {
-                    const e = this._defaultEffects;
-                    if (!e.find((e => e.id === t.id))) {
-                        const n = e.findIndex((e => {
-                            return n = t, (null !== (i = e.order) && void 0 !== i ? i : 1 / 0) - (null !== (r = n.order) && void 0 !== r ? r : 1 / 0) > 0;
-                            var n, i, r
-                        }));
-                        n < 0 ? e.push(t) : e.splice(n, 0, t), this._setEffects(this.effects)
+                preRender(t, {
+                    layers: e,
+                    layerFilter: n,
+                    viewports: i,
+                    onViewportActive: r,
+                    views: s
+                }) {
+                    this.dummyMaskMap || (this.dummyMaskMap = new Kd(t, {
+                        width: 1,
+                        height: 1
+                    }));
+                    const o = e.filter((t => t.props.visible && t.props.operation === kh));
+                    if (0 === o.length) return this.masks = null, void(this.channels.length = 0);
+                    this.masks = {}, this.maskPass || (this.maskPass = new Pg(t, {
+                        id: "default-mask"
+                    }), this.maskMap = this.maskPass.maskMap);
+                    const a = this._sortMaskChannels(o),
+                        l = i[0],
+                        c = !this.lastViewport || !this.lastViewport.equals(l);
+                    for (const t in a) this._renderChannel(a[t], {
+                        layerFilter: n,
+                        onViewportActive: r,
+                        views: s,
+                        viewport: l,
+                        viewportChanged: c
+                    })
+                }
+                _renderChannel(t, {
+                    layerFilter: e,
+                    onViewportActive: n,
+                    views: i,
+                    viewport: r,
+                    viewportChanged: s
+                }) {
+                    const o = this.channels[t.index];
+                    if (!o) return;
+                    const a = t === o || o.layers.length !== t.layers.length || t.layerBounds.some(((t, e) => t !== o.layerBounds[e]));
+                    if (t.bounds = o.bounds, t.maskBounds = o.maskBounds, this.channels[t.index] = t, (a || s) && (this.lastViewport = r, t.bounds = function({
+                            layers: t,
+                            viewport: e
+                        }) {
+                            let n = null;
+                            for (const e of t) {
+                                const t = e.getBounds();
+                                t && (n ? (n[0] = Math.min(n[0], t[0][0]), n[1] = Math.min(n[1], t[0][1]), n[2] = Math.max(n[2], t[1][0]), n[3] = Math.max(n[3], t[1][1])) : n = [t[0][0], t[0][1], t[1][0], t[1][1]])
+                            }
+                            const i = e.getBounds();
+                            if (!n) return i;
+                            const r = function(t) {
+                                const e = t[2] - t[0],
+                                    n = t[3] - t[1],
+                                    i = t[0] + .5 * e,
+                                    r = t[1] + .5 * n;
+                                return [i - e, r - n, i + e, r + n]
+                            }(i);
+                            return n[2] - n[0] < r[2] - r[0] || n[3] - n[1] < r[3] - r[1] || (n[0] = Math.max(n[0], r[0]), n[1] = Math.max(n[1], r[1]), n[2] = Math.min(n[2], r[2]), n[3] = Math.min(n[3], r[3])), n
+                        }({
+                            layers: t.layers,
+                            viewport: r
+                        }), a || !lc(t.bounds, o.bounds))) {
+                        const {
+                            maskPass: s,
+                            maskMap: o
+                        } = this, a = function({
+                            bounds: t,
+                            viewport: e,
+                            width: n,
+                            height: i
+                        }) {
+                            if (t[2] <= t[0] || t[3] <= t[1]) return null;
+                            if (n -= 2, i -= 2, e instanceof Rf) {
+                                const {
+                                    longitude: e,
+                                    latitude: r,
+                                    zoom: s
+                                } = Ph({
+                                    width: n,
+                                    height: i,
+                                    bounds: [
+                                        [t[0], t[1]],
+                                        [t[2], t[3]]
+                                    ],
+                                    maxZoom: 20
+                                });
+                                return new Rf({
+                                    longitude: e,
+                                    latitude: r,
+                                    zoom: s,
+                                    x: 1,
+                                    y: 1,
+                                    width: n,
+                                    height: i
+                                })
+                            }
+                            const r = [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2, 0],
+                                s = Math.min(20, n / (t[2] - t[0]), i / (t[3] - t[1]));
+                            return new Lg({
+                                x: 1,
+                                y: 1
+                            }).makeViewport({
+                                width: n,
+                                height: i,
+                                viewState: {
+                                    target: r,
+                                    zoom: Math.log2(s)
+                                }
+                            })
+                        }({
+                            bounds: t.bounds,
+                            viewport: r,
+                            width: o.width,
+                            height: o.height
+                        });
+                        t.maskBounds = a ? a.getBounds() : [0, 0, 1, 1], s.render({
+                            pass: "mask",
+                            channel: t.index,
+                            layers: t.layers,
+                            layerFilter: e,
+                            viewports: a ? [a] : [],
+                            onViewportActive: n,
+                            views: i,
+                            moduleParameters: {
+                                devicePixelRatio: 1
+                            }
+                        })
+                    }
+                    this.masks[t.id] = {
+                        index: t.index,
+                        bounds: t.maskBounds,
+                        coordinateOrigin: t.coordinateOrigin,
+                        coordinateSystem: t.coordinateSystem
+                    }
+                }
+                _sortMaskChannels(t) {
+                    const e = {};
+                    let n = 0;
+                    for (const i of t) {
+                        const {
+                            id: t
+                        } = i.root;
+                        let r = e[t];
+                        if (!r) {
+                            if (++n > 4) {
+                                ta.warn("Too many mask layers. The max supported is 4")();
+                                continue
+                            }
+                            r = {
+                                id: t,
+                                index: this.channels.findIndex((e => (null == e ? void 0 : e.id) === t)),
+                                layers: [],
+                                layerBounds: [],
+                                coordinateOrigin: i.root.props.coordinateOrigin,
+                                coordinateSystem: i.root.props.coordinateSystem
+                            }, e[t] = r
+                        }
+                        r.layers.push(i), r.layerBounds.push(i.getBounds())
+                    }
+                    for (let t = 0; t < 4; t++) {
+                        const n = this.channels[t];
+                        n && n.id in e || (this.channels[t] = null)
+                    }
+                    for (const t in e) {
+                        const n = e[t];
+                        n.index < 0 && (n.index = this.channels.findIndex((t => !t)), this.channels[n.index] = n)
+                    }
+                    return e
+                }
+                getModuleParameters() {
+                    return {
+                        maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
+                        maskChannels: this.masks
                     }
                 }
+                cleanup() {
+                    this.dummyMaskMap && (this.dummyMaskMap.delete(), this.dummyMaskMap = void 0), this.maskPass && (this.maskPass.delete(), this.maskPass = void 0, this.maskMap = void 0), this.lastViewport = void 0, this.masks = null, this.channels.length = 0
+                }
+            }
+            const Rg = new Eg;
+            class Ig {
+                constructor() {
+                    wo(this, "effects", void 0), wo(this, "_internalEffects", void 0), wo(this, "_needsRedraw", void 0), this.effects = [], this._internalEffects = [], this._needsRedraw = "Initial render", this.setEffects()
+                }
                 setProps(t) {
-                    "effects" in t && (Sf(t.effects, this.effects, 1) || this._setEffects(t.effects))
+                    "effects" in t && (t.effects.length === this.effects.length && Pf(t.effects, this.effects) || (this.setEffects(t.effects), this._needsRedraw = "effects changed"))
                 }
                 needsRedraw(t = {
                     clearRedrawFlags: !1
                 }) {
                     const e = this._needsRedraw;
                     return t.clearRedrawFlags && (this._needsRedraw = !1), e
                 }
                 getEffects() {
-                    return this._resolvedEffects
-                }
-                _setEffects(t) {
-                    const e = {};
-                    for (const t of this.effects) e[t.id] = t;
-                    const n = [];
-                    for (const i of t) {
-                        const t = e[i.id];
-                        t && t !== i ? t.setProps ? (t.setProps(i.props), n.push(t)) : (t.cleanup(), n.push(i)) : n.push(i), delete e[i.id]
-                    }
-                    for (const t in e) e[t].cleanup();
-                    this.effects = n, this._resolvedEffects = n.concat(this._defaultEffects), t.some((t => t instanceof wg)) || this._resolvedEffects.push(Eg), this._needsRedraw = "effects changed"
+                    return this._internalEffects
                 }
                 finalize() {
-                    for (const t of this._resolvedEffects) t.cleanup();
-                    this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0
+                    this.cleanup()
+                }
+                setEffects(t = []) {
+                    this.cleanup(), this.effects = t, this._internalEffects = t.slice(), this._internalEffects.push(new kg), t.some((t => t instanceof Eg)) || this._internalEffects.push(Rg)
+                }
+                cleanup() {
+                    for (const t of this.effects) t.cleanup();
+                    for (const t of this._internalEffects) t.cleanup();
+                    this.effects.length = 0, this._internalEffects.length = 0
                 }
             }
-            class Sg extends ug {
+            class jg extends dg {
                 shouldDrawLayer(t) {
-                    const {
-                        operation: e
-                    } = t.props;
-                    return e.includes("draw") || e.includes("terrain")
+                    return t.props.operation === Lh
                 }
             }
-            const Cg = {
+            const Fg = {
                 blendFunc: [1, 0, 32771, 0],
                 blendEquation: 32774
             };
-            class Tg extends ug {
+            class zg extends dg {
                 constructor(...t) {
-                    super(...t), wo(this, "pickZ", void 0), wo(this, "_colorEncoderState", null)
+                    super(...t), wo(this, "pickZ", void 0), wo(this, "_colors", null)
                 }
                 render(t) {
-                    return "pickingFBO" in t ? this._drawPickingBuffer(t) : super.render(t)
+                    return t.pickingFBO ? this._drawPickingBuffer(t) : super.render(t)
                 }
                 _drawPickingBuffer({
                     layers: t,
                     layerFilter: e,
                     views: n,
                     viewports: i,
                     onViewportActive: r,
@@ -15980,121 +16609,102 @@
                         y: a,
                         width: l,
                         height: c
                     },
                     cullRect: h,
                     effects: u,
                     pass: d = "picking",
-                    pickZ: p,
-                    moduleParameters: f
+                    pickZ: p
                 }) {
-                    const g = this.gl;
+                    const f = this.gl;
                     this.pickZ = p;
-                    const m = this._resetColorEncoder(p),
-                        v = ud(g, {
-                            scissorTest: !0,
-                            scissor: [o, a, l, c],
-                            clearColor: [0, 0, 0, 0],
-                            depthMask: !0,
-                            depthTest: !0,
-                            depthRange: [0, 1],
-                            colorMask: [!0, !0, !0, !0],
-                            ...Cg,
-                            blend: !p
-                        }, (() => super.render({
-                            target: s,
-                            layers: t,
-                            layerFilter: e,
-                            views: n,
-                            viewports: i,
-                            onViewportActive: r,
-                            cullRect: h,
-                            effects: null == u ? void 0 : u.filter((t => t.useInPicking)),
-                            pass: d,
-                            isPicking: !0,
-                            moduleParameters: f
-                        })));
-                    return this._colorEncoderState = null, {
-                        decodePickingColor: m && Ag.bind(null, m),
-                        stats: v
+                    const g = p ? null : {
+                        byLayer: new Map,
+                        byAlpha: []
+                    };
+                    this._colors = g;
+                    const m = cd(f, {
+                        scissorTest: !0,
+                        scissor: [o, a, l, c],
+                        clearColor: [0, 0, 0, 0],
+                        depthMask: !0,
+                        depthTest: !0,
+                        depthRange: [0, 1],
+                        colorMask: [!0, !0, !0, !0],
+                        ...Fg,
+                        blend: !p
+                    }, (() => super.render({
+                        target: s,
+                        layers: t,
+                        layerFilter: e,
+                        views: n,
+                        viewports: i,
+                        onViewportActive: r,
+                        cullRect: h,
+                        effects: null == u ? void 0 : u.filter((t => t.useInPicking)),
+                        pass: d
+                    })));
+                    return this._colors = null, {
+                        decodePickingColor: g && Bg.bind(null, g),
+                        stats: m
                     }
                 }
                 shouldDrawLayer(t) {
-                    const {
-                        pickable: e,
-                        operation: n
-                    } = t.props;
-                    return e && n.includes("draw") || n.includes("terrain")
+                    return t.props.pickable && t.props.operation === Lh
                 }
                 getModuleParameters() {
                     return {
                         pickingActive: 1,
                         pickingAttribute: this.pickZ,
                         lightSources: {}
                     }
                 }
                 getLayerParameters(t, e, n) {
                     const i = {
-                            ...t.props.parameters
-                        },
-                        {
-                            pickable: r,
-                            operation: s
-                        } = t.props;
-                    return this._colorEncoderState ? r && s.includes("draw") && (Object.assign(i, Cg), i.blend = !0, i.blendColor = function(t, e, n) {
+                        ...t.props.parameters
+                    };
+                    return this._colors ? (Object.assign(i, Fg), i.blend = !0, i.blendColor = function(t, e, n) {
                         const {
                             byLayer: i,
                             byAlpha: r
                         } = t;
                         let s, o = i.get(e);
                         return o ? (o.viewports.push(n), s = o.a) : (s = i.size + 1, s <= 255 ? (o = {
                             a: s,
                             layer: e,
                             viewports: [n]
-                        }, i.set(e, o), r[s] = o) : (na.warn("Too many pickable layers, only picking the first 255")(), s = 0)), [0, 0, 0, s / 255]
-                    }(this._colorEncoderState, t, n)) : i.blend = !1, s.includes("terrain") && (i.blend = !1), i
-                }
-                _resetColorEncoder(t) {
-                    return this._colorEncoderState = t ? null : {
-                        byLayer: new Map,
-                        byAlpha: []
-                    }, this._colorEncoderState
+                        }, i.set(e, o), r[s] = o) : (ta.warn("Too many pickable layers, only picking the first 255")(), s = 0)), [0, 0, 0, s / 255]
+                    }(this._colors, t, n)) : i.blend = !1, i
                 }
             }
 
-            function Ag(t, e) {
+            function Bg(t, e) {
                 const n = t.byAlpha[e[3]];
                 return n && {
                     pickedLayer: n.layer,
                     pickedViewports: n.viewports,
                     pickedObjectIndex: n.layer.decodePickingColor(e)
                 }
             }
-            class Mg {
+            class Dg {
                 constructor(t) {
-                    wo(this, "gl", void 0), wo(this, "layerFilter", void 0), wo(this, "drawPickingColors", void 0), wo(this, "drawLayersPass", void 0), wo(this, "pickLayersPass", void 0), wo(this, "renderCount", void 0), wo(this, "_needsRedraw", void 0), wo(this, "renderBuffers", void 0), wo(this, "lastPostProcessEffect", void 0), this.gl = t, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new Sg(t), this.pickLayersPass = new Tg(t), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null
+                    this.gl = t, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new jg(t), this.pickLayersPass = new zg(t), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null
                 }
                 setProps(t) {
-                    this.layerFilter !== t.layerFilter && (this.layerFilter = t.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== t.drawPickingColors && (this.drawPickingColors = t.drawPickingColors, this._needsRedraw = "drawPickingColors changed")
+                    "layerFilter" in t && this.layerFilter !== t.layerFilter && (this.layerFilter = t.layerFilter, this._needsRedraw = "layerFilter changed"), "drawPickingColors" in t && this.drawPickingColors !== t.drawPickingColors && (this.drawPickingColors = t.drawPickingColors, this._needsRedraw = "drawPickingColors changed")
                 }
                 renderLayers(t) {
-                    const e = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass,
-                        n = {
-                            layerFilter: this.layerFilter,
-                            isPicking: this.drawPickingColors,
+                    const e = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
+                    t.layerFilter = t.layerFilter || this.layerFilter, t.effects = t.effects || [], t.target = t.target || vp.getDefaultFramebuffer(this.gl), this._preRender(t.effects, t);
+                    const n = this.lastPostProcessEffect ? this.renderBuffers[0] : t.target,
+                        i = e.render({
                             ...t,
-                            target: t.target || bp.getDefaultFramebuffer(this.gl)
-                        };
-                    n.effects && this._preRender(n.effects, n);
-                    const i = this.lastPostProcessEffect ? this.renderBuffers[0] : n.target,
-                        r = e.render({
-                            ...n,
-                            target: i
+                            target: n
                         });
-                    n.effects && this._postRender(n.effects, n), this.renderCount++, sa("deckRenderer.renderLayers", this, r, t)
+                    this._postRender(t.effects, t), this.renderCount++, na("deckRenderer.renderLayers", this, i, t)
                 }
                 needsRedraw(t = {
                     clearRedrawFlags: !1
                 }) {
                     const e = this._needsRedraw;
                     return t.clearRedrawFlags && (this._needsRedraw = !1), e
                 }
@@ -16102,51 +16712,50 @@
                     const {
                         renderBuffers: t
                     } = this;
                     for (const e of t) e.delete();
                     t.length = 0
                 }
                 _preRender(t, e) {
-                    this.lastPostProcessEffect = null, e.preRenderStats = e.preRenderStats || {};
-                    for (const n of t) e.preRenderStats[n.id] = n.preRender(this.gl, e), n.postRender && (this.lastPostProcessEffect = n.id);
-                    this.lastPostProcessEffect && this._resizeRenderBuffers()
+                    let n = null;
+                    for (const i of t) i.preRender(this.gl, e), i.postRender && (n = i);
+                    n && this._resizeRenderBuffers(), this.lastPostProcessEffect = n
                 }
                 _resizeRenderBuffers() {
                     const {
                         renderBuffers: t
                     } = this;
-                    0 === t.length && t.push(new bp(this.gl), new bp(this.gl));
+                    0 === t.length && t.push(new vp(this.gl), new vp(this.gl));
                     for (const e of t) e.resize()
                 }
                 _postRender(t, e) {
                     const {
                         renderBuffers: n
                     } = this, i = {
-                        ...e,
                         inputBuffer: n[0],
                         swapBuffer: n[1],
                         target: null
                     };
                     for (const r of t)
                         if (r.postRender) {
-                            if (r.id === this.lastPostProcessEffect) {
+                            if (r === this.lastPostProcessEffect) {
                                 i.target = e.target, r.postRender(this.gl, i);
                                 break
                             }
                             const t = r.postRender(this.gl, i);
                             i.inputBuffer = t, i.swapBuffer = t === n[0] ? n[1] : n[0]
                         }
                 }
             }
-            const Og = {
+            const Ng = {
                 pickedColor: null,
                 pickedObjectIndex: -1
             };
 
-            function Lg({
+            function Vg({
                 pickedColors: t,
                 decodePickingColor: e,
                 deviceX: n,
                 deviceY: i,
                 deviceRadius: r,
                 deviceRect: s
             }) {
@@ -16182,20 +16791,20 @@
                         return {
                             ...i,
                             pickedColor: n,
                             pickedX: o + e,
                             pickedY: a + t
                         }
                     }
-                    na.error("Picked non-existent layer. Is picking buffer corrupt?")()
+                    ta.error("Picked non-existent layer. Is picking buffer corrupt?")()
                 }
-                return Og
+                return Ng
             }
 
-            function Rg({
+            function Ug({
                 pickInfo: t,
                 viewports: e,
                 pixelRatio: n,
                 x: i,
                 y: r,
                 z: s
             }) {
@@ -16224,15 +16833,15 @@
                     pixel: [i, r],
                     coordinate: o,
                     devicePixel: t && "pickedX" in t ? [t.pickedX, t.pickedY] : void 0,
                     pixelRatio: n
                 }
             }
 
-            function Ig(t) {
+            function Gg(t) {
                 const {
                     pickInfo: e,
                     lastPickedInfo: n,
                     mode: i,
                     layers: r
                 } = t, {
                     pickedColor: s,
@@ -16247,48 +16856,48 @@
                         if (i !== e) {
                             const t = r.find((t => t.props.id === e));
                             t && l.unshift(t)
                         }
                         n.layerId = i, n.index = a, n.info = null
                     }
                 }
-                const c = Rg(t),
+                const c = Ug(t),
                     h = new Map;
                 return h.set(null, c), l.forEach((t => {
                     let e = {
                         ...c
                     };
-                    t === o && (e.color = s, e.index = a, e.picked = !0), e = kg({
+                    t === o && (e.color = s, e.index = a, e.picked = !0), e = Wg({
                         layer: t,
                         info: e,
                         mode: i
                     });
                     const r = e.layer;
                     t === o && "hover" === i && (n.info = e), h.set(r.id, e), "hover" === i && r.updateAutoHighlight(e)
                 })), h
             }
 
-            function kg({
+            function Wg({
                 layer: t,
                 info: e,
                 mode: n
             }) {
                 for (; t && e;) {
                     const i = e.layer || null;
                     e.sourceLayer = i, e.layer = t, e = t.getPickingInfo({
                         info: e,
                         mode: n,
                         sourceLayer: i
                     }), t = t.parent
                 }
                 return e
             }
-            class jg {
+            class Hg {
                 constructor(t) {
-                    wo(this, "gl", void 0), wo(this, "pickingFBO", void 0), wo(this, "depthFBO", void 0), wo(this, "pickLayersPass", void 0), wo(this, "layerFilter", void 0), wo(this, "lastPickedInfo", void 0), wo(this, "_pickable", !0), this.gl = t, this.pickLayersPass = new Tg(t), this.lastPickedInfo = {
+                    wo(this, "gl", void 0), wo(this, "pickingFBO", void 0), wo(this, "depthFBO", void 0), wo(this, "pickLayersPass", void 0), wo(this, "layerFilter", void 0), wo(this, "lastPickedInfo", void 0), wo(this, "_pickable", !0), this.gl = t, this.pickLayersPass = new zg(t), this.lastPickedInfo = {
                         index: -1,
                         layerId: null,
                         info: null
                     }
                 }
                 setProps(t) {
                     "layerFilter" in t && (this.layerFilter = t.layerFilter), "_pickable" in t && (this._pickable = t._pickable)
@@ -16326,36 +16935,36 @@
                     }
                 }
                 _resizeBuffer() {
                     var t, e;
                     const {
                         gl: n
                     } = this;
-                    if (!this.pickingFBO && (this.pickingFBO = new bp(n), bp.isSupported(n, {
+                    if (!this.pickingFBO && (this.pickingFBO = new vp(n), vp.isSupported(n, {
                             colorBufferFloat: !0
                         }))) {
-                        const t = new bp(n);
+                        const t = new vp(n);
                         t.attach({
-                            36064: new Qd(n, {
-                                format: Lu(n) ? 34836 : 6408,
+                            36064: new Kd(n, {
+                                format: Mu(n) ? 34836 : 6408,
                                 type: 5126
                             })
                         }), this.depthFBO = t
                     }
                     null === (t = this.pickingFBO) || void 0 === t || t.resize({
                         width: n.canvas.width,
                         height: n.canvas.height
                     }), null === (e = this.depthFBO) || void 0 === e || e.resize({
                         width: n.canvas.width,
                         height: n.canvas.height
                     })
                 }
                 _getPickable(t) {
                     if (!1 === this._pickable) return null;
-                    const e = t.filter((t => this.pickLayersPass.shouldDrawLayer(t) && !t.isComposite));
+                    const e = t.filter((t => t.isPickable() && !t.isComposite));
                     return e.length ? e : null
                 }
                 _pickClosestObject({
                     layers: t,
                     views: e,
                     viewports: n,
                     x: i,
@@ -16364,26 +16973,26 @@
                     depth: o = 1,
                     mode: a = "query",
                     unproject3D: l,
                     onViewportActive: c,
                     effects: h
                 }) {
                     const u = this._getPickable(t),
-                        d = dd(this.gl);
+                        d = hd(this.gl);
                     if (!u) return {
                         result: [],
-                        emptyInfo: Rg({
+                        emptyInfo: Ug({
                             viewports: n,
                             x: i,
                             y: r,
                             pixelRatio: d
                         })
                     };
                     this._resizeBuffer();
-                    const p = pd(this.gl, [i, r], !0),
+                    const p = ud(this.gl, [i, r], !0),
                         f = [p.x + Math.floor(p.width / 2), p.y + Math.floor(p.height / 2)],
                         g = Math.round(s * d),
                         {
                             width: m,
                             height: v
                         } = this.pickingFBO,
                         b = this._getPickingRect({
@@ -16400,53 +17009,47 @@
                             height: 2 * s + 1
                         };
                     let _;
                     const x = [],
                         w = new Set;
                     for (let t = 0; t < o; t++) {
                         let s, p;
-                        if (s = b ? Lg({
-                                ...this._drawAndSample({
-                                    layers: u,
-                                    views: e,
-                                    viewports: n,
-                                    onViewportActive: c,
-                                    deviceRect: b,
-                                    cullRect: y,
-                                    effects: h,
-                                    pass: "picking:".concat(a)
-                                }),
-                                deviceX: f[0],
-                                deviceY: f[1],
-                                deviceRadius: g,
-                                deviceRect: b
-                            }) : {
-                                pickedColor: null,
-                                pickedObjectIndex: -1
-                            }, s.pickedLayer && l && this.depthFBO) {
-                            const {
-                                pickedColors: t
-                            } = this._drawAndSample({
-                                layers: [s.pickedLayer],
+                        s = b ? Vg({
+                            ...this._drawAndSample({
+                                layers: u,
                                 views: e,
                                 viewports: n,
                                 onViewportActive: c,
-                                deviceRect: {
-                                    x: s.pickedX,
-                                    y: s.pickedY,
-                                    width: 1,
-                                    height: 1
-                                },
+                                deviceRect: b,
                                 cullRect: y,
                                 effects: h,
-                                pass: "picking:".concat(a, ":z")
-                            }, !0);
-                            t[3] && (p = t[0])
-                        }
-                        s.pickedLayer && t + 1 < o && (w.add(s.pickedLayer), s.pickedLayer.disablePickingIndex(s.pickedObjectIndex)), _ = Ig({
+                                pass: "picking:".concat(a)
+                            }),
+                            deviceX: f[0],
+                            deviceY: f[1],
+                            deviceRadius: g,
+                            deviceRect: b
+                        }) : {
+                            pickedColor: null,
+                            pickedObjectIndex: -1
+                        }, s.pickedLayer && l && this.depthFBO && (p = this._drawAndSample({
+                            layers: [s.pickedLayer],
+                            views: e,
+                            viewports: n,
+                            onViewportActive: c,
+                            deviceRect: {
+                                x: s.pickedX,
+                                y: s.pickedY,
+                                width: 1,
+                                height: 1
+                            },
+                            cullRect: y,
+                            effects: h,
+                            pass: "picking:".concat(a, ":z")
+                        }, !0).pickedColors[0]), s.pickedLayer && t + 1 < o && (w.add(s.pickedLayer), s.pickedLayer.disablePickingIndex(s.pickedObjectIndex)), _ = Gg({
                             pickInfo: s,
                             lastPickedInfo: this.lastPickedInfo,
                             mode: a,
                             layers: u,
                             viewports: n,
                             x: i,
                             y: r,
@@ -16474,19 +17077,19 @@
                     maxObjects: l = null,
                     onViewportActive: c,
                     effects: h
                 }) {
                     const u = this._getPickable(t);
                     if (!u) return [];
                     this._resizeBuffer();
-                    const d = dd(this.gl),
-                        p = pd(this.gl, [i, r], !0),
+                    const d = hd(this.gl),
+                        p = ud(this.gl, [i, r], !0),
                         f = p.x,
                         g = p.y + p.height,
-                        m = pd(this.gl, [i + s, r + o], !0),
+                        m = ud(this.gl, [i + s, r + o], !0),
                         v = m.x + m.width,
                         b = m.y,
                         y = {
                             x: f,
                             y: b,
                             width: v - f,
                             height: g - b
@@ -16502,15 +17105,15 @@
                                         const r = t.slice(i, i + 4),
                                             s = r.join(",");
                                         if (!n.has(s)) {
                                             const t = e(r);
                                             t ? n.set(s, {
                                                 ...t,
                                                 color: r
-                                            }) : na.error("Picked non-existent layer. Is picking buffer corrupt?")()
+                                            }) : ta.error("Picked non-existent layer. Is picking buffer corrupt?")()
                                         }
                                     } return Array.from(n.values())
                         }(this._drawAndSample({
                             layers: u,
                             views: e,
                             viewports: n,
                             onViewportActive: c,
@@ -16533,15 +17136,15 @@
                             layer: null,
                             index: e.pickedObjectIndex,
                             picked: !0,
                             x: i,
                             y: r,
                             pixelRatio: d
                         };
-                        n = kg({
+                        n = Wg({
                             layer: e.pickedLayer,
                             info: n,
                             mode: a
                         }), x.has(n.object) || x.set(n.object, n)
                     }
                     return Array.from(x.values())
                 }
@@ -16552,46 +17155,45 @@
                     onViewportActive: i,
                     deviceRect: r,
                     cullRect: s,
                     effects: o,
                     pass: a
                 }, l = !1) {
                     const c = l ? this.depthFBO : this.pickingFBO,
-                        h = {
+                        {
+                            decodePickingColor: h
+                        } = this.pickLayersPass.render({
                             layers: t,
                             layerFilter: this.layerFilter,
                             views: e,
                             viewports: n,
                             onViewportActive: i,
                             pickingFBO: c,
                             deviceRect: r,
                             cullRect: s,
                             effects: o,
                             pass: a,
-                            pickZ: l,
-                            preRenderStats: {}
-                        };
-                    for (const t of o) t.useInPicking && (h.preRenderStats[t.id] = t.preRender(this.gl, h));
-                    const {
-                        decodePickingColor: u
-                    } = this.pickLayersPass.render(h), {
-                        x: d,
-                        y: p,
-                        width: f,
-                        height: g
-                    } = r, m = new(l ? Float32Array : Uint8Array)(f * g * 4);
-                    return lp(c, {
-                        sourceX: d,
-                        sourceY: p,
-                        sourceWidth: f,
-                        sourceHeight: g,
-                        target: m
+                            pickZ: l
+                        }),
+                        {
+                            x: u,
+                            y: d,
+                            width: p,
+                            height: f
+                        } = r,
+                        g = new(l ? Float32Array : Uint8Array)(p * f * 4);
+                    return ap(c, {
+                        sourceX: u,
+                        sourceY: d,
+                        sourceWidth: p,
+                        sourceHeight: f,
+                        target: g
                     }), {
-                        pickedColors: m,
-                        decodePickingColor: u
+                        pickedColors: g,
+                        decodePickingColor: h
                     }
                 }
                 _getPickingRect({
                     deviceX: t,
                     deviceY: e,
                     deviceRadius: n,
                     deviceWidth: i,
@@ -16605,30 +17207,30 @@
                         x: s,
                         y: o,
                         width: a,
                         height: l
                     }
                 }
             }
-            const Fg = {
+            const Zg = {
                 zIndex: "1",
                 position: "absolute",
                 pointerEvents: "none",
                 color: "#a0a7b4",
                 backgroundColor: "#29323c",
                 padding: "10px",
                 top: "0",
                 left: "0",
                 display: "none"
             };
-            class zg {
+            class qg {
                 constructor(t) {
                     wo(this, "el", null), wo(this, "isVisible", !1);
                     const e = t.parentElement;
-                    e && (this.el = document.createElement("div"), this.el.className = "deck-tooltip", Object.assign(this.el.style, Fg), e.appendChild(this.el))
+                    e && (this.el = document.createElement("div"), this.el.className = "deck-tooltip", Object.assign(this.el.style, Zg), e.appendChild(this.el))
                 }
                 setTooltip(t, e, n) {
                     const i = this.el;
                     if (i) {
                         if ("string" == typeof t) i.innerText = t;
                         else {
                             if (!t) return this.isVisible = !1, void(i.style.display = "none");
@@ -16638,47 +17240,47 @@
                     }
                 }
                 remove() {
                     this.el && (this.el.remove(), this.el = null)
                 }
             }
             const {
-                _parseImageNode: Bg
-            } = globalThis, Dg = "undefined" != typeof Image, Ng = "undefined" != typeof ImageBitmap, Vg = Boolean(Bg), Ug = !!ol || Vg;
+                _parseImageNode: Xg
+            } = globalThis, Yg = "undefined" != typeof Image, Kg = "undefined" != typeof ImageBitmap, Qg = Boolean(Xg), Jg = !!il || Qg;
 
-            function Gg(t) {
+            function $g(t) {
                 const e = function(t) {
                     return "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? "imagebitmap" : "undefined" != typeof Image && t instanceof Image ? "image" : t && "object" == typeof t && t.data && t.width && t.height ? "data" : null
                 }(t);
                 if (!e) throw new Error("Not an image");
                 return e
             }
-            const Wg = /^data:image\/svg\+xml/,
-                Hg = /\.svg((\?|#).*)?$/;
+            const tm = /^data:image\/svg\+xml/,
+                em = /\.svg((\?|#).*)?$/;
 
-            function Zg(t) {
-                return t && (Wg.test(t) || Hg.test(t))
+            function nm(t) {
+                return t && (tm.test(t) || em.test(t))
             }
 
-            function qg(t, e) {
-                if (Zg(e)) throw new Error("SVG cannot be parsed directly to imagebitmap");
+            function im(t, e) {
+                if (nm(e)) throw new Error("SVG cannot be parsed directly to imagebitmap");
                 return new Blob([new Uint8Array(t)])
             }
-            async function Xg(t, e, n) {
+            async function rm(t, e, n) {
                 const i = function(t, e) {
-                        if (Zg(e)) {
+                        if (nm(e)) {
                             let e = (new TextDecoder).decode(t);
                             try {
                                 "function" == typeof unescape && "function" == typeof encodeURIComponent && (e = unescape(encodeURIComponent(e)))
                             } catch (t) {
                                 throw new Error(t.message)
                             }
                             return "data:image/svg+xml;base64,".concat(btoa(e))
                         }
-                        return qg(t, e)
+                        return im(t, e)
                     }(t, n),
                     r = self.URL || self.webkitURL,
                     s = "string" != typeof i && r.createObjectURL(i);
                 try {
                     return await async function(t, e) {
                         const n = new Image;
                         return n.src = t, e.image && e.image.decode && n.decode ? (await n.decode(), n) : await new Promise(((e, i) => {
@@ -16689,67 +17291,67 @@
                             }
                         }))
                     }(s || i, e)
                 } finally {
                     s && r.revokeObjectURL(s)
                 }
             }
-            const Yg = {};
-            let Kg = !0;
-            const Qg = !1,
-                Jg = !0;
+            const sm = {};
+            let om = !0;
+            const am = !1,
+                lm = !0;
 
-            function $g(t) {
-                const e = tm(t);
+            function cm(t) {
+                const e = hm(t);
                 return function(t) {
-                    const e = tm(t);
-                    return e.byteLength >= 24 && 2303741511 === e.getUint32(0, Qg) ? {
+                    const e = hm(t);
+                    return e.byteLength >= 24 && 2303741511 === e.getUint32(0, am) ? {
                         mimeType: "image/png",
-                        width: e.getUint32(16, Qg),
-                        height: e.getUint32(20, Qg)
+                        width: e.getUint32(16, am),
+                        height: e.getUint32(20, am)
                     } : null
                 }(e) || function(t) {
-                    const e = tm(t);
-                    if (!(e.byteLength >= 3 && 65496 === e.getUint16(0, Qg) && 255 === e.getUint8(2))) return null;
+                    const e = hm(t);
+                    if (!(e.byteLength >= 3 && 65496 === e.getUint16(0, am) && 255 === e.getUint8(2))) return null;
                     const {
                         tableMarkers: n,
                         sofMarkers: i
                     } = function() {
                         const t = new Set([65499, 65476, 65484, 65501, 65534]);
                         for (let e = 65504; e < 65520; ++e) t.add(e);
                         return {
                             tableMarkers: t,
                             sofMarkers: new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])
                         }
                     }();
                     let r = 2;
                     for (; r + 9 < e.byteLength;) {
-                        const t = e.getUint16(r, Qg);
+                        const t = e.getUint16(r, am);
                         if (i.has(t)) return {
                             mimeType: "image/jpeg",
-                            height: e.getUint16(r + 5, Qg),
-                            width: e.getUint16(r + 7, Qg)
+                            height: e.getUint16(r + 5, am),
+                            width: e.getUint16(r + 7, am)
                         };
                         if (!n.has(t)) return null;
-                        r += 2, r += e.getUint16(r, Qg)
+                        r += 2, r += e.getUint16(r, am)
                     }
                     return null
                 }(e) || function(t) {
-                    const e = tm(t);
-                    return e.byteLength >= 10 && 1195984440 === e.getUint32(0, Qg) ? {
+                    const e = hm(t);
+                    return e.byteLength >= 10 && 1195984440 === e.getUint32(0, am) ? {
                         mimeType: "image/gif",
-                        width: e.getUint16(6, Jg),
-                        height: e.getUint16(8, Jg)
+                        width: e.getUint16(6, lm),
+                        height: e.getUint16(8, lm)
                     } : null
                 }(e) || function(t) {
-                    const e = tm(t);
-                    return e.byteLength >= 14 && 16973 === e.getUint16(0, Qg) && e.getUint32(2, Jg) === e.byteLength ? {
+                    const e = hm(t);
+                    return e.byteLength >= 14 && 16973 === e.getUint16(0, am) && e.getUint32(2, lm) === e.byteLength ? {
                         mimeType: "image/bmp",
-                        width: e.getUint32(18, Jg),
-                        height: e.getUint32(22, Jg)
+                        width: e.getUint32(18, lm),
+                        height: e.getUint32(22, lm)
                     } : null
                 }(e) || function(t) {
                     const e = function(t) {
                         return function(t, e) {
                             let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                             const i = (r = e, [...r].map((t => t.charCodeAt(0))));
                             var r;
@@ -16773,21 +17375,21 @@
                         mimeType: e.mimeType,
                         width: 0,
                         height: 0
                     } : null
                 }(e)
             }
 
-            function tm(t) {
+            function hm(t) {
                 if (t instanceof DataView) return t;
                 if (ArrayBuffer.isView(t)) return new DataView(t.buffer);
                 if (t instanceof ArrayBuffer) return new DataView(t);
                 throw new Error("toDataView")
             }
-            const em = {
+            const um = {
                     id: "image",
                     module: "images",
                     name: "Images",
                     version: "3.4.4",
                     mimeTypes: ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"],
                     extensions: ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"],
                     parse: async function(t, e, n) {
@@ -16797,160 +17399,161 @@
                             } = n || {};
                         let s;
                         switch (function(t) {
                                 switch (t) {
                                     case "auto":
                                     case "data":
                                         return function() {
-                                            if (Ng) return "imagebitmap";
-                                            if (Dg) return "image";
-                                            if (Ug) return "data";
+                                            if (Kg) return "imagebitmap";
+                                            if (Yg) return "image";
+                                            if (Jg) return "data";
                                             throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js")
                                         }();
                                     default:
                                         return function(t) {
                                             switch (t) {
                                                 case "auto":
-                                                    return Ng || Dg || Ug;
+                                                    return Kg || Yg || Jg;
                                                 case "imagebitmap":
-                                                    return Ng;
+                                                    return Kg;
                                                 case "image":
-                                                    return Dg;
+                                                    return Yg;
                                                 case "data":
-                                                    return Ug;
+                                                    return Jg;
                                                 default:
                                                     throw new Error("@loaders.gl/images: image ".concat(t, " not supported in this environment"))
                                             }
                                         }(t), t
                                 }
                             }(i)) {
                             case "imagebitmap":
                                 s = await async function(t, e, n) {
                                     let i;
-                                    i = Zg(n) ? await Xg(t, e, n) : qg(t, n);
+                                    i = nm(n) ? await rm(t, e, n) : im(t, n);
                                     const r = e && e.imagebitmap;
                                     return await async function(t) {
                                         let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                                         if (! function(t) {
-                                                for (const e in t || Yg) return !1;
+                                                for (const e in t || sm) return !1;
                                                 return !0
-                                            }(e) && Kg || (e = null), e) try {
+                                            }(e) && om || (e = null), e) try {
                                             return await createImageBitmap(t, e)
                                         } catch (t) {
-                                            console.warn(t), Kg = !1
+                                            console.warn(t), om = !1
                                         }
                                         return await createImageBitmap(t)
                                     }(i, r)
                                 }(t, e, r);
                                 break;
                             case "image":
-                                s = await Xg(t, e, r);
+                                s = await rm(t, e, r);
                                 break;
                             case "data":
                                 s = await async function(t, e) {
                                     const {
                                         mimeType: n
-                                    } = $g(t) || {}, i = globalThis._parseImageNode;
-                                    return wa(i), await i(t, n)
+                                    } = cm(t) || {}, i = globalThis._parseImageNode;
+                                    return ya(i), await i(t, n)
                                 }(t);
                                 break;
                             default:
-                                wa(!1)
+                                ya(!1)
                         }
                         return "data" === i && (s = function(t) {
-                            switch (Gg(t)) {
+                            switch ($g(t)) {
                                 case "data":
                                     return t;
                                 case "image":
                                 case "imagebitmap":
                                     const e = document.createElement("canvas"),
                                         n = e.getContext("2d");
                                     if (!n) throw new Error("getImageData");
                                     return e.width = t.width, e.height = t.height, n.drawImage(t, 0, 0), n.getImageData(0, 0, t.width, t.height);
                                 default:
                                     throw new Error("getImageData")
                             }
                         }(s)), s
                     },
-                    tests: [t => Boolean($g(new DataView(t)))],
+                    tests: [t => Boolean(cm(new DataView(t)))],
                     options: {
                         image: {
                             type: "auto",
                             decode: !0
                         }
                     }
                 },
-                nm = {
+                dm = {
                     id: "JSON",
                     name: "JSON",
                     module: "",
                     version: "",
                     options: {},
                     extensions: ["json", "geojson"],
                     mimeTypes: ["application/json", "application/geo+json"],
                     testText: function(t) {
                         const e = t[0],
                             n = t[t.length - 1];
                         return "{" === e && "}" === n || "[" === e && "]" === n
                     },
                     parseTextSync: JSON.parse
                 },
-                im = function() {
-                    const t = "8.9.16",
-                        e = globalThis.deck && globalThis.deck.VERSION;
-                    if (e && e !== t) throw new Error("deck.gl - multiple versions detected: ".concat(e, " vs ").concat(t));
-                    return e || (na.log(1, "deck.gl ".concat(t))(), globalThis.deck = {
-                        ...globalThis.deck,
-                        VERSION: t,
-                        version: t,
-                        log: na,
-                        _registerLoggers: ra
-                    }, function(t) {
-                        const e = Hl();
-                        t = Array.isArray(t) ? t : [t];
-                        for (const n of t) {
-                            const t = Pa(n);
-                            e.find((e => t === e)) || e.unshift(t)
-                        }
-                    }([nm, [em, {
-                        imagebitmap: {
-                            premultiplyAlpha: "none"
-                        }
-                    }]])), t
-                }(),
-                rm = globalThis;
-
-            function sm(t) {
-                if (!t && !jo()) return "Node";
-                if (Io(t)) return "Electron";
+                pm = "8.8.12",
+                fm = globalThis.deck && globalThis.deck.VERSION;
+            if (fm && fm !== pm) throw new Error("deck.gl - multiple versions detected: ".concat(fm, " vs ").concat(pm));
+            fm || (ta.log(1, "deck.gl ".concat(pm))(), globalThis.deck = {
+                ...globalThis.deck,
+                VERSION: pm,
+                version: pm,
+                log: ta,
+                _registerLoggers: function(t) {
+                    ea = t
+                }
+            }, function(t) {
+                const e = Ul();
+                t = Array.isArray(t) ? t : [t];
+                for (const n of t) {
+                    const t = xa(n);
+                    e.find((e => t === e)) || e.unshift(t)
+                }
+            }([dm, [um, {
+                imagebitmap: {
+                    premultiplyAlpha: "none"
+                }
+            }]]));
+            const gm = globalThis.deck,
+                mm = globalThis;
+
+            function vm(t) {
+                if (!t && !Ro()) return "Node";
+                if (Lo(t)) return "Electron";
                 const e = "undefined" != typeof navigator ? navigator : {},
                     n = t || e.userAgent || "";
                 if (n.indexOf("Edge") > -1) return "Edge";
                 const i = -1 !== n.indexOf("MSIE "),
                     r = -1 !== n.indexOf("Trident/");
-                return i || r ? "IE" : rm.chrome ? "Chrome" : rm.safari ? "Safari" : rm.mozInnerScreenX ? "Firefox" : "Unknown"
+                return i || r ? "IE" : mm.chrome ? "Chrome" : mm.safari ? "Safari" : mm.mozInnerScreenX ? "Firefox" : "Unknown"
             }
-            class om extends Rd {
+            class bm extends Ld {
                 get[Symbol.toStringTag]() {
                     return "Query"
                 }
                 static isSupported(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
-                    const n = Lu(t),
-                        i = gp(t, up);
+                    const n = Mu(t),
+                        i = fp(t, hp);
                     let r = n || i;
                     for (const t of e) switch (t) {
                         case "queries":
                             r = r && n;
                             break;
                         case "timers":
                             r = r && i;
                             break;
                         default:
-                            Ed(!1)
+                            wd(!1)
                     }
                     return r
                 }
                 constructor(t) {
                     super(t, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}), this.target = null, this._queryPending = !1, this._pollingPromise = null, Object.seal(this)
                 }
                 beginTimeElapsedQuery() {
@@ -16993,44 +17596,44 @@
                         const r = () => {
                             this.isResultAvailable() ? (n(this.getResult()), this._pollingPromise = null) : e++ > t ? (i("Timed out"), this._pollingPromise = null) : requestAnimationFrame(r)
                         };
                         requestAnimationFrame(r)
                     })), this._pollingPromise
                 }
                 _createHandle() {
-                    return om.isSupported(this.gl) ? this.gl2.createQuery() : null
+                    return bm.isSupported(this.gl) ? this.gl2.createQuery() : null
                 }
                 _deleteHandle() {
                     this.gl2.deleteQuery(this.handle)
                 }
             }
-            const am = jo() && "undefined" != typeof document;
-            let lm = 0;
-            class cm {
+            const ym = Ro() && "undefined" != typeof document;
+            let _m = 0;
+            class xm {
                 constructor() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const {
-                        onCreateContext: e = (t => yd(t)),
+                        onCreateContext: e = (t => vd(t)),
                         onAddHTML: n = null,
                         onInitialize: i = (() => {}),
                         onRender: r = (() => {}),
                         onFinalize: s = (() => {}),
                         onError: o,
                         gl: a = null,
                         glOptions: l = {},
                         debug: c = !1,
                         createFramebuffer: h = !1,
                         autoResizeViewport: u = !0,
                         autoResizeDrawingBuffer: d = !0,
-                        stats: p = wd.get("animation-loop-".concat(lm++))
+                        stats: p = xd.get("animation-loop-".concat(_m++))
                     } = t;
                     let {
                         useDevicePixels: f = !0
                     } = t;
-                    "useDevicePixelRatio" in t && (Tu.deprecated("useDevicePixelRatio", "useDevicePixels")(), f = t.useDevicePixelRatio), this.props = {
+                    "useDevicePixelRatio" in t && (Su.deprecated("useDevicePixelRatio", "useDevicePixels")(), f = t.useDevicePixelRatio), this.props = {
                         onCreateContext: e,
                         onAddHTML: n,
                         onInitialize: i,
                         onRender: r,
                         onFinalize: s,
                         onError: o,
                         gl: a,
@@ -17043,24 +17646,24 @@
                         useDevicePixels: f
                     }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._pageLoadPromise = null, this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this)
                 }
                 delete() {
                     this.stop(), this._setDisplay(null)
                 }
                 setNeedsRedraw(t) {
-                    return Ed("string" == typeof t), this.needsRedraw = this.needsRedraw || t, this
+                    return wd("string" == typeof t), this.needsRedraw = this.needsRedraw || t, this
                 }
                 setProps(t) {
                     return "autoResizeViewport" in t && (this.autoResizeViewport = t.autoResizeViewport), "autoResizeDrawingBuffer" in t && (this.autoResizeDrawingBuffer = t.autoResizeDrawingBuffer), "useDevicePixels" in t && (this.useDevicePixels = t.useDevicePixels), this
                 }
                 start() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     if (this._running) return this;
                     this._running = !0;
-                    const e = this._getPageLoadPromise().then((() => !this._running || this._initialized ? null : (this._createWebGLContext(t), this._createFramebuffer(), this._startEventHandling(), this._initializeCallbackData(), this._updateCallbackData(), this._resizeCanvasDrawingBuffer(), this._resizeViewport(), this._gpuTimeQuery = om.isSupported(this.gl, ["timers"]) ? new om(this.gl) : null, this._initialized = !0, this.onInitialize(this.animationProps)))).then((t => {
+                    const e = this._getPageLoadPromise().then((() => !this._running || this._initialized ? null : (this._createWebGLContext(t), this._createFramebuffer(), this._startEventHandling(), this._initializeCallbackData(), this._updateCallbackData(), this._resizeCanvasDrawingBuffer(), this._resizeViewport(), this._gpuTimeQuery = bm.isSupported(this.gl, ["timers"]) ? new bm(this.gl) : null, this._initialized = !0, this.onInitialize(this.animationProps)))).then((t => {
                         this._running && (this._addCallbackData(t || {}), !1 !== t && this._startLoop())
                     }));
                     return this.props.onError && e.catch(this.props.onError), this
                 }
                 redraw() {
                     return this.isContextLost() || (this._beginTimers(), this._setupFrame(), this._updateCallbackData(), this._renderFrame(this.animationProps), this._clearNeedsRedraw(), this.offScreen && this.gl.commit && this.gl.commit(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endTimers()), this
                 }
@@ -17098,25 +17701,25 @@
                 }
                 getHTMLControlValue(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                     const n = document.getElementById(t);
                     return n ? Number(n.value) : e
                 }
                 setViewParameters() {
-                    return Tu.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")(), this
+                    return Su.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")(), this
                 }
                 _startLoop() {
                     const t = () => {
                         this._running && (this.redraw(), this._animationFrameId = this._requestAnimationFrame(t))
                     };
                     this._cancelAnimationFrame(this._animationFrameId), this._animationFrameId = this._requestAnimationFrame(t)
                 }
                 _getPageLoadPromise() {
-                    return this._pageLoadPromise || (this._pageLoadPromise = am ? new Promise(((t, e) => {
-                        am && "complete" === document.readyState ? t(document) : window.addEventListener("load", (() => {
+                    return this._pageLoadPromise || (this._pageLoadPromise = ym ? new Promise(((t, e) => {
+                        ym && "complete" === document.readyState ? t(document) : window.addEventListener("load", (() => {
                             t(document)
                         }))
                     })) : Promise.resolve({})), this._pageLoadPromise
                 }
                 _setDisplay(t) {
                     this.display && (this.display.delete(), this.display.animationLoop = null), t && (t.animationLoop = this), this.display = t
                 }
@@ -17167,16 +17770,16 @@
                 _finalizeCallbackData() {
                     this.onFinalize(this.animationProps)
                 }
                 _addCallbackData(t) {
                     "object" == typeof t && null !== t && (this.animationProps = Object.assign({}, this.animationProps, t))
                 }
                 _createWebGLContext(t) {
-                    if (this.offScreen = t.canvas && "undefined" != typeof OffscreenCanvas && t.canvas instanceof OffscreenCanvas, t = Object.assign({}, t, this.props.glOptions), this.gl = this.props.gl ? _d(this.props.gl, t) : this.onCreateContext(t), !Ou(this.gl)) throw new Error("AnimationLoop.onCreateContext - illegal context returned");
-                    hd(this.gl, Zu), this._createInfoDiv()
+                    if (this.offScreen = t.canvas && "undefined" != typeof OffscreenCanvas && t.canvas instanceof OffscreenCanvas, t = Object.assign({}, t, this.props.glOptions), this.gl = this.props.gl ? bd(this.props.gl, t) : this.onCreateContext(t), !Au(this.gl)) throw new Error("AnimationLoop.onCreateContext - illegal context returned");
+                    ld(this.gl, Wu), this._createInfoDiv()
                 }
                 _createInfoDiv() {
                     if (this.gl.canvas && this.props.onAddHTML) {
                         const t = document.createElement("div");
                         document.body.appendChild(t), t.style.position = "relative";
                         const e = document.createElement("div");
                         e.style.position = "absolute", e.style.left = "10px", e.style.bottom = "10px", e.style.width = "300px", e.style.background = "white", t.appendChild(this.gl.canvas), t.appendChild(e);
@@ -17203,21 +17806,21 @@
                 _resizeCanvasDrawingBuffer() {
                     this.autoResizeDrawingBuffer && function(t) {
                         let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                         if (t.canvas) return void
                         function(t, e, n) {
                             let i = "width" in n ? n.width : t.canvas.clientWidth,
                                 r = "height" in n ? n.height : t.canvas.clientHeight;
-                            i && r || (Tu.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, i = t.canvas.width || 1, r = t.canvas.height || 1), t.luma = t.luma || {}, t.luma.canvasSizeInfo = t.luma.canvasSizeInfo || {};
+                            i && r || (Su.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, i = t.canvas.width || 1, r = t.canvas.height || 1), t.luma = t.luma || {}, t.luma.canvasSizeInfo = t.luma.canvasSizeInfo || {};
                             const s = t.luma.canvasSizeInfo;
                             if (s.clientWidth !== i || s.clientHeight !== r || s.devicePixelRatio !== e) {
                                 let n = e;
                                 const s = Math.floor(i * n),
                                     o = Math.floor(r * n);
-                                t.canvas.width = s, t.canvas.height = o, t.drawingBufferWidth === s && t.drawingBufferHeight === o || (Tu.warn("Device pixel ratio clamped")(), n = Math.min(t.drawingBufferWidth / i, t.drawingBufferHeight / r), t.canvas.width = Math.floor(i * n), t.canvas.height = Math.floor(r * n)), Object.assign(t.luma.canvasSizeInfo, {
+                                t.canvas.width = s, t.canvas.height = o, t.drawingBufferWidth === s && t.drawingBufferHeight === o || (Su.warn("Device pixel ratio clamped")(), n = Math.min(t.drawingBufferWidth / i, t.drawingBufferHeight / r), t.canvas.width = Math.floor(i * n), t.canvas.height = Math.floor(r * n)), Object.assign(t.luma.canvasSizeInfo, {
                                     clientWidth: i,
                                     clientHeight: r,
                                     devicePixelRatio: e
                                 })
                             }
                         }(t, function(t) {
                             const e = "undefined" == typeof window ? 1 : window.devicePixelRatio || 1;
@@ -17226,15 +17829,15 @@
                         const n = t.getExtension("STACKGL_resize_drawingbuffer");
                         n && "width" in e && "height" in e && n.resize(e.width, e.height)
                     }(this.gl, {
                         useDevicePixels: this.useDevicePixels
                     })
                 }
                 _createFramebuffer() {
-                    this.props.createFramebuffer && (this.framebuffer = new bp(this.gl))
+                    this.props.createFramebuffer && (this.framebuffer = new vp(this.gl))
                 }
                 _resizeFramebuffer() {
                     this.framebuffer && this.framebuffer.resize({
                         width: this.gl.drawingBufferWidth,
                         height: this.gl.drawingBufferHeight
                     })
                 }
@@ -17253,113 +17856,113 @@
                 _onMousemove(t) {
                     this.animationProps._mousePosition = [t.offsetX, t.offsetY]
                 }
                 _onMouseleave(t) {
                     this.animationProps._mousePosition = null
                 }
             }
-            var hm = n(840);
-            const um = {
+            var wm = n(840);
+            const Em = {
                 mousedown: 1,
                 mousemove: 2,
                 mouseup: 4
             };
             ! function(t) {
                 const e = t.prototype.handler;
                 t.prototype.handler = function(t) {
                     const n = this.store;
                     t.button > 0 && "pointerdown" === t.type && (function(e, n) {
                         for (let n = 0; n < e.length; n++)
                             if (e[n].pointerId === t.pointerId) return !0;
                         return !1
                     }(n) || n.push(t)), e.call(this, t)
                 }
-            }(hm.PointerEventInput), hm.MouseInput.prototype.handler = function(t) {
-                let e = um[t.type];
+            }(wm.PointerEventInput), wm.MouseInput.prototype.handler = function(t) {
+                let e = Em[t.type];
                 1 & e && t.button >= 0 && (this.pressed = !0), 2 & e && 0 === t.which && (e = 4), this.pressed && (4 & e && (this.pressed = !1), this.callback(this.manager, e, {
                     pointers: [t],
                     changedPointers: [t],
                     pointerType: "mouse",
                     srcEvent: t
                 }))
             };
-            const dm = hm.Manager,
-                pm = hm;
-            class fm {
+            const Pm = wm.Manager,
+                Sm = wm;
+            class Cm {
                 constructor(t, e, n) {
                     this.element = t, this.callback = e, this.options = {
                         enable: !0,
                         ...n
                     }
                 }
             }
-            const gm = pm ? [
-                    [pm.Pan, {
+            const Tm = Sm ? [
+                    [Sm.Pan, {
                         event: "tripan",
                         pointers: 3,
                         threshold: 0,
                         enable: !1
                     }],
-                    [pm.Rotate, {
+                    [Sm.Rotate, {
                         enable: !1
                     }],
-                    [pm.Pinch, {
+                    [Sm.Pinch, {
                         enable: !1
                     }],
-                    [pm.Swipe, {
+                    [Sm.Swipe, {
                         enable: !1
                     }],
-                    [pm.Pan, {
+                    [Sm.Pan, {
                         threshold: 0,
                         enable: !1
                     }],
-                    [pm.Press, {
+                    [Sm.Press, {
                         enable: !1
                     }],
-                    [pm.Tap, {
+                    [Sm.Tap, {
                         event: "doubletap",
                         taps: 2,
                         enable: !1
                     }],
-                    [pm.Tap, {
+                    [Sm.Tap, {
                         event: "anytap",
                         enable: !1
                     }],
-                    [pm.Tap, {
+                    [Sm.Tap, {
                         enable: !1
                     }]
                 ] : null,
-                mm = {
+                Am = {
                     tripan: ["rotate", "pinch", "pan"],
                     rotate: ["pinch"],
                     pinch: ["pan"],
                     pan: ["press", "doubletap", "anytap", "tap"],
                     doubletap: ["anytap"],
                     anytap: ["tap"]
                 },
-                vm = {
+                Mm = {
                     doubletap: ["tap"]
                 },
-                bm = {
+                Om = {
                     pointerdown: "pointerdown",
                     pointermove: "pointermove",
                     pointerup: "pointerup",
                     touchstart: "pointerdown",
                     touchmove: "pointermove",
                     touchend: "pointerup",
                     mousedown: "pointerdown",
                     mousemove: "pointermove",
                     mouseup: "pointerup"
                 },
-                ym = {
+                Lm = {
                     KEY_EVENTS: ["keydown", "keyup"],
                     MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
                     WHEEL_EVENTS: ["wheel", "mousewheel"]
                 },
-                _m = {
+                km = {
                     tap: "tap",
                     anytap: "anytap",
                     doubletap: "doubletap",
                     press: "press",
                     pinch: "pinch",
                     pinchin: "pinch",
                     pinchout: "pinch",
@@ -17392,110 +17995,110 @@
                     pancancel: "pan",
                     swipe: "swipe",
                     swipeleft: "swipe",
                     swiperight: "swipe",
                     swipeup: "swipe",
                     swipedown: "swipe"
                 },
-                xm = {
+                Rm = {
                     click: "tap",
                     anyclick: "anytap",
                     dblclick: "doubletap",
                     mousedown: "pointerdown",
                     mousemove: "pointermove",
                     mouseup: "pointerup",
                     mouseover: "pointerover",
                     mouseout: "pointerout",
                     mouseleave: "pointerleave"
                 },
-                wm = "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : "",
-                Em = "undefined" != typeof window ? window : n.g;
+                Im = "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : "",
+                jm = "undefined" != typeof window ? window : n.g;
             void 0 !== n.g ? n.g : window, "undefined" != typeof document && document;
-            let Pm = !1;
+            let Fm = !1;
             try {
                 const t = {
                     get passive() {
-                        return Pm = !0, !0
+                        return Fm = !0, !0
                     }
                 };
-                Em.addEventListener("test", null, t), Em.removeEventListener("test", null)
+                jm.addEventListener("test", null, t), jm.removeEventListener("test", null)
             } catch (t) {
-                Pm = !1
+                Fm = !1
             }
-            const Sm = -1 !== wm.indexOf("firefox"),
+            const zm = -1 !== Im.indexOf("firefox"),
                 {
-                    WHEEL_EVENTS: Cm
-                } = ym,
-                Tm = "wheel",
-                Am = 4.000244140625;
-            class Mm extends fm {
+                    WHEEL_EVENTS: Bm
+                } = Lm,
+                Dm = "wheel",
+                Nm = 4.000244140625;
+            class Vm extends Cm {
                 constructor(t, e, n) {
                     super(t, e, n), this.handleEvent = t => {
                         if (!this.options.enable) return;
                         let e = t.deltaY;
-                        Em.WheelEvent && (Sm && t.deltaMode === Em.WheelEvent.DOM_DELTA_PIXEL && (e /= Em.devicePixelRatio), t.deltaMode === Em.WheelEvent.DOM_DELTA_LINE && (e *= 40)), 0 !== e && e % Am == 0 && (e = Math.floor(e / Am)), t.shiftKey && e && (e *= .25), this.callback({
-                            type: Tm,
+                        jm.WheelEvent && (zm && t.deltaMode === jm.WheelEvent.DOM_DELTA_PIXEL && (e /= jm.devicePixelRatio), t.deltaMode === jm.WheelEvent.DOM_DELTA_LINE && (e *= 40)), 0 !== e && e % Nm == 0 && (e = Math.floor(e / Nm)), t.shiftKey && e && (e *= .25), this.callback({
+                            type: Dm,
                             center: {
                                 x: t.clientX,
                                 y: t.clientY
                             },
                             delta: -e,
                             srcEvent: t,
                             pointerType: "mouse",
                             target: t.target
                         })
-                    }, this.events = (this.options.events || []).concat(Cm), this.events.forEach((e => t.addEventListener(e, this.handleEvent, !!Pm && {
+                    }, this.events = (this.options.events || []).concat(Bm), this.events.forEach((e => t.addEventListener(e, this.handleEvent, !!Fm && {
                         passive: !1
                     })))
                 }
                 destroy() {
                     this.events.forEach((t => this.element.removeEventListener(t, this.handleEvent)))
                 }
                 enableEventType(t, e) {
-                    t === Tm && (this.options.enable = e)
+                    t === Dm && (this.options.enable = e)
                 }
             }
             const {
-                MOUSE_EVENTS: Om
-            } = ym, Lm = "pointermove", Rm = "pointerover", Im = "pointerout", km = "pointerenter", jm = "pointerleave";
-            class Fm extends fm {
+                MOUSE_EVENTS: Um
+            } = Lm, Gm = "pointermove", Wm = "pointerover", Hm = "pointerout", Zm = "pointerenter", qm = "pointerleave";
+            class Xm extends Cm {
                 constructor(t, e, n) {
                     super(t, e, n), this.handleEvent = t => {
                         this.handleOverEvent(t), this.handleOutEvent(t), this.handleEnterEvent(t), this.handleLeaveEvent(t), this.handleMoveEvent(t)
                     }, this.pressed = !1;
                     const {
                         enable: i
                     } = this.options;
-                    this.enableMoveEvent = i, this.enableLeaveEvent = i, this.enableEnterEvent = i, this.enableOutEvent = i, this.enableOverEvent = i, this.events = (this.options.events || []).concat(Om), this.events.forEach((e => t.addEventListener(e, this.handleEvent)))
+                    this.enableMoveEvent = i, this.enableLeaveEvent = i, this.enableEnterEvent = i, this.enableOutEvent = i, this.enableOverEvent = i, this.events = (this.options.events || []).concat(Um), this.events.forEach((e => t.addEventListener(e, this.handleEvent)))
                 }
                 destroy() {
                     this.events.forEach((t => this.element.removeEventListener(t, this.handleEvent)))
                 }
                 enableEventType(t, e) {
-                    t === Lm && (this.enableMoveEvent = e), t === Rm && (this.enableOverEvent = e), t === Im && (this.enableOutEvent = e), t === km && (this.enableEnterEvent = e), t === jm && (this.enableLeaveEvent = e)
+                    t === Gm && (this.enableMoveEvent = e), t === Wm && (this.enableOverEvent = e), t === Hm && (this.enableOutEvent = e), t === Zm && (this.enableEnterEvent = e), t === qm && (this.enableLeaveEvent = e)
                 }
                 handleOverEvent(t) {
-                    this.enableOverEvent && "mouseover" === t.type && this._emit(Rm, t)
+                    this.enableOverEvent && "mouseover" === t.type && this._emit(Wm, t)
                 }
                 handleOutEvent(t) {
-                    this.enableOutEvent && "mouseout" === t.type && this._emit(Im, t)
+                    this.enableOutEvent && "mouseout" === t.type && this._emit(Hm, t)
                 }
                 handleEnterEvent(t) {
-                    this.enableEnterEvent && "mouseenter" === t.type && this._emit(km, t)
+                    this.enableEnterEvent && "mouseenter" === t.type && this._emit(Zm, t)
                 }
                 handleLeaveEvent(t) {
-                    this.enableLeaveEvent && "mouseleave" === t.type && this._emit(jm, t)
+                    this.enableLeaveEvent && "mouseleave" === t.type && this._emit(qm, t)
                 }
                 handleMoveEvent(t) {
                     if (this.enableMoveEvent) switch (t.type) {
                         case "mousedown":
                             t.button >= 0 && (this.pressed = !0);
                             break;
                         case "mousemove":
-                            0 === t.which && (this.pressed = !1), this.pressed || this._emit(Lm, t);
+                            0 === t.which && (this.pressed = !1), this.pressed || this._emit(Gm, t);
                             break;
                         case "mouseup":
                             this.pressed = !1
                     }
                 }
                 _emit(t, e) {
                     this.callback({
@@ -17507,74 +18110,74 @@
                         srcEvent: e,
                         pointerType: "mouse",
                         target: e.target
                     })
                 }
             }
             const {
-                KEY_EVENTS: zm
-            } = ym, Bm = "keydown", Dm = "keyup";
-            class Nm extends fm {
+                KEY_EVENTS: Ym
+            } = Lm, Km = "keydown", Qm = "keyup";
+            class Jm extends Cm {
                 constructor(t, e, n) {
                     super(t, e, n), this.handleEvent = t => {
                         const e = t.target || t.srcElement;
                         "INPUT" === e.tagName && "text" === e.type || "TEXTAREA" === e.tagName || (this.enableDownEvent && "keydown" === t.type && this.callback({
-                            type: Bm,
+                            type: Km,
                             srcEvent: t,
                             key: t.key,
                             target: t.target
                         }), this.enableUpEvent && "keyup" === t.type && this.callback({
-                            type: Dm,
+                            type: Qm,
                             srcEvent: t,
                             key: t.key,
                             target: t.target
                         }))
-                    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(zm), t.tabIndex = this.options.tabIndex || 0, t.style.outline = "none", this.events.forEach((e => t.addEventListener(e, this.handleEvent)))
+                    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(Ym), t.tabIndex = this.options.tabIndex || 0, t.style.outline = "none", this.events.forEach((e => t.addEventListener(e, this.handleEvent)))
                 }
                 destroy() {
                     this.events.forEach((t => this.element.removeEventListener(t, this.handleEvent)))
                 }
                 enableEventType(t, e) {
-                    t === Bm && (this.enableDownEvent = e), t === Dm && (this.enableUpEvent = e)
+                    t === Km && (this.enableDownEvent = e), t === Qm && (this.enableUpEvent = e)
                 }
             }
-            const Vm = "contextmenu";
-            class Um extends fm {
+            const $m = "contextmenu";
+            class tv extends Cm {
                 constructor(t, e, n) {
                     super(t, e, n), this.handleEvent = t => {
                         this.options.enable && this.callback({
-                            type: Vm,
+                            type: $m,
                             center: {
                                 x: t.clientX,
                                 y: t.clientY
                             },
                             srcEvent: t,
                             pointerType: "mouse",
                             target: t.target
                         })
                     }, t.addEventListener("contextmenu", this.handleEvent)
                 }
                 destroy() {
                     this.element.removeEventListener("contextmenu", this.handleEvent)
                 }
                 enableEventType(t, e) {
-                    t === Vm && (this.options.enable = e)
+                    t === $m && (this.options.enable = e)
                 }
             }
-            const Gm = {
+            const ev = {
                 pointerdown: 1,
                 pointermove: 2,
                 pointerup: 4,
                 mousedown: 1,
                 mousemove: 2,
                 mouseup: 4
             };
 
-            function Wm(t) {
-                const e = Gm[t.srcEvent.type];
+            function nv(t) {
+                const e = ev[t.srcEvent.type];
                 if (!e) return null;
                 const {
                     buttons: n,
                     button: i,
                     which: r
                 } = t.srcEvent;
                 let s = !1,
@@ -17583,33 +18186,33 @@
                 return 4 === e || 2 === e && !Number.isFinite(n) ? (s = 1 === r, o = 2 === r, a = 3 === r) : 2 === e ? (s = Boolean(1 & n), o = Boolean(4 & n), a = Boolean(2 & n)) : 1 === e && (s = 0 === i, o = 1 === i, a = 2 === i), {
                     leftButton: s,
                     middleButton: o,
                     rightButton: a
                 }
             }
 
-            function Hm(t, e) {
+            function iv(t, e) {
                 const n = t.center;
                 if (!n) return null;
                 const i = e.getBoundingClientRect(),
                     r = i.width / e.offsetWidth || 1,
                     s = i.height / e.offsetHeight || 1;
                 return {
                     center: n,
                     offsetCenter: {
                         x: (n.x - i.left - e.clientLeft) / r,
                         y: (n.y - i.top - e.clientTop) / s
                     }
                 }
             }
-            const Zm = {
+            const rv = {
                 srcElement: "root",
                 priority: 0
             };
-            class qm {
+            class sv {
                 constructor(t) {
                     this.handleEvent = t => {
                         if (this.isEmpty()) return;
                         const e = this._normalizeEvent(t);
                         let n = t.srcEvent.target;
                         for (; n && n !== e.rootElement;) {
                             if (this._emit(e, n), e.handled) return;
@@ -17622,20 +18225,20 @@
                     return !this._active
                 }
                 add(t, e, n, i = !1, r = !1) {
                     const {
                         handlers: s,
                         handlersByElement: o
                     } = this;
-                    let a = Zm;
+                    let a = rv;
                     "string" == typeof n || n && n.addEventListener ? a = {
-                        ...Zm,
+                        ...rv,
                         srcElement: n
                     } : n && (a = {
-                        ...Zm,
+                        ...rv,
                         ...n
                     });
                     let l = o.get(a.srcElement);
                     l || (l = [], o.set(a.srcElement, l));
                     const c = {
                         type: t,
                         handler: e,
@@ -17695,45 +18298,45 @@
                         }
                     }
                 }
                 _normalizeEvent(t) {
                     const e = this.eventManager.getElement();
                     return {
                         ...t,
-                        ...Wm(t),
-                        ...Hm(t, e),
+                        ...nv(t),
+                        ...iv(t, e),
                         preventDefault: () => {
                             t.srcEvent.preventDefault()
                         },
                         stopImmediatePropagation: null,
                         stopPropagation: null,
                         handled: !1,
                         rootElement: e
                     }
                 }
             }
-            const Xm = {
+            const ov = {
                 events: null,
                 recognizers: null,
                 recognizerOptions: {},
-                Manager: dm,
+                Manager: Pm,
                 touchAction: "none",
                 tabIndex: 0
             };
-            class Ym {
+            class av {
                 constructor(t = null, e) {
                     this._onBasicInput = t => {
                         const {
                             srcEvent: e
-                        } = t, n = bm[e.type];
+                        } = t, n = Om[e.type];
                         n && this.manager.emit(n, t)
                     }, this._onOtherEvent = t => {
                         this.manager.emit(t.type, t)
                     }, this.options = {
-                        ...Xm,
+                        ...ov,
                         ...e
                     }, this.events = new Map, this.setElement(t);
                     const {
                         events: n
                     } = this.options;
                     n && this.on(n)
                 }
@@ -17743,36 +18346,36 @@
                 setElement(t) {
                     if (this.element && this.destroy(), this.element = t, !t) return;
                     const {
                         options: e
                     } = this, n = e.Manager;
                     this.manager = new n(t, {
                         touchAction: e.touchAction,
-                        recognizers: e.recognizers || gm
-                    }).on("hammer.input", this._onBasicInput), e.recognizers || Object.keys(mm).forEach((t => {
+                        recognizers: e.recognizers || Tm
+                    }).on("hammer.input", this._onBasicInput), e.recognizers || Object.keys(Am).forEach((t => {
                         const e = this.manager.get(t);
-                        e && mm[t].forEach((t => {
+                        e && Am[t].forEach((t => {
                             e.recognizeWith(t)
                         }))
                     }));
                     for (const t in e.recognizerOptions) {
                         const n = this.manager.get(t);
                         if (n) {
                             const i = e.recognizerOptions[t];
                             delete i.enable, n.set(i)
                         }
                     }
-                    this.wheelInput = new Mm(t, this._onOtherEvent, {
+                    this.wheelInput = new Vm(t, this._onOtherEvent, {
                         enable: !1
-                    }), this.moveInput = new Fm(t, this._onOtherEvent, {
+                    }), this.moveInput = new Xm(t, this._onOtherEvent, {
                         enable: !1
-                    }), this.keyInput = new Nm(t, this._onOtherEvent, {
+                    }), this.keyInput = new Jm(t, this._onOtherEvent, {
                         enable: !1,
                         tabIndex: e.tabIndex
-                    }), this.contextmenuInput = new Um(t, this._onOtherEvent, {
+                    }), this.contextmenuInput = new tv(t, this._onOtherEvent, {
                         enable: !1
                     });
                     for (const [t, e] of this.events) e.isEmpty() || (this._toggleRecognizer(e.recognizerName, !0), this.manager.on(t, e.handleEvent))
                 }
                 destroy() {
                     this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy(), this.wheelInput = null, this.moveInput = null, this.keyInput = null, this.contextmenuInput = null, this.manager = null, this.element = null)
                 }
@@ -17794,15 +18397,15 @@
                     } = this;
                     if (!n) return;
                     const i = n.get(t);
                     if (i && i.options.enable !== e) {
                         i.set({
                             enable: e
                         });
-                        const r = vm[t];
+                        const r = Mm[t];
                         r && !this.options.recognizers && r.forEach((r => {
                             const s = n.get(r);
                             e ? (s.requireFailure(t), i.dropRequireFailure(r)) : s.dropRequireFailure(t)
                         }))
                     }
                     this.wheelInput.enableEventType(t, e), this.moveInput.enableEventType(t, e), this.keyInput.enableEventType(t, e), this.contextmenuInput.enableEventType(t, e)
                 }
@@ -17811,42 +18414,42 @@
                         n = e;
                         for (const e in t) this._addEventHandler(e, t[e], n, i, r);
                         return
                     }
                     const {
                         manager: s,
                         events: o
-                    } = this, a = xm[t] || t;
+                    } = this, a = Rm[t] || t;
                     let l = o.get(a);
-                    l || (l = new qm(this), o.set(a, l), l.recognizerName = _m[a] || a, s && s.on(a, l.handleEvent)), l.add(t, e, n, i, r), l.isEmpty() || this._toggleRecognizer(l.recognizerName, !0)
+                    l || (l = new sv(this), o.set(a, l), l.recognizerName = km[a] || a, s && s.on(a, l.handleEvent)), l.add(t, e, n, i, r), l.isEmpty() || this._toggleRecognizer(l.recognizerName, !0)
                 }
                 _removeEventHandler(t, e) {
                     if ("string" != typeof t) {
                         for (const e in t) this._removeEventHandler(e, t[e]);
                         return
                     }
                     const {
                         events: n
-                    } = this, i = xm[t] || t, r = n.get(i);
+                    } = this, i = Rm[t] || t, r = n.get(i);
                     if (r && (r.remove(t, e), r.isEmpty())) {
                         const {
                             recognizerName: t
                         } = r;
                         let e = !1;
                         for (const i of n.values())
                             if (i.recognizerName === t && !i.isEmpty()) {
                                 e = !0;
                                 break
                             } e || this._toggleRecognizer(t, !1)
                     }
                 }
             }
 
-            function Km() {}
-            const Qm = {
+            function lv() {}
+            const cv = {
                 id: "",
                 width: "100%",
                 height: "100%",
                 style: null,
                 viewState: null,
                 initialViewState: null,
                 pickingRadius: 0,
@@ -17864,36 +18467,36 @@
                 touchAction: "none",
                 eventRecognizerOptions: {},
                 _framebuffer: null,
                 _animate: !1,
                 _pickable: !0,
                 _typedArrayManagerProps: {},
                 _customRender: null,
-                onWebGLInitialized: Km,
-                onResize: Km,
-                onViewStateChange: Km,
-                onInteractionStateChange: Km,
-                onBeforeRender: Km,
-                onAfterRender: Km,
-                onLoad: Km,
-                onError: t => na.error(t.message)(),
+                onWebGLInitialized: lv,
+                onResize: lv,
+                onViewStateChange: lv,
+                onInteractionStateChange: lv,
+                onBeforeRender: lv,
+                onAfterRender: lv,
+                onLoad: lv,
+                onError: t => ta.error(t.message)(),
                 onHover: null,
                 onClick: null,
                 onDragStart: null,
                 onDrag: null,
                 onDragEnd: null,
                 _onMetrics: null,
                 getCursor: ({
                     isDragging: t
                 }) => t ? "grabbing" : "grab",
                 getTooltip: null,
                 debug: !1,
                 drawPickingColors: !1
             };
-            class Jm {
+            class hv {
                 constructor(t) {
                     wo(this, "props", void 0), wo(this, "width", 0), wo(this, "height", 0), wo(this, "userData", {}), wo(this, "canvas", null), wo(this, "viewManager", null), wo(this, "layerManager", null), wo(this, "effectManager", null), wo(this, "deckRenderer", null), wo(this, "deckPicker", null), wo(this, "eventManager", null), wo(this, "tooltip", null), wo(this, "metrics", void 0), wo(this, "animationLoop", void 0), wo(this, "stats", void 0), wo(this, "viewState", void 0), wo(this, "cursorState", void 0), wo(this, "_needsRedraw", void 0), wo(this, "_pickRequest", void 0), wo(this, "_lastPointerDownInfo", null), wo(this, "_metricsCounter", void 0), wo(this, "_onPointerMove", (t => {
                         const {
                             _pickRequest: e
                         } = this;
                         if ("pointerleave" === t.type) e.x = -1, e.y = -1, e.radius = 0;
                         else {
@@ -17904,15 +18507,15 @@
                             }
                         }
                         this.layerManager && (this.layerManager.context.mousePosition = {
                             x: e.x,
                             y: e.y
                         }), e.event = t
                     })), wo(this, "_onEvent", (t => {
-                        const e = kh[t.type],
+                        const e = Oh[t.type],
                             n = t.offsetCenter;
                         if (!e || !n || !this.layerManager) return;
                         const i = this.layerManager.getLayers(),
                             r = this.deckPicker.getLastPickedObject({
                                 x: n.x,
                                 y: n.y,
                                 layers: i,
@@ -17930,26 +18533,26 @@
                             n = this._pick("pickObject", "pickObject Time", {
                                 x: e.x,
                                 y: e.y,
                                 radius: this.props.pickingRadius
                             });
                         this._lastPointerDownInfo = n.result[0] || n.emptyInfo
                     })), this.props = {
-                        ...Qm,
+                        ...cv,
                         ...t
                     }, t = this.props, this._needsRedraw = "Initial render", this._pickRequest = {
                         mode: "hover",
                         x: -1,
                         y: -1,
                         radius: 0,
                         event: null
                     }, this.cursorState = {
                         isHovering: !1,
                         isDragging: !1
-                    }, t.viewState && t.initialViewState && na.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), "IE" === sm() && na.warn("IE 11 is not supported")(), this.viewState = t.initialViewState, t.gl || "undefined" != typeof document && (this.canvas = this._createCanvas(t)), this.animationLoop = this._createAnimationLoop(t), this.stats = new da({
+                    }, t.viewState && t.initialViewState && ta.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), "IE" === vm() && ta.warn("IE 11 is not supported")(), this.viewState = t.initialViewState, t.gl || "undefined" != typeof document && (this.canvas = this._createCanvas(t)), this.animationLoop = this._createAnimationLoop(t), this.stats = new ca({
                         id: "deck.gl"
                     }), this.metrics = {
                         fps: 0,
                         setPropsTime: 0,
                         updateAttributesTime: 0,
                         framesRedrawn: 0,
                         pickTime: 0,
@@ -17958,22 +18561,22 @@
                         gpuTimePerFrame: 0,
                         cpuTime: 0,
                         cpuTimePerFrame: 0,
                         bufferMemory: 0,
                         textureMemory: 0,
                         renderbufferMemory: 0,
                         gpuMemory: 0
-                    }, this._metricsCounter = 0, this.setProps(t), t._typedArrayManagerProps && sc.setOptions(t._typedArrayManagerProps), this.animationLoop.start()
+                    }, this._metricsCounter = 0, this.setProps(t), t._typedArrayManagerProps && nc.setOptions(t._typedArrayManagerProps), this.animationLoop.start()
                 }
                 finalize() {
-                    var t, e, n, i, r, s, o, a, l;
-                    null === (t = this.animationLoop) || void 0 === t || t.stop(), this.animationLoop = null, this._lastPointerDownInfo = null, null === (e = this.layerManager) || void 0 === e || e.finalize(), this.layerManager = null, null === (n = this.viewManager) || void 0 === n || n.finalize(), this.viewManager = null, null === (i = this.effectManager) || void 0 === i || i.finalize(), this.effectManager = null, null === (r = this.deckRenderer) || void 0 === r || r.finalize(), this.deckRenderer = null, null === (s = this.deckPicker) || void 0 === s || s.finalize(), this.deckPicker = null, null === (o = this.eventManager) || void 0 === o || o.destroy(), this.eventManager = null, null === (a = this.tooltip) || void 0 === a || a.remove(), this.tooltip = null, this.props.canvas || this.props.gl || !this.canvas || (null === (l = this.canvas.parentElement) || void 0 === l || l.removeChild(this.canvas), this.canvas = null)
+                    var t, e, n, i, r, s, o, a;
+                    this.animationLoop.stop(), this.animationLoop = null, this._lastPointerDownInfo = null, null === (t = this.layerManager) || void 0 === t || t.finalize(), this.layerManager = null, null === (e = this.viewManager) || void 0 === e || e.finalize(), this.viewManager = null, null === (n = this.effectManager) || void 0 === n || n.finalize(), this.effectManager = null, null === (i = this.deckRenderer) || void 0 === i || i.finalize(), this.deckRenderer = null, null === (r = this.deckPicker) || void 0 === r || r.finalize(), this.deckPicker = null, null === (s = this.eventManager) || void 0 === s || s.destroy(), this.eventManager = null, null === (o = this.tooltip) || void 0 === o || o.remove(), this.tooltip = null, this.props.canvas || this.props.gl || !this.canvas || (null === (a = this.canvas.parentElement) || void 0 === a || a.removeChild(this.canvas), this.canvas = null)
                 }
                 setProps(t) {
-                    this.stats.get("setProps Time").timeStart(), "onLayerHover" in t && na.removed("onLayerHover", "onHover")(), "onLayerClick" in t && na.removed("onLayerClick", "onClick")(), t.initialViewState && !Sf(this.props.initialViewState, t.initialViewState, 3) && (this.viewState = t.initialViewState), Object.assign(this.props, t), this._setCanvasSize(this.props);
+                    this.stats.get("setProps Time").timeStart(), "onLayerHover" in t && ta.removed("onLayerHover", "onHover")(), "onLayerClick" in t && ta.removed("onLayerClick", "onClick")(), t.initialViewState && !Pf(this.props.initialViewState, t.initialViewState) && (this.viewState = t.initialViewState), Object.assign(this.props, t), this._setCanvasSize(this.props);
                     const e = Object.create(this.props);
                     Object.assign(e, {
                         views: this._getViews(),
                         width: this.width,
                         height: this.height,
                         viewState: this._getViewState()
                     }), this.animationLoop.setProps(e), this.layerManager && (this.viewManager.setProps(e), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(e), this.effectManager.setProps(e), this.deckRenderer.setProps(e), this.deckPicker.setProps(e)), this.stats.get("setProps Time").timeEnd()
@@ -17998,18 +18601,18 @@
                     });
                     e = t || e, e && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(e) : this._drawLayers(e))
                 }
                 get isInitialized() {
                     return null !== this.viewManager
                 }
                 getViews() {
-                    return Of(this.viewManager), this.viewManager.views
+                    return Mf(this.viewManager), this.viewManager.views
                 }
                 getViewports(t) {
-                    return Of(this.viewManager), this.viewManager.getViewports(t)
+                    return Mf(this.viewManager), this.viewManager.getViewports(t)
                 }
                 pickObject(t) {
                     const e = this._pick("pickObject", "pickObject Time", t).result;
                     return e.length ? e[0] : null
                 }
                 pickMultipleObjects(t) {
                     return t.depth = t.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", t).result
@@ -18023,19 +18626,16 @@
                         data: t[n],
                         forceUpdate: e
                     })
                 }
                 _removeResources(t) {
                     for (const e of t) this.layerManager.resourceManager.remove(e)
                 }
-                _addDefaultEffect(t) {
-                    this.effectManager.addDefaultEffect(t)
-                }
                 _pick(t, e, n) {
-                    Of(this.deckPicker);
+                    Mf(this.deckPicker);
                     const {
                         stats: i
                     } = this;
                     i.get("Pick Count").incrementCount(), i.get(e).timeStart();
                     const r = this.deckPicker[t]({
                         layers: this.layerManager.getLayers(n),
                         views: this.viewManager.getViews(),
@@ -18044,15 +18644,15 @@
                         effects: this.effectManager.getEffects(),
                         ...n
                     });
                     return i.get(e).timeEnd(), r
                 }
                 _createCanvas(t) {
                     let e = t.canvas;
-                    return "string" == typeof e && (e = document.getElementById(e), Of(e)), e || (e = document.createElement("canvas"), e.id = t.id || "deckgl-overlay", (t.parent || document.body).appendChild(e)), Object.assign(e.style, t.style), e
+                    return "string" == typeof e && (e = document.getElementById(e), Mf(e)), e || (e = document.createElement("canvas"), e.id = t.id || "deckgl-overlay", (t.parent || document.body).appendChild(e)), Object.assign(e.style, t.style), e
                 }
                 _setCanvasSize(t) {
                     if (!this.canvas) return;
                     const {
                         width: e,
                         height: n
                     } = t;
@@ -18063,50 +18663,48 @@
                     if (n || 0 === n) {
                         var i;
                         const e = Number.isFinite(n) ? "".concat(n, "px") : n;
                         this.canvas.style.position = (null === (i = t.style) || void 0 === i ? void 0 : i.position) || "absolute", this.canvas.style.height = e
                     }
                 }
                 _updateCanvasSize() {
-                    var t, e;
                     const {
-                        canvas: n
+                        canvas: t
                     } = this;
-                    if (!n) return;
-                    const i = null !== (t = n.clientWidth) && void 0 !== t ? t : n.width,
-                        r = null !== (e = n.clientHeight) && void 0 !== e ? e : n.height;
-                    var s, o;
-                    i === this.width && r === this.height || (this.width = i, this.height = r, null === (s = this.viewManager) || void 0 === s || s.setProps({
-                        width: i,
-                        height: r
-                    }), null === (o = this.layerManager) || void 0 === o || o.activateViewport(this.getViewports()[0]), this.props.onResize({
-                        width: i,
-                        height: r
+                    if (!t) return;
+                    const e = t.clientWidth || t.width,
+                        n = t.clientHeight || t.height;
+                    var i;
+                    e === this.width && n === this.height || (this.width = e, this.height = n, null === (i = this.viewManager) || void 0 === i || i.setProps({
+                        width: e,
+                        height: n
+                    }), this.props.onResize({
+                        width: e,
+                        height: n
                     }))
                 }
                 _createAnimationLoop(t) {
                     const {
                         width: e,
                         height: n,
                         gl: i,
                         glOptions: r,
                         debug: s,
                         onError: o,
                         onBeforeRender: a,
                         onAfterRender: l,
                         useDevicePixels: c
                     } = t;
-                    return new cm({
+                    return new xm({
                         width: e,
                         height: n,
                         useDevicePixels: c,
-                        autoResizeDrawingBuffer: !i,
                         autoResizeViewport: !1,
                         gl: i,
-                        onCreateContext: t => yd({
+                        onCreateContext: t => vd({
                             ...r,
                             ...t,
                             canvas: this.canvas,
                             debug: s,
                             onContextLost: () => this._onContextLost()
                         }),
                         onInitialize: t => this._setGLContext(t.gl),
@@ -18116,15 +18714,15 @@
                         onError: o
                     })
                 }
                 _getViewState() {
                     return this.props.viewState || this.viewState
                 }
                 _getViews() {
-                    let t = this.props.views || [new tg({
+                    let t = this.props.views || [new eg({
                         id: "default-view"
                     })];
                     return t = Array.isArray(t) ? t : [t], t.length && this.props.controller && (t[0].props.controller = this.props.controller), t
                 }
                 _onContextLost() {
                     const {
                         onError: t
@@ -18156,74 +18754,75 @@
                 }
                 _updateCursor() {
                     const t = this.props.parent || this.canvas;
                     t && (t.style.cursor = this.props.getCursor(this.cursorState))
                 }
                 _setGLContext(t) {
                     if (this.layerManager) return;
-                    this.canvas || (this.canvas = t.canvas, _d(t, {
+                    this.canvas || (this.canvas = t.canvas, bd(t, {
                         enable: !0,
                         copyState: !0
-                    })), this.tooltip = new zg(this.canvas), hd(t, {
+                    })), this.tooltip = new qg(this.canvas), ld(t, {
                         blend: !0,
                         blendFunc: [770, 771, 1, 771],
                         polygonOffsetFill: !0,
                         depthTest: !0,
                         depthFunc: 515
                     }), this.props.onWebGLInitialized(t);
                     const e = new So;
-                    e.play(), this.animationLoop.attachTimeline(e), this.eventManager = new Ym(this.props.parent || t.canvas, {
+                    e.play(), this.animationLoop.attachTimeline(e), this.eventManager = new av(this.props.parent || t.canvas, {
                         touchAction: this.props.touchAction,
                         recognizerOptions: this.props.eventRecognizerOptions,
                         events: {
                             pointerdown: this._onPointerDown,
                             pointermove: this._onPointerMove,
                             pointerleave: this._onPointerMove
                         }
                     });
-                    for (const t in kh) this.eventManager.on(t, this._onEvent);
-                    this.viewManager = new Cf({
+                    for (const t in Oh) this.eventManager.on(t, this._onEvent);
+                    this.viewManager = new Sf({
                         timeline: e,
                         eventManager: this.eventManager,
                         onViewStateChange: this._onViewStateChange.bind(this),
                         onInteractionStateChange: this._onInteractionStateChange.bind(this),
                         views: this._getViews(),
                         viewState: this._getViewState(),
                         width: this.width,
                         height: this.height
                     });
                     const n = this.viewManager.getViewports()[0];
-                    this.layerManager = new Pf(t, {
+                    this.layerManager = new Ef(t, {
                         deck: this,
                         stats: this.stats,
                         viewport: n,
                         timeline: e
-                    }), this.effectManager = new Pg, this.deckRenderer = new Mg(t), this.deckPicker = new jg(t), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad()
+                    }), this.effectManager = new Ig, this.deckRenderer = new Dg(t), this.deckPicker = new Hg(t), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad()
                 }
                 _drawLayers(t, e) {
                     const {
                         gl: n
                     } = this.layerManager.context;
-                    hd(n, this.props.parameters), this.props.onBeforeRender({
+                    ld(n, this.props.parameters), this.props.onBeforeRender({
                         gl: n
                     }), this.deckRenderer.renderLayers({
                         target: this.props._framebuffer,
                         layers: this.layerManager.getLayers(),
                         viewports: this.viewManager.getViewports(),
                         onViewportActive: this.layerManager.activateViewport,
                         views: this.viewManager.getViews(),
                         pass: "screen",
+                        redrawReason: t,
                         effects: this.effectManager.getEffects(),
                         ...e
                     }), this.props.onAfterRender({
                         gl: n
                     })
                 }
                 _onRenderFrame(t) {
-                    this._getFrameStats(), this._metricsCounter++ % 60 == 0 && (this._getMetrics(), this.stats.reset(), na.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.tooltip.isVisible && this.viewManager.needsRedraw() && this.tooltip.setTooltip(null), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates()
+                    this._getFrameStats(), this._metricsCounter++ % 60 == 0 && (this._getMetrics(), this.stats.reset(), ta.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.tooltip.isVisible && this.viewManager.needsRedraw() && this.tooltip.setTooltip(null), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates()
                 }
                 _onViewStateChange(t) {
                     const e = this.props.onViewStateChange(t) || t.viewState;
                     this.viewState && (this.viewState = {
                         ...this.viewState,
                         [t.viewId]: e
                     }, this.props.viewState || this.viewManager && this.viewManager.setProps({
@@ -18243,29 +18842,29 @@
                 }
                 _getMetrics() {
                     const {
                         metrics: t,
                         stats: e
                     } = this;
                     t.fps = e.get("frameRate").getHz(), t.setPropsTime = e.get("setProps Time").time, t.updateAttributesTime = e.get("Update Attributes").time, t.framesRedrawn = e.get("Redraw Count").count, t.pickTime = e.get("pickObject Time").time + e.get("pickMultipleObjects Time").time + e.get("pickObjects Time").time, t.pickCount = e.get("Pick Count").count, t.gpuTime = e.get("GPU Time").time, t.cpuTime = e.get("CPU Time").time, t.gpuTimePerFrame = e.get("GPU Time").getAverageTime(), t.cpuTimePerFrame = e.get("CPU Time").getAverageTime();
-                    const n = wd.get("Memory Usage");
+                    const n = xd.get("Memory Usage");
                     t.bufferMemory = n.get("Buffer Memory").count, t.textureMemory = n.get("Texture Memory").count, t.renderbufferMemory = n.get("Renderbuffer Memory").count, t.gpuMemory = n.get("GPU Memory").count
                 }
             }
-            wo(Jm, "defaultProps", Qm), wo(Jm, "VERSION", im);
-            const $m = "undefined" != typeof window ? c.useLayoutEffect : c.useEffect;
+            wo(hv, "defaultProps", cv), wo(hv, "VERSION", gm.VERSION);
+            const uv = "undefined" != typeof window ? c.useLayoutEffect : c.useEffect;
 
-            function tv(t, e) {
+            function dv(t, e) {
                 for (; t;) {
                     if (t === e) return !0;
                     t = Object.getPrototypeOf(t)
                 }
                 return !1
             }
-            class ev {
+            class pv {
                 constructor(t, e) {
                     wo(this, "opts", void 0), wo(this, "source", void 0), this.opts = e, this.source = t
                 }
                 get value() {
                     return this.source.value
                 }
                 getValue() {
@@ -18289,39 +18888,39 @@
                     return {
                         ...this.source.getAccessor(),
                         ...this.opts
                     }
                 }
             }
 
-            function nv(t) {
+            function fv(t) {
                 return t.stride || t.size * t.bytesPerElement
             }
 
-            function iv(t, e) {
-                e.offset && na.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
-                const n = nv(t),
+            function gv(t, e) {
+                e.offset && ta.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
+                const n = fv(t),
                     i = (void 0 !== e.vertexOffset ? e.vertexOffset : t.vertexOffset || 0) * n + (e.elementOffset || 0) * t.bytesPerElement + (t.offset || 0);
                 return {
                     ...e,
                     offset: i,
                     stride: n
                 }
             }
-            class rv {
+            class mv {
                 constructor(t, e, n) {
                     wo(this, "gl", void 0), wo(this, "id", void 0), wo(this, "size", void 0), wo(this, "settings", void 0), wo(this, "value", void 0), wo(this, "doublePrecision", void 0), wo(this, "_buffer", void 0), wo(this, "state", void 0), this.gl = t, this.id = e.id || "", this.size = e.size || 1;
                     const i = e.logicalType || e.type,
                         r = 5130 === i;
                     let s, {
                         defaultValue: o
                     } = e;
                     o = Number.isFinite(o) ? [o] : o || new Array(this.size).fill(0), s = r ? 5126 : !i && e.isIndexed ? t && function(t, e) {
-                        return gp(t, e)
-                    }(t, dp) ? 5125 : 5123 : i || 5126;
+                        return fp(t, e)
+                    }(t, up) ? 5125 : 5123 : i || 5126;
                     let a = function(t) {
                         switch (t) {
                             case 5126:
                                 return Float32Array;
                             case 5130:
                                 return Float64Array;
                             case 5123:
@@ -18366,57 +18965,57 @@
                 }
                 get buffer() {
                     if (!this._buffer) {
                         const {
                             isIndexed: t,
                             type: e
                         } = this.settings;
-                        this._buffer = new Wd(this.gl, {
+                        this._buffer = new Gd(this.gl, {
                             id: this.id,
                             target: t ? 34963 : 34962,
                             accessor: {
                                 type: e
                             }
                         })
                     }
                     return this._buffer
                 }
                 get byteOffset() {
                     const t = this.getAccessor();
-                    return t.vertexOffset ? t.vertexOffset * nv(t) : 0
+                    return t.vertexOffset ? t.vertexOffset * fv(t) : 0
                 }
                 get numInstances() {
                     return this.state.numInstances
                 }
                 set numInstances(t) {
                     this.state.numInstances = t
                 }
                 delete() {
-                    this._buffer && (this._buffer.delete(), this._buffer = null), sc.release(this.state.allocatedValue)
+                    this._buffer && (this._buffer.delete(), this._buffer = null), nc.release(this.state.allocatedValue)
                 }
                 getShaderAttributes(t, e) {
                     if (this.doublePrecision) {
                         const n = {},
                             i = this.value instanceof Float64Array,
                             r = function(t, e) {
-                                const n = iv(t, e);
+                                const n = gv(t, e);
                                 return {
                                     high: n,
                                     low: {
                                         ...n,
                                         offset: n.offset + 4 * t.size
                                     }
                                 }
                             }(this.getAccessor(), e || {});
-                        return n[t] = new ev(this, r.high), n["".concat(t, "64Low")] = i ? new ev(this, r.low) : new Float32Array(this.size), n
+                        return n[t] = new pv(this, r.high), n["".concat(t, "64Low")] = i ? new pv(this, r.low) : new Float32Array(this.size), n
                     }
                     if (e) {
-                        const n = iv(this.getAccessor(), e);
+                        const n = gv(this.getAccessor(), e);
                         return {
-                            [t]: new ev(this, n)
+                            [t]: new pv(this, n)
                         }
                     }
                     return {
                         [t]: this
                     }
                 }
                 getBuffer() {
@@ -18456,39 +19055,39 @@
                 setData(t) {
                     const {
                         state: e
                     } = this;
                     let n;
                     n = ArrayBuffer.isView(t) ? {
                         value: t
-                    } : t instanceof Wd ? {
+                    } : t instanceof Gd ? {
                         buffer: t
                     } : t;
                     const i = {
                         ...this.settings,
                         ...n
                     };
                     if (e.bufferAccessor = i, e.bounds = null, n.constant) {
                         let t = n.value;
                         if (t = this._normalizeValue(t, [], 0), this.settings.normalized && (t = this.normalizeConstant(t)), e.constant && this._areValuesEqual(t, this.value)) return !1;
                         e.externalBuffer = null, e.constant = !0, this.value = t
                     } else if (n.buffer) {
                         const t = n.buffer;
                         e.externalBuffer = t, e.constant = !1, this.value = n.value || null;
                         const r = n.value instanceof Float64Array;
-                        i.type = n.type || t.accessor.type, i.bytesPerElement = t.accessor.BYTES_PER_ELEMENT * (r ? 2 : 1), i.stride = nv(i)
+                        i.type = n.type || t.accessor.type, i.bytesPerElement = t.accessor.BYTES_PER_ELEMENT * (r ? 2 : 1), i.stride = fv(i)
                     } else if (n.value) {
                         this._checkExternalBuffer(n);
                         let t = n.value;
-                        e.externalBuffer = null, e.constant = !1, this.value = t, i.bytesPerElement = t.BYTES_PER_ELEMENT, i.stride = nv(i);
+                        e.externalBuffer = null, e.constant = !1, this.value = t, i.bytesPerElement = t.BYTES_PER_ELEMENT, i.stride = fv(i);
                         const {
                             buffer: r,
                             byteOffset: s
                         } = this;
-                        this.doublePrecision && t instanceof Float64Array && (t = zc(t, i));
+                        this.doublePrecision && t instanceof Float64Array && (t = Ic(t, i));
                         const o = t.byteLength + s + 2 * i.stride;
                         r.byteLength < o && r.reallocate(o), r.setAccessor(null), r.subData({
                             data: t,
                             offset: s
                         }), i.type = n.type || r.accessor.type
                     }
                     return !0
@@ -18497,49 +19096,49 @@
                     this.state.bounds = null;
                     const e = this.value,
                         {
                             startOffset: n = 0,
                             endOffset: i
                         } = t;
                     this.buffer.subData({
-                        data: this.doublePrecision && e instanceof Float64Array ? zc(e, {
+                        data: this.doublePrecision && e instanceof Float64Array ? Ic(e, {
                             size: this.size,
                             startIndex: n,
                             endIndex: i
                         }) : e.subarray(n, i),
                         offset: n * e.BYTES_PER_ELEMENT + this.byteOffset
                     })
                 }
                 allocate(t, e = !1) {
                     const {
                         state: n
-                    } = this, i = n.allocatedValue, r = sc.allocate(i, t + 1, {
+                    } = this, i = n.allocatedValue, r = nc.allocate(i, t + 1, {
                         size: this.size,
                         type: this.settings.defaultType,
                         copy: e
                     });
                     this.value = r;
                     const {
                         buffer: s,
                         byteOffset: o
                     } = this;
                     return s.byteLength < r.byteLength + o && (s.reallocate(r.byteLength + o), e && i && s.subData({
-                        data: i instanceof Float64Array ? zc(i, this) : i,
+                        data: i instanceof Float64Array ? Ic(i, this) : i,
                         offset: o
                     })), n.allocatedValue = r, n.constant = !1, n.externalBuffer = null, n.bufferAccessor = this.settings, !0
                 }
                 _checkExternalBuffer(t) {
                     const {
                         value: e
                     } = t;
                     if (!ArrayBuffer.isView(e)) throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
                     const n = this.settings.defaultType;
                     let i = !1;
                     if (this.doublePrecision && (i = e.BYTES_PER_ELEMENT < 4), i) throw new Error("Attribute ".concat(this.id, " does not support ").concat(e.constructor.name));
-                    e instanceof n || !this.settings.normalized || "normalized" in t || na.warn("Attribute ".concat(this.id, " is normalized"))()
+                    e instanceof n || !this.settings.normalized || "normalized" in t || ta.warn("Attribute ".concat(this.id, " is normalized"))()
                 }
                 normalizeConstant(t) {
                     switch (this.settings.type) {
                         case 5120:
                             return new Float32Array(t).map((t => (t + 128) / 255 * 2 - 1));
                         case 5122:
                             return new Float32Array(t).map((t => (t + 32768) / 65535 * 2 - 1));
@@ -18553,19 +19152,15 @@
                 }
                 _normalizeValue(t, e, n) {
                     const {
                         defaultValue: i,
                         size: r
                     } = this.settings;
                     if (Number.isFinite(t)) return e[n] = t, e;
-                    if (!t) {
-                        let t = r;
-                        for (; --t >= 0;) e[n + t] = i[t];
-                        return e
-                    }
+                    if (!t) return e[n] = i[0], e;
                     switch (r) {
                         case 4:
                             e[n + 3] = Number.isFinite(t[3]) ? t[3] : i[3];
                         case 3:
                             e[n + 2] = Number.isFinite(t[2]) ? t[2] : i[2];
                         case 2:
                             e[n + 1] = Number.isFinite(t[1]) ? t[1] : i[1];
@@ -18584,35 +19179,35 @@
                         size: n
                     } = this;
                     for (let i = 0; i < n; i++)
                         if (t[i] !== e[i]) return !1;
                     return !0
                 }
             }
-            const sv = [],
-                ov = [];
+            const vv = [],
+                bv = [];
 
-            function av(t, e = 0, n = 1 / 0) {
-                let i = sv;
+            function yv(t, e = 0, n = 1 / 0) {
+                let i = vv;
                 const r = {
                     index: -1,
                     data: t,
                     target: []
                 };
-                return t ? "function" == typeof t[Symbol.iterator] ? i = t : t.length > 0 && (ov.length = t.length, i = ov) : i = sv, (e > 0 || Number.isFinite(n)) && (i = (Array.isArray(i) ? i : Array.from(i)).slice(e, n), r.index = e - 1), {
+                return t ? "function" == typeof t[Symbol.iterator] ? i = t : t.length > 0 && (bv.length = t.length, i = bv) : i = vv, (e > 0 || Number.isFinite(n)) && (i = (Array.isArray(i) ? i : Array.from(i)).slice(e, n), r.index = e - 1), {
                     iterable: i,
                     objectInfo: r
                 }
             }
 
-            function lv(t) {
+            function _v(t) {
                 return t && t[Symbol.asyncIterator]
             }
 
-            function cv(t, e) {
+            function xv(t, e) {
                 const {
                     size: n,
                     stride: i,
                     offset: r,
                     startIndices: s,
                     nested: o
                 } = e, a = t.BYTES_PER_ELEMENT, l = i ? i / a : n, c = r ? r / a : 0, h = Math.floor((t.length - c) / l);
@@ -18644,20 +19239,20 @@
                             const r = i * l + c;
                             for (let i = 0; i < n; i++) d[e++] = t[r + i]
                         }
                     }
                     return d
                 }
             }
-            const hv = [],
-                uv = [
+            const wv = [],
+                Ev = [
                     [0, 1 / 0]
                 ];
 
-            function dv(t) {
+            function Pv(t) {
                 const {
                     source: e,
                     target: n,
                     start: i = 0,
                     size: r,
                     getData: s
                 } = t, o = t.end || n.length, a = e.length, l = o - i;
@@ -18665,92 +19260,92 @@
                 if (n.set(e, i), !s) return;
                 let c = a;
                 for (; c < l;) {
                     const t = s(c, e);
                     for (let e = 0; e < r; e++) n[i + c] = t[e] || 0, c++
                 }
             }
-            const pv = {
+            const Sv = {
                 interpolation: {
                     duration: 0,
                     easing: t => t
                 },
                 spring: {
                     stiffness: .05,
                     damping: .5
                 }
             };
 
-            function fv(t, e) {
+            function Cv(t, e) {
                 if (!t) return null;
                 Number.isFinite(t) && (t = {
                     type: "interpolation",
                     duration: t
                 });
                 const n = t.type || "interpolation";
                 return {
-                    ...pv[n],
+                    ...Sv[n],
                     ...e,
                     ...t,
                     type: n
                 }
             }
 
-            function gv(t, e) {
+            function Tv(t, e) {
                 const n = e.getBuffer();
                 return n ? [n, {
                     divisor: 0,
                     size: e.size,
                     normalized: e.settings.normalized
                 }] : e.value
             }
 
-            function mv(t) {
+            function Av(t) {
                 switch (t) {
                     case 1:
                         return "float";
                     case 2:
                         return "vec2";
                     case 3:
                         return "vec3";
                     case 4:
                         return "vec4";
                     default:
                         throw new Error('No defined attribute type for size "'.concat(t, '"'))
                 }
             }
 
-            function vv(t) {
+            function Mv(t) {
                 t.push(t.shift())
             }
 
-            function bv(t, e) {
+            function Ov(t, e) {
                 const {
                     doublePrecision: n,
                     settings: i,
                     value: r,
                     size: s
                 } = t, o = n && r instanceof Float64Array ? 2 : 1;
                 return (i.noAlloc ? r.length : e * s) * o
             }
 
-            function yv({
+            function Lv({
                 buffer: t,
                 numInstances: e,
                 attribute: n,
                 fromLength: i,
                 fromStartIndices: r,
                 getData: s = (t => t)
             }) {
                 const o = n.doublePrecision && n.value instanceof Float64Array ? 2 : 1,
                     a = n.size * o,
                     l = n.byteOffset,
                     c = n.startIndices,
                     h = r && c,
-                    u = bv(n, e),
+                    u = Ov(n, e),
                     d = n.isConstant;
                 if (!h && i >= u) return;
                 const p = d ? n.value : n.getBuffer().getData({
                     srcByteOffset: l
                 });
                 if (n.settings.normalized && !d) {
                     const t = s;
@@ -18765,37 +19360,37 @@
                     source: t,
                     target: e,
                     size: n,
                     getData: i,
                     sourceStartIndices: r,
                     targetStartIndices: s
                 }) {
-                    if (!Array.isArray(s)) return dv({
+                    if (!Array.isArray(s)) return Pv({
                         source: t,
                         target: e,
                         size: n,
                         getData: i
                     }), e;
                     let o = 0,
                         a = 0;
                     const l = i && ((t, e) => i(t + a, e)),
                         c = Math.min(r.length, s.length);
                     for (let i = 1; i < c; i++) {
                         const c = r[i] * n,
                             h = s[i] * n;
-                        dv({
+                        Pv({
                             source: t.subarray(o, c),
                             target: e,
                             start: a,
                             end: h,
                             size: n,
                             getData: l
                         }), o = c, a = h
                     }
-                    a < e.length && dv({
+                    a < e.length && Pv({
                         source: [],
                         target: e,
                         start: a,
                         size: n,
                         getData: l
                     })
                 }({
@@ -18806,24 +19401,24 @@
                     size: a,
                     getData: f
                 }), t.byteLength < m.byteLength + l && t.reallocate(m.byteLength + l), t.subData({
                     data: m,
                     offset: l
                 })
             }
-            class _v extends rv {
+            class kv extends mv {
                 constructor(t, e) {
                     super(t, e, {
                         startIndices: null,
                         lastExternalBuffer: null,
                         binaryValue: null,
                         binaryAccessor: null,
                         needsUpdate: !0,
                         needsRedraw: !1,
-                        updateRanges: uv
+                        updateRanges: Ev
                     }), wo(this, "constant", !1), this.settings.update = e.update || (e.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters()
                 }
                 get startIndices() {
                     return this.state.startIndices
                 }
                 set startIndices(t) {
                     this.state.startIndices = t
@@ -18847,48 +19442,48 @@
                     return Boolean(this.settings.transition)
                 }
                 getTransitionSetting(t) {
                     if (!t || !this.supportsTransition()) return null;
                     const {
                         accessor: e
                     } = this.settings, n = this.settings.transition;
-                    return fv(Array.isArray(e) ? t[e.find((e => t[e]))] : t[e], n)
+                    return Cv(Array.isArray(e) ? t[e.find((e => t[e]))] : t[e], n)
                 }
                 setNeedsUpdate(t = this.id, e) {
                     if (this.state.needsUpdate = this.state.needsUpdate || t, this.setNeedsRedraw(t), e) {
                         const {
                             startRow: t = 0,
                             endRow: n = 1 / 0
                         } = e;
                         this.state.updateRanges = function(t, e) {
-                            if (t === uv) return t;
+                            if (t === Ev) return t;
                             if (e[0] < 0 && (e[0] = 0), e[0] >= e[1]) return t;
                             const n = [],
                                 i = t.length;
                             let r = 0;
                             for (let s = 0; s < i; s++) {
                                 const i = t[s];
                                 i[1] < e[0] ? (n.push(i), r = s + 1) : i[0] > e[1] ? n.push(i) : e = [Math.min(i[0], e[0]), Math.max(i[1], e[1])]
                             }
                             return n.splice(r, 0, e), n
                         }(this.state.updateRanges, [t, n])
-                    } else this.state.updateRanges = uv
+                    } else this.state.updateRanges = Ev
                 }
                 clearNeedsUpdate() {
-                    this.state.needsUpdate = !1, this.state.updateRanges = hv
+                    this.state.needsUpdate = !1, this.state.updateRanges = wv
                 }
                 setNeedsRedraw(t = this.id) {
                     this.state.needsRedraw = this.state.needsRedraw || t
                 }
                 allocate(t) {
                     const {
                         state: e,
                         settings: n
                     } = this;
-                    return !n.noAlloc && !!n.update && (super.allocate(t, e.updateRanges !== uv), !0)
+                    return !n.noAlloc && !!n.update && (super.allocate(t, e.updateRanges !== Ev), !0)
                 }
                 updateBuffer({
                     numInstances: t,
                     data: e,
                     props: n,
                     context: i
                 }) {
@@ -18950,31 +19545,31 @@
                     if (i.noAlloc) return !1;
                     if (n.binaryValue === t) return this.clearNeedsUpdate(), !0;
                     if (n.binaryValue = t, this.setNeedsRedraw(), i.transform || e !== this.startIndices) {
                         ArrayBuffer.isView(t) && (t = {
                             value: t
                         });
                         const r = t;
-                        Of(ArrayBuffer.isView(r.value), "invalid ".concat(i.accessor));
+                        Mf(ArrayBuffer.isView(r.value), "invalid ".concat(i.accessor));
                         const s = Boolean(r.size) && r.size !== this.size;
-                        return n.binaryAccessor = cv(r.value, {
+                        return n.binaryAccessor = xv(r.value, {
                             size: r.size || this.size,
                             stride: r.stride,
                             offset: r.offset,
                             startIndices: e,
                             nested: s
                         }), !1
                     }
                     return this.clearNeedsUpdate(), this.setData(t), !0
                 }
                 getVertexOffset(t) {
                     const {
                         startIndices: e
                     } = this;
-                    return (e ? t < e.length ? e[t] : this.numInstances : t) * this.size
+                    return (e ? e[t] : t) * this.size
                 }
                 getShaderAttributes() {
                     const t = this.settings.shaderAttributes || {
                             [this.id]: null
                         },
                         e = {};
                     for (const n in t) Object.assign(e, super.getShaderAttributes(n, t[n]));
@@ -18994,29 +19589,29 @@
                         value: l,
                         size: c,
                         startIndices: h
                     } = t, {
                         accessor: u,
                         transform: d
                     } = o, p = a.binaryAccessor || ("function" == typeof u ? u : r[u]);
-                    Of("function" == typeof p, 'accessor "'.concat(u, '" is not a function'));
+                    Mf("function" == typeof p, 'accessor "'.concat(u, '" is not a function'));
                     let f = t.getVertexOffset(n);
                     const {
                         iterable: g,
                         objectInfo: m
-                    } = av(e, n, i);
+                    } = yv(e, n, i);
                     for (const e of g) {
                         m.index++;
                         let n = p(e, m);
                         if (d && (n = d.call(this, n)), h) {
                             const e = (m.index < h.length - 1 ? h[m.index + 1] : s) - h[m.index];
                             if (n && Array.isArray(n[0])) {
                                 let e = f;
                                 for (const i of n) t._normalizeValue(i, l, e), e += c
-                            } else n && n.length > c ? l.set(n, f) : (t._normalizeValue(n, m.target, 0), la({
+                            } else n && n.length > c ? l.set(n, f) : (t._normalizeValue(n, m.target, 0), sa({
                                 target: l,
                                 source: m.target,
                                 start: f,
                                 count: e
                             }));
                             f += e * c
                         } else t._normalizeValue(n, l, f), f += c
@@ -19047,67 +19642,67 @@
                             default:
                                 n = !1
                         }
                         if (!n) throw new Error("Illegal attribute generated for ".concat(this.id))
                     }
                 }
             }
-            const xv = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}",
-                wv = "#version 300 es\n".concat(xv);
+            const Rv = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}",
+                Iv = "#version 300 es\n".concat(Rv);
 
-            function Ev(t, e) {
+            function jv(t, e) {
                 e = Array.isArray(e) ? e : [e];
                 const n = t.replace(/^\s+/, "").split(/\s+/),
                     [i, r, s] = n;
                 return e.includes(i) && r && s ? {
                     qualifier: i,
                     type: r,
                     name: s.split(";")[0]
                 } : null
             }
 
-            function Pv() {
+            function Fv() {
                 let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                 const {
                     version: e = 100,
                     input: n,
                     inputType: i,
                     output: r
                 } = t;
-                if (!n) return 300 === e ? wv : e > 300 ? "#version ".concat(e, "\n").concat(xv) : "void main() {gl_FragColor = vec4(0);}";
+                if (!n) return 300 === e ? Iv : e > 300 ? "#version ".concat(e, "\n").concat(Rv) : "void main() {gl_FragColor = vec4(0);}";
                 const s = function(t, e) {
                     switch (e) {
                         case "float":
                             return "vec4(".concat(t, ", 0.0, 0.0, 1.0)");
                         case "vec2":
                             return "vec4(".concat(t, ", 0.0, 1.0)");
                         case "vec3":
                             return "vec4(".concat(t, ", 1.0)");
                         case "vec4":
                             return t;
                         default:
-                            return Uh(!1), null
+                            return Nh(!1), null
                     }
                 }(n, i);
                 return e >= 300 ? "#version ".concat(e, " ").concat(300 === e ? "es" : "", "\nin ").concat(i, " ").concat(n, ";\nout vec4 ").concat(r, ";\nvoid main() {\n  ").concat(r, " = ").concat(s, ";\n}") : "varying ".concat(i, " ").concat(n, ";\nvoid main() {\n  gl_FragColor = ").concat(s, ";\n}")
             }
-            class Sv extends Rd {
+            class zv extends Ld {
                 get[Symbol.toStringTag]() {
                     return "TransformFeedback"
                 }
                 static isSupported(t) {
-                    return Lu(t)
+                    return Mu(t)
                 }
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
-                    Iu(t), super(t, e), this.initialize(e), this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]), Object.seal(this)
+                    Lu(t), super(t, e), this.initialize(e), this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]), Object.seal(this)
                 }
                 initialize() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                    return this.buffers = {}, this.unused = {}, this.configuration = null, this.bindOnUse = !0, Md(this.buffers) || this.bind((() => this._unbindBuffers())), this.setProps(t), this
+                    return this.buffers = {}, this.unused = {}, this.configuration = null, this.bindOnUse = !0, Ad(this.buffers) || this.bind((() => this._unbindBuffers())), this.setProps(t), this
                 }
                 setProps(t) {
                     "program" in t && (this.configuration = t.program && t.program.configuration), "configuration" in t && (this.configuration = t.configuration), "bindOnUse" in t && (t = t.bindOnUse), "buffers" in t && this.setBuffers(t.buffers)
                 }
                 setBuffers() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     return this.bind((() => {
@@ -19117,26 +19712,26 @@
                 setBuffer(t, e) {
                     const n = this._getVaryingIndex(t),
                         {
                             buffer: i,
                             byteSize: r,
                             byteOffset: s
                         } = this._getBufferParams(e);
-                    return n < 0 ? (this.unused[t] = i, Tu.warn("".concat(this.id, " unused varying buffer ").concat(t))(), this) : (this.buffers[n] = e, this.bindOnUse || this._bindBuffer(n, i, s, r), this)
+                    return n < 0 ? (this.unused[t] = i, Su.warn("".concat(this.id, " unused varying buffer ").concat(t))(), this) : (this.buffers[n] = e, this.bindOnUse || this._bindBuffer(n, i, s, r), this)
                 }
                 begin() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                     return this.gl.bindTransformFeedback(36386, this.handle), this._bindBuffers(), this.gl.beginTransformFeedback(t), this
                 }
                 end() {
                     return this.gl.endTransformFeedback(), this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null), this
                 }
                 _getBufferParams(t) {
                     let e, n, i;
-                    return t instanceof Wd == 0 ? (i = t.buffer, n = t.byteSize, e = t.byteOffset) : i = t, void 0 === e && void 0 === n || (e = e || 0, n = n || i.byteLength - e), {
+                    return t instanceof Gd == 0 ? (i = t.buffer, n = t.byteSize, e = t.byteOffset) : i = t, void 0 === e && void 0 === n || (e = e || 0, n = n || i.byteLength - e), {
                         buffer: i,
                         byteOffset: e,
                         byteSize: n
                     }
                 }
                 _getVaryingInfo(t) {
                     return this.configuration && this.configuration.getVaryingInfo(t)
@@ -19173,15 +19768,15 @@
                 _deleteHandle() {
                     this.gl.deleteTransformFeedback(this.handle)
                 }
                 _bindHandle(t) {
                     this.gl.bindTransformFeedback(36386, this.handle)
                 }
             }
-            class Cv {
+            class Bv {
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     this.gl = t, this.currentIndex = 0, this.feedbackMap = {}, this.varyings = null, this.bindings = [], this.resources = {}, this._initialize(e), Object.seal(this)
                 }
                 setupResources(t) {
                     for (const e of this.bindings) this._setupTransformFeedback(e, t)
                 }
@@ -19213,29 +19808,29 @@
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     this._setupBuffers(t)
                 }
                 getBuffer(t) {
                     const {
                         feedbackBuffers: e
                     } = this.bindings[this.currentIndex], n = t ? e[t] : null;
-                    return n ? n instanceof Wd ? n : n.buffer : null
+                    return n ? n instanceof Gd ? n : n.buffer : null
                 }
                 getData() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const {
                         varyingName: e
                     } = t, n = this.getBuffer(e);
                     return n ? n.getData() : null
                 }
                 delete() {
                     for (const t in this.resources) this.resources[t].delete()
                 }
                 _initialize() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                    this._setupBuffers(t), this.varyings = t.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers), this.varyings.length > 0 && Ed(Lu(this.gl))
+                    this._setupBuffers(t), this.varyings = t.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers), this.varyings.length > 0 && wd(Mu(this.gl))
                 }
                 _getFeedbackBuffers(t) {
                     const {
                         sourceBuffers: e = {}
                     } = t, n = {};
                     if (this.bindings[this.currentIndex] && Object.assign(n, this.bindings[this.currentIndex].feedbackBuffers), this.feedbackMap)
                         for (const t in this.feedbackMap) {
@@ -19276,15 +19871,15 @@
                 _setupTransformFeedback(t, e) {
                     let {
                         model: n
                     } = e;
                     const {
                         program: i
                     } = n;
-                    t.transformFeedback = new Sv(this.gl, {
+                    t.transformFeedback = new zv(this.gl, {
                         program: i,
                         buffers: t.feedbackBuffers
                     })
                 }
                 _updateBindings(t) {
                     if (this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], t), this.feedbackMap) {
                         const {
@@ -19305,53 +19900,53 @@
                 }
                 _swapBuffers(t) {
                     if (!this.feedbackMap) return null;
                     const e = Object.assign({}, t.sourceBuffers),
                         n = Object.assign({}, t.feedbackBuffers);
                     for (const i in this.feedbackMap) {
                         const r = this.feedbackMap[i];
-                        e[i] = t.feedbackBuffers[r], n[r] = t.sourceBuffers[i], Ed(n[r] instanceof Wd)
+                        e[i] = t.feedbackBuffers[r], n[r] = t.sourceBuffers[i], wd(n[r] instanceof Gd)
                     }
                     return {
                         sourceBuffers: e,
                         feedbackBuffers: n
                     }
                 }
                 _createNewBuffer(t, e) {
-                    const n = new Wd(this.gl, e);
+                    const n = new Gd(this.gl, e);
                     return this.resources[t] && this.resources[t].delete(), this.resources[t] = n, n
                 }
                 _getNextIndex() {
                     return (this.currentIndex + 1) % 2
                 }
             }
 
-            function Tv(t) {
+            function Dv(t) {
                 let e = 100;
                 const n = t.match(/[^\s]+/g);
                 if (n.length >= 2 && "#version" === n[0]) {
                     const t = parseInt(n[1], 10);
                     Number.isFinite(t) && (e = t)
                 }
                 return e
             }
-            const Av = {
+            const Nv = {
                     name: "transform",
                     vs: "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n",
                     fs: null
                 },
-                Mv = "transform_uSize_",
-                Ov = "transform_position";
-            const Lv = {
+                Vv = "transform_uSize_",
+                Uv = "transform_position";
+            const Gv = {
                 10241: 9728,
                 10240: 9728,
                 10242: 33071,
                 10243: 33071
             };
-            class Rv {
+            class Wv {
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     this.gl = t, this.id = this.currentIndex = 0, this._swapTexture = null, this.targetTextureVarying = null, this.targetTextureType = null, this.samplerTextureMap = null, this.bindings = [], this.resources = {}, this._initialize(e), Object.seal(this)
                 }
                 updateModelProps() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const e = this._processVertexShader(t);
@@ -19380,19 +19975,19 @@
                                 targetTexture: i
                             } = t;
                             const r = {};
                             let s, o;
                             n && (({
                                 width: s,
                                 height: o
-                            } = i), r["".concat(Mv).concat(n)] = [s, o]);
+                            } = i), r["".concat(Vv).concat(n)] = [s, o]);
                             for (const t in e)({
                                 width: s,
                                 height: o
-                            } = e[t]), r["".concat(Mv).concat(t)] = [s, o];
+                            } = e[t]), r["".concat(Vv).concat(t)] = [s, o];
                             return r
                         }({
                             sourceTextureMap: n,
                             targetTextureVarying: this.targetTextureVarying,
                             targetTexture: r
                         });
                         Object.assign(o, t)
@@ -19420,29 +20015,29 @@
                 }
                 getData() {
                     let {
                         packed: t = !1
                     } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const {
                         framebuffer: e
-                    } = this.bindings[this.currentIndex], n = lp(e);
+                    } = this.bindings[this.currentIndex], n = ap(e);
                     if (!t) return n;
                     const i = n.constructor,
                         r = function(t) {
                             switch (t) {
                                 case "float":
                                     return 1;
                                 case "vec2":
                                     return 2;
                                 case "vec3":
                                     return 3;
                                 case "vec4":
                                     return 4;
                                 default:
-                                    return Uh(!1), null
+                                    return Nh(!1), null
                             }
                         }(this.targetTextureType),
                         s = new i(n.length * r / 4);
                     let o = 0;
                     for (let t = 0; t < n.length; t += 4)
                         for (let e = 0; e < r; e++) s[o++] = n[t + e];
                     return s
@@ -19462,15 +20057,15 @@
                     this._swapTexture = n, this.targetTextureVarying = e, this.hasTargetTexture = e, this._setupTextures(t)
                 }
                 _createTargetTexture(t) {
                     const {
                         sourceTextures: e,
                         textureOrReference: n
                     } = t;
-                    if (n instanceof Qd) return n;
+                    if (n instanceof Kd) return n;
                     const i = e[n];
                     return i ? (this._targetRefTexName = n, this._createNewTexture(i)) : null
                 }
                 _setupTextures() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const {
                         sourceBuffers: e,
@@ -19489,15 +20084,15 @@
                 _updateElementIDBuffer(t) {
                     if ("number" != typeof t || this.elementCount >= t) return;
                     const e = new Float32Array(t);
                     e.forEach(((t, e, n) => {
                         n[e] = e
                     })), this.elementIDBuffer ? this.elementIDBuffer.setData({
                         data: e
-                    }) : this.elementIDBuffer = new Wd(this.gl, {
+                    }) : this.elementIDBuffer = new Gd(this.gl, {
                         data: e,
                         accessor: {
                             size: 1
                         }
                     }), this.elementCount = t
                 }
                 _updateBindings(t) {
@@ -19534,15 +20129,15 @@
                             attachments: {
                                 36064: r
                             },
                             resizeAttachments: !1
                         }), i.resize({
                             width: e,
                             height: n
-                        })) : t.framebuffer = new bp(this.gl, {
+                        })) : t.framebuffer = new vp(this.gl, {
                             id: "transform-framebuffer",
                             width: e,
                             height: n,
                             attachments: {
                                 36064: r
                             }
                         })
@@ -19550,27 +20145,27 @@
                     return t
                 }
                 _setSourceTextureParameters() {
                     const t = this.currentIndex,
                         {
                             sourceTextures: e
                         } = this.bindings[t];
-                    for (const t in e) e[t].setParameters(Lv)
+                    for (const t in e) e[t].setParameters(Gv)
                 }
                 _swapTextures(t) {
                     if (!this._swapTexture) return null;
                     const e = Object.assign({}, t.sourceTextures);
                     return e[this._swapTexture] = t.targetTexture, {
                         sourceTextures: e,
                         targetTexture: t.sourceTextures[this._swapTexture]
                     }
                 }
                 _createNewTexture(t) {
                     const e = function(t, e) {
-                        Ed(t instanceof Qd || t instanceof sp || t instanceof op);
+                        wd(t instanceof Kd || t instanceof rp || t instanceof sp);
                         const n = t.constructor,
                             {
                                 gl: i,
                                 width: r,
                                 height: s,
                                 format: o,
                                 type: a,
@@ -19628,30 +20223,30 @@
                             const t = l.split("\n"),
                                 e = t.slice();
                             if (t.forEach(((t, r, l) => {
                                     if (s > 0) {
                                         const i = function(t, e) {
                                             const n = {},
                                                 i = function(t) {
-                                                    return Ev(t, ["attribute", "in"])
+                                                    return jv(t, ["attribute", "in"])
                                                 }(t);
                                             if (!i) return null;
                                             const {
                                                 type: r,
                                                 name: s
                                             } = i;
                                             if (s && e[s]) {
                                                 const e = "// ".concat(t, " => Replaced by Transform with a sampler"),
                                                     {
                                                         samplerName: i,
                                                         sizeName: o,
                                                         uniformDeclerations: a
                                                     } = function(t) {
                                                         const e = "".concat("transform_uSampler_").concat(t),
-                                                            n = "".concat(Mv).concat(t);
+                                                            n = "".concat(Vv).concat(t);
                                                         return {
                                                             samplerName: e,
                                                             sizeName: n,
                                                             uniformDeclerations: "  uniform sampler2D ".concat(e, ";\n  uniform vec2 ").concat(n, ";")
                                                         }
                                                     }(s),
                                                     l = function(t) {
@@ -19661,15 +20256,15 @@
                                                             case "vec2":
                                                                 return "xy";
                                                             case "vec3":
                                                                 return "xyz";
                                                             case "vec4":
                                                                 return "xyzw";
                                                             default:
-                                                                return Uh(!1), null
+                                                                return Nh(!1), null
                                                         }
                                                     }(r),
                                                     c = "  ".concat(r, " ").concat(s, " = transform_getInput(").concat(i, ", ").concat(o, ").").concat(l, ";\n");
                                                 return n[i] = s, {
                                                     updatedLine: e,
                                                     inject: {
                                                         "vs:#decl": a,
@@ -19681,27 +20276,27 @@
                                             return null
                                         }(t, n);
                                         if (i) {
                                             const {
                                                 updatedLine: t,
                                                 inject: n
                                             } = i;
-                                            e[r] = t, c = uu([c, n]), Object.assign(a, i.samplerTextureMap), s--
+                                            e[r] = t, c = cu([c, n]), Object.assign(a, i.samplerTextureMap), s--
                                         }
                                     }
                                     i && !o && (o = function(t, e) {
-                                        const n = Ev(t, ["varying", "out"]);
+                                        const n = jv(t, ["varying", "out"]);
                                         return n && n.name === e ? n.type : null
                                     }(t, i))
                                 })), i) {
-                                Ed(r);
-                                const t = "".concat(Mv).concat(i),
+                                wd(r);
+                                const t = "".concat(Vv).concat(i),
                                     e = "uniform vec2 ".concat(t, ";\n"),
-                                    n = "     vec2 ".concat(Ov, " = transform_getPos(").concat(t, ");\n     gl_Position = vec4(").concat(Ov, ", 0, 1.);\n");
-                                c = uu([c, {
+                                    n = "     vec2 ".concat(Uv, " = transform_getPos(").concat(t, ");\n     gl_Position = vec4(").concat(Uv, ", 0, 1.);\n");
+                                c = cu([c, {
                                     "vs:#decl": e,
                                     "vs:#main-start": n
                                 }])
                             }
                             l = e.join("\n")
                         }
                         return {
@@ -19711,84 +20306,84 @@
                             samplerTextureMap: a
                         }
                     }({
                         vs: t.vs,
                         sourceTextureMap: e,
                         targetTextureVarying: this.targetTextureVarying,
                         targetTexture: n
-                    }), l = uu([t.inject || {}, o]);
+                    }), l = cu([t.inject || {}, o]);
                     return this.targetTextureType = s, this.samplerTextureMap = a, {
                         vs: i,
-                        fs: t._fs || Pv({
-                            version: Tv(i),
+                        fs: t._fs || Fv({
+                            version: Dv(i),
                             input: this.targetTextureVarying,
                             inputType: s,
                             output: "transform_output"
                         }),
-                        modules: this.hasSourceTextures || this.targetTextureVarying ? [Av].concat(t.modules || []) : t.modules,
+                        modules: this.hasSourceTextures || this.targetTextureVarying ? [Nv].concat(t.modules || []) : t.modules,
                         uniforms: r,
                         inject: l
                     }
                 }
             }
-            let Iv = null;
-            class kv extends Rd {
+            let Hv = null;
+            class Zv extends Ld {
                 get[Symbol.toStringTag]() {
                     return "VertexArrayObject"
                 }
                 static isSupported(t) {
-                    return !(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).constantAttributeZero || Lu(t) || "Chrome" === sm()
+                    return !(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).constantAttributeZero || Mu(t) || "Chrome" === vm()
                 }
                 static getDefaultArray(t) {
-                    return t.luma = t.luma || {}, t.luma.defaultVertexArray || (t.luma.defaultVertexArray = new kv(t, {
+                    return t.luma = t.luma || {}, t.luma.defaultVertexArray || (t.luma.defaultVertexArray = new Zv(t, {
                         handle: null,
                         isDefaultArray: !0
                     })), t.luma.defaultVertexArray
                 }
                 static getMaxAttributes(t) {
-                    return kv.MAX_ATTRIBUTES = kv.MAX_ATTRIBUTES || t.getParameter(34921), kv.MAX_ATTRIBUTES
+                    return Zv.MAX_ATTRIBUTES = Zv.MAX_ATTRIBUTES || t.getParameter(34921), Zv.MAX_ATTRIBUTES
                 }
                 static setConstant(t, e, n) {
                     switch (n.constructor) {
                         case Float32Array:
-                            kv._setConstantFloatArray(t, e, n);
+                            Zv._setConstantFloatArray(t, e, n);
                             break;
                         case Int32Array:
-                            kv._setConstantIntArray(t, e, n);
+                            Zv._setConstantIntArray(t, e, n);
                             break;
                         case Uint32Array:
-                            kv._setConstantUintArray(t, e, n);
+                            Zv._setConstantUintArray(t, e, n);
                             break;
                         default:
-                            Ed(!1)
+                            wd(!1)
                     }
                 }
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     const n = e.id || e.program && e.program.id;
                     super(t, Object.assign({}, e, {
                         id: n
                     })), this.buffer = null, this.bufferValue = null, this.isDefaultArray = e.isDefaultArray || !1, this.gl2 = t, this.initialize(e), Object.seal(this)
                 }
                 delete() {
                     return super.delete(), this.buffer && this.buffer.delete(), this
                 }
                 get MAX_ATTRIBUTES() {
-                    return kv.getMaxAttributes(this.gl)
+                    return Zv.getMaxAttributes(this.gl)
                 }
                 initialize() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     return this.setProps(t)
                 }
                 setProps(t) {
                     return this
                 }
                 setElementBuffer() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
-                    return Ed(!t || 34963 === t.target, "elements must be GL.ELEMENT_ARRAY_BUFFER"), this.bind((() => {
+                    return wd(!t || 34963 === t.target, "elements must be GL.ELEMENT_ARRAY_BUFFER"), this.bind((() => {
                         this.gl.bindBuffer(34963, t ? t.handle : null)
                     })), this
                 }
                 setBuffer(t, e, n) {
                     if (34963 === e.target) return this.setElementBuffer(e, n);
                     const {
                         size: i,
@@ -19799,32 +20394,32 @@
                         integer: l,
                         divisor: c
                     } = n, {
                         gl: h,
                         gl2: u
                     } = this;
                     return t = Number(t), this.bind((() => {
-                        h.bindBuffer(34962, e.handle), l ? (Ed(Lu(h)), u.vertexAttribIPointer(t, i, r, s, o)) : h.vertexAttribPointer(t, i, r, a, s, o), h.enableVertexAttribArray(t), u.vertexAttribDivisor(t, c || 0)
+                        h.bindBuffer(34962, e.handle), l ? (wd(Mu(h)), u.vertexAttribIPointer(t, i, r, s, o)) : h.vertexAttribPointer(t, i, r, a, s, o), h.enableVertexAttribArray(t), u.vertexAttribDivisor(t, c || 0)
                     })), this
                 }
                 enable(t) {
                     let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
-                    return !e && 0 === t && !kv.isSupported(this.gl, {
+                    return !e && 0 === t && !Zv.isSupported(this.gl, {
                         constantAttributeZero: !0
                     }) || (t = Number(t), this.bind((() => e ? this.gl.enableVertexAttribArray(t) : this.gl.disableVertexAttribArray(t)))), this
                 }
                 getConstantBuffer(t, e) {
                     const n = this._normalizeConstantArrayValue(e),
                         i = n.byteLength * t,
                         r = n.length * t;
                     let s = !this.buffer;
-                    if (this.buffer = this.buffer || new Wd(this.gl, i), s = s || this.buffer.reallocate(i), s = s || !this._compareConstantArrayValues(n, this.bufferValue), s) {
+                    if (this.buffer = this.buffer || new Gd(this.gl, i), s = s || this.buffer.reallocate(i), s = s || !this._compareConstantArrayValues(n, this.bufferValue), s) {
                         const t = function(t, e) {
                             var n;
-                            return new t((n = t.BYTES_PER_ELEMENT * e, (!Iv || Iv.byteLength < n) && (Iv = new ArrayBuffer(n)), Iv), 0, e)
+                            return new t((n = t.BYTES_PER_ELEMENT * e, (!Hv || Hv.byteLength < n) && (Hv = new ArrayBuffer(n)), Hv), 0, e)
                         }(e.constructor, r);
                         ! function(t) {
                             let {
                                 target: e,
                                 source: n,
                                 start: i = 0,
                                 count: r = 1
@@ -19863,51 +20458,51 @@
                         case 3:
                             t.vertexAttrib3fv(e, n);
                             break;
                         case 4:
                             t.vertexAttrib4fv(e, n);
                             break;
                         default:
-                            Ed(!1)
+                            wd(!1)
                     }
                 }
                 static _setConstantIntArray(t, e, n) {
-                    switch (Ed(Lu(t)), n.length) {
+                    switch (wd(Mu(t)), n.length) {
                         case 1:
                             t.vertexAttribI1iv(e, n);
                             break;
                         case 2:
                             t.vertexAttribI2iv(e, n);
                             break;
                         case 3:
                             t.vertexAttribI3iv(e, n);
                             break;
                         case 4:
                             t.vertexAttribI4iv(e, n);
                             break;
                         default:
-                            Ed(!1)
+                            wd(!1)
                     }
                 }
                 static _setConstantUintArray(t, e, n) {
-                    switch (Ed(Lu(t)), n.length) {
+                    switch (wd(Mu(t)), n.length) {
                         case 1:
                             t.vertexAttribI1uiv(e, n);
                             break;
                         case 2:
                             t.vertexAttribI2uiv(e, n);
                             break;
                         case 3:
                             t.vertexAttribI3uiv(e, n);
                             break;
                         case 4:
                             t.vertexAttribI4uiv(e, n);
                             break;
                         default:
-                            Ed(!1)
+                            wd(!1)
                     }
                 }
                 _createHandle() {
                     return this.gl.createVertexArray()
                 }
                 _deleteHandle(t) {
                     return this.gl2.deleteVertexArray(t), [this.elements]
@@ -19915,24 +20510,24 @@
                 _bindHandle(t) {
                     this.gl2.bindVertexArray(t)
                 }
                 _getParameter(t, e) {
                     let {
                         location: n
                     } = e;
-                    return Ed(Number.isFinite(n)), this.bind((() => 34373 === t ? this.gl.getVertexAttribOffset(n, t) : this.gl.getVertexAttrib(n, t)))
+                    return wd(Number.isFinite(n)), this.bind((() => 34373 === t ? this.gl.getVertexAttribOffset(n, t) : this.gl.getVertexAttrib(n, t)))
                 }
             }
-            const jv = /^(.+)__LOCATION_([0-9]+)$/,
-                Fv = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
-            class zv {
+            const qv = /^(.+)__LOCATION_([0-9]+)$/,
+                Xv = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
+            class Yv {
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     const n = e.id || e.program && e.program.id;
-                    this.id = n, this.gl = t, this.configuration = null, this.elements = null, this.elementsAccessor = null, this.values = null, this.accessors = null, this.unused = null, this.drawParams = null, this.buffer = null, this.attributes = {}, this.vertexArrayObject = new kv(t), Od(this, "VertexArray", "v6.0", Fv), this.initialize(e), Object.seal(this)
+                    this.id = n, this.gl = t, this.configuration = null, this.elements = null, this.elementsAccessor = null, this.values = null, this.accessors = null, this.unused = null, this.drawParams = null, this.buffer = null, this.attributes = {}, this.vertexArrayObject = new Zv(t), Md(this, "VertexArray", "v6.0", Xv), this.initialize(e), Object.seal(this)
                 }
                 delete() {
                     this.buffer && this.buffer.delete(), this.vertexArrayObject.delete()
                 }
                 initialize() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     return this.reset(), this.configuration = null, this.bindOnUse = !1, this.setProps(t)
@@ -19984,28 +20579,28 @@
                     } = this._resolveLocationAndAccessor(t, e, Object.assign({
                         size: e.length
                     }, n));
                     return i >= 0 && (e = this.vertexArrayObject._normalizeConstantArrayValue(e), this.values[i] = e, this.accessors[i] = r, this.clearDrawParams(), this.vertexArrayObject.enable(i, !1)), this
                 }
                 unbindBuffers() {
                     return this.vertexArrayObject.bind((() => {
-                        this.elements && this.vertexArrayObject.setElementBuffer(null), this.buffer = this.buffer || new Wd(this.gl, {
+                        this.elements && this.vertexArrayObject.setElementBuffer(null), this.buffer = this.buffer || new Gd(this.gl, {
                             accessor: {
                                 size: 4
                             }
                         });
-                        for (let t = 0; t < this.vertexArrayObject.MAX_ATTRIBUTES; t++) this.values[t] instanceof Wd && (this.gl.disableVertexAttribArray(t), this.gl.bindBuffer(34962, this.buffer.handle), this.gl.vertexAttribPointer(t, 1, 5126, !1, 0, 0))
+                        for (let t = 0; t < this.vertexArrayObject.MAX_ATTRIBUTES; t++) this.values[t] instanceof Gd && (this.gl.disableVertexAttribArray(t), this.gl.bindBuffer(34962, this.buffer.handle), this.gl.vertexAttribPointer(t, 1, 5126, !1, 0, 0))
                     })), this
                 }
                 bindBuffers() {
                     return this.vertexArrayObject.bind((() => {
                         this.elements && this.setElementBuffer(this.elements);
                         for (let t = 0; t < this.vertexArrayObject.MAX_ATTRIBUTES; t++) {
                             const e = this.values[t];
-                            e instanceof Wd && this.setBuffer(t, e)
+                            e instanceof Gd && this.setBuffer(t, e)
                         }
                     })), this
                 }
                 bindForDraw(t, e, n) {
                     let i;
                     return this.vertexArrayObject.bind((() => {
                         this._setConstantAttributes(t, e), i = n()
@@ -20016,77 +20611,77 @@
                             location: -1,
                             accessor: null
                         },
                         {
                             location: s,
                             name: o
                         } = this._getAttributeIndex(t);
-                    if (!Number.isFinite(s) || s < 0) return this.unused[t] = e, Tu.once(3, (() => "unused value ".concat(t, " in ").concat(this.id)))(), r;
+                    if (!Number.isFinite(s) || s < 0) return this.unused[t] = e, Su.once(3, (() => "unused value ".concat(t, " in ").concat(this.id)))(), r;
                     const a = this._getAttributeInfo(o || s);
                     if (!a) return r;
                     const l = this.accessors[s] || {},
-                        c = Nd.resolve(a.accessor, l, n, i),
+                        c = Dd.resolve(a.accessor, l, n, i),
                         {
                             size: h,
                             type: u
                         } = c;
-                    return Ed(Number.isFinite(h) && Number.isFinite(u)), {
+                    return wd(Number.isFinite(h) && Number.isFinite(u)), {
                         location: s,
                         accessor: c
                     }
                 }
                 _getAttributeInfo(t) {
                     return this.configuration && this.configuration.getAttributeInfo(t)
                 }
                 _getAttributeIndex(t) {
                     const e = Number(t);
                     if (Number.isFinite(e)) return {
                         location: e
                     };
-                    const n = jv.exec(t),
+                    const n = qv.exec(t),
                         i = n ? n[1] : t,
                         r = n ? Number(n[2]) : 0;
                     return this.configuration ? {
                         location: this.configuration.getAttributeLocation(i) + r,
                         name: i
                     } : {
                         location: -1
                     }
                 }
                 _setAttribute(t, e) {
-                    if (e instanceof Wd) this.setBuffer(t, e);
-                    else if (Array.isArray(e) && e.length && e[0] instanceof Wd) {
+                    if (e instanceof Gd) this.setBuffer(t, e);
+                    else if (Array.isArray(e) && e.length && e[0] instanceof Gd) {
                         const n = e[0],
                             i = e[1];
                         this.setBuffer(t, n, i)
                     } else if (ArrayBuffer.isView(e) || Array.isArray(e)) {
                         const n = e;
                         this.setConstant(t, n)
                     } else {
-                        if (!(e.buffer instanceof Wd)) throw new Error("VertexArray: attributes must be Buffers or constants (i.e. typed array)"); {
+                        if (!(e.buffer instanceof Gd)) throw new Error("VertexArray: attributes must be Buffers or constants (i.e. typed array)"); {
                             const n = e;
                             this.setBuffer(t, n.buffer, n)
                         }
                     }
                 }
                 _setConstantAttributes(t, e) {
                     const n = Math.max(0 | t, 0 | e);
                     let i = this.values[0];
                     ArrayBuffer.isView(i) && this._setConstantAttributeZero(i, n);
                     for (let t = 1; t < this.vertexArrayObject.MAX_ATTRIBUTES; t++) i = this.values[t], ArrayBuffer.isView(i) && this._setConstantAttribute(t, i)
                 }
                 _setConstantAttributeZero(t, e) {
-                    if (kv.isSupported(this.gl, {
+                    if (Zv.isSupported(this.gl, {
                             constantAttributeZero: !0
                         })) return void this._setConstantAttribute(0, t);
                     const n = this.vertexArrayObject.getConstantBuffer(e, t);
                     this.vertexArrayObject.setBuffer(0, n, this.accessors[0])
                 }
                 _setConstantAttribute(t, e) {
-                    kv.setConstant(this.gl, t, e)
+                    Zv.setConstant(this.gl, t, e)
                 }
                 _updateDrawParams() {
                     const t = {
                         isIndexed: !1,
                         isInstanced: !1,
                         indexCount: 1 / 0,
                         vertexCount: 1 / 0,
@@ -20098,197 +20693,197 @@
                 _updateDrawParamsForLocation(t, e) {
                     const n = this.values[e],
                         i = this.accessors[e];
                     if (!n) return;
                     const {
                         divisor: r
                     } = i, s = r > 0;
-                    if (t.isInstanced = t.isInstanced || s, n instanceof Wd) {
+                    if (t.isInstanced = t.isInstanced || s, n instanceof Gd) {
                         const e = n;
                         if (s) {
                             const n = e.getVertexCount(i);
                             t.instanceCount = Math.min(t.instanceCount, n)
                         } else {
                             const n = e.getVertexCount(i);
                             t.vertexCount = Math.min(t.vertexCount, n)
                         }
                     }
                 }
                 setElements() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                         e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
-                    return Tu.deprecated("setElements", "setElementBuffer")(), this.setElementBuffer(t, e)
+                    return Su.deprecated("setElements", "setElementBuffer")(), this.setElementBuffer(t, e)
                 }
             }
 
-            function Bv(t) {
+            function Kv(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                 const {
                     isInteger: n = !1
                 } = e;
                 if (Array.isArray(t) || ArrayBuffer.isView(t)) return function(t, e) {
                     const {
                         maxElts: n = 16,
                         size: i = 1
                     } = e;
                     let r = "[";
-                    for (let s = 0; s < t.length && s < n; ++s) s > 0 && (r += ",".concat(s % i == 0 ? " " : "")), r += Bv(t[s], e);
+                    for (let s = 0; s < t.length && s < n; ++s) s > 0 && (r += ",".concat(s % i == 0 ? " " : "")), r += Kv(t[s], e);
                     const s = t.length > n ? "..." : "]";
                     return "".concat(r).concat(s)
                 }(t, e);
                 if (!Number.isFinite(t)) return String(t);
                 if (Math.abs(t) < 1e-16) return n ? "0" : "0.";
                 if (n) return t.toFixed(0);
                 if (Math.abs(t) > 100 && Math.abs(t) < 1e4) return t.toFixed(0);
                 const i = t.toPrecision(2);
                 return i.indexOf(".0") === i.length - 2 ? i.slice(0, -1) : i
             }
 
-            function Dv(t, e, n, i) {
+            function Qv(t, e, n, i) {
                 const {
                     gl: r
                 } = t;
                 if (!e) return {
                     [i]: "null",
                     "Format ": "N/A"
                 };
                 let s, o, a, l = "NOT PROVIDED",
                     c = 1,
                     h = 0,
                     u = 0;
-                if (n && (l = n.type, c = n.size, l = String(l).replace("Array", ""), s = -1 !== l.indexOf("nt")), e instanceof Wd) {
+                if (n && (l = n.type, c = n.size, l = String(l).replace("Array", ""), s = -1 !== l.indexOf("nt")), e instanceof Gd) {
                     const t = e,
                         {
                             data: d,
                             changed: p
                         } = t.getDebugData();
                     let f;
                     if (o = p ? "*" : "", a = d, u = t.byteLength, h = u / d.BYTES_PER_ELEMENT / c, n) {
                         const t = n.divisor > 0;
-                        f = "".concat(t ? "I " : "P ", " ").concat(h, " (x").concat(c, "=").concat(u, " bytes ").concat(Sd(r, l), ")")
+                        f = "".concat(t ? "I " : "P ", " ").concat(h, " (x").concat(c, "=").concat(u, " bytes ").concat(Pd(r, l), ")")
                     } else s = !0, f = "".concat(u, " bytes");
                     return {
-                        [i]: "".concat(o).concat(Bv(a, {
+                        [i]: "".concat(o).concat(Kv(a, {
                             size: c,
                             isInteger: s
                         })),
                         "Format ": f
                     }
                 }
                 return a = e, c = e.length, l = String(e.constructor.name).replace("Array", ""), s = -1 !== l.indexOf("nt"), {
-                    [i]: "".concat(Bv(a, {
+                    [i]: "".concat(Kv(a, {
                         size: c,
                         isInteger: s
                     }), " (constant)"),
                     "Format ": "".concat(c, "x").concat(l, " (constant)")
                 }
             }
 
-            function Nv(t, e) {
+            function Jv(t, e) {
                 const {
                     type: n,
                     size: i
-                } = e, r = Qp(n, i);
+                } = e, r = Kp(n, i);
                 return r ? "".concat(t, " (").concat(r.name, ")") : t
             }
 
-            function Vv(t) {
+            function $v(t) {
                 let {
                     header: e = "Uniforms",
                     program: n,
                     uniforms: i,
                     undefinedOnly: r = !1
                 } = t;
-                Ed(n);
+                wd(n);
                 const s = ".*Matrix",
                     o = n._uniformSetters,
                     a = {},
                     l = Object.keys(o).sort();
                 let c = 0;
-                for (const t of l) t.match(".*_.*") || t.match(s) || Uv({
+                for (const t of l) t.match(".*_.*") || t.match(s) || tb({
                     table: a,
                     header: e,
                     uniforms: i,
                     uniformName: t,
                     undefinedOnly: r
                 }) && c++;
-                for (const t of l) t.match(s) && Uv({
+                for (const t of l) t.match(s) && tb({
                     table: a,
                     header: e,
                     uniforms: i,
                     uniformName: t,
                     undefinedOnly: r
                 }) && c++;
-                for (const t of l) a[t] || Uv({
+                for (const t of l) a[t] || tb({
                     table: a,
                     header: e,
                     uniforms: i,
                     uniformName: t,
                     undefinedOnly: r
                 }) && c++;
                 let h = 0;
                 const u = {};
                 if (!r)
                     for (const t in i) {
                         const n = i[t];
                         a[t] || (h++, u[t] = {
                             Type: "NOT USED: ".concat(n),
-                            [e]: Bv(n)
+                            [e]: Kv(n)
                         })
                     }
                 return {
                     table: a,
                     count: c,
                     unusedTable: u,
                     unusedCount: h
                 }
             }
 
-            function Uv(t) {
+            function tb(t) {
                 let {
                     table: e,
                     header: n,
                     uniforms: i,
                     uniformName: r,
                     undefinedOnly: s
                 } = t;
                 const o = i[r],
                     a = function(t) {
                         return null != t
                     }(o);
                 return !(s && a || (e[r] = {
-                    [n]: a ? Bv(o) : "N/A",
+                    [n]: a ? Kv(o) : "N/A",
                     "Uniform Type": a ? o : "NOT PROVIDED"
                 }, 0))
             }
 
-            function Gv(t) {
+            function eb(t) {
                 const {
                     type: e,
                     size: n
-                } = t.accessor, i = Qp(e, n);
+                } = t.accessor, i = Kp(e, n);
                 return i ? "".concat(i.name, " ").concat(t.name) : t.name
             }
-            const Wv = {
+            const nb = {
                 POSITION: "positions",
                 NORMAL: "normals",
                 COLOR_0: "colors",
                 TEXCOORD_0: "texCoords",
                 TEXCOORD_1: "texCoords1",
                 TEXCOORD_2: "texCoords2"
             };
 
-            function Hv(t, e) {
+            function ib(t, e) {
                 const {
-                    attributeMap: n = Wv
+                    attributeMap: n = nb
                 } = e || {};
                 return n && n[t] || t
             }
 
-            function Zv(t, e) {
+            function rb(t, e) {
                 let n;
                 switch (t) {
                     case "texCoords":
                     case "texCoord1":
                     case "texCoord2":
                     case "texCoord3":
                         n = "uvs";
@@ -20302,28 +20897,28 @@
                 switch (n) {
                     case "vectors":
                         e.size = e.size || 3;
                         break;
                     case "uvs":
                         e.size = e.size || 2
                 }
-                Ed(Number.isFinite(e.size), "attribute ".concat(t, " needs size"))
+                wd(Number.isFinite(e.size), "attribute ".concat(t, " needs size"))
             }
-            const qv = () => {},
-                Xv = {};
-            class Yv {
+            const sb = () => {},
+                ob = {};
+            class ab {
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     const {
-                        id: n = Td("model")
+                        id: n = Cd("model")
                     } = e;
-                    Ed(Ou(t)), this.id = n, this.gl = t, this.id = e.id || Td("Model"), this.lastLogTime = 0, this.animated = !1, this.initialize(e)
+                    wd(Au(t)), this.id = n, this.gl = t, this.id = e.id || Cd("Model"), this.lastLogTime = 0, this.animated = !1, this.initialize(e)
                 }
                 initialize(t) {
-                    this.props = {}, this.programManager = t.programManager || nf.getDefaultProgramManager(this.gl), this._programManagerState = -1, this._managedProgram = !1;
+                    this.props = {}, this.programManager = t.programManager || ef.getDefaultProgramManager(this.gl), this._programManagerState = -1, this._managedProgram = !1;
                     const {
                         program: e = null,
                         vs: n,
                         fs: i,
                         modules: r,
                         defines: s,
                         inject: o,
@@ -20337,15 +20932,15 @@
                         fs: i,
                         modules: r,
                         defines: s,
                         inject: o,
                         varyings: a,
                         bufferMode: l,
                         transpileToGLSL100: c
-                    }, this.program = null, this.vertexArray = null, this._programDirty = !0, this.userData = {}, this.needsRedraw = !0, this._attributes = {}, this.attributes = {}, this.uniforms = {}, this.pickable = !0, this._checkProgram(), this.setUniforms(Object.assign({}, this.getModuleUniforms(t.moduleSettings))), this.drawMode = void 0 !== t.drawMode ? t.drawMode : 4, this.vertexCount = t.vertexCount || 0, this.geometryBuffers = {}, this.isInstanced = t.isInstanced || t.instanced || t.instanceCount > 0, this._setModelProps(t), this.geometry = {}, Ed(void 0 !== this.drawMode && Number.isFinite(this.vertexCount), "Model needs drawMode and vertexCount")
+                    }, this.program = null, this.vertexArray = null, this._programDirty = !0, this.userData = {}, this.needsRedraw = !0, this._attributes = {}, this.attributes = {}, this.uniforms = {}, this.pickable = !0, this._checkProgram(), this.setUniforms(Object.assign({}, this.getModuleUniforms(t.moduleSettings))), this.drawMode = void 0 !== t.drawMode ? t.drawMode : 4, this.vertexCount = t.vertexCount || 0, this.geometryBuffers = {}, this.isInstanced = t.isInstanced || t.instanced || t.instanceCount > 0, this._setModelProps(t), this.geometry = {}, wd(void 0 !== this.drawMode && Number.isFinite(this.vertexCount), "Model needs drawMode and vertexCount")
                 }
                 setProps(t) {
                     this._setModelProps(t)
                 }
                 delete() {
                     for (const t in this._attributes) this._attributes[t] !== this.attributes[t] && this._attributes[t].delete();
                     this._managedProgram && (this.programManager.release(this.program), this._managedProgram = !1), this.vertexArray.delete(), this._deleteGeometryBuffers()
@@ -20392,54 +20987,54 @@
                 getUniforms() {
                     return this.uniforms
                 }
                 setDrawMode(t) {
                     return this.drawMode = t, this
                 }
                 setVertexCount(t) {
-                    return Ed(Number.isFinite(t)), this.vertexCount = t, this
+                    return wd(Number.isFinite(t)), this.vertexCount = t, this
                 }
                 setInstanceCount(t) {
-                    return Ed(Number.isFinite(t)), this.instanceCount = t, this
+                    return wd(Number.isFinite(t)), this.instanceCount = t, this
                 }
                 setGeometry(t) {
                     return this.drawMode = t.drawMode, this.vertexCount = t.getVertexCount(), this._deleteGeometryBuffers(), this.geometryBuffers = function(t, e, n) {
                         const i = {};
                         let r = e.indices;
                         for (const n in e.attributes) {
                             const s = e.attributes[n],
-                                o = Hv(n, undefined);
+                                o = ib(n, undefined);
                             if ("indices" === n) r = s;
                             else if (s.constant) i[o] = s.value;
                             else {
                                 const e = s.value,
                                     r = {
                                         ...s
                                     };
-                                delete r.value, i[o] = [new Wd(t, e), r], Zv(n, r)
+                                delete r.value, i[o] = [new Gd(t, e), r], rb(n, r)
                             }
                         }
                         if (r) {
                             const e = r.value || r;
-                            Ed(e instanceof Uint16Array || e instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
+                            wd(e instanceof Uint16Array || e instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
                             const n = {
                                 size: 1,
                                 isIndexed: void 0 === r.isIndexed || r.isIndexed
                             };
-                            i.indices = [new Wd(t, {
+                            i.indices = [new Gd(t, {
                                 data: e,
                                 target: 34963
                             }), n]
                         }
                         return i
                     }(this.gl, t), this.vertexArray.setAttributes(this.geometryBuffers), this
                 }
                 setAttributes() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                    if (Md(t)) return this;
+                    if (Ad(t)) return this;
                     const e = {};
                     for (const n in t) {
                         const i = t[n];
                         e[n] = i.getValue ? i.getValue() : i
                     }
                     return this.vertexArray.setAttributes(e), this
                 }
@@ -20453,62 +21048,62 @@
                     return e ? e(t) : {}
                 }
                 updateModuleSettings(t) {
                     const e = this.getModuleUniforms(t || {});
                     return this.setUniforms(e)
                 }
                 clear(t) {
-                    return ip(this.program.gl, t), this
+                    return np(this.program.gl, t), this
                 }
                 draw() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     this._checkProgram();
                     const {
                         moduleSettings: e = null,
                         framebuffer: n,
                         uniforms: i = {},
                         attributes: r = {},
                         transformFeedback: s = this.transformFeedback,
                         parameters: o = {},
                         vertexArray: a = this.vertexArray
                     } = t;
                     let l;
-                    this.setAttributes(r), this.updateModuleSettings(e), this.setUniforms(i), Tu.priority >= 2 && (l = this._logDrawCallStart(2));
+                    this.setAttributes(r), this.updateModuleSettings(e), this.setUniforms(i), Su.priority >= 2 && (l = this._logDrawCallStart(2));
                     const c = this.vertexArray.getDrawParams(),
                         {
                             isIndexed: h = c.isIndexed,
                             indexType: u = c.indexType,
                             indexOffset: d = c.indexOffset,
                             vertexArrayInstanced: p = c.isInstanced
                         } = this.props;
-                    p && !this.isInstanced && Tu.warn("Found instanced attributes on non-instanced model", this.id)();
+                    p && !this.isInstanced && Su.warn("Found instanced attributes on non-instanced model", this.id)();
                     const {
                         isInstanced: f,
                         instanceCount: g
                     } = this, {
-                        onBeforeRender: m = qv,
-                        onAfterRender: v = qv
+                        onBeforeRender: m = sb,
+                        onAfterRender: v = sb
                     } = this.props;
                     m(), this.program.setUniforms(this.uniforms);
-                    const b = this.program.draw(Object.assign(Xv, t, {
+                    const b = this.program.draw(Object.assign(ob, t, {
                         logPriority: l,
                         uniforms: null,
                         framebuffer: n,
                         parameters: o,
                         drawMode: this.getDrawMode(),
                         vertexCount: this.getVertexCount(),
                         vertexArray: a,
                         transformFeedback: s,
                         isIndexed: h,
                         indexType: u,
                         isInstanced: f,
                         instanceCount: g,
                         offset: h ? d : 0
                     }));
-                    return v(), Tu.priority >= 2 && this._logDrawCallEnd(l, a, n), b
+                    return v(), Su.priority >= 2 && this._logDrawCallEnd(l, a, n), b
                 }
                 transform() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const {
                         discard: e = !0,
                         feedbackBuffers: n,
                         unbindModels: i = []
@@ -20526,15 +21121,15 @@
                     } finally {
                         i.forEach((t => t.vertexArray.bindBuffers()))
                     }
                     return this
                 }
                 render() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                    return Tu.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")(), this.setUniforms(t).draw()
+                    return Su.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")(), this.setUniforms(t).draw()
                 }
                 _setModelProps(t) {
                     Object.assign(this.props, t), "uniforms" in t && this.setUniforms(t.uniforms), "pickable" in t && (this.pickable = t.pickable), "instanceCount" in t && (this.instanceCount = t.instanceCount), "geometry" in t && this.setGeometry(t.geometry), "attributes" in t && this.setAttributes(t.attributes), "_feedbackBuffers" in t && this._setFeedbackBuffers(t._feedbackBuffers)
                 }
                 _checkProgram() {
                     if (!this._programDirty && this.programManager.stateHash === this._programManagerState) return;
                     let {
@@ -20559,116 +21154,116 @@
                             inject: r,
                             defines: s,
                             varyings: o,
                             bufferMode: a,
                             transpileToGLSL100: l
                         }), this.program && this._managedProgram && this.programManager.release(this.program), this._programManagerState = this.programManager.stateHash, this._managedProgram = !0
                     }
-                    Ed(t instanceof ef, "Model needs a program"), this._programDirty = !1, t !== this.program && (this.program = t, this.vertexArray ? this.vertexArray.setProps({
+                    wd(t instanceof tf, "Model needs a program"), this._programDirty = !1, t !== this.program && (this.program = t, this.vertexArray ? this.vertexArray.setProps({
                         program: this.program,
                         attributes: this.vertexArray.attributes
-                    }) : this.vertexArray = new zv(this.gl, {
+                    }) : this.vertexArray = new Yv(this.gl, {
                         program: this.program
                     }), this.setUniforms(Object.assign({}, this.getModuleUniforms())))
                 }
                 _deleteGeometryBuffers() {
                     for (const t in this.geometryBuffers) {
                         const e = this.geometryBuffers[t][0] || this.geometryBuffers[t];
-                        e instanceof Wd && e.delete()
+                        e instanceof Gd && e.delete()
                     }
                 }
                 _setAnimationProps(t) {
-                    this.animated && Ed(t, "Model.draw(): animated uniforms but no animationProps")
+                    this.animated && wd(t, "Model.draw(): animated uniforms but no animationProps")
                 }
                 _setFeedbackBuffers() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                    if (Md(t)) return this;
+                    if (Ad(t)) return this;
                     const {
                         gl: e
                     } = this.program;
-                    return this.transformFeedback = this.transformFeedback || new Sv(e, {
+                    return this.transformFeedback = this.transformFeedback || new zv(e, {
                         program: this.program
                     }), this.transformFeedback.setBuffers(t), this
                 }
                 _logDrawCallStart(t) {
                     const e = t > 3 ? 0 : 1e4;
-                    if (!(Date.now() - this.lastLogTime < e)) return this.lastLogTime = Date.now(), Tu.group(2, ">>> DRAWING MODEL ".concat(this.id), {
-                        collapsed: Tu.level <= 2
+                    if (!(Date.now() - this.lastLogTime < e)) return this.lastLogTime = Date.now(), Su.group(2, ">>> DRAWING MODEL ".concat(this.id), {
+                        collapsed: Su.level <= 2
                     })(), t
                 }
                 _logDrawCallEnd(t, e, n, i) {
                     if (void 0 === t) return;
                     const r = function(t) {
                             let {
                                 vertexArray: e,
                                 header: n = "Attributes"
                             } = t;
                             if (!e.configuration) return {};
                             const i = {};
-                            e.elements && (i.ELEMENT_ARRAY_BUFFER = Dv(e, e.elements, null, n));
+                            e.elements && (i.ELEMENT_ARRAY_BUFFER = Qv(e, e.elements, null, n));
                             const r = e.values;
                             for (const t in r) {
                                 const s = e._getAttributeInfo(t);
                                 if (s) {
                                     let o = "".concat(t, ": ").concat(s.name);
                                     const a = e.accessors[s.location];
-                                    a && (o = "".concat(t, ": ").concat(Nv(s.name, a))), i[o] = Dv(e, r[t], a, n)
+                                    a && (o = "".concat(t, ": ").concat(Jv(s.name, a))), i[o] = Qv(e, r[t], a, n)
                                 }
                             }
                             return i
                         }({
                             vertexArray: e,
                             header: "".concat(this.id, " attributes"),
                             attributes: this._attributes
                         }),
                         {
                             table: s,
                             unusedTable: o,
                             unusedCount: a
-                        } = Vv({
+                        } = $v({
                             header: "".concat(this.id, " uniforms"),
                             program: this.program,
                             uniforms: Object.assign({}, this.program.uniforms, n)
                         }),
                         {
                             table: l,
                             count: c
-                        } = Vv({
+                        } = $v({
                             header: "".concat(this.id, " uniforms"),
                             program: this.program,
                             uniforms: Object.assign({}, this.program.uniforms, n),
                             undefinedOnly: !0
                         });
-                    c > 0 && Tu.log("MISSING UNIFORMS", Object.keys(l))(), a > 0 && Tu.log("UNUSED UNIFORMS", Object.keys(o))();
+                    c > 0 && Su.log("MISSING UNIFORMS", Object.keys(l))(), a > 0 && Su.log("UNUSED UNIFORMS", Object.keys(o))();
                     const h = function(t) {
                         const e = {},
                             n = "Accessors for ".concat(t.id);
                         for (const i of t.attributeInfos)
                             if (i) {
-                                const t = Gv(i);
+                                const t = eb(i);
                                 e["in ".concat(t)] = {
                                     [n]: JSON.stringify(i.accessor)
                                 }
                             } for (const i of t.varyingInfos)
                             if (i) {
-                                const t = Gv(i);
+                                const t = eb(i);
                                 e["out ".concat(t)] = {
                                     [n]: JSON.stringify(i.accessor)
                                 }
                             } return e
                     }(this.vertexArray.configuration);
-                    Tu.table(t, r)(), Tu.table(t, s)(), Tu.table(t + 1, h)(), i && i.log({
+                    Su.table(t, r)(), Su.table(t, s)(), Su.table(t + 1, h)(), i && i.log({
                         logLevel: 2,
                         message: "Rendered to ".concat(i.id)
-                    }), Tu.groupEnd(2)()
+                    }), Su.groupEnd(2)()
                 }
             }
-            class Kv {
+            class lb {
                 static isSupported(t) {
-                    return Lu(t)
+                    return Mu(t)
                 }
                 constructor(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     this.gl = t, this.model = null, this.elementCount = 0, this.bufferTransform = null, this.textureTransform = null, this.elementIDBuffer = null, this._initialize(e), Object.seal(this)
                 }
                 delete() {
                     const {
@@ -20687,15 +21282,15 @@
                         color: !0
                     }), this.model.transform(n)
                 }
                 swap() {
                     let t = !1;
                     const e = [this.bufferTransform, this.textureTransform].filter(Boolean);
                     for (const n of e) t = t || n.swap();
-                    Ed(t, "Nothing to swap")
+                    wd(t, "Nothing to swap")
                 }
                 getBuffer() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                     return this.bufferTransform && this.bufferTransform.getBuffer(t)
                 }
                 getData() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
@@ -20716,17 +21311,17 @@
                     for (const n of e) n.update(t)
                 }
                 _initialize() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const {
                         gl: e
                     } = this;
-                    this._buildResourceTransforms(e, t), t = this._updateModelProps(t), this.model = new Yv(e, Object.assign({}, t, {
-                        fs: t.fs || Pv({
-                            version: Tv(t.vs)
+                    this._buildResourceTransforms(e, t), t = this._updateModelProps(t), this.model = new ab(e, Object.assign({}, t, {
+                        fs: t.fs || Fv({
+                            version: Dv(t.vs)
                         }),
                         id: t.id || "transform-model",
                         drawMode: t.drawMode || 0,
                         vertexCount: t.elementCount
                     })), this.bufferTransform && this.bufferTransform.setupResources({
                         model: this.model
                     })
@@ -20735,81 +21330,81 @@
                     let e = Object.assign({}, t);
                     const n = [this.bufferTransform, this.textureTransform].filter(Boolean);
                     for (const t of n) e = t.updateModelProps(e);
                     return e
                 }
                 _buildResourceTransforms(t, e) {
                     (function(t) {
-                        return !(Md(t.feedbackBuffers) && Md(t.feedbackMap) && !(t.varyings && t.varyings.length > 0))
-                    })(e) && (this.bufferTransform = new Cv(t, e)),
+                        return !(Ad(t.feedbackBuffers) && Ad(t.feedbackMap) && !(t.varyings && t.varyings.length > 0))
+                    })(e) && (this.bufferTransform = new Bv(t, e)),
                     function(t) {
-                        return !(Md(t._sourceTextures) && !t._targetTexture && !t._targetTextureVarying)
-                    }(e) && (this.textureTransform = new Rv(t, e)), Ed(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures")
+                        return !(Ad(t._sourceTextures) && !t._targetTexture && !t._targetTextureVarying)
+                    }(e) && (this.textureTransform = new Wv(t, e)), wd(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures")
                 }
                 _updateDrawOptions(t) {
                     let e = Object.assign({}, t);
                     const n = [this.bufferTransform, this.textureTransform].filter(Boolean);
                     for (const t of n) e = Object.assign(e, t.getDrawOptions(e));
                     return e
                 }
             }
-            const Qv = {
+            const cb = {
                 interpolation: class {
                     constructor({
                         gl: t,
                         attribute: e,
                         timeline: n
                     }) {
-                        wo(this, "gl", void 0), wo(this, "type", "interpolation"), wo(this, "attributeInTransition", void 0), wo(this, "settings", void 0), wo(this, "attribute", void 0), wo(this, "transition", void 0), wo(this, "currentStartIndices", void 0), wo(this, "currentLength", void 0), wo(this, "transform", void 0), wo(this, "buffers", void 0), this.gl = t, this.transition = new If(n), this.attribute = e, this.attributeInTransition = new _v(t, e.settings), this.currentStartIndices = e.startIndices, this.currentLength = 0, this.transform = function(t, e) {
-                            const n = mv(e.size);
-                            return new Kv(t, {
+                        wo(this, "gl", void 0), wo(this, "type", "interpolation"), wo(this, "attributeInTransition", void 0), wo(this, "settings", void 0), wo(this, "attribute", void 0), wo(this, "transition", void 0), wo(this, "currentStartIndices", void 0), wo(this, "currentLength", void 0), wo(this, "transform", void 0), wo(this, "buffers", void 0), this.gl = t, this.transition = new If(n), this.attribute = e, this.attributeInTransition = new kv(t, e.settings), this.currentStartIndices = e.startIndices, this.currentLength = 0, this.transform = function(t, e) {
+                            const n = Av(e.size);
+                            return new lb(t, {
                                 vs: "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n",
                                 defines: {
                                     ATTRIBUTE_TYPE: n
                                 },
                                 varyings: ["vCurrent"]
                             })
                         }(t, e);
                         const i = {
                             byteLength: 0,
                             usage: 35050
                         };
-                        this.buffers = [new Wd(t, i), new Wd(t, i)]
+                        this.buffers = [new Gd(t, i), new Gd(t, i)]
                     }
                     get inProgress() {
                         return this.transition.inProgress
                     }
                     start(t, e) {
                         if (t.duration <= 0) return void this.transition.cancel();
                         this.settings = t;
                         const {
                             gl: n,
                             buffers: i,
                             attribute: r
                         } = this;
-                        vv(i);
+                        Mv(i);
                         const s = {
                             numInstances: e,
                             attribute: r,
                             fromLength: this.currentLength,
                             fromStartIndices: this.currentStartIndices,
                             getData: t.enter
                         };
-                        for (const t of i) yv({
+                        for (const t of i) Lv({
                             buffer: t,
                             ...s
                         });
-                        this.currentStartIndices = r.startIndices, this.currentLength = bv(r, e), this.attributeInTransition.setData({
+                        this.currentStartIndices = r.startIndices, this.currentLength = Ov(r, e), this.attributeInTransition.setData({
                             buffer: i[1],
                             value: r.value
                         }), this.transition.start(t), this.transform.update({
                             elementCount: Math.floor(this.currentLength / r.size),
                             sourceBuffers: {
                                 aFrom: i[0],
-                                aTo: gv(0, r)
+                                aTo: Tv(0, r)
                             },
                             feedbackBuffers: {
                                 vCurrent: i[1]
                             }
                         })
                     }
                     update() {
@@ -20838,54 +21433,54 @@
                 },
                 spring: class {
                     constructor({
                         gl: t,
                         attribute: e,
                         timeline: n
                     }) {
-                        wo(this, "gl", void 0), wo(this, "type", "spring"), wo(this, "attributeInTransition", void 0), wo(this, "settings", void 0), wo(this, "attribute", void 0), wo(this, "transition", void 0), wo(this, "currentStartIndices", void 0), wo(this, "currentLength", void 0), wo(this, "texture", void 0), wo(this, "framebuffer", void 0), wo(this, "transform", void 0), wo(this, "buffers", void 0), this.gl = t, this.type = "spring", this.transition = new If(n), this.attribute = e, this.attributeInTransition = new _v(t, {
+                        wo(this, "gl", void 0), wo(this, "type", "spring"), wo(this, "attributeInTransition", void 0), wo(this, "settings", void 0), wo(this, "attribute", void 0), wo(this, "transition", void 0), wo(this, "currentStartIndices", void 0), wo(this, "currentLength", void 0), wo(this, "texture", void 0), wo(this, "framebuffer", void 0), wo(this, "transform", void 0), wo(this, "buffers", void 0), this.gl = t, this.type = "spring", this.transition = new If(n), this.attribute = e, this.attributeInTransition = new kv(t, {
                             ...e.settings,
                             normalized: !1
                         }), this.currentStartIndices = e.startIndices, this.currentLength = 0, this.texture = function(t) {
-                            return new Qd(t, {
+                            return new Kd(t, {
                                 data: new Uint8Array(4),
                                 format: 6408,
                                 type: 5121,
                                 border: 0,
                                 mipmaps: !1,
                                 dataFormat: 6408,
                                 width: 1,
                                 height: 1
                             })
                         }(t), this.framebuffer = function(t, e) {
-                            return new bp(t, {
+                            return new vp(t, {
                                 id: "spring-transition-is-transitioning-framebuffer",
                                 width: 1,
                                 height: 1,
                                 attachments: {
                                     36064: e
                                 }
                             })
                         }(t, this.texture), this.transform = function(t, e, n) {
-                            const i = mv(e.size);
-                            return new Kv(t, {
+                            const i = Av(e.size);
+                            return new lb(t, {
                                 framebuffer: n,
                                 vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
                                 fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
                                 defines: {
                                     ATTRIBUTE_TYPE: i
                                 },
                                 varyings: ["vNext"]
                             })
                         }(t, e, this.framebuffer);
                         const i = {
                             byteLength: 0,
                             usage: 35050
                         };
-                        this.buffers = [new Wd(t, i), new Wd(t, i), new Wd(t, i)]
+                        this.buffers = [new Gd(t, i), new Gd(t, i), new Gd(t, i)]
                     }
                     get inProgress() {
                         return this.transition.inProgress
                     }
                     start(t, e) {
                         const {
                             gl: n,
@@ -20894,28 +21489,28 @@
                         } = this, s = {
                             numInstances: e,
                             attribute: r,
                             fromLength: this.currentLength,
                             fromStartIndices: this.currentStartIndices,
                             getData: t.enter
                         };
-                        for (const t of i) yv({
+                        for (const t of i) Lv({
                             buffer: t,
                             ...s
                         });
-                        this.settings = t, this.currentStartIndices = r.startIndices, this.currentLength = bv(r, e), this.attributeInTransition.setData({
+                        this.settings = t, this.currentStartIndices = r.startIndices, this.currentLength = Ov(r, e), this.attributeInTransition.setData({
                             buffer: i[1],
                             value: r.value
                         }), this.transition.start({
                             ...t,
                             duration: 1 / 0
                         }), this.transform.update({
                             elementCount: Math.floor(this.currentLength / r.size),
                             sourceBuffers: {
-                                aTo: gv(0, r)
+                                aTo: Tv(0, r)
                             }
                         })
                     }
                     update() {
                         const {
                             buffers: t,
                             transform: e,
@@ -20943,32 +21538,32 @@
                             parameters: {
                                 depthTest: !1,
                                 blend: !0,
                                 viewport: [0, 0, 1, 1],
                                 blendFunc: [1, 1],
                                 blendEquation: [32776, 32776]
                             }
-                        }), vv(t), this.attributeInTransition.setData({
+                        }), Mv(t), this.attributeInTransition.setData({
                             buffer: t[1],
                             value: this.attribute.value
-                        }), lp(n)[0] > 0 || i.end(), !0
+                        }), ap(n)[0] > 0 || i.end(), !0
                     }
                     cancel() {
                         this.transition.cancel(), this.transform.delete();
                         for (const t of this.buffers) t.delete();
                         this.buffers.length = 0, this.texture.delete(), this.framebuffer.delete()
                     }
                 }
             };
-            class Jv {
+            class hb {
                 constructor(t, {
                     id: e,
                     timeline: n
                 }) {
-                    wo(this, "id", void 0), wo(this, "isSupported", void 0), wo(this, "gl", void 0), wo(this, "timeline", void 0), wo(this, "transitions", void 0), wo(this, "needsRedraw", void 0), wo(this, "numInstances", void 0), this.id = e, this.gl = t, this.timeline = n, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1, this.isSupported = Kv.isSupported(t)
+                    wo(this, "id", void 0), wo(this, "isSupported", void 0), wo(this, "gl", void 0), wo(this, "timeline", void 0), wo(this, "transitions", void 0), wo(this, "needsRedraw", void 0), wo(this, "numInstances", void 0), this.id = e, this.gl = t, this.timeline = n, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1, this.isSupported = lb.isSupported(t)
                 }
                 finalize() {
                     for (const t in this.transitions) this._removeTransition(t)
                 }
                 update({
                     attributes: t,
                     transitions: e,
@@ -21006,33 +21601,33 @@
                 _removeTransition(t) {
                     this.transitions[t].cancel(), delete this.transitions[t]
                 }
                 _updateAttribute(t, e, n) {
                     const i = this.transitions[t];
                     let r = !i || i.type !== n.type;
                     if (r) {
-                        if (!this.isSupported) return void na.warn("WebGL2 not supported by this browser. Transition for ".concat(t, " is disabled."))();
+                        if (!this.isSupported) return void ta.warn("WebGL2 not supported by this browser. Transition for ".concat(t, " is disabled."))();
                         i && this._removeTransition(t);
-                        const s = Qv[n.type];
+                        const s = cb[n.type];
                         s ? this.transitions[t] = new s({
                             attribute: e,
                             timeline: this.timeline,
                             gl: this.gl
-                        }) : (na.error("unsupported transition type '".concat(n.type, "'"))(), r = !1)
+                        }) : (ta.error("unsupported transition type '".concat(n.type, "'"))(), r = !1)
                     }(r || e.needsRedraw()) && (this.needsRedraw = !0, this.transitions[t].start(n, this.numInstances))
                 }
             }
-            const $v = "attributeManager.invalidate";
-            class tb {
+            const ub = "attributeManager.invalidate";
+            class db {
                 constructor(t, {
                     id: e = "attribute-manager",
                     stats: n,
                     timeline: i
                 } = {}) {
-                    wo(this, "id", void 0), wo(this, "gl", void 0), wo(this, "attributes", void 0), wo(this, "updateTriggers", void 0), wo(this, "needsRedraw", void 0), wo(this, "userData", void 0), wo(this, "stats", void 0), wo(this, "attributeTransitionManager", void 0), wo(this, "mergeBoundsMemoized", uf(Bc)), this.id = e, this.gl = t, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = n, this.attributeTransitionManager = new Jv(t, {
+                    wo(this, "id", void 0), wo(this, "gl", void 0), wo(this, "attributes", void 0), wo(this, "updateTriggers", void 0), wo(this, "needsRedraw", void 0), wo(this, "userData", void 0), wo(this, "stats", void 0), wo(this, "attributeTransitionManager", void 0), this.id = e, this.gl = t, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = n, this.attributeTransitionManager = new hb(t, {
                         id: "".concat(e, "-transitions"),
                         timeline: i
                     }), Object.seal(this)
                 }
                 finalize() {
                     for (const t in this.attributes) this.attributes[t].delete();
                     this.attributeTransitionManager.finalize()
@@ -21055,64 +21650,57 @@
                     })
                 }
                 remove(t) {
                     for (const e of t) void 0 !== this.attributes[e] && (this.attributes[e].delete(), delete this.attributes[e])
                 }
                 invalidate(t, e) {
                     const n = this._invalidateTrigger(t, e);
-                    sa($v, this, t, n)
+                    na(ub, this, t, n)
                 }
                 invalidateAll(t) {
                     for (const e in this.attributes) this.attributes[e].setNeedsUpdate(e, t);
-                    sa($v, this, "all")
+                    na(ub, this, "all")
                 }
                 update({
                     data: t,
                     numInstances: e,
                     startIndices: n = null,
                     transitions: i,
                     props: r = {},
                     buffers: s = {},
                     context: o = {}
                 }) {
                     let a = !1;
-                    sa("attributeManager.updateStart", this), this.stats && this.stats.get("Update Attributes").timeStart();
+                    na("attributeManager.updateStart", this), this.stats && this.stats.get("Update Attributes").timeStart();
                     for (const i in this.attributes) {
                         const l = this.attributes[i],
                             c = l.settings.accessor;
-                        l.startIndices = n, l.numInstances = e, r[i] && na.removed("props.".concat(i), "data.attributes.".concat(i))(), l.setExternalBuffer(s[i]) || l.setBinaryValue("string" == typeof c ? s[c] : void 0, t.startIndices) || "string" == typeof c && !s[c] && l.setConstantValue(r[c]) || l.needsUpdate() && (a = !0, this._updateAttribute({
+                        l.startIndices = n, l.numInstances = e, r[i] && ta.removed("props.".concat(i), "data.attributes.".concat(i))(), l.setExternalBuffer(s[i]) || l.setBinaryValue("string" == typeof c ? s[c] : void 0, t.startIndices) || "string" == typeof c && !s[c] && l.setConstantValue(r[c]) || l.needsUpdate() && (a = !0, this._updateAttribute({
                             attribute: l,
                             numInstances: e,
                             data: t,
                             props: r,
                             context: o
                         })), this.needsRedraw = this.needsRedraw || l.needsRedraw()
                     }
-                    a && sa("attributeManager.updateEnd", this, e), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
+                    a && na("attributeManager.updateEnd", this, e), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
                         attributes: this.attributes,
                         numInstances: e,
                         transitions: i
                     })
                 }
                 updateTransition() {
                     const {
                         attributeTransitionManager: t
                     } = this, e = t.run();
                     return this.needsRedraw = this.needsRedraw || e, e
                 }
                 getAttributes() {
                     return this.attributes
                 }
-                getBounds(t) {
-                    const e = t.map((t => {
-                        var e;
-                        return null === (e = this.attributes[t]) || void 0 === e ? void 0 : e.getBounds()
-                    }));
-                    return this.mergeBoundsMemoized(e)
-                }
                 getChangedAttributes(t = {
                     clearChangedFlags: !1
                 }) {
                     const {
                         attributes: e,
                         attributeTransitionManager: n
                     } = this, i = {
@@ -21140,15 +21728,15 @@
                 _createAttribute(t, e, n) {
                     const i = {
                         ...e,
                         id: t,
                         size: (e.isIndexed ? 1 : e.size) || 1,
                         divisor: n.instanced ? 1 : e.divisor || 0
                     };
-                    return new _v(this.gl, i)
+                    return new kv(this.gl, i)
                 }
                 _mapUpdateTriggersToAttributes() {
                     const t = {};
                     for (const e in this.attributes) this.attributes[e].getUpdateTriggers().forEach((n => {
                         t[n] || (t[n] = []), t[n].push(e)
                     }));
                     this.updateTriggers = t
@@ -21164,51 +21752,51 @@
                     })), r
                 }
                 _updateAttribute(t) {
                     const {
                         attribute: e,
                         numInstances: n
                     } = t;
-                    sa("attribute.updateStart", e), e.constant ? e.setConstantValue(e.value) : (e.allocate(n) && sa("attribute.allocate", e, n), e.updateBuffer(t) && (this.needsRedraw = !0, sa("attribute.updateEnd", e, n)))
+                    na("attribute.updateStart", e), e.constant ? e.setConstantValue(e.value) : (e.allocate(n) && na("attribute.allocate", e, n), e.updateBuffer(t) && (this.needsRedraw = !0, na("attribute.updateEnd", e, n)))
                 }
             }
-            const eb = 1e-5;
+            const pb = 1e-5;
 
-            function nb(t, e, n, i, r) {
+            function fb(t, e, n, i, r) {
                 const s = e - t;
                 return (n - e) * r + -s * i + s + e
             }
 
-            function ib(t, e) {
+            function gb(t, e) {
                 if (Array.isArray(t)) {
                     let n = 0;
                     for (let i = 0; i < t.length; i++) {
                         const r = t[i] - e[i];
                         n += r * r
                     }
                     return Math.sqrt(n)
                 }
                 return Math.abs(t - e)
             }
-            const rb = {
+            const mb = {
                 interpolation: class extends If {
                     get value() {
                         return this._value
                     }
                     _onUpdate() {
                         const {
                             time: t,
                             settings: {
                                 fromValue: e,
                                 toValue: n,
                                 duration: i,
                                 easing: r
                             }
                         } = this, s = r(t / i);
-                        this._value = hc(e, n, s)
+                        this._value = ac(e, n, s)
                     }
                 },
                 spring: class extends If {
                     get value() {
                         return this._currValue
                     }
                     _onUpdate() {
@@ -21220,26 +21808,26 @@
                         } = this.settings, {
                             _prevValue: r = t,
                             _currValue: s = t
                         } = this;
                         let o = function(t, e, n, i, r) {
                             if (Array.isArray(n)) {
                                 const s = [];
-                                for (let o = 0; o < n.length; o++) s[o] = nb(t[o], e[o], n[o], i, r);
+                                for (let o = 0; o < n.length; o++) s[o] = fb(t[o], e[o], n[o], i, r);
                                 return s
                             }
-                            return nb(t, e, n, i, r)
+                            return fb(t, e, n, i, r)
                         }(r, s, e, n, i);
-                        const a = ib(o, e),
-                            l = ib(o, s);
-                        a < eb && l < eb && (o = e, this.end()), this._prevValue = s, this._currValue = o
+                        const a = gb(o, e),
+                            l = gb(o, s);
+                        a < pb && l < pb && (o = e, this.end()), this._prevValue = s, this._currValue = o
                     }
                 }
             };
-            class sb {
+            class vb {
                 constructor(t) {
                     this.transitions = new Map, this.timeline = t
                 }
                 get active() {
                     return this.transitions.size > 0
                 }
                 add(t, e, n, i) {
@@ -21249,17 +21837,17 @@
                     if (r.has(t)) {
                         const n = r.get(t),
                             {
                                 value: i = n.settings.fromValue
                             } = n;
                         e = i, this.remove(t)
                     }
-                    if (!(i = fv(i))) return;
-                    const s = rb[i.type];
-                    if (!s) return void na.error("unsupported transition type '".concat(i.type, "'"))();
+                    if (!(i = Cv(i))) return;
+                    const s = mb[i.type];
+                    if (!s) return void ta.error("unsupported transition type '".concat(i.type, "'"))();
                     const o = new s(this.timeline);
                     o.start({
                         ...i,
                         fromValue: e,
                         toValue: n
                     }), r.set(t, o)
                 }
@@ -21275,83 +21863,89 @@
                     return t
                 }
                 clear() {
                     for (const t of this.transitions.keys()) this.remove(t)
                 }
             }
 
-            function ob(t, e) {
+            function bb(t, e) {
                 if (!t.transitions) return !1;
                 const n = {},
-                    i = t[To];
+                    i = Eb(t);
                 let r = !1;
                 for (const s in t.transitions) {
                     const o = i[s],
                         a = o && o.type;
-                    ("number" === a || "color" === a || "array" === a) && lb(t[s], e[s], o) && (n[s] = !0, r = !0)
+                    ("number" === a || "color" === a || "array" === a) && _b(t[s], e[s], o) && (n[s] = !0, r = !0)
                 }
                 return !!r && n
             }
 
-            function ab({
+            function yb({
                 newProps: t,
                 oldProps: e,
                 ignoreProps: n = {},
                 propTypes: i = {},
                 triggerName: r = "props"
             }) {
                 if (e === t) return !1;
                 if ("object" != typeof t || null === t) return "".concat(r, " changed shallowly");
                 if ("object" != typeof e || null === e) return "".concat(r, " changed shallowly");
                 for (const s of Object.keys(t))
                     if (!(s in n)) {
                         if (!(s in e)) return "".concat(r, ".").concat(s, " added");
-                        const n = lb(t[s], e[s], i[s]);
+                        const n = _b(t[s], e[s], i[s]);
                         if (n) return "".concat(r, ".").concat(s, " ").concat(n)
                     } for (const s of Object.keys(e))
                     if (!(s in n)) {
                         if (!(s in t)) return "".concat(r, ".").concat(s, " dropped");
                         if (!Object.hasOwnProperty.call(t, s)) {
-                            const n = lb(t[s], e[s], i[s]);
+                            const n = _b(t[s], e[s], i[s]);
                             if (n) return "".concat(r, ".").concat(s, " ").concat(n)
                         }
                     } return !1
             }
 
-            function lb(t, e, n) {
+            function _b(t, e, n) {
                 let i = n && n.equal;
                 return i && !i(t, e, n) ? "changed deeply" : i || (i = t && e && t.equals, !i || i.call(t, e)) ? i || e === t ? null : "changed shallowly" : "changed deeply"
             }
 
-            function cb(t, e) {
+            function xb(t, e) {
                 if (null === e) return !0;
                 const n = e.extensions,
                     {
                         extensions: i
                     } = t;
                 if (i === n) return !1;
                 if (!n || !i) return !0;
                 if (i.length !== n.length) return !0;
                 for (let t = 0; t < i.length; t++)
                     if (!i[t].equals(n[t])) return !0;
                 return !1
             }
 
-            function hb(t, e, n) {
+            function wb(t, e, n) {
                 let i = t.updateTriggers[n];
                 i = null == i ? {} : i;
                 let r = e.updateTriggers[n];
-                return r = null == r ? {} : r, ab({
+                return r = null == r ? {} : r, yb({
                     oldProps: r,
                     newProps: i,
                     triggerName: n
                 })
             }
 
-            function ub(t, e) {
+            function Eb(t) {
+                const e = t[Co],
+                    n = e && e.constructor;
+                return n ? n._propTypes : {}
+            }
+
+            function Pb(t, e) {
                 if (!e) return t;
                 const n = {
                     ...t,
                     ...e
                 };
                 if ("defines" in e && (n.defines = {
                         ...t.defines,
@@ -21366,339 +21960,325 @@
                             ...t.inject
                         };
                         for (const t in e.inject) i[t] = (i[t] || "") + e.inject[t];
                         n.inject = i
                     } else n.inject = e.inject;
                 return n
             }
-            const db = [0, 0, 0];
 
-            function pb(t, e, n = !1) {
+            function Sb(t, e, n = !1) {
                 const i = e.projectPosition(t);
                 if (n && e instanceof Rf) {
                     const [n, r, s = 0] = t, o = e.getDistanceScales([n, r]);
                     i[2] = s * o.unitsPerMeter[2]
                 }
                 return i
             }
 
-            function fb(t, {
+            function Cb(t, {
                 viewport: e,
                 modelMatrix: n,
                 coordinateSystem: i,
                 coordinateOrigin: r,
                 offsetMode: s
             }) {
                 let [o, a, l = 0] = t;
-                switch (n && ([o, a, l] = Qc([], [o, a, l, 1], n)), i) {
-                    case Lh.LNGLAT:
-                        return pb([o, a, l], e, s);
-                    case Lh.LNGLAT_OFFSETS:
-                        return pb([o + r[0], a + r[1], l + (r[2] || 0)], e, s);
-                    case Lh.METER_OFFSETS:
-                        return pb(Ph(r, [o, a, l]), e, s);
-                    case Lh.CARTESIAN:
+                switch (n && ([o, a, l] = qc([], [o, a, l, 1], n)), i) {
+                    case Th.LNGLAT:
+                        return Sb([o, a, l], e, s);
+                    case Th.LNGLAT_OFFSETS:
+                        return Sb([o + r[0], a + r[1], l + (r[2] || 0)], e, s);
+                    case Th.METER_OFFSETS:
+                        return Sb(yh(r, [o, a, l]), e, s);
+                    case Th.CARTESIAN:
                     default:
                         return e.isGeospatial ? [o + r[0], a + r[1], l + r[2]] : e.projectPosition([o, a, l])
                 }
             }
-            const gb = {
+            const Tb = {
                     10241: 9987,
                     10240: 9729,
                     10242: 33071,
                     10243: 33071
                 },
-                mb = {},
-                vb = {
+                Ab = {},
+                Mb = {
                     boolean: {
                         validate: (t, e) => !0,
                         equal: (t, e, n) => Boolean(t) === Boolean(e)
                     },
                     number: {
                         validate: (t, e) => Number.isFinite(t) && (!("max" in e) || t <= e.max) && (!("min" in e) || t >= e.min)
                     },
                     color: {
-                        validate: (t, e) => e.optional && !t || _b(t) && (3 === t.length || 4 === t.length),
-                        equal: (t, e, n) => Sf(t, e, 1)
+                        validate: (t, e) => e.optional && !t || Rb(t) && (3 === t.length || 4 === t.length),
+                        equal: (t, e, n) => Ob(t, e)
                     },
                     accessor: {
                         validate(t, e) {
-                            const n = xb(t);
-                            return "function" === n || n === xb(e.value)
+                            const n = Ib(t);
+                            return "function" === n || n === Ib(e.value)
                         },
-                        equal: (t, e, n) => "function" == typeof e || Sf(t, e, 1)
+                        equal: (t, e, n) => "function" == typeof e || Ob(t, e)
                     },
                     array: {
-                        validate: (t, e) => e.optional && !t || _b(t),
-                        equal(t, e, n) {
-                            const {
-                                compare: i
-                            } = n, r = Number.isInteger(i) ? i : i ? 1 : 0;
-                            return i ? Sf(t, e, r) : t === e
-                        }
+                        validate: (t, e) => e.optional && !t || Rb(t),
+                        equal: (t, e, n) => n.compare ? Ob(t, e) : t === e
                     },
                     object: {
-                        equal(t, e, n) {
-                            if (n.ignore) return !0;
-                            const {
-                                compare: i
-                            } = n, r = Number.isInteger(i) ? i : i ? 1 : 0;
-                            return i ? Sf(t, e, r) : t === e
-                        }
+                        equal: (t, e, n) => n.compare ? Pf(t, e) : t === e
                     },
                     function: {
                         validate: (t, e) => e.optional && !t || "function" == typeof t,
-                        equal: (t, e, n) => !n.compare && !1 !== n.ignore || t === e
+                        equal: (t, e, n) => !n.compare || t === e
                     },
                     data: {
                         transform: (t, e, n) => {
                             const {
                                 dataTransform: i
                             } = n.props;
                             return i && t ? i(t) : t
                         }
                     },
                     image: {
-                        transform: (t, e, n) => {
-                            const i = n.context;
-                            return i && i.gl ? function(t, e, n, i) {
-                                if (n instanceof Qd) return n;
-                                n.constructor && "Object" !== n.constructor.name && (n = {
-                                    data: n
-                                });
-                                let r = null;
-                                n.compressed && (r = {
-                                    10241: n.data.length > 1 ? 9985 : 9729
-                                });
-                                const s = new Qd(e, {
-                                    ...n,
-                                    parameters: {
-                                        ...gb,
-                                        ...r,
-                                        ...i
-                                    }
-                                });
-                                return mb[s.id] = t, s
-                            }(n.id, i.gl, t, {
-                                ...e.parameters,
-                                ...n.props.textureParameters
-                            }) : null
-                        },
-                        release: (t, e, n) => {
-                            var i, r;
-                            i = n.id, (r = t) && r instanceof Qd && mb[r.id] === i && (r.delete(), delete mb[r.id])
+                        transform: (t, e, n) => function(t, e) {
+                            const n = t.context && t.context.gl;
+                            if (!n || !e) return null;
+                            if (e instanceof Kd) return e;
+                            e.constructor && "Object" !== e.constructor.name && (e = {
+                                data: e
+                            });
+                            let i = null;
+                            e.compressed && (i = {
+                                10241: e.data.length > 1 ? 9985 : 9729
+                            });
+                            const r = new Kd(n, {
+                                ...e,
+                                parameters: {
+                                    ...Tb,
+                                    ...i,
+                                    ...t.props.textureParameters
+                                }
+                            });
+                            return Ab[r.id] = !0, r
+                        }(n, t),
+                        release: t => {
+                            var e;
+                            (e = t) && e instanceof Kd && Ab[e.id] && (e.delete(), delete Ab[e.id])
                         }
                     }
                 };
 
-            function bb(t, e) {
-                switch (xb(e)) {
+            function Ob(t, e) {
+                if (t === e) return !0;
+                if (!Rb(t) || !Rb(e)) return !1;
+                const n = t.length;
+                if (n !== e.length) return !1;
+                for (let i = 0; i < n; i++)
+                    if (t[i] !== e[i]) return !1;
+                return !0
+            }
+
+            function Lb(t, e) {
+                switch (Ib(e)) {
                     case "object":
-                        return yb(t, e);
+                        return kb(t, e);
                     case "array":
-                        return yb(t, {
+                        return kb(t, {
                             type: "array",
                             value: e,
                             compare: !1
                         });
                     case "boolean":
-                        return yb(t, {
+                        return kb(t, {
                             type: "boolean",
                             value: e
                         });
                     case "number":
-                        return yb(t, {
+                        return kb(t, {
                             type: "number",
                             value: e
                         });
                     case "function":
-                        return yb(t, {
+                        return kb(t, {
                             type: "function",
                             value: e,
                             compare: !0
                         });
                     default:
                         return {
                             name: t, type: "unknown", value: e
                         }
                 }
             }
 
-            function yb(t, e) {
+            function kb(t, e) {
                 return "type" in e ? {
                     name: t,
-                    ...vb[e.type],
+                    ...Mb[e.type],
                     ...e
                 } : "value" in e ? {
                     name: t,
-                    type: xb(e.value),
+                    type: Ib(e.value),
                     ...e
                 } : {
                     name: t,
                     type: "object",
                     value: e
                 }
             }
 
-            function _b(t) {
+            function Rb(t) {
                 return Array.isArray(t) || ArrayBuffer.isView(t)
             }
 
-            function xb(t) {
-                return _b(t) ? "array" : null === t ? "null" : typeof t
+            function Ib(t) {
+                return Rb(t) ? "array" : null === t ? "null" : typeof t
             }
 
-            function wb(t, e) {
-                let n = "_mergedDefaultProps";
-                if (e)
-                    for (const t of e) {
-                        const e = t.constructor;
-                        e && (n += ":".concat(e.extensionName || e.name))
-                    }
-                return Sb(t, n) || (t[n] = function(t, e) {
-                    if (!t.prototype) return null;
-                    const n = wb(Object.getPrototypeOf(t)),
+            function jb(t) {
+                return Bb(t, "_mergedDefaultProps") || (function(t) {
+                    if (!t.prototype) return;
+                    const e = Object.getPrototypeOf(t),
+                        n = jb(e),
                         i = function(t) {
                             const e = {},
                                 n = {},
                                 i = {};
                             for (const [r, s] of Object.entries(t)) {
                                 const t = null == s ? void 0 : s.deprecatedFor;
                                 if (t) i[r] = Array.isArray(t) ? t : [t];
                                 else {
-                                    const t = bb(r, s);
+                                    const t = Lb(r, s);
                                     e[r] = t, n[r] = t.value
                                 }
                             }
                             return {
                                 propTypes: e,
                                 defaultProps: n,
                                 deprecatedProps: i
                             }
-                        }(Sb(t, "defaultProps") || {}),
-                        r = Object.assign(Object.create(null), n, i.defaultProps),
-                        s = Object.assign(Object.create(null), null == n ? void 0 : n[To], i.propTypes),
-                        o = Object.assign(Object.create(null), null == n ? void 0 : n[Ao], i.deprecatedProps);
-                    for (const t of e) {
-                        const e = wb(t.constructor);
-                        e && (Object.assign(r, e), Object.assign(s, e[To]), Object.assign(o, e[Ao]))
-                    }
-                    return function(t, e) {
-                            const n = function(t) {
-                                const e = t.componentName;
-                                return e || na.warn("".concat(t.name, ".componentName not specified"))(), e || t.name
-                            }(e);
-                            Object.defineProperties(t, {
+                        }(Bb(t, "defaultProps") || {}),
+                        r = function(t, e, n) {
+                            const i = Object.create(null);
+                            Object.assign(i, e, t);
+                            const r = function(t) {
+                                const e = Bb(t, "layerName") || Bb(t, "componentName");
+                                return e || ta.once(0, "".concat(t.name, ".componentName not specified"))(), e || t.name
+                            }(n);
+                            return delete t.id, Object.defineProperties(i, {
                                 id: {
                                     writable: !0,
-                                    value: n
+                                    value: r
                                 }
-                            })
-                        }(r, t),
-                        function(t, e) {
-                            const n = {},
-                                i = {};
-                            for (const t in e) {
-                                const r = e[t],
-                                    {
-                                        name: s,
-                                        value: o
-                                    } = r;
-                                r.async && (n[s] = o, i[s] = Eb(s))
+                            }), i
+                        }(i.defaultProps, n, t),
+                        s = {
+                            ...e._propTypes,
+                            ...i.propTypes
+                        };
+                    ! function(t, e) {
+                        const n = {},
+                            i = {};
+                        for (const t in e) {
+                            const r = e[t],
+                                {
+                                    name: s,
+                                    value: o
+                                } = r;
+                            r.async && (n[s] = o, i[s] = Fb(s))
+                        }
+                        t[To] = n, t[Ao] = {}, Object.defineProperties(t, i)
+                    }(r, s);
+                    const o = {
+                        ...e._deprecatedProps,
+                        ...i.deprecatedProps
+                    };
+                    (function(t, e) {
+                        for (const n in e) Object.defineProperty(t, n, {
+                            enumerable: !1,
+                            set(t) {
+                                const i = "".concat(this.id, ": ").concat(n);
+                                for (const i of e[n]) zb(this, i) || (this[i] = t);
+                                ta.deprecated(i, e[n].join("/"))()
                             }
-                            t[Mo] = n, t[Oo] = {}, Object.defineProperties(t, i)
-                        }(r, s),
-                        function(t, e) {
-                            for (const n in e) Object.defineProperty(t, n, {
-                                enumerable: !1,
-                                set(t) {
-                                    const i = "".concat(this.id, ": ").concat(n);
-                                    for (const i of e[n]) Pb(this, i) || (this[i] = t);
-                                    na.deprecated(i, e[n].join("/"))()
-                                }
-                            })
-                        }(r, o), r[To] = s, r[Ao] = o, 0 !== e.length || Pb(t, "_propTypes") || (t._propTypes = s), r
-                }(t, e || []))
+                        })
+                    })(r, o), t._mergedDefaultProps = r, t._propTypes = s, t._deprecatedProps = o
+                }(t), t._mergedDefaultProps)
             }
 
-            function Eb(t) {
+            function Fb(t) {
                 return {
                     enumerable: !0,
                     set(e) {
-                        "string" == typeof e || e instanceof Promise || lv(e) ? this[Oo][t] = e : this[Lo][t] = e
+                        "string" == typeof e || e instanceof Promise || _v(e) ? this[Ao][t] = e : this[Mo][t] = e
                     },
                     get() {
-                        if (this[Lo]) {
-                            if (t in this[Lo]) return this[Lo][t] || this[Mo][t];
-                            if (t in this[Oo]) {
+                        if (this[Mo]) {
+                            if (t in this[Mo]) return this[Mo][t] || this[To][t];
+                            if (t in this[Ao]) {
                                 const e = this[Co] && this[Co].internalState;
-                                if (e && e.hasAsyncProp(t)) return e.getAsyncProp(t) || this[Mo][t]
+                                if (e && e.hasAsyncProp(t)) return e.getAsyncProp(t) || this[To][t]
                             }
                         }
-                        return this[Mo][t]
+                        return this[To][t]
                     }
                 }
             }
 
-            function Pb(t, e) {
+            function zb(t, e) {
                 return Object.prototype.hasOwnProperty.call(t, e)
             }
 
-            function Sb(t, e) {
-                return Pb(t, e) && t[e]
+            function Bb(t, e) {
+                return zb(t, e) && t[e]
             }
-            let Cb = 0;
-            class Tb {
+            let Db = 0;
+            class Nb {
                 constructor(...t) {
                     wo(this, "id", void 0), wo(this, "props", void 0), wo(this, "count", void 0), this.props = function(t, e) {
-                        let n;
-                        for (let t = e.length - 1; t >= 0; t--) {
-                            const i = e[t];
-                            "extensions" in i && (n = i.extensions)
-                        }
-                        const i = wb(t.constructor, n),
-                            r = Object.create(i);
-                        r[Co] = t, r[Oo] = {}, r[Lo] = {};
+                        const n = jb(t.constructor),
+                            i = Object.create(n);
+                        i[Co] = t, i[Ao] = {}, i[Mo] = {};
                         for (let t = 0; t < e.length; ++t) {
                             const n = e[t];
-                            for (const t in n) r[t] = n[t]
+                            for (const t in n) i[t] = n[t]
                         }
-                        return Object.freeze(r), r
-                    }(this, t), this.id = this.props.id, this.count = Cb++
+                        return Object.freeze(i), i
+                    }(this, t), this.id = this.props.id, this.count = Db++
                 }
                 clone(t) {
                     const {
                         props: e
                     } = this, n = {};
-                    for (const t in e[Mo]) t in e[Lo] ? n[t] = e[Lo][t] : t in e[Oo] && (n[t] = e[Oo][t]);
+                    for (const t in e[To]) t in e[Mo] ? n[t] = e[Mo][t] : t in e[Ao] && (n[t] = e[Ao][t]);
                     return new this.constructor({
                         ...e,
                         ...n,
                         ...t
                     })
                 }
             }
-            wo(Tb, "componentName", "Component"), wo(Tb, "defaultProps", {});
-            const Ab = Object.freeze({});
-            class Mb {
+            wo(Nb, "componentName", "Component"), wo(Nb, "defaultProps", {});
+            const Vb = Object.freeze({});
+            class Ub {
                 constructor(t) {
                     wo(this, "component", void 0), wo(this, "onAsyncPropUpdated", void 0), wo(this, "asyncProps", void 0), wo(this, "oldProps", void 0), wo(this, "oldAsyncProps", void 0), this.component = t, this.asyncProps = {}, this.onAsyncPropUpdated = () => {}, this.oldProps = null, this.oldAsyncProps = null
                 }
                 finalize() {
                     for (const t in this.asyncProps) {
                         const e = this.asyncProps[t];
                         e && e.type && e.type.release && e.type.release(e.resolvedValue, e.type, this.component)
                     }
-                    this.asyncProps = {}, this.component = null, this.resetOldProps()
                 }
                 getOldProps() {
-                    return this.oldAsyncProps || this.oldProps || Ab
+                    return this.oldAsyncProps || this.oldProps || Vb
                 }
                 resetOldProps() {
-                    this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null
+                    this.oldAsyncProps = null, this.oldProps = this.component.props
                 }
                 hasAsyncProp(t) {
                     return t in this.asyncProps
                 }
                 getAsyncProp(t) {
                     const e = this.asyncProps[t];
                     return e && e.resolvedValue
@@ -21712,18 +22292,17 @@
                         if (this.isAsyncPropLoading(t)) return !0;
                     return !1
                 }
                 reloadAsyncProp(t, e) {
                     this._watchPromise(t, Promise.resolve(e))
                 }
                 setAsyncProps(t) {
-                    this.component = t[Co] || this.component;
-                    const e = t[Lo] || {},
-                        n = t[Oo] || t,
-                        i = t[Mo] || {};
+                    const e = t[Mo] || {},
+                        n = t[Ao] || t,
+                        i = t[To] || {};
                     for (const t in e) {
                         const n = e[t];
                         this._createAsyncPropData(t, i[t]), this._updateAsyncProp(t, n), e[t] = this.getAsyncProp(t)
                     }
                     for (const t in n) {
                         const e = n[t];
                         this._createAsyncPropData(t, i[t]), this._updateAsyncProp(t, e)
@@ -21731,15 +22310,15 @@
                 }
                 _fetch(t, e) {
                     return null
                 }
                 _onResolve(t, e) {}
                 _onError(t, e) {}
                 _updateAsyncProp(t, e) {
-                    this._didAsyncInputValueChange(t, e) && ("string" == typeof e && (e = this._fetch(t, e)), e instanceof Promise ? this._watchPromise(t, e) : lv(e) ? this._resolveAsyncIterable(t, e) : this._setPropValue(t, e))
+                    this._didAsyncInputValueChange(t, e) && ("string" == typeof e && (e = this._fetch(t, e)), e instanceof Promise ? this._watchPromise(t, e) : _v(e) ? this._resolveAsyncIterable(t, e) : this._setPropValue(t, e))
                 }
                 _freezeAsyncOldProps() {
                     if (!this.oldAsyncProps && this.oldProps) {
                         this.oldAsyncProps = Object.create(this.oldProps);
                         for (const t in this.asyncProps) Object.defineProperty(this.oldAsyncProps, t, {
                             enumerable: !0,
                             value: this.oldProps[t]
@@ -21761,30 +22340,29 @@
                 }
                 _watchPromise(t, e) {
                     const n = this.asyncProps[t];
                     if (n) {
                         n.pendingLoadCount++;
                         const i = n.pendingLoadCount;
                         e.then((e => {
-                            this.component && (e = this._postProcessValue(n, e), this._setAsyncPropValue(t, e, i), this._onResolve(t, e))
+                            e = this._postProcessValue(n, e), this._setAsyncPropValue(t, e, i), this._onResolve(t, e)
                         })).catch((e => {
                             this._onError(t, e)
                         }))
                     }
                 }
                 async _resolveAsyncIterable(t, e) {
                     if ("data" !== t) return void this._setPropValue(t, e);
                     const n = this.asyncProps[t];
                     if (!n) return;
                     n.pendingLoadCount++;
                     const i = n.pendingLoadCount;
                     let r = [],
                         s = 0;
                     for await (const n of e) {
-                        if (!this.component) return;
                         const {
                             dataTransform: e
                         } = this.component.props;
                         r = e ? e(n, r) : r.concat(n), Object.defineProperty(r, "__diff", {
                             enumerable: !1,
                             value: [{
                                 startRow: s,
@@ -21792,98 +22370,101 @@
                             }]
                         }), s = r.length, this._setAsyncPropValue(t, r, i)
                     }
                     this._onResolve(t, r)
                 }
                 _postProcessValue(t, e) {
                     const n = t.type;
-                    return n && this.component && (n.release && n.release(t.resolvedValue, n, this.component), n.transform) ? n.transform(e, n, this.component) : e
+                    return n && (n.release && n.release(t.resolvedValue, n, this.component), n.transform) ? n.transform(e, n, this.component) : e
                 }
                 _createAsyncPropData(t, e) {
                     if (!this.asyncProps[t]) {
-                        const n = this.component && this.component.props[To];
+                        const n = this.component && this.component.constructor._propTypes;
                         this.asyncProps[t] = {
                             type: n && n[t],
                             lastValue: null,
                             resolvedValue: e,
                             pendingLoadCount: 0,
                             resolvedLoadCount: 0
                         }
                     }
                 }
             }
-            class Ob extends Mb {
+            class Gb extends Ub {
                 constructor({
                     attributeManager: t,
                     layer: e
                 }) {
-                    super(e), wo(this, "attributeManager", void 0), wo(this, "needsRedraw", void 0), wo(this, "needsUpdate", void 0), wo(this, "subLayers", void 0), wo(this, "usesPickingColorCache", void 0), wo(this, "hasPickingBuffer", void 0), wo(this, "changeFlags", void 0), wo(this, "viewport", void 0), wo(this, "uniformTransitions", void 0), wo(this, "propsInTransition", void 0), this.attributeManager = t, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1
+                    super(e), wo(this, "attributeManager", void 0), wo(this, "needsRedraw", void 0), wo(this, "needsUpdate", void 0), wo(this, "subLayers", void 0), wo(this, "usesPickingColorCache", void 0), wo(this, "changeFlags", void 0), wo(this, "viewport", void 0), wo(this, "uniformTransitions", void 0), wo(this, "propsInTransition", void 0), this.attributeManager = t, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1
                 }
                 get layer() {
                     return this.component
                 }
+                set layer(t) {
+                    this.component = t
+                }
                 _fetch(t, e) {
-                    const n = this.layer,
-                        i = null == n ? void 0 : n.props.fetch;
-                    return i ? i(e, {
+                    const n = this.component.props.fetch;
+                    return n ? n(e, {
                         propName: t,
-                        layer: n
+                        layer: this.layer
                     }) : super._fetch(t, e)
                 }
                 _onResolve(t, e) {
-                    const n = this.layer;
-                    if (n) {
-                        const i = n.props.onDataLoad;
-                        "data" === t && i && i(e, {
-                            propName: t,
-                            layer: n
-                        })
-                    }
+                    const n = this.component.props.onDataLoad;
+                    "data" === t && n && n(e, {
+                        propName: t,
+                        layer: this.layer
+                    })
                 }
                 _onError(t, e) {
-                    const n = this.layer;
-                    n && n.raiseError(e, "loading ".concat(t, " of ").concat(this.layer))
+                    this.layer.raiseError(e, "loading ".concat(t, " of ").concat(this.layer))
                 }
             }
-            const Lb = 2 ** 24 - 1,
-                Rb = Object.freeze([]),
-                Ib = uf((({
+            const Wb = 2 ** 24 - 1,
+                Hb = Object.freeze([]),
+                Zb = hf((({
                     oldViewport: t,
                     viewport: e
                 }) => t.equals(e)));
-            let kb = new Uint8ClampedArray(0);
-            const jb = {
+            let qb = new Uint8ClampedArray(0);
+            const Xb = {
                 data: {
                     type: "data",
-                    value: Rb,
+                    value: Hb,
                     async: !0
                 },
                 dataComparator: {
                     type: "function",
                     value: null,
+                    compare: !1,
                     optional: !0
                 },
                 _dataDiff: {
                     type: "function",
                     value: t => t && t.__diff,
+                    compare: !1,
                     optional: !0
                 },
                 dataTransform: {
                     type: "function",
                     value: null,
+                    compare: !1,
                     optional: !0
                 },
                 onDataLoad: {
                     type: "function",
                     value: null,
+                    compare: !1,
                     optional: !0
                 },
                 onError: {
                     type: "function",
                     value: null,
+                    compare: !1,
                     optional: !0
                 },
                 fetch: {
                     type: "function",
                     value: (t, {
                         propName: e,
                         layer: n,
@@ -21901,63 +22482,69 @@
                                 ...null === (a = r) || void 0 === a ? void 0 : a.fetch,
                                 signal: s
                             }
                         });
                         let l = o.contains(t);
                         return l || r || (o.add({
                             resourceId: t,
-                            data: nc(t, i),
+                            data: $l(t, i),
                             persistent: !1
                         }), l = !0), l ? o.subscribe({
                             resourceId: t,
                             onChange: t => {
                                 var i;
                                 return null === (i = n.internalState) || void 0 === i ? void 0 : i.reloadAsyncProp(e, t)
                             },
                             consumerId: n.id,
                             requestId: e
-                        }) : nc(t, i, r)
-                    }
+                        }) : $l(t, i, r)
+                    },
+                    compare: !1
                 },
                 updateTriggers: {},
                 visible: !0,
                 pickable: !1,
                 opacity: {
                     type: "number",
                     min: 0,
                     max: 1,
                     value: 1
                 },
-                operation: "draw",
+                operation: Lh,
                 onHover: {
                     type: "function",
                     value: null,
+                    compare: !1,
                     optional: !0
                 },
                 onClick: {
                     type: "function",
                     value: null,
+                    compare: !1,
                     optional: !0
                 },
                 onDragStart: {
                     type: "function",
                     value: null,
+                    compare: !1,
                     optional: !0
                 },
                 onDrag: {
                     type: "function",
                     value: null,
+                    compare: !1,
                     optional: !0
                 },
                 onDragEnd: {
                     type: "function",
                     value: null,
+                    compare: !1,
                     optional: !0
                 },
-                coordinateSystem: Lh.DEFAULT,
+                coordinateSystem: Th.DEFAULT,
                 coordinateOrigin: {
                     type: "array",
                     value: [0, 0, 0],
                     compare: !0
                 },
                 modelMatrix: {
                     type: "array",
@@ -21968,76 +22555,68 @@
                 wrapLongitude: !1,
                 positionFormat: "XYZ",
                 colorFormat: "RGBA",
                 parameters: {
                     type: "object",
                     value: {},
                     optional: !0,
-                    compare: 2
-                },
-                loadOptions: {
-                    type: "object",
-                    value: null,
-                    optional: !0,
-                    ignore: !0
+                    compare: !0
                 },
                 transitions: null,
                 extensions: [],
                 loaders: {
                     type: "array",
                     value: [],
                     optional: !0,
-                    ignore: !0
+                    compare: !0
                 },
                 getPolygonOffset: {
                     type: "function",
                     value: ({
                         layerIndex: t
-                    }) => [0, 100 * -t]
+                    }) => [0, 100 * -t],
+                    compare: !1
                 },
                 highlightedObjectIndex: null,
                 autoHighlight: !1,
                 highlightColor: {
                     type: "accessor",
                     value: [0, 0, 128, 128]
                 }
             };
-            class Fb extends Tb {
+            class Yb extends Nb {
                 constructor(...t) {
                     super(...t), wo(this, "internalState", null), wo(this, "lifecycle", "Awaiting state"), wo(this, "context", void 0), wo(this, "state", void 0), wo(this, "parent", null)
                 }
-                static get componentName() {
-                    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : ""
-                }
                 get root() {
                     let t = this;
                     for (; t.parent;) t = t.parent;
                     return t
                 }
                 toString() {
                     const t = this.constructor.layerName || this.constructor.name;
                     return "".concat(t, "({id: '").concat(this.props.id, "'})")
                 }
                 project(t) {
-                    Of(this.internalState);
+                    Mf(this.internalState);
                     const e = this.internalState.viewport || this.context.viewport,
-                        n = fb(t, {
+                        n = Cb(t, {
                             viewport: e,
                             modelMatrix: this.props.modelMatrix,
                             coordinateOrigin: this.props.coordinateOrigin,
                             coordinateSystem: this.props.coordinateSystem
                         }),
-                        [i, r, s] = Th(n, e.pixelProjectionMatrix);
+                        [i, r, s] = wh(n, e.pixelProjectionMatrix);
                     return 2 === t.length ? [i, r] : [i, r, s]
                 }
                 unproject(t) {
-                    return Of(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(t)
+                    return Mf(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(t)
                 }
                 projectPosition(t, e) {
-                    return Of(this.internalState),
+                    return Mf(this.internalState),
                         function(t, e) {
                             const {
                                 viewport: n,
                                 coordinateSystem: i,
                                 coordinateOrigin: r,
                                 modelMatrix: s,
                                 fromCoordinateSystem: o,
@@ -22049,40 +22628,38 @@
                                     coordinateOrigin: i
                                 } = t;
                                 let {
                                     coordinateSystem: r,
                                     fromCoordinateSystem: s,
                                     fromCoordinateOrigin: o
                                 } = t;
-                                return r === Lh.DEFAULT && (r = e.isGeospatial ? Lh.LNGLAT : Lh.CARTESIAN), void 0 === s && (s = r), void 0 === o && (o = i), {
+                                return r === Th.DEFAULT && (r = e.isGeospatial ? Th.LNGLAT : Th.CARTESIAN), void 0 === s && (s = r), void 0 === o && (o = i), {
                                     viewport: e,
                                     coordinateSystem: r,
                                     coordinateOrigin: i,
                                     modelMatrix: n,
                                     fromCoordinateSystem: s,
                                     fromCoordinateOrigin: o
                                 }
                             }(e), {
-                                autoOffset: l = !0
-                            } = e, {
-                                geospatialOrigin: c = db,
-                                shaderCoordinateOrigin: h = db,
-                                offsetMode: u = !1
-                            } = l ? bf(n, i, r) : {}, d = fb(t, {
+                                geospatialOrigin: l,
+                                shaderCoordinateOrigin: c,
+                                offsetMode: h
+                            } = vf(n, i, r), u = Cb(t, {
                                 viewport: n,
                                 modelMatrix: s,
                                 coordinateSystem: o,
                                 coordinateOrigin: a,
-                                offsetMode: u
+                                offsetMode: h
                             });
-                            if (u) {
-                                const t = n.projectPosition(c || h);
-                                Cc(d, d, t)
+                            if (h) {
+                                const t = n.projectPosition(l || c);
+                                Ec(u, u, t)
                             }
-                            return d
+                            return u
                         }(t, {
                             viewport: this.internalState.viewport || this.context.viewport,
                             modelMatrix: this.props.modelMatrix,
                             coordinateOrigin: this.props.coordinateOrigin,
                             coordinateSystem: this.props.coordinateSystem,
                             ...e
                         })
@@ -22125,30 +22702,30 @@
                 getLoadOptions() {
                     return this.props.loadOptions
                 }
                 use64bitPositions() {
                     const {
                         coordinateSystem: t
                     } = this.props;
-                    return t === Lh.DEFAULT || t === Lh.LNGLAT || t === Lh.CARTESIAN
+                    return t === Th.DEFAULT || t === Th.LNGLAT || t === Th.CARTESIAN
                 }
                 onHover(t, e) {
                     return this.props.onHover && this.props.onHover(t, e) || !1
                 }
                 onClick(t, e) {
                     return this.props.onClick && this.props.onClick(t, e) || !1
                 }
                 nullPickingColor() {
                     return [0, 0, 0]
                 }
                 encodePickingColor(t, e = []) {
                     return e[0] = t + 1 & 255, e[1] = t + 1 >> 8 & 255, e[2] = t + 1 >> 8 >> 8 & 255, e
                 }
                 decodePickingColor(t) {
-                    Of(t instanceof Uint8Array);
+                    Mf(t instanceof Uint8Array);
                     const [e, n, i] = t;
                     return e + 256 * n + 65536 * i - 1
                 }
                 getNumInstances() {
                     return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && void 0 !== this.state.numInstances ? this.state.numInstances : function(t) {
                         if (null === (e = t) || "object" != typeof e) throw new Error("count(): argument not an object");
                         var e;
@@ -22162,44 +22739,48 @@
                     }(this.props.data)
                 }
                 getStartIndices() {
                     return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null
                 }
                 getBounds() {
                     var t;
-                    return null === (t = this.getAttributeManager()) || void 0 === t ? void 0 : t.getBounds(["positions", "instancePositions"])
+                    const e = this.getAttributeManager();
+                    if (!e) return null;
+                    const {
+                        positions: n,
+                        instancePositions: i
+                    } = e.attributes;
+                    return null === (t = n || i) || void 0 === t ? void 0 : t.getBounds()
                 }
                 getShaders(t) {
-                    for (const e of this.props.extensions) t = ub(t, e.getShaders.call(this, e));
+                    for (const e of this.props.extensions) t = Pb(t, e.getShaders.call(this, e));
                     return t
                 }
                 shouldUpdateState(t) {
                     return t.changeFlags.propsOrDataChanged
                 }
                 updateState(t) {
                     const e = this.getAttributeManager(),
                         {
                             dataChanged: n
                         } = t.changeFlags;
                     if (n && e)
                         if (Array.isArray(n))
                             for (const t of n) e.invalidateAll(t);
                         else e.invalidateAll();
-                    if (e) {
+                    const {
+                        props: i,
+                        oldProps: r
+                    } = t, s = Number.isInteger(r.highlightedObjectIndex) || r.pickable, o = Number.isInteger(i.highlightedObjectIndex) || i.pickable;
+                    if (s !== o && e) {
                         const {
-                            props: n
-                        } = t, i = this.internalState.hasPickingBuffer, r = Number.isInteger(n.highlightedObjectIndex) || n.pickable || n.extensions.some((t => t.getNeedsPickingBuffer.call(this, t)));
-                        if (i !== r) {
-                            this.internalState.hasPickingBuffer = r;
-                            const {
-                                pickingColors: t,
-                                instancePickingColors: n
-                            } = e.attributes, i = t || n;
-                            i && (r && i.constant && (i.constant = !1, e.invalidate(i.id)), i.value || r || (i.constant = !0, i.value = [0, 0, 0]))
-                        }
+                            pickingColors: t,
+                            instancePickingColors: n
+                        } = e.attributes, i = t || n;
+                        i && (o && i.constant && (i.constant = !1, e.invalidate(i.id)), i.value || o || (i.constant = !0, i.value = [0, 0, 0]))
                     }
                 }
                 finalizeState(t) {
                     for (const t of this.getModels()) t.delete();
                     const e = this.getAttributeManager();
                     e && e.finalize(), this.context && this.context.resourceManager.unsubscribe({
                         consumerId: this.id
@@ -22233,15 +22814,15 @@
                 hasUniformTransition() {
                     var t;
                     return (null === (t = this.internalState) || void 0 === t ? void 0 : t.uniformTransitions.active) || !1
                 }
                 activateViewport(t) {
                     if (!this.internalState) return;
                     const e = this.internalState.viewport;
-                    this.internalState.viewport = t, e && Ib({
+                    this.internalState.viewport = t, e && Zb({
                         oldViewport: e,
                         viewport: t
                     }) || (this.setChangeFlags({
                         viewportChanged: !0
                     }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update())
                 }
                 invalidateAttribute(t = "all") {
@@ -22289,48 +22870,35 @@
                     }
                     return this.props
                 }
                 calculateInstancePickingColors(t, {
                     numInstances: e
                 }) {
                     if (t.constant) return;
-                    const n = Math.floor(kb.length / 3);
+                    const n = Math.floor(qb.length / 3);
                     if (this.internalState.usesPickingColorCache = !0, n < e) {
-                        e > Lb && na.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), kb = sc.allocate(kb, e, {
+                        e > Wb && ta.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), qb = nc.allocate(qb, e, {
                             size: 3,
                             copy: !0,
-                            maxCount: Math.max(e, Lb)
+                            maxCount: Math.max(e, Wb)
                         });
-                        const t = Math.floor(kb.length / 3),
+                        const t = Math.floor(qb.length / 3),
                             i = [];
-                        for (let e = n; e < t; e++) this.encodePickingColor(e, i), kb[3 * e + 0] = i[0], kb[3 * e + 1] = i[1], kb[3 * e + 2] = i[2]
+                        for (let e = n; e < t; e++) this.encodePickingColor(e, i), qb[3 * e + 0] = i[0], qb[3 * e + 1] = i[1], qb[3 * e + 2] = i[2]
                     }
-                    t.value = kb.subarray(0, 3 * e)
+                    t.value = qb.subarray(0, 3 * e)
                 }
                 _setModelAttributes(t, e) {
                     const n = this.getAttributeManager(),
                         i = t.userData.excludeAttributes || {},
                         r = n.getShaderAttributes(e, i);
                     t.setAttributes(r)
                 }
                 disablePickingIndex(t) {
-                    const e = this.props.data;
-                    if (!("attributes" in e)) return void this._disablePickingIndex(t);
-                    const {
-                        pickingColors: n,
-                        instancePickingColors: i
-                    } = this.getAttributeManager().attributes, r = n || i, s = r && e.attributes && e.attributes[r.id];
-                    if (s && s.value) {
-                        const n = s.value,
-                            i = this.encodePickingColor(t);
-                        for (let t = 0; t < e.length; t++) {
-                            const e = r.getVertexOffset(t);
-                            n[e] === i[0] && n[e + 1] === i[1] && n[e + 2] === i[2] && this._disablePickingIndex(t)
-                        }
-                    } else this._disablePickingIndex(t)
+                    this._disablePickingIndex(t)
                 }
                 _disablePickingIndex(t) {
                     const {
                         pickingColors: e,
                         instancePickingColors: n
                     } = this.getAttributeManager().attributes, i = e || n;
                     if (!i) return;
@@ -22342,53 +22910,53 @@
                     })
                 }
                 restorePickingColors() {
                     const {
                         pickingColors: t,
                         instancePickingColors: e
                     } = this.getAttributeManager().attributes, n = t || e;
-                    n && (this.internalState.usesPickingColorCache && n.value.buffer !== kb.buffer && (n.value = kb.subarray(0, n.value.length)), n.updateSubBuffer({
+                    n && (this.internalState.usesPickingColorCache && n.value.buffer !== qb.buffer && (n.value = qb.subarray(0, n.value.length)), n.updateSubBuffer({
                         startOffset: 0
                     }))
                 }
                 _initialize() {
-                    Of(!this.internalState), Of(Number.isFinite(this.props.coordinateSystem)), sa("layer.initialize", this);
+                    Mf(!this.internalState), Mf(Number.isFinite(this.props.coordinateSystem)), na("layer.initialize", this);
                     const t = this._getAttributeManager();
                     t && t.addInstanced({
                         instancePickingColors: {
                             type: 5121,
                             size: 3,
                             noAlloc: !0,
                             update: this.calculateInstancePickingColors
                         }
-                    }), this.internalState = new Ob({
+                    }), this.internalState = new Gb({
                         attributeManager: t,
                         layer: this
                     }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
-                        get: () => (na.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), t)
-                    }), this.internalState.uniformTransitions = new sb(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
+                        get: () => (ta.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), t)
+                    }), this.internalState.layer = this, this.internalState.uniformTransitions = new vb(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
                     for (const t of this.props.extensions) t.initializeState.call(this, this.context, t);
                     this.setChangeFlags({
                         dataChanged: "init",
                         propsChanged: "init",
                         viewportChanged: !0,
                         extensionsChanged: !0
                     }), this._update()
                 }
                 _transferState(t) {
-                    sa("layer.matched", this, this === t);
+                    na("layer.matched", this, this === t);
                     const {
                         state: e,
                         internalState: n
                     } = t;
-                    this !== t && (this.internalState = n, this.state = e, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()))
+                    this !== t && (this.internalState = n, this.internalState.layer = this, this.state = e, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()))
                 }
                 _update() {
                     const t = this.needsUpdate();
-                    if (sa("layer.update", this, t), !t) return;
+                    if (na("layer.update", this, t), !t) return;
                     const e = this.props,
                         n = this.context,
                         i = this.internalState,
                         r = n.viewport,
                         s = this._updateUniformTransition();
                     i.propsInTransition = s, n.viewport = i.viewport || r, this.props = s;
                     try {
@@ -22402,16 +22970,16 @@
                         const i = this.getModels()[0] !== e[0];
                         this._postUpdate(t, i)
                     } finally {
                         n.viewport = r, this.props = e, this._clearChangeFlags(), i.needsUpdate = !1, i.resetOldProps()
                     }
                 }
                 _finalize() {
-                    sa("layer.finalize", this), this.finalizeState(this.context);
-                    for (const t of this.props.extensions) t.finalizeState.call(this, this.context, t)
+                    na("layer.finalize", this), this.finalizeState(this.context);
+                    for (const t of this.props.extensions) t.finalizeState.call(this, t)
                 }
                 _drawLayer({
                     moduleParameters: t = null,
                     uniforms: e = {},
                     parameters: n = {}
                 }) {
                     this._updateAttributeTransition();
@@ -22421,17 +22989,17 @@
                     const s = this.props.opacity;
                     e.opacity = Math.pow(s, 1 / 2.2);
                     try {
                         t && this.setModuleParameters(t);
                         const {
                             getPolygonOffset: i
                         } = this.props, s = i && i(e) || [0, 0];
-                        hd(r.gl, {
+                        ld(r.gl, {
                             polygonOffset: s
-                        }), ud(r.gl, n, (() => {
+                        }), cd(r.gl, n, (() => {
                             const i = {
                                 moduleParameters: t,
                                 uniforms: e,
                                 parameters: n,
                                 context: r
                             };
                             for (const t of this.props.extensions) t.draw.call(this, i, t);
@@ -22454,15 +23022,15 @@
                         if (t[n]) {
                             let i = !1;
                             if ("dataChanged" === n) {
                                 const r = t[n],
                                     s = e[n];
                                 r && Array.isArray(s) && (e.dataChanged = Array.isArray(r) ? s.concat(r) : r, i = !0)
                             }
-                            e[n] || (e[n] = t[n], i = !0), i && sa("layer.changeFlag", this, n, t)
+                            e[n] || (e[n] = t[n], i = !0), i && na("layer.changeFlag", this, n, t)
                         } const n = Boolean(e.dataChanged || e.updateTriggersChanged || e.propsChanged || e.extensionsChanged);
                     e.propsOrDataChanged = n, e.somethingChanged = n || e.viewportChanged || e.stateChanged
                 }
                 _clearChangeFlags() {
                     this.internalState.changeFlags = {
                         dataChanged: !1,
                         propsChanged: !1,
@@ -22472,18 +23040,18 @@
                         extensionsChanged: !1,
                         propsOrDataChanged: !1,
                         somethingChanged: !1
                     }
                 }
                 _diffProps(t, e) {
                     const n = function(t, e) {
-                        const n = ab({
+                        const n = yb({
                                 newProps: t,
                                 oldProps: e,
-                                propTypes: t[To],
+                                propTypes: Eb(t),
                                 ignoreProps: {
                                     data: null,
                                     updateTriggers: null,
                                     extensions: null,
                                     transitions: null
                                 }
                             }),
@@ -22497,41 +23065,41 @@
                                 return i ? i(t.data, e.data) || (n = "Data comparator detected a change") : t.data !== e.data && (n = "A new data container was supplied"), n && r && (n = r(t.data, e.data) || n), n
                             }(t, e);
                         let r = !1;
                         return i || (r = function(t, e) {
                             if (null === e) return {
                                 all: !0
                             };
-                            if ("all" in t.updateTriggers && hb(t, e, "all")) return {
+                            if ("all" in t.updateTriggers && wb(t, e, "all")) return {
                                 all: !0
                             };
                             const n = {};
                             let i = !1;
-                            for (const r in t.updateTriggers) "all" !== r && hb(t, e, r) && (n[r] = !0, i = !0);
+                            for (const r in t.updateTriggers) "all" !== r && wb(t, e, r) && (n[r] = !0, i = !0);
                             return !!i && n
                         }(t, e)), {
                             dataChanged: i,
                             propsChanged: n,
                             updateTriggersChanged: r,
-                            extensionsChanged: cb(t, e),
-                            transitionsChanged: ob(t, e)
+                            extensionsChanged: xb(t, e),
+                            transitionsChanged: bb(t, e)
                         }
                     }(t, e);
                     if (n.updateTriggersChanged)
                         for (const t in n.updateTriggersChanged) n.updateTriggersChanged[t] && this.invalidateAttribute(t);
                     if (n.transitionsChanged)
                         for (const r in n.transitionsChanged) {
                             var i;
                             this.internalState.uniformTransitions.add(r, e[r], t[r], null === (i = t.transitions) || void 0 === i ? void 0 : i[r])
                         }
                     return this.setChangeFlags(n)
                 }
                 validateProps() {
                     ! function(t) {
-                        const e = t[To];
+                        const e = Eb(t);
                         for (const n in e) {
                             const i = e[n],
                                 {
                                     validate: r
                                 } = i;
                             if (r && !r(t[n], i)) throw new Error("Invalid prop ".concat(n, ": ").concat(t[n]))
                         }
@@ -22547,15 +23115,15 @@
                         {
                             highlightColor: n
                         } = this.props;
                     t.picked && "function" == typeof n && (e.pickingHighlightColor = n(t)), this.setModuleParameters(e), this.setNeedsRedraw()
                 }
                 _getAttributeManager() {
                     const t = this.context;
-                    return new tb(t.gl, {
+                    return new db(t.gl, {
                         id: this.props.id,
                         stats: t.stats,
                         timeline: t.timeline
                     })
                 }
                 _postUpdate(t, e) {
                     const {
@@ -22570,108 +23138,106 @@
                     const {
                         autoHighlight: s,
                         highlightedObjectIndex: o,
                         highlightColor: a
                     } = n;
                     if (e || i.autoHighlight !== s || i.highlightedObjectIndex !== o || i.highlightColor !== a) {
                         const t = {};
-                        s || (t.pickingSelectedColor = null), Array.isArray(a) && (t.pickingHighlightColor = a), (e || o !== i.highlightedObjectIndex) && (t.pickingSelectedColor = Number.isFinite(o) && o >= 0 ? this.encodePickingColor(o) : null), this.setModuleParameters(t)
+                        s || (t.pickingSelectedColor = null), Array.isArray(a) && (t.pickingHighlightColor = a), Number.isInteger(o) && (t.pickingSelectedColor = Number.isFinite(o) && o >= 0 ? this.encodePickingColor(o) : null), this.setModuleParameters(t)
                     }
                 }
                 _getUpdateParams() {
                     return {
                         props: this.props,
                         oldProps: this.internalState.getOldProps(),
                         context: this.context,
                         changeFlags: this.internalState.changeFlags
                     }
                 }
                 _getNeedsRedraw(t) {
                     if (!this.internalState) return !1;
                     let e = !1;
-                    e = e || this.internalState.needsRedraw && this.id;
+                    e = e || this.internalState.needsRedraw && this.id, this.internalState.needsRedraw = this.internalState.needsRedraw && !t.clearRedrawFlags;
                     const n = this.getAttributeManager(),
                         i = !!n && n.getNeedsRedraw(t);
-                    if (e = e || i, e)
-                        for (const t of this.props.extensions) t.onNeedsRedraw.call(this, t);
-                    return this.internalState.needsRedraw = this.internalState.needsRedraw && !t.clearRedrawFlags, e
+                    return e = e || i, e
                 }
                 _onAsyncPropUpdated() {
                     this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate()
                 }
             }
-            wo(Fb, "defaultProps", jb), wo(Fb, "layerName", "Layer");
-            const zb = {
+            wo(Yb, "defaultProps", Xb), wo(Yb, "layerName", "Layer");
+            const Kb = {
                 position: "absolute",
                 zIndex: -1
             };
 
-            function Bb(t, e) {
+            function Qb(t, e) {
                 if ("function" == typeof t) return t(e);
-                if (Array.isArray(t)) return t.map((t => Bb(t, e)));
-                if (Db(t)) {
+                if (Array.isArray(t)) return t.map((t => Qb(t, e)));
+                if (Jb(t)) {
                     if (function(t) {
                             const e = t.type,
                                 n = e && e.defaultProps;
                             return n && n.mapStyle
-                        }(t)) return e.style = zb, (0, c.cloneElement)(t, e);
+                        }(t)) return e.style = Kb, (0, c.cloneElement)(t, e);
                     if (function(t) {
                             const e = t.type;
                             return e && e.deckGLViewProps
                         }(t)) return (0, c.cloneElement)(t, e)
                 }
                 return t
             }
 
-            function Db(t) {
+            function Jb(t) {
                 return t && "object" == typeof t && "type" in t || !1
             }
 
-            function Nb(t) {
-                if ("function" == typeof t) return (0, c.createElement)(Lf, {}, t);
-                if (Array.isArray(t)) return t.map(Nb);
-                if (Db(t)) {
-                    if (t.type === c.Fragment) return Nb(t.props.children);
-                    if (tv(t.type, Lf)) return t
+            function $b(t) {
+                if ("function" == typeof t) return (0, c.createElement)(Of, {}, t);
+                if (Array.isArray(t)) return t.map($b);
+                if (Jb(t)) {
+                    if (t.type === c.Fragment) return $b(t.props.children);
+                    if (dv(t.type, Of)) return t
                 }
                 return t
             }
-            const Vb = {
+            const ty = {
                 mixBlendMode: null
             };
 
-            function Ub(t) {
+            function ey(t) {
                 t.redrawReason && (t.deck._drawLayers(t.redrawReason), t.redrawReason = null)
             }
-            const Gb = (0, c.forwardRef)(((t, e) => {
+            const ny = (0, c.forwardRef)(((t, e) => {
                 const [n, i] = (0, c.useState)(0), r = (0, c.useRef)({
                     control: null,
                     version: n,
                     forceUpdate: () => i((t => t + 1))
                 }).current, s = (0, c.useRef)(null), o = (0, c.useRef)(null), a = (0, c.useMemo)((() => function({
                     children: t,
                     layers: e = [],
                     views: n = null
                 }) {
                     const i = [],
                         r = [],
                         s = {};
-                    return c.Children.forEach(Nb(t), (t => {
-                        if (Db(t)) {
+                    return c.Children.forEach($b(t), (t => {
+                        if (Jb(t)) {
                             const e = t.type;
-                            if (tv(e, Fb)) {
+                            if (dv(e, Yb)) {
                                 const n = function(t, e) {
                                     const n = {},
                                         i = t.defaultProps || {};
                                     for (const t in e) i[t] !== e[t] && (n[t] = e[t]);
                                     return new t(n)
                                 }(e, t.props);
                                 r.push(n)
                             } else i.push(t);
-                            if (tv(e, Lf) && e !== Lf && t.props.id) {
+                            if (dv(e, Of) && e !== Of && t.props.id) {
                                 const n = new e(t.props);
                                 s[n.id] = n
                             }
                         } else t && i.push(t)
                     })), Object.keys(s).length > 0 && (Array.isArray(n) ? n.forEach((t => {
                         s[t.id] = t
                     })) : n && (s[n.id] = n), n = Object.values(s)), {
@@ -22701,35 +23267,35 @@
                             views: a.views,
                             onViewStateChange: h,
                             onInteractionStateChange: u
                         };
                         return delete e._customRender, r.deck && r.deck.setProps(e), e
                     }), [t]);
                 (0, c.useEffect)((() => {
-                    const e = t.Deck || Jm;
+                    const e = t.Deck || hv;
                     return r.deck = function(t, e, n) {
                         const i = new e({
                             ...n,
                             _customRender: e => {
                                 t.redrawReason = e;
                                 const n = i.getViewports();
-                                t.lastRenderedViewports !== n ? t.forceUpdate() : Ub(t)
+                                t.lastRenderedViewports !== n ? t.forceUpdate() : ey(t)
                             }
                         });
                         return i
                     }(r, e, {
                         ...d,
                         parent: s.current,
                         canvas: o.current
                     }), () => {
                         var t;
                         return null === (t = r.deck) || void 0 === t ? void 0 : t.finalize()
                     }
-                }), []), $m((() => {
-                    Ub(r);
+                }), []), uv((() => {
+                    ey(r);
                     const {
                         viewStateUpdateRequested: t,
                         interactionStateUpdateRequested: e
                     } = r;
                     t && h(t), e && u(e)
                 })), (0, c.useImperativeHandle)(e, (() => function(t) {
                     return {
@@ -22766,15 +23332,15 @@
                                 height: e
                             },
                             r = {
                                 left: 0,
                                 top: 0
                             };
                         if (n)
-                            for (const t in n) t in Vb ? r[t] = n[t] : i[t] = n[t];
+                            for (const t in n) t in ty ? r[t] = n[t] : i[t] = n[t];
                         return {
                             containerStyle: i,
                             canvasStyle: r
                         }
                     }({
                         width: g,
                         height: m,
@@ -22792,26 +23358,25 @@
                             } = e || {};
                             if (!i || !i.views.length) return [];
                             const r = {},
                                 s = i.views[0].id;
                             for (const e of t) {
                                 let t = s,
                                     n = e;
-                                Db(e) && tv(e.type, Lf) && (t = e.props.id || s, n = e.props.children);
+                                Jb(e) && dv(e.type, Of) && (t = e.props.id || s, n = e.props.children);
                                 const o = i.getViewport(t),
                                     a = i.getViewState(t);
                                 if (o) {
-                                    a.padding = o.padding;
                                     const {
                                         x: e,
                                         y: i,
                                         width: s,
                                         height: l
                                     } = o;
-                                    n = Bb(n, {
+                                    n = Qb(n, {
                                         x: e,
                                         y: i,
                                         width: s,
                                         height: l,
                                         viewport: o,
                                         viewState: a
                                     }), r[t] || (r[t] = {
@@ -22871,404 +23436,17 @@
                         id: "".concat(v || "deckgl", "-wrapper"),
                         ref: s,
                         style: y
                     }, [e, t])
                 }
                 return l = !1, r.control
             }));
-            Gb.defaultProps = Jm.defaultProps;
-            const Wb = Gb,
-                Hb = (new ih).lookAt({
-                    eye: [0, 0, 1]
-                });
-
-            function Zb({
-                width: t,
-                height: e,
-                near: n,
-                far: i,
-                padding: r
-            }) {
-                let s = -t / 2,
-                    o = t / 2,
-                    a = -e / 2,
-                    l = e / 2;
-                if (r) {
-                    const {
-                        left: n = 0,
-                        right: i = 0,
-                        top: c = 0,
-                        bottom: h = 0
-                    } = r, u = cc((n + t - i) / 2, 0, t) - t / 2, d = cc((c + e - h) / 2, 0, e) - e / 2;
-                    s -= u, o -= u, a += d, l += d
-                }
-                return (new ih).ortho({
-                    left: s,
-                    right: o,
-                    bottom: a,
-                    top: l,
-                    near: n,
-                    far: i
-                })
-            }
-            class qb extends Dh {
-                constructor(t) {
-                    const {
-                        width: e,
-                        height: n,
-                        near: i = .1,
-                        far: r = 1e3,
-                        zoom: s = 0,
-                        target: o = [0, 0, 0],
-                        padding: a = null,
-                        flipY: l = !0
-                    } = t, c = Array.isArray(s) ? s[0] : s, h = Array.isArray(s) ? s[1] : s, u = Math.min(c, h), d = Math.pow(2, u);
-                    let p;
-                    if (c !== h) {
-                        const t = Math.pow(2, c),
-                            e = Math.pow(2, h);
-                        p = {
-                            unitsPerMeter: [t / d, e / d, 1],
-                            metersPerUnit: [d / t, d / e, 1]
-                        }
-                    }
-                    super({
-                        ...t,
-                        longitude: void 0,
-                        position: o,
-                        viewMatrix: Hb.clone().scale([d, d * (l ? -1 : 1), d]),
-                        projectionMatrix: Zb({
-                            width: e || 1,
-                            height: n || 1,
-                            padding: a,
-                            near: i,
-                            far: r
-                        }),
-                        zoom: u,
-                        distanceScales: p
-                    })
-                }
-                projectFlat([t, e]) {
-                    const {
-                        unitsPerMeter: n
-                    } = this.distanceScales;
-                    return [t * n[0], e * n[1]]
-                }
-                unprojectFlat([t, e]) {
-                    const {
-                        metersPerUnit: n
-                    } = this.distanceScales;
-                    return [t * n[0], e * n[1]]
-                }
-                panByPosition(t, e) {
-                    const n = Ah(e, this.pixelUnprojectionMatrix),
-                        i = qc([], this.projectFlat(t), Xc([], n)),
-                        r = qc([], this.center, i);
-                    return {
-                        target: this.unprojectFlat(r)
-                    }
-                }
-            }
-            class Xb extends Qf {
-                constructor(t) {
-                    const {
-                        width: e,
-                        height: n,
-                        rotationX: i = 0,
-                        rotationOrbit: r = 0,
-                        target: s = [0, 0, 0],
-                        zoom: o = 0,
-                        minRotationX: a = -90,
-                        maxRotationX: l = 90,
-                        minZoom: c = -1 / 0,
-                        maxZoom: h = 1 / 0,
-                        startPanPosition: u,
-                        startRotatePos: d,
-                        startRotationX: p,
-                        startRotationOrbit: f,
-                        startZoomPosition: g,
-                        startZoom: m
-                    } = t;
-                    super({
-                        width: e,
-                        height: n,
-                        rotationX: i,
-                        rotationOrbit: r,
-                        target: s,
-                        zoom: o,
-                        minRotationX: a,
-                        maxRotationX: l,
-                        minZoom: c,
-                        maxZoom: h
-                    }, {
-                        startPanPosition: u,
-                        startRotatePos: d,
-                        startRotationX: p,
-                        startRotationOrbit: f,
-                        startZoomPosition: g,
-                        startZoom: m
-                    }), wo(this, "makeViewport", void 0), this.makeViewport = t.makeViewport
-                }
-                panStart({
-                    pos: t
-                }) {
-                    return this._getUpdatedState({
-                        startPanPosition: this._unproject(t)
-                    })
-                }
-                pan({
-                    pos: t,
-                    startPosition: e
-                }) {
-                    const n = this.getState().startPanPosition || e;
-                    if (!n) return this;
-                    const i = this.makeViewport(this.getViewportProps()).panByPosition(n, t);
-                    return this._getUpdatedState(i)
-                }
-                panEnd() {
-                    return this._getUpdatedState({
-                        startPanPosition: null
-                    })
-                }
-                rotateStart({
-                    pos: t
-                }) {
-                    return this._getUpdatedState({
-                        startRotatePos: t,
-                        startRotationX: this.getViewportProps().rotationX,
-                        startRotationOrbit: this.getViewportProps().rotationOrbit
-                    })
-                }
-                rotate({
-                    pos: t,
-                    deltaAngleX: e = 0,
-                    deltaAngleY: n = 0
-                }) {
-                    const {
-                        startRotatePos: i,
-                        startRotationX: r,
-                        startRotationOrbit: s
-                    } = this.getState(), {
-                        width: o,
-                        height: a
-                    } = this.getViewportProps();
-                    if (!i || void 0 === r || void 0 === s) return this;
-                    let l;
-                    if (t) {
-                        let e = (t[0] - i[0]) / o;
-                        (r < -90 || r > 90) && (e *= -1), l = {
-                            rotationX: r + (t[1] - i[1]) / a * 180,
-                            rotationOrbit: s + 180 * e
-                        }
-                    } else l = {
-                        rotationX: r + n,
-                        rotationOrbit: s + e
-                    };
-                    return this._getUpdatedState(l)
-                }
-                rotateEnd() {
-                    return this._getUpdatedState({
-                        startRotationX: null,
-                        startRotationOrbit: null
-                    })
-                }
-                shortestPathFrom(t) {
-                    const e = t.getViewportProps(),
-                        n = {
-                            ...this.getViewportProps()
-                        },
-                        {
-                            rotationOrbit: i
-                        } = n;
-                    return Math.abs(i - e.rotationOrbit) > 180 && (n.rotationOrbit = i < 0 ? i + 360 : i - 360), n
-                }
-                zoomStart({
-                    pos: t
-                }) {
-                    return this._getUpdatedState({
-                        startZoomPosition: this._unproject(t),
-                        startZoom: this.getViewportProps().zoom
-                    })
-                }
-                zoom({
-                    pos: t,
-                    startPos: e,
-                    scale: n
-                }) {
-                    let {
-                        startZoom: i,
-                        startZoomPosition: r
-                    } = this.getState();
-                    if (r || (i = this.getViewportProps().zoom, r = this._unproject(e) || this._unproject(t)), !r) return this;
-                    const s = this._calculateNewZoom({
-                            scale: n,
-                            startZoom: i
-                        }),
-                        o = this.makeViewport({
-                            ...this.getViewportProps(),
-                            zoom: s
-                        });
-                    return this._getUpdatedState({
-                        zoom: s,
-                        ...o.panByPosition(r, t)
-                    })
-                }
-                zoomEnd() {
-                    return this._getUpdatedState({
-                        startZoomPosition: null,
-                        startZoom: null
-                    })
-                }
-                zoomIn(t = 2) {
-                    return this._getUpdatedState({
-                        zoom: this._calculateNewZoom({
-                            scale: t
-                        })
-                    })
-                }
-                zoomOut(t = 2) {
-                    return this._getUpdatedState({
-                        zoom: this._calculateNewZoom({
-                            scale: 1 / t
-                        })
-                    })
-                }
-                moveLeft(t = 50) {
-                    return this._panFromCenter([-t, 0])
-                }
-                moveRight(t = 50) {
-                    return this._panFromCenter([t, 0])
-                }
-                moveUp(t = 50) {
-                    return this._panFromCenter([0, -t])
-                }
-                moveDown(t = 50) {
-                    return this._panFromCenter([0, t])
-                }
-                rotateLeft(t = 15) {
-                    return this._getUpdatedState({
-                        rotationOrbit: this.getViewportProps().rotationOrbit - t
-                    })
-                }
-                rotateRight(t = 15) {
-                    return this._getUpdatedState({
-                        rotationOrbit: this.getViewportProps().rotationOrbit + t
-                    })
-                }
-                rotateUp(t = 10) {
-                    return this._getUpdatedState({
-                        rotationX: this.getViewportProps().rotationX - t
-                    })
-                }
-                rotateDown(t = 10) {
-                    return this._getUpdatedState({
-                        rotationX: this.getViewportProps().rotationX + t
-                    })
-                }
-                _unproject(t) {
-                    const e = this.makeViewport(this.getViewportProps());
-                    return t && e.unproject(t)
-                }
-                _calculateNewZoom({
-                    scale: t,
-                    startZoom: e
-                }) {
-                    const {
-                        maxZoom: n,
-                        minZoom: i
-                    } = this.getViewportProps();
-                    return void 0 === e && (e = this.getViewportProps().zoom), cc(e + Math.log2(t), i, n)
-                }
-                _panFromCenter(t) {
-                    const {
-                        width: e,
-                        height: n,
-                        target: i
-                    } = this.getViewportProps();
-                    return this.pan({
-                        startPosition: i,
-                        pos: [e / 2 + t[0], n / 2 + t[1]]
-                    })
-                }
-                _getUpdatedState(t) {
-                    return new this.constructor({
-                        makeViewport: this.makeViewport,
-                        ...this.getViewportProps(),
-                        ...this.getState(),
-                        ...t
-                    })
-                }
-                applyConstraints(t) {
-                    const {
-                        maxZoom: e,
-                        minZoom: n,
-                        zoom: i,
-                        maxRotationX: r,
-                        minRotationX: s,
-                        rotationOrbit: o
-                    } = t;
-                    return t.zoom = Array.isArray(i) ? [cc(i[0], n, e), cc(i[1], n, e)] : cc(i, n, e), t.rotationX = cc(t.rotationX, s, r), (o < -180 || o > 180) && (t.rotationOrbit = function(t, e) {
-                        const n = t % 360;
-                        return n < 0 ? 360 + n : n
-                    }(o + 180) - 180), t
-                }
-            }
-            class Yb extends Xb {
-                constructor(t) {
-                    super(t), wo(this, "zoomAxis", void 0), this.zoomAxis = t.zoomAxis || "all"
-                }
-                _calculateNewZoom({
-                    scale: t,
-                    startZoom: e
-                }) {
-                    const {
-                        maxZoom: n,
-                        minZoom: i
-                    } = this.getViewportProps();
-                    void 0 === e && (e = this.getViewportProps().zoom);
-                    let r = Math.log2(t);
-                    if (Array.isArray(e)) {
-                        let [t, s] = e;
-                        switch (this.zoomAxis) {
-                            case "X":
-                                t = cc(t + r, i, n);
-                                break;
-                            case "Y":
-                                s = cc(s + r, i, n);
-                                break;
-                            default:
-                                let e = Math.min(t + r, s + r);
-                                e < i && (r += i - e), e = Math.max(t + r, s + r), e > n && (r += n - e), t += r, s += r
-                        }
-                        return [t, s]
-                    }
-                    return cc(e + r, i, n)
-                }
-            }
-            class Kb extends Kf {
-                constructor(...t) {
-                    super(...t), wo(this, "ControllerState", Yb), wo(this, "transition", {
-                        transitionDuration: 300,
-                        transitionInterpolator: new Nf(["target", "zoom"])
-                    }), wo(this, "dragMode", "pan")
-                }
-                _onPanRotate() {
-                    return !1
-                }
-            }
-            class Qb extends Lf {
-                get ViewportType() {
-                    return qb
-                }
-                get ControllerType() {
-                    return Kb
-                }
-            }
-            wo(Qb, "displayName", "OrthographicView");
-            class Jb extends Fb {
+            ny.defaultProps = hv.defaultProps;
+            const iy = ny;
+            class ry extends Yb {
                 get isComposite() {
                     return !0
                 }
                 get isLoaded() {
                     return super.isLoaded && this.getSubLayers().every((t => t.isLoaded))
                 }
                 getSubLayers() {
@@ -23353,15 +23531,15 @@
                         positionFormat: p,
                         modelMatrix: f,
                         extensions: g,
                         fetch: m,
                         operation: v
                     }, _ = b && t.id && b[t.id], x = _ && _.updateTriggers, w = t.id || "sublayer";
                     if (_) {
-                        const e = this.props[To],
+                        const e = this.constructor._propTypes,
                             n = t.type ? t.type._propTypes : {};
                         for (const t in _) {
                             const i = n[t] || e[t];
                             i && "accessor" === i.type && (_[t] = this.getSubLayerAccessor(_[t]))
                         }
                     }
                     Object.assign(y, t, _), y.id = "".concat(this.props.id, "-").concat(w), y.updateTriggers = {
@@ -23382,20 +23560,20 @@
                 }
                 _getAttributeManager() {
                     return null
                 }
                 _postUpdate(t, e) {
                     let n = this.internalState.subLayers;
                     const i = !n || this.needsUpdate();
-                    i && (n = oa(this.renderLayers(), Boolean), this.internalState.subLayers = n), sa("compositeLayer.renderLayers", this, i, n);
+                    i && (n = ia(this.renderLayers(), Boolean), this.internalState.subLayers = n), na("compositeLayer.renderLayers", this, i, n);
                     for (const t of n) t.parent = this
                 }
             }
 
-            function $b({
+            function sy({
                 data: t,
                 getIndex: e,
                 dataRange: n,
                 replace: i
             }) {
                 const {
                     startRow: r = 0,
@@ -23418,72 +23596,71 @@
                     t.length = c
                 }
                 return {
                     startRow: a,
                     endRow: a + i.length
                 }
             }
-            wo(Jb, "layerName", "CompositeLayer");
-            const ty = {
+            wo(ry, "layerName", "CompositeLayer");
+            const oy = {
                     name: "project32",
-                    dependencies: [_f],
+                    dependencies: [yf],
                     vs: "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n"
                 },
-                ey = {
+                ay = {
                     pickingSelectedColor: null,
                     pickingHighlightColor: new Uint8Array([0, 255, 255, 255]),
                     pickingActive: !1,
                     pickingAttribute: !1
                 },
-                ny = {
+                ly = {
                     inject: {
                         "vs:DECKGL_FILTER_GL_POSITION": "\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ",
                         "vs:DECKGL_FILTER_COLOR": "\n  picking_setPickingColor(geometry.pickingColor);\n  ",
-                        "fs:#decl": "\nuniform bool picking_uAttribute;\n  ",
                         "fs:DECKGL_FILTER_COLOR": {
                             order: 99,
                             injection: "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "
                         }
                     },
                     name: "picking",
                     vs: "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",
                     fs: "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n",
                     getUniforms: function() {
-                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ey;
+                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ay;
                         const e = {};
                         if (void 0 !== t.pickingSelectedColor)
                             if (t.pickingSelectedColor) {
                                 const n = t.pickingSelectedColor.slice(0, 3);
                                 e.picking_uSelectedColorValid = 1, e.picking_uSelectedColor = n
                             } else e.picking_uSelectedColorValid = 0;
                         if (t.pickingHighlightColor) {
                             const n = Array.from(t.pickingHighlightColor, (t => t / 255));
                             Number.isFinite(n[3]) || (n[3] = 1), e.picking_uHighlightColor = n
                         }
                         return void 0 !== t.pickingActive && (e.picking_uActive = Boolean(t.pickingActive), e.picking_uAttribute = Boolean(t.pickingAttribute)), e
                     }
                 },
-                iy = {
+                cy = {
                     POINTS: 0,
                     LINES: 1,
                     LINE_LOOP: 2,
                     LINE_STRIP: 3,
                     TRIANGLES: 4,
                     TRIANGLE_STRIP: 5,
                     TRIANGLE_FAN: 6
                 };
-            class ry {
+            class hy {
                 static get DRAW_MODE() {
-                    return iy
+                    return cy
                 }
                 constructor() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     const {
-                        id: e = Td("geometry"),
-                        drawMode: n = iy.TRIANGLES,
+                        id: e = Cd("geometry"),
+                        drawMode: n = cy.TRIANGLES,
                         attributes: i = {},
                         indices: r = null,
                         vertexCount: s = null
                     } = t;
                     this.id = e, this.drawMode = 0 | n, this.attributes = {}, this.userData = {}, this._setAttributes(i, r), this.vertexCount = s || this._calculateVertexCount(this.attributes, this.indices)
                 }
                 get mode() {
@@ -23506,15 +23683,15 @@
                         value: e,
                         size: 1
                     } : e);
                     for (const e in t) {
                         let n = t[e];
                         n = ArrayBuffer.isView(n) ? {
                             value: n
-                        } : n, Ed(ArrayBuffer.isView(n.value), "".concat(this._print(e), ": must be typed array or object with value as typed array")), "POSITION" !== e && "positions" !== e || n.size || (n.size = 3), "indices" === e ? (Ed(!this.indices), this.indices = n) : this.attributes[e] = n
+                        } : n, wd(ArrayBuffer.isView(n.value), "".concat(this._print(e), ": must be typed array or object with value as typed array")), "POSITION" !== e && "positions" !== e || n.size || (n.size = 3), "indices" === e ? (wd(!this.indices), this.indices = n) : this.attributes[e] = n
                     }
                     return this.indices && void 0 !== this.indices.isIndexed && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this
                 }
                 _calculateVertexCount(t, e) {
                     if (e) return e.value.length;
                     let n = 1 / 0;
                     for (const e in t) {
@@ -23522,73 +23699,62 @@
                             {
                                 value: r,
                                 size: s,
                                 constant: o
                             } = i;
                         !o && r && s >= 1 && (n = Math.min(n, r.length / s))
                     }
-                    return Ed(Number.isFinite(n)), n
+                    return wd(Number.isFinite(n)), n
                 }
             }
-            const sy = () => {},
-                oy = {
+            const uy = () => {},
+                dy = {
                     10241: 9987,
                     10240: 9729,
                     10242: 33071,
                     10243: 33071
                 };
 
-            function ay(t, e, n, i) {
-                const r = Math.min(n / e.width, i / e.height),
-                    s = Math.floor(e.width * r),
-                    o = Math.floor(e.height * r);
-                return 1 === r ? {
-                    data: e,
-                    width: s,
-                    height: o
-                } : (t.canvas.height = o, t.canvas.width = s, t.clearRect(0, 0, s, o), t.drawImage(e, 0, 0, e.width, e.height, 0, 0, s, o), {
-                    data: t.canvas,
-                    width: s,
-                    height: o
-                })
+            function py(t, e, n, i) {
+                return n === e.width && i === e.height ? e : (t.canvas.height = i, t.canvas.width = n, t.clearRect(0, 0, t.canvas.width, t.canvas.height), t.drawImage(e, 0, 0, e.width, e.height, 0, 0, n, i), t.canvas)
             }
 
-            function ly(t) {
+            function fy(t) {
                 return t && (t.id || t.url)
             }
 
-            function cy(t, e, n) {
+            function gy(t, e, n) {
                 for (let i = 0; i < e.length; i++) {
                     const {
                         icon: r,
                         xOffset: s
                     } = e[i];
-                    t[ly(r)] = {
+                    t[fy(r)] = {
                         ...r,
                         x: s,
                         y: n
                     }
                 }
             }
-            class hy {
+            class my {
                 constructor(t, {
-                    onUpdate: e = sy,
-                    onError: n = sy
+                    onUpdate: e = uy,
+                    onError: n = uy
                 }) {
                     wo(this, "gl", void 0), wo(this, "onUpdate", void 0), wo(this, "onError", void 0), wo(this, "_loadOptions", null), wo(this, "_texture", null), wo(this, "_externalTexture", null), wo(this, "_mapping", {}), wo(this, "_textureParameters", null), wo(this, "_pendingCount", 0), wo(this, "_autoPacking", !1), wo(this, "_xOffset", 0), wo(this, "_yOffset", 0), wo(this, "_rowHeight", 0), wo(this, "_buffer", 4), wo(this, "_canvasWidth", 1024), wo(this, "_canvasHeight", 0), wo(this, "_canvas", null), this.gl = t, this.onUpdate = e, this.onError = n
                 }
                 finalize() {
                     var t;
                     null === (t = this._texture) || void 0 === t || t.delete()
                 }
                 getTexture() {
                     return this._texture || this._externalTexture
                 }
                 getIconMapping(t) {
-                    const e = this._autoPacking ? ly(t) : t;
+                    const e = this._autoPacking ? fy(t) : t;
                     return this._mapping[e] || {}
                 }
                 setProps({
                     loadOptions: t,
                     autoPacking: e,
                     iconAtlas: n,
                     iconMapping: i,
@@ -23605,19 +23771,19 @@
                     const n = Object.values(function(t, e, n) {
                         if (!t || !e) return null;
                         n = n || {};
                         const i = {},
                             {
                                 iterable: r,
                                 objectInfo: s
-                            } = av(t);
+                            } = yv(t);
                         for (const t of r) {
                             s.index++;
                             const r = e(t, s),
-                                o = ly(r);
+                                o = fy(r);
                             if (!r) throw new Error("Icon is missing.");
                             if (!r.url) throw new Error("Icon url is missing.");
                             i[o] || n[o] && r.url === n[o].url || (i[o] = {
                                 ...r,
                                 source: t,
                                 sourceIndex: s.index
                             })
@@ -23639,26 +23805,26 @@
                             yOffset: r = 0,
                             rowHeight: s = 0,
                             canvasWidth: o
                         }) {
                             let a = [];
                             for (let l = 0; l < t.length; l++) {
                                 const c = t[l];
-                                if (!n[ly(c)]) {
+                                if (!n[fy(c)]) {
                                     const {
                                         height: t,
                                         width: l
                                     } = c;
-                                    i + l + e > o && (cy(n, a, r), i = 0, r = s + r + e, s = 0, a = []), a.push({
+                                    i + l + e > o && (gy(n, a, r), i = 0, r = s + r + e, s = 0, a = []), a.push({
                                         icon: c,
                                         xOffset: i
                                     }), i = i + l + e, s = Math.max(s, t)
                                 }
                             }
-                            return a.length > 0 && cy(n, a, r), {
+                            return a.length > 0 && gy(n, a, r), {
                                 mapping: n,
                                 rowHeight: s,
                                 xOffset: i,
                                 yOffset: r,
                                 canvasWidth: o,
                                 canvasHeight: (l = s + r + e, Math.pow(2, Math.ceil(Math.log2(l))))
                             };
@@ -23668,22 +23834,22 @@
                             buffer: this._buffer,
                             canvasWidth: this._canvasWidth,
                             mapping: this._mapping,
                             rowHeight: this._rowHeight,
                             xOffset: this._xOffset,
                             yOffset: this._yOffset
                         });
-                        this._rowHeight = r, this._mapping = t, this._xOffset = e, this._yOffset = i, this._canvasHeight = s, this._texture || (this._texture = new Qd(this.gl, {
+                        this._rowHeight = r, this._mapping = t, this._xOffset = e, this._yOffset = i, this._canvasHeight = s, this._texture || (this._texture = new Kd(this.gl, {
                             width: this._canvasWidth,
                             height: this._canvasHeight,
-                            parameters: this._textureParameters || oy
+                            parameters: this._textureParameters || dy
                         })), this._texture.height !== this._canvasHeight && (this._texture = function(t, e, n, i) {
                             const r = t.width,
                                 s = t.height,
-                                o = new Qd(t.gl, {
+                                o = new Kd(t.gl, {
                                     width: e,
                                     height: n,
                                     parameters: i
                                 });
                             return function(t, e) {
                                 let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                                 const {
@@ -23698,82 +23864,75 @@
                                     targetZ: c,
                                     width: h,
                                     height: u
                                 } = n;
                                 const {
                                     framebuffer: d,
                                     deleteFramebuffer: p
-                                } = hp(t);
-                                Ed(d);
+                                } = cp(t);
+                                wd(d);
                                 const {
                                     gl: f,
                                     handle: g
                                 } = d, m = void 0 !== a || void 0 !== l || void 0 !== c;
                                 a = a || 0, l = l || 0, c = c || 0;
                                 const v = f.bindFramebuffer(36160, g);
-                                Ed(e);
+                                wd(e);
                                 let b = null;
-                                if (e instanceof Kd && (b = e, h = Number.isFinite(h) ? h : b.width, u = Number.isFinite(u) ? u : b.height, b.bind(0), e = b.target), m) switch (e) {
+                                if (e instanceof Yd && (b = e, h = Number.isFinite(h) ? h : b.width, u = Number.isFinite(u) ? u : b.height, b.bind(0), e = b.target), m) switch (e) {
                                     case 3553:
                                     case 34067:
                                         f.copyTexSubImage2D(e, s, a, l, i, r, h, u);
                                         break;
                                     case 35866:
                                     case 32879:
-                                        Iu(f).copyTexSubImage3D(e, s, a, l, c, i, r, h, u)
+                                        Lu(f).copyTexSubImage3D(e, s, a, l, c, i, r, h, u)
                                 } else f.copyTexImage2D(e, s, o, i, r, h, u, 0);
                                 b && b.unbind(), f.bindFramebuffer(36160, v || null), p && d.delete()
                             }(t, o, {
                                 targetY: 0,
                                 width: r,
                                 height: s
                             }), t.delete(), o
-                        }(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || oy)), this.onUpdate(), this._canvas = this._canvas || document.createElement("canvas"), this._loadIcons(n)
+                        }(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || dy)), this.onUpdate(), this._canvas = this._canvas || document.createElement("canvas"), this._loadIcons(n)
                     }
                 }
                 _loadIcons(t) {
-                    const e = this._canvas.getContext("2d", {
-                        willReadFrequently: !0
-                    });
-                    for (const n of t) this._pendingCount++, nc(n.url, this._loadOptions).then((t => {
-                        const i = ly(n),
-                            r = this._mapping[i],
+                    const e = this._canvas.getContext("2d");
+                    for (const n of t) this._pendingCount++, $l(n.url, um, this._loadOptions).then((t => {
+                        const i = fy(n),
                             {
-                                x: s,
-                                y: o,
-                                width: a,
-                                height: l
-                            } = r,
-                            {
-                                data: c,
-                                width: h,
-                                height: u
-                            } = ay(e, t, a, l);
+                                x: r,
+                                y: s,
+                                width: o,
+                                height: a
+                            } = this._mapping[i],
+                            l = py(e, t, o, a);
                         this._texture.setSubImageData({
-                            data: c,
-                            x: s + (a - h) / 2,
-                            y: o + (l - u) / 2,
-                            width: h,
-                            height: u
-                        }), r.width = h, r.height = u, this._texture.generateMipmap(), this.onUpdate()
+                            data: l,
+                            x: r,
+                            y: s,
+                            width: o,
+                            height: a
+                        }), this._texture.generateMipmap(), this.onUpdate()
                     })).catch((t => {
                         this.onError({
                             url: n.url,
                             source: n.source,
                             sourceIndex: n.sourceIndex,
                             loadOptions: this._loadOptions,
                             error: t
                         })
                     })).finally((() => {
                         this._pendingCount--
                     }))
                 }
             }
-            const uy = [0, 0, 0, 255],
-                dy = {
+            const vy = [0, 0, 0, 255],
+                by = {
                     iconAtlas: {
                         type: "image",
                         value: null,
                         async: !0
                     },
                     iconMapping: {
                         type: "object",
@@ -23809,15 +23968,15 @@
                     },
                     getIcon: {
                         type: "accessor",
                         value: t => t.icon
                     },
                     getColor: {
                         type: "accessor",
-                        value: uy
+                        value: vy
                     },
                     getSize: {
                         type: "accessor",
                         value: 1
                     },
                     getAngle: {
                         type: "accessor",
@@ -23826,35 +23985,32 @@
                     getPixelOffset: {
                         type: "accessor",
                         value: [0, 0]
                     },
                     onIconError: {
                         type: "function",
                         value: null,
+                        compare: !1,
                         optional: !0
-                    },
-                    textureParameters: {
-                        type: "object",
-                        ignore: !0
                     }
                 };
-            class py extends Fb {
+            class yy extends Yb {
                 constructor(...t) {
                     super(...t), wo(this, "state", void 0)
                 }
                 getShaders() {
                     return super.getShaders({
-                        vs: "#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n",
-                        fs: "#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
-                        modules: [ty, ny]
+                        vs: '#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  // convert size in meters to pixels, then scaled and clamp\n \n  // project meters to pixels and clamp to limits \n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n\n  // scale icon height to match instanceSize\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n\n  // scale and rotate vertex in "pixel" value and convert back to fraction in clipspace\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n',
+                        fs: "#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n\n  // if colorMode == 0, use pixel color from the texture\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  // Take the global opacity and the alpha from vColor into account for the alpha component\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
+                        modules: [oy, ly]
                     })
                 }
                 initializeState() {
                     this.state = {
-                        iconManager: new hy(this.context.gl, {
+                        iconManager: new my(this.context.gl, {
                             onUpdate: this._onUpdate.bind(this),
                             onError: this._onError.bind(this)
                         })
                     }, this.getAttributeManager().addInstanced({
                         instancePositions: {
                             size: 3,
                             type: 5130,
@@ -23886,15 +24042,15 @@
                         },
                         instanceColors: {
                             size: this.props.colorFormat.length,
                             type: 5121,
                             normalized: !0,
                             transition: !0,
                             accessor: "getColor",
-                            defaultValue: uy
+                            defaultValue: vy
                         },
                         instanceAngles: {
                             size: 1,
                             transition: !0,
                             accessor: "getAngle"
                         },
                         instancePixelOffset: {
@@ -23951,27 +24107,27 @@
                         alphaCutoff: o
                     } = this.props, {
                         iconManager: a
                     } = this.state, l = a.getTexture();
                     l && this.state.model.setUniforms(t).setUniforms({
                         iconsTexture: l,
                         iconsTextureDim: [l.width, l.height],
-                        sizeUnits: Ih[r],
+                        sizeUnits: Mh[r],
                         sizeScale: e,
                         sizeMinPixels: n,
                         sizeMaxPixels: i,
                         billboard: s,
                         alphaCutoff: o
                     }).draw()
                 }
                 _getModel(t) {
-                    return new Yv(t, {
+                    return new ab(t, {
                         ...this.getShaders(),
                         id: this.props.id,
-                        geometry: new ry({
+                        geometry: new hy({
                             drawMode: 6,
                             attributes: {
                                 positions: {
                                     size: 2,
                                     value: new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1])
                                 }
                             }
@@ -23981,15 +24137,15 @@
                 }
                 _onUpdate() {
                     this.setNeedsRedraw()
                 }
                 _onError(t) {
                     var e;
                     const n = null === (e = this.getCurrentLayer()) || void 0 === e ? void 0 : e.props.onIconError;
-                    n ? n(t) : na.error(t.error.message)()
+                    n ? n(t) : ta.error(t.error.message)()
                 }
                 getInstanceOffset(t) {
                     const {
                         width: e,
                         height: n,
                         anchorX: i = e / 2,
                         anchorY: r = n / 2
@@ -24005,17 +24161,17 @@
                         y: n,
                         width: i,
                         height: r
                     } = this.state.iconManager.getIconMapping(t);
                     return [e, n, i, r]
                 }
             }
-            wo(py, "defaultProps", dy), wo(py, "layerName", "IconLayer");
-            const fy = [0, 0, 0, 255],
-                gy = {
+            wo(yy, "defaultProps", by), wo(yy, "layerName", "IconLayer");
+            const _y = [0, 0, 0, 255],
+                xy = {
                     radiusUnits: "meters",
                     radiusScale: {
                         type: "number",
                         min: 0,
                         value: 1
                     },
                     radiusMinPixels: {
@@ -24054,19 +24210,19 @@
                     },
                     getRadius: {
                         type: "accessor",
                         value: 1
                     },
                     getFillColor: {
                         type: "accessor",
-                        value: fy
+                        value: _y
                     },
                     getLineColor: {
                         type: "accessor",
-                        value: fy
+                        value: _y
                     },
                     getLineWidth: {
                         type: "accessor",
                         value: 1
                     },
                     strokeWidth: {
                         deprecatedFor: "getLineWidth"
@@ -24074,20 +24230,20 @@
                     outline: {
                         deprecatedFor: "stroked"
                     },
                     getColor: {
                         deprecatedFor: ["getFillColor", "getLineColor"]
                     }
                 };
-            class my extends Fb {
+            class wy extends Yb {
                 getShaders() {
                     return super.getShaders({
-                        vs: "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",
+                        vs: "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  // Multiply out radius and clamp to limits\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  \n  // Multiply out line width and clamp to limits\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n\n  // Expand geometry to accomodate edge smoothing\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  }\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Apply opacity to instance color, or return instance picking color\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",
                         fs: "#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
-                        modules: [ty, ny]
+                        modules: [oy, ly]
                     })
                 }
                 initializeState() {
                     this.getAttributeManager().addInstanced({
                         instancePositions: {
                             size: 3,
                             type: 5130,
@@ -24152,53 +24308,52 @@
                         lineWidthMaxPixels: d
                     } = this.props;
                     this.state.model.setUniforms(t).setUniforms({
                         stroked: s ? 1 : 0,
                         filled: o,
                         billboard: a,
                         antialiasing: l,
-                        radiusUnits: Ih[e],
+                        radiusUnits: Mh[e],
                         radiusScale: n,
                         radiusMinPixels: i,
                         radiusMaxPixels: r,
-                        lineWidthUnits: Ih[c],
+                        lineWidthUnits: Mh[c],
                         lineWidthScale: h,
                         lineWidthMinPixels: u,
                         lineWidthMaxPixels: d
                     }).draw()
                 }
                 _getModel(t) {
-                    return new Yv(t, {
+                    return new ab(t, {
                         ...this.getShaders(),
                         id: this.props.id,
-                        geometry: new ry({
+                        geometry: new hy({
                             drawMode: 6,
                             vertexCount: 4,
                             attributes: {
                                 positions: {
                                     size: 3,
                                     value: new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0])
                                 }
                             }
                         }),
                         isInstanced: !0
                     })
                 }
             }
-            wo(my, "defaultProps", gy), wo(my, "layerName", "ScatterplotLayer");
-            const vy = .75,
-                by = [];
-            class yy extends py {
+            wo(wy, "defaultProps", xy), wo(wy, "layerName", "ScatterplotLayer");
+            const Ey = [];
+            class Py extends yy {
                 constructor(...t) {
                     super(...t), wo(this, "state", void 0)
                 }
                 getShaders() {
                     return {
                         ...super.getShaders(),
-                        fs: "#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float sdfBuffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n"
+                        fs: "#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float buffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n\n    // if enable sdf (signed distance fields)\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(buffer - gamma, buffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n\n    // Take the global opacity and the alpha from color into account for the alpha component\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n"
                     }
                 }
                 initializeState() {
                     super.initializeState(), this.getAttributeManager().addInstanced({
                         instanceOffsets: {
                             size: 2,
                             accessor: "getIconOffsets"
@@ -24220,206 +24375,142 @@
                         oldProps: n
                     } = t;
                     let {
                         outlineColor: i
                     } = e;
                     i !== n.outlineColor && (i = i.map((t => t / 255)), i[3] = Number.isFinite(i[3]) ? i[3] : 1, this.setState({
                         outlineColor: i
-                    })), !e.sdf && e.outlineWidth && na.warn("".concat(this.id, ": fontSettings.sdf is required to render outline"))()
+                    })), !e.sdf && e.outlineWidth && ta.warn("".concat(this.id, ": fontSettings.sdf is required to render outline"))()
                 }
                 draw(t) {
                     const {
                         sdf: e,
                         smoothing: n,
                         outlineWidth: i
                     } = this.props, {
                         outlineColor: r
-                    } = this.state, s = i ? Math.max(n, vy * (1 - i)) : -1;
-                    if (t.uniforms = {
-                            ...t.uniforms,
-                            sdfBuffer: vy,
-                            outlineBuffer: s,
-                            gamma: n,
-                            sdf: Boolean(e),
-                            outlineColor: r
-                        }, super.draw(t), e && i) {
-                        const {
-                            iconManager: t
-                        } = this.state;
-                        t.getTexture() && this.state.model.draw({
-                            uniforms: {
-                                outlineBuffer: vy
-                            }
-                        })
-                    }
+                    } = this.state;
+                    t.uniforms = {
+                        ...t.uniforms,
+                        buffer: .75,
+                        outlineBuffer: i ? Math.max(n, .75 * (1 - i)) : -1,
+                        gamma: n,
+                        sdf: Boolean(e),
+                        outlineColor: r
+                    }, super.draw(t)
                 }
                 getInstanceOffset(t) {
-                    return t ? Array.from(t).flatMap((t => super.getInstanceOffset(t))) : by
+                    return t ? Array.from(t).flatMap((t => super.getInstanceOffset(t))) : Ey
                 }
                 getInstanceColorMode(t) {
                     return 1
                 }
                 getInstanceIconFrame(t) {
-                    return t ? Array.from(t).flatMap((t => super.getInstanceIconFrame(t))) : by
+                    return t ? Array.from(t).flatMap((t => super.getInstanceIconFrame(t))) : Ey
                 }
             }
-            wo(yy, "defaultProps", {
+            wo(Py, "defaultProps", {
                 getIconOffsets: {
                     type: "accessor",
                     value: t => t.offsets
                 },
                 alphaCutoff: .001,
                 smoothing: .1,
                 outlineWidth: 0,
                 outlineColor: {
                     type: "color",
                     value: [0, 0, 0, 255]
                 }
-            }), wo(yy, "layerName", "MultiIconLayer");
-            const _y = 1e20;
-            class xy {
-                constructor({
-                    fontSize: t = 24,
-                    buffer: e = 3,
-                    radius: n = 8,
-                    cutoff: i = .25,
-                    fontFamily: r = "sans-serif",
-                    fontWeight: s = "normal",
-                    fontStyle: o = "normal"
-                } = {}) {
-                    this.buffer = e, this.cutoff = i, this.radius = n;
-                    const a = this.size = t + 4 * e,
-                        l = this._createCanvas(a),
-                        c = this.ctx = l.getContext("2d", {
-                            willReadFrequently: !0
-                        });
-                    c.font = `${o} ${s} ${t}px ${r}`, c.textBaseline = "alphabetic", c.textAlign = "left", c.fillStyle = "black", this.gridOuter = new Float64Array(a * a), this.gridInner = new Float64Array(a * a), this.f = new Float64Array(a), this.z = new Float64Array(a + 1), this.v = new Uint16Array(a)
-                }
-                _createCanvas(t) {
-                    const e = document.createElement("canvas");
-                    return e.width = e.height = t, e
-                }
-                draw(t) {
-                    const {
-                        width: e,
-                        actualBoundingBoxAscent: n,
-                        actualBoundingBoxDescent: i,
-                        actualBoundingBoxLeft: r,
-                        actualBoundingBoxRight: s
-                    } = this.ctx.measureText(t), o = Math.ceil(n), a = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - r))), l = Math.min(this.size - this.buffer, o + Math.ceil(i)), c = a + 2 * this.buffer, h = l + 2 * this.buffer, u = Math.max(c * h, 0), d = new Uint8ClampedArray(u), p = {
-                        data: d,
-                        width: c,
-                        height: h,
-                        glyphWidth: a,
-                        glyphHeight: l,
-                        glyphTop: o,
-                        glyphLeft: 0,
-                        glyphAdvance: e
-                    };
-                    if (0 === a || 0 === l) return p;
-                    const {
-                        ctx: f,
-                        buffer: g,
-                        gridInner: m,
-                        gridOuter: v
-                    } = this;
-                    f.clearRect(g, g, a, l), f.fillText(t, g, g + o);
-                    const b = f.getImageData(g, g, a, l);
-                    v.fill(_y, 0, u), m.fill(0, 0, u);
-                    for (let t = 0; t < l; t++)
-                        for (let e = 0; e < a; e++) {
-                            const n = b.data[4 * (t * a + e) + 3] / 255;
-                            if (0 === n) continue;
-                            const i = (t + g) * c + e + g;
-                            if (1 === n) v[i] = 0, m[i] = _y;
-                            else {
-                                const t = .5 - n;
-                                v[i] = t > 0 ? t * t : 0, m[i] = t < 0 ? t * t : 0
-                            }
-                        }
-                    wy(v, 0, 0, c, h, c, this.f, this.v, this.z), wy(m, g, g, a, l, c, this.f, this.v, this.z);
-                    for (let t = 0; t < u; t++) {
-                        const e = Math.sqrt(v[t]) - Math.sqrt(m[t]);
-                        d[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff))
-                    }
-                    return p
-                }
-            }
+            }), wo(Py, "layerName", "MultiIconLayer");
+            var Sy = n(9296),
+                Cy = n.n(Sy);
+            const Ty = 32,
+                Ay = [];
 
-            function wy(t, e, n, i, r, s, o, a, l) {
-                for (let c = e; c < e + i; c++) Ey(t, n * s + c, s, r, o, a, l);
-                for (let c = n; c < n + r; c++) Ey(t, c * s + e, 1, i, o, a, l)
-            }
-
-            function Ey(t, e, n, i, r, s, o) {
-                s[0] = 0, o[0] = -_y, o[1] = _y, r[0] = t[e];
-                for (let a = 1, l = 0, c = 0; a < i; a++) {
-                    r[a] = t[e + a * n];
-                    const i = a * a;
-                    do {
-                        const t = s[l];
-                        c = (r[a] - r[t] + i - t * t) / (a - t) / 2
-                    } while (c <= o[l] && --l > -1);
-                    l++, s[l] = a, o[l] = c, o[l + 1] = _y
-                }
-                for (let a = 0, l = 0; a < i; a++) {
-                    for (; o[l + 1] < a;) l++;
-                    const i = s[l],
-                        c = a - i;
-                    t[e + a * n] = r[i] + c * c
-                }
-            }
-            const Py = [];
-
-            function Sy(t, e, n, i) {
+            function My(t, e, n, i) {
                 let r = 0;
                 for (let o = e; o < n; o++) {
                     var s;
-                    r += (null === (s = i[t[o]]) || void 0 === s ? void 0 : s.layoutWidth) || 0
+                    r += (null === (s = i[t[o]]) || void 0 === s ? void 0 : s.width) || 0
                 }
                 return r
             }
 
-            function Cy(t, e, n, i, r, s) {
+            function Oy(t, e, n, i, r, s) {
                 let o = e,
                     a = 0;
                 for (let l = e; l < n; l++) {
-                    const e = Sy(t, l, l + 1, r);
+                    const e = My(t, l, l + 1, r);
                     a + e > i && (o < l && s.push(l), o = l, a = 0), a += e
                 }
                 return a
             }
 
-            function Ty(t, e, n, i, r = 0, s) {
+            function Ly(t, e, n, i, r = 0, s) {
                 void 0 === s && (s = t.length);
                 const o = [];
-                return "break-all" === e ? Cy(t, r, s, n, i, o) : function(t, e, n, i, r, s) {
+                return "break-all" === e ? Oy(t, r, s, n, i, o) : function(t, e, n, i, r, s) {
                     let o = e,
                         a = e,
                         l = e,
                         c = 0;
                     for (let h = e; h < n; h++)
                         if (" " === t[h] ? l = h + 1 : " " !== t[h + 1] && h + 1 !== n || (l = h + 1), l > a) {
-                            let e = Sy(t, a, l, r);
-                            c + e > i && (o < a && (s.push(a), o = a, c = 0), e > i && (e = Cy(t, a, l, i, r, s), o = s[s.length - 1])), a = l, c += e
+                            let e = My(t, a, l, r);
+                            c + e > i && (o < a && (s.push(a), o = a, c = 0), e > i && (e = Oy(t, a, l, i, r, s), o = s[s.length - 1])), a = l, c += e
                         }
                 }(t, r, s, n, i, o), o
             }
 
-            function Ay(t, e, n, i, r, s) {
+            function ky(t, e, n, i, r, s) {
                 let o = 0,
                     a = 0;
                 for (let s = e; s < n; s++) {
                     const e = t[s],
                         n = i[e];
-                    n ? (a || (a = n.layoutHeight), r[s] = o + n.layoutWidth / 2, o += n.layoutWidth) : (na.warn("Missing character: ".concat(e, " (").concat(e.codePointAt(0), ")"))(), r[s] = o, o += 32)
+                    n ? (a || (a = n.height), r[s] = o + n.width / 2, o += n.width) : (ta.warn("Missing character: ".concat(e, " (").concat(e.codePointAt(0), ")"))(), r[s] = o, o += Ty)
                 }
                 s[0] = o, s[1] = a
             }
-            class My {
+
+            function Ry(t, e, n, i, r) {
+                const s = Array.from(t),
+                    o = s.length,
+                    a = new Array(o),
+                    l = new Array(o),
+                    c = new Array(o),
+                    h = ("break-word" === n || "break-all" === n) && isFinite(i) && i > 0,
+                    u = [0, 0],
+                    d = [0, 0];
+                let p = 0,
+                    f = 0,
+                    g = 0;
+                for (let t = 0; t <= o; t++) {
+                    const m = s[t];
+                    if ("\n" !== m && t !== o || (g = t), g > f) {
+                        const t = h ? Ly(s, n, i, r, f, g) : Ay;
+                        for (let n = 0; n <= t.length; n++) {
+                            const i = 0 === n ? f : t[n - 1],
+                                o = n < t.length ? t[n] : g;
+                            ky(s, i, o, r, a, d);
+                            for (let t = i; t < o; t++) l[t] = p + d[1] / 2, c[t] = d[0];
+                            p += d[1] * e, u[0] = Math.max(u[0], d[0])
+                        }
+                        f = g
+                    }
+                    "\n" === m && (a[f] = 0, l[f] = 0, c[f] = 0, f++)
+                }
+                return u[1] = p, {
+                    x: a,
+                    y: l,
+                    rowWidth: c,
+                    size: u
+                }
+            }
+            class Iy {
                 constructor(t = 5) {
                     wo(this, "limit", void 0), wo(this, "_cache", {}), wo(this, "_order", []), this.limit = t
                 }
                 get(t) {
                     const e = this._cache[t];
                     return e && (this._deleteOrder(t), this._appendOrder(t)), e
                 }
@@ -24433,169 +24524,147 @@
                     const e = this._order.indexOf(t);
                     e >= 0 && this._order.splice(e, 1)
                 }
                 _appendOrder(t) {
                     this._order.push(t)
                 }
             }
-            const Oy = {
+            const jy = {
                 fontFamily: "Monaco, monospace",
                 fontWeight: "normal",
                 characterSet: function() {
                     const t = [];
                     for (let e = 32; e < 128; e++) t.push(String.fromCharCode(e));
                     return t
                 }(),
                 fontSize: 64,
                 buffer: 4,
                 sdf: !1,
                 cutoff: .25,
                 radius: 12,
                 smoothing: .1
             };
-            let Ly = new My(3);
+            let Fy = new Iy(3);
 
-            function Ry(t, e) {
+            function zy(t, e) {
                 for (let n = 0; n < t.length; n++) e.data[4 * n + 3] = t[n]
             }
 
-            function Iy(t, e, n, i) {
+            function By(t, e, n, i) {
                 t.font = "".concat(i, " ").concat(n, "px ").concat(e), t.fillStyle = "#000", t.textBaseline = "alphabetic", t.textAlign = "left"
             }
-            class ky {
+            class Dy {
                 constructor() {
                     wo(this, "props", {
-                        ...Oy
+                        ...jy
                     }), wo(this, "_key", void 0), wo(this, "_atlas", void 0)
                 }
                 get texture() {
                     return this._atlas
                 }
                 get mapping() {
                     return this._atlas && this._atlas.mapping
                 }
                 get scale() {
-                    const {
-                        fontSize: t,
-                        buffer: e
-                    } = this.props;
-                    return (1.2 * t + 2 * e) / t
+                    return 1.2
                 }
                 setProps(t = {}) {
-                    Object.assign(this.props, t), this._key = this._getKey();
-                    const e = function(t, e) {
+                    Object.assign(this.props, t);
+                    const e = this._key;
+                    this._key = this._getKey();
+                    const n = function(t, e) {
                             let n;
                             n = "string" == typeof e ? new Set(Array.from(e)) : new Set(e);
-                            const i = Ly.get(t);
+                            const i = Fy.get(t);
                             if (!i) return n;
                             for (const t in i.mapping) n.has(t) && n.delete(t);
                             return n
                         }(this._key, this.props.characterSet),
-                        n = Ly.get(this._key);
-                    if (n && 0 === e.size) return void(this._atlas !== n && (this._atlas = n));
-                    const i = this._generateFontAtlas(e, n);
-                    this._atlas = i, Ly.set(this._key, i)
-                }
-                _generateFontAtlas(t, e) {
-                    const {
-                        fontFamily: n,
-                        fontWeight: i,
-                        fontSize: r,
-                        buffer: s,
-                        sdf: o,
-                        radius: a,
-                        cutoff: l
+                        i = Fy.get(this._key);
+                    if (i && 0 === n.size) return void(this._key !== e && (this._atlas = i));
+                    const r = this._generateFontAtlas(this._key, n, i);
+                    this._atlas = r, Fy.set(this._key, r)
+                }
+                _generateFontAtlas(t, e, n) {
+                    const {
+                        fontFamily: i,
+                        fontWeight: r,
+                        fontSize: s,
+                        buffer: o,
+                        sdf: a,
+                        radius: l,
+                        cutoff: c
                     } = this.props;
-                    let c = e && e.data;
-                    c || (c = document.createElement("canvas"), c.width = 1024);
-                    const h = c.getContext("2d", {
-                        willReadFrequently: !0
-                    });
-                    Iy(h, n, r, i);
-                    const {
-                        mapping: u,
-                        canvasHeight: d,
-                        xOffset: p,
-                        yOffset: f
+                    let h = n && n.data;
+                    h || (h = document.createElement("canvas"), h.width = 1024);
+                    const u = h.getContext("2d");
+                    By(u, i, s, r);
+                    const {
+                        mapping: d,
+                        canvasHeight: p,
+                        xOffset: f,
+                        yOffset: g
                     } = function({
                         characterSet: t,
                         getFontWidth: e,
                         fontHeight: n,
                         buffer: i,
                         maxCanvasWidth: r,
                         mapping: s = {},
                         xOffset: o = 0,
                         yOffset: a = 0
                     }) {
                         let l = 0,
                             c = o;
-                        const h = n + 2 * i;
                         for (const o of t)
                             if (!s[o]) {
                                 const t = e(o);
                                 c + t + 2 * i > r && (c = 0, l++), s[o] = {
                                     x: c + i,
-                                    y: a + l * h + i,
+                                    y: a + l * (n + 2 * i) + i,
                                     width: t,
-                                    height: h,
-                                    layoutWidth: t,
-                                    layoutHeight: n
+                                    height: n
                                 }, c += t + 2 * i
-                            } return {
+                            } const h = n + 2 * i;
+                        return {
                             mapping: s,
                             xOffset: c,
                             yOffset: a + l * h,
                             canvasHeight: (u = a + (l + 1) * h, Math.pow(2, Math.ceil(Math.log2(u))))
                         };
                         var u
                     }({
-                        getFontWidth: t => h.measureText(t).width,
-                        fontHeight: 1.2 * r,
-                        buffer: s,
-                        characterSet: t,
+                        getFontWidth: t => u.measureText(t).width,
+                        fontHeight: 1.2 * s,
+                        buffer: o,
+                        characterSet: e,
                         maxCanvasWidth: 1024,
-                        ...e && {
-                            mapping: e.mapping,
-                            xOffset: e.xOffset,
-                            yOffset: e.yOffset
+                        ...n && {
+                            mapping: n.mapping,
+                            xOffset: n.xOffset,
+                            yOffset: n.yOffset
                         }
                     });
-                    if (c.height !== d) {
-                        const t = h.getImageData(0, 0, c.width, c.height);
-                        c.height = d, h.putImageData(t, 0, 0)
-                    }
-                    if (Iy(h, n, r, i), o) {
-                        const e = new xy({
-                            fontSize: r,
-                            buffer: s,
-                            radius: a,
-                            cutoff: l,
-                            fontFamily: n,
-                            fontWeight: "".concat(i)
-                        });
-                        for (const n of t) {
-                            const {
-                                data: t,
-                                width: i,
-                                height: s,
-                                glyphTop: o
-                            } = e.draw(n);
-                            u[n].width = i, u[n].layoutOffsetY = .9 * r - o;
-                            const a = h.createImageData(i, s);
-                            Ry(t, a), h.putImageData(a, u[n].x, u[n].y)
-                        }
+                    if (h.height !== p) {
+                        const t = u.getImageData(0, 0, h.width, h.height);
+                        h.height = p, u.putImageData(t, 0, 0)
+                    }
+                    if (By(u, i, s, r), a) {
+                        const t = new(Cy())(s, o, l, c, i, r),
+                            n = u.getImageData(0, 0, t.size, t.size);
+                        for (const i of e) zy(t.draw(i), n), u.putImageData(n, d[i].x - o, d[i].y + o)
                     } else
-                        for (const e of t) h.fillText(e, u[e].x, u[e].y + s + .9 * r);
+                        for (const t of e) u.fillText(t, d[t].x, d[t].y + .9 * s);
                     return {
-                        xOffset: p,
-                        yOffset: f,
-                        mapping: u,
-                        data: c,
-                        width: c.width,
-                        height: c.height
+                        xOffset: f,
+                        yOffset: g,
+                        mapping: d,
+                        data: h,
+                        width: h.width,
+                        height: h.height
                     }
                 }
                 _getKey() {
                     const {
                         fontFamily: t,
                         fontWeight: e,
                         fontSize: n,
@@ -24603,15 +24672,15 @@
                         sdf: r,
                         radius: s,
                         cutoff: o
                     } = this.props;
                     return r ? "".concat(t, " ").concat(e, " ").concat(n, " ").concat(i, " ").concat(s, " ").concat(o) : "".concat(t, " ").concat(e, " ").concat(n, " ").concat(i)
                 }
             }
-            const jy = {
+            const Ny = {
                 billboard: !0,
                 sizeScale: 1,
                 sizeUnits: "pixels",
                 sizeMinPixels: 0,
                 sizeMaxPixels: Number.MAX_SAFE_INTEGER,
                 padding: {
                     type: "array",
@@ -24646,23 +24715,23 @@
                     value: [0, 0, 0, 255]
                 },
                 getLineWidth: {
                     type: "accessor",
                     value: 1
                 }
             };
-            class Fy extends Fb {
+            class Vy extends Yb {
                 constructor(...t) {
                     super(...t), wo(this, "state", void 0)
                 }
                 getShaders() {
                     return super.getShaders({
-                        vs: "#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",
+                        vs: "#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n\n  // convert size in meters to pixels, then scaled and clamp\n\n  // project meters to pixels and clamp to limits\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Apply opacity to instance color, or return instance picking color\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",
                         fs: "#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
-                        modules: [ty, ny]
+                        modules: [oy, ly]
                     })
                 }
                 initializeState() {
                     this.getAttributeManager().addInstanced({
                         instancePositions: {
                             size: 3,
                             type: 5130,
@@ -24741,94 +24810,90 @@
                     let {
                         padding: a
                     } = this.props;
                     a.length < 4 && (a = [a[0], a[1], a[0], a[1]]), this.state.model.setUniforms(t).setUniforms({
                         billboard: e,
                         stroked: Boolean(o),
                         padding: a,
-                        sizeUnits: Ih[i],
+                        sizeUnits: Mh[i],
                         sizeScale: n,
                         sizeMinPixels: r,
                         sizeMaxPixels: s
                     }).draw()
                 }
                 _getModel(t) {
-                    return new Yv(t, {
+                    return new ab(t, {
                         ...this.getShaders(),
                         id: this.props.id,
-                        geometry: new ry({
+                        geometry: new hy({
                             drawMode: 6,
                             vertexCount: 4,
                             attributes: {
                                 positions: {
                                     size: 2,
                                     value: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])
                                 }
                             }
                         }),
                         isInstanced: !0
                     })
                 }
             }
-            wo(Fy, "defaultProps", jy), wo(Fy, "layerName", "TextBackgroundLayer");
-            const zy = {
+            wo(Vy, "defaultProps", Ny), wo(Vy, "layerName", "TextBackgroundLayer");
+            const Uy = {
                     start: 1,
                     middle: 0,
                     end: -1
                 },
-                By = {
+                Gy = {
                     top: 1,
                     center: 0,
                     bottom: -1
                 },
-                Dy = [0, 0, 0, 255],
-                Ny = {
+                Wy = [0, 0, 0, 255],
+                Hy = {
                     billboard: !0,
                     sizeScale: 1,
                     sizeUnits: "pixels",
                     sizeMinPixels: 0,
                     sizeMaxPixels: Number.MAX_SAFE_INTEGER,
                     background: !1,
                     getBackgroundColor: {
                         type: "accessor",
                         value: [255, 255, 255, 255]
                     },
                     getBorderColor: {
                         type: "accessor",
-                        value: Dy
+                        value: Wy
                     },
                     getBorderWidth: {
                         type: "accessor",
                         value: 0
                     },
                     backgroundPadding: {
                         type: "array",
                         value: [0, 0, 0, 0]
                     },
                     characterSet: {
                         type: "object",
-                        value: Oy.characterSet
+                        value: jy.characterSet
                     },
-                    fontFamily: Oy.fontFamily,
-                    fontWeight: Oy.fontWeight,
+                    fontFamily: jy.fontFamily,
+                    fontWeight: jy.fontWeight,
                     lineHeight: 1,
                     outlineWidth: {
                         type: "number",
                         value: 0,
                         min: 0
                     },
                     outlineColor: {
                         type: "color",
-                        value: Dy
-                    },
-                    fontSettings: {
-                        type: "object",
-                        value: {},
-                        compare: 1
+                        value: Wy
                     },
+                    fontSettings: {},
                     wordBreak: "break-word",
                     maxWidth: {
                         type: "number",
                         value: -1
                     },
                     getText: {
                         type: "accessor",
@@ -24836,15 +24901,15 @@
                     },
                     getPosition: {
                         type: "accessor",
                         value: t => t.position
                     },
                     getColor: {
                         type: "accessor",
-                        value: Dy
+                        value: Wy
                     },
                     getSize: {
                         type: "accessor",
                         value: 32
                     },
                     getAngle: {
                         type: "accessor",
@@ -24862,52 +24927,65 @@
                         type: "accessor",
                         value: [0, 0]
                     },
                     backgroundColor: {
                         deprecatedFor: ["background", "getBackgroundColor"]
                     }
                 };
-            class Vy extends Jb {
+            class Zy extends ry {
                 constructor(...t) {
                     super(...t), wo(this, "state", void 0), wo(this, "getBoundingRect", ((t, e) => {
-                        let {
-                            size: [n, i]
-                        } = this.transformParagraph(t, e);
-                        const {
-                            fontSize: r
-                        } = this.state.fontAtlasManager.props;
-                        n /= r, i /= r;
-                        const {
-                            getTextAnchor: s,
-                            getAlignmentBaseline: o
-                        } = this.props;
-                        return [(zy["function" == typeof s ? s(t, e) : s] - 1) * n / 2, (By["function" == typeof o ? o(t, e) : o] - 1) * i / 2, n, i]
+                        const n = this.state.fontAtlasManager.mapping,
+                            i = this.state.getText,
+                            {
+                                wordBreak: r,
+                                maxWidth: s,
+                                lineHeight: o,
+                                getTextAnchor: a,
+                                getAlignmentBaseline: l
+                            } = this.props,
+                            c = i(t, e) || "",
+                            {
+                                size: [h, u]
+                            } = Ry(c, o, r, s, n);
+                        return [(Uy["function" == typeof a ? a(t, e) : a] - 1) * h / 2, (Gy["function" == typeof l ? l(t, e) : l] - 1) * u / 2, h, u]
                     })), wo(this, "getIconOffsets", ((t, e) => {
-                        const {
-                            getTextAnchor: n,
-                            getAlignmentBaseline: i
-                        } = this.props, {
-                            x: r,
-                            y: s,
-                            rowWidth: o,
-                            size: [a, l]
-                        } = this.transformParagraph(t, e), c = zy["function" == typeof n ? n(t, e) : n], h = By["function" == typeof i ? i(t, e) : i], u = r.length, d = new Array(2 * u);
-                        let p = 0;
-                        for (let t = 0; t < u; t++) {
-                            const e = (1 - c) * (a - o[t]) / 2;
-                            d[p++] = (c - 1) * a / 2 + e + r[t], d[p++] = (h - 1) * l / 2 + s[t]
+                        const n = this.state.fontAtlasManager.mapping,
+                            i = this.state.getText,
+                            {
+                                wordBreak: r,
+                                maxWidth: s,
+                                lineHeight: o,
+                                getTextAnchor: a,
+                                getAlignmentBaseline: l
+                            } = this.props,
+                            c = i(t, e) || "",
+                            {
+                                x: h,
+                                y: u,
+                                rowWidth: d,
+                                size: [p, f]
+                            } = Ry(c, o, r, s, n),
+                            g = Uy["function" == typeof a ? a(t, e) : a],
+                            m = Gy["function" == typeof l ? l(t, e) : l],
+                            v = h.length,
+                            b = new Array(2 * v);
+                        let y = 0;
+                        for (let t = 0; t < v; t++) {
+                            const e = (1 - g) * (p - d[t]) / 2;
+                            b[y++] = (g - 1) * p / 2 + e + h[t], b[y++] = (m - 1) * f / 2 + u[t]
                         }
-                        return d
+                        return b
                     }))
                 }
                 initializeState() {
                     this.state = {
                         styleVersion: 0,
-                        fontAtlasManager: new ky
-                    }, this.props.maxWidth > 0 && na.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")()
+                        fontAtlasManager: new Dy
+                    }
                 }
                 updateState(t) {
                     const {
                         props: e,
                         oldProps: n,
                         changeFlags: i
                     } = t;
@@ -24996,76 +25074,29 @@
                         r = n, s = (e, {
                             index: n
                         }) => t[n]
                     } else {
                         const {
                             iterable: t,
                             objectInfo: n
-                        } = av(e);
+                        } = yv(e);
                         o = [0], r = 0;
                         for (const e of t) {
                             n.index++;
                             const t = Array.from(s(e, n) || "");
                             a && t.forEach(a.add, a), r += t.length, o.push(r)
                         }
                     }
                     this.setState({
                         getText: s,
                         startIndices: o,
                         numInstances: r,
                         characterSet: a || n
                     })
                 }
-                transformParagraph(t, e) {
-                    const {
-                        fontAtlasManager: n
-                    } = this.state, i = n.mapping, r = this.state.getText, {
-                        wordBreak: s,
-                        lineHeight: o,
-                        maxWidth: a
-                    } = this.props;
-                    return function(t, e, n, i, r) {
-                        const s = Array.from(t),
-                            o = s.length,
-                            a = new Array(o),
-                            l = new Array(o),
-                            c = new Array(o),
-                            h = ("break-word" === n || "break-all" === n) && isFinite(i) && i > 0,
-                            u = [0, 0],
-                            d = [0, 0];
-                        let p = 0,
-                            f = 0,
-                            g = 0;
-                        for (let t = 0; t <= o; t++) {
-                            const v = s[t];
-                            if ("\n" !== v && t !== o || (g = t), g > f) {
-                                const t = h ? Ty(s, n, i, r, f, g) : Py;
-                                for (let n = 0; n <= t.length; n++) {
-                                    const i = 0 === n ? f : t[n - 1],
-                                        o = n < t.length ? t[n] : g;
-                                    Ay(s, i, o, r, a, d);
-                                    for (let t = i; t < o; t++) {
-                                        var m;
-                                        const e = (null === (m = r[s[t]]) || void 0 === m ? void 0 : m.layoutOffsetY) || 0;
-                                        l[t] = p + d[1] / 2 + e, c[t] = d[0]
-                                    }
-                                    p += d[1] * e, u[0] = Math.max(u[0], d[0])
-                                }
-                                f = g
-                            }
-                            "\n" === v && (a[f] = 0, l[f] = 0, c[f] = 0, f++)
-                        }
-                        return u[1] = p, {
-                            x: a,
-                            y: l,
-                            rowWidth: c,
-                            size: u
-                        }
-                    }(r(t, e) || "", o, s, a * n.props.fontSize, i)
-                }
                 renderLayers() {
                     const {
                         startIndices: t,
                         numInstances: e,
                         getText: n,
                         fontAtlasManager: {
                             scale: i,
@@ -25092,26 +25123,26 @@
                         outlineColor: w,
                         sizeScale: E,
                         sizeUnits: P,
                         sizeMinPixels: S,
                         sizeMaxPixels: C,
                         transitions: T,
                         updateTriggers: A
-                    } = this.props, M = this.getSubLayerClass("characters", yy), O = this.getSubLayerClass("background", Fy);
+                    } = this.props, M = this.getSubLayerClass("characters", Py), O = this.getSubLayerClass("background", Vy);
                     return [b && new O({
                         getFillColor: f,
                         getLineColor: g,
                         getLineWidth: m,
                         padding: v,
                         getPosition: c,
                         getSize: u,
                         getAngle: d,
                         getPixelOffset: p,
                         billboard: y,
-                        sizeScale: E,
+                        sizeScale: E / this.state.fontAtlasManager.props.fontSize,
                         sizeUnits: P,
                         sizeMinPixels: S,
                         sizeMaxPixels: C,
                         transitions: T && {
                             getPosition: T.getPosition,
                             getAngle: T.getAngle,
                             getSize: T.getSize,
@@ -25143,16 +25174,16 @@
                             attributes: a.attributes.background
                         } : a,
                         _dataDiff: l,
                         autoHighlight: !1,
                         getBoundingRect: this.getBoundingRect
                     }), new M({
                         sdf: _.sdf,
-                        smoothing: Number.isFinite(_.smoothing) ? _.smoothing : Oy.smoothing,
-                        outlineWidth: x / (_.radius || Oy.radius),
+                        smoothing: Number.isFinite(_.smoothing) ? _.smoothing : jy.smoothing,
+                        outlineWidth: x,
                         outlineColor: w,
                         iconAtlas: r,
                         iconMapping: s,
                         getPosition: c,
                         getColor: h,
                         getSize: u,
                         getAngle: d,
@@ -25168,21 +25199,22 @@
                             getColor: T.getColor,
                             getSize: T.getSize,
                             getPixelOffset: T.getPixelOffset
                         }
                     }, this.getSubLayerProps({
                         id: "characters",
                         updateTriggers: {
-                            all: A.getText,
+                            getIcon: A.getText,
                             getPosition: A.getPosition,
                             getAngle: A.getAngle,
                             getColor: A.getColor,
                             getSize: A.getSize,
                             getPixelOffset: A.getPixelOffset,
                             getIconOffsets: {
+                                getText: A.getText,
                                 getTextAnchor: A.getTextAnchor,
                                 getAlignmentBaseline: A.getAlignmentBaseline,
                                 styleVersion: o
                             }
                         }
                     }), {
                         data: a,
@@ -25191,54 +25223,54 @@
                         numInstances: e,
                         getIconOffsets: this.getIconOffsets,
                         getIcon: n
                     })]
                 }
                 static set fontAtlasCacheLimit(t) {
                     ! function(t) {
-                        na.assert(Number.isFinite(t) && t >= 3, "Invalid cache limit"), Ly = new My(t)
+                        ta.assert(Number.isFinite(t) && t >= 3, "Invalid cache limit"), Fy = new Iy(t)
                     }(t)
                 }
             }
-            wo(Vy, "defaultProps", Ny), wo(Vy, "layerName", "TextLayer");
-            class Uy {
+            wo(Zy, "defaultProps", Hy), wo(Zy, "layerName", "TextLayer");
+            class qy {
                 constructor(t) {
                     wo(this, "opts", void 0), wo(this, "typedArrayManager", void 0), wo(this, "indexStarts", [0]), wo(this, "vertexStarts", [0]), wo(this, "vertexCount", 0), wo(this, "instanceCount", 0), wo(this, "attributes", void 0), wo(this, "_attributeDefs", void 0), wo(this, "data", void 0), wo(this, "getGeometry", void 0), wo(this, "geometryBuffer", void 0), wo(this, "buffers", void 0), wo(this, "positionSize", void 0), wo(this, "normalize", void 0);
                     const {
                         attributes: e = {}
                     } = t;
-                    this.typedArrayManager = sc, this.attributes = {}, this._attributeDefs = e, this.opts = t, this.updateGeometry(t)
+                    this.typedArrayManager = nc, this.attributes = {}, this._attributeDefs = e, this.opts = t, this.updateGeometry(t)
                 }
                 updateGeometry(t) {
                     Object.assign(this.opts, t);
                     const {
                         data: e,
                         buffers: n = {},
                         getGeometry: i,
                         geometryBuffer: r,
                         positionFormat: s,
                         dataChanged: o,
                         normalize: a = !0
                     } = this.opts;
-                    if (this.data = e, this.getGeometry = i, this.positionSize = r && r.size || ("XY" === s ? 2 : 3), this.buffers = n, this.normalize = a, r && (Of(e.startIndices), this.getGeometry = this.getGeometryFromBuffer(r), a || (n.positions = r)), this.geometryBuffer = n.positions, Array.isArray(o))
+                    if (this.data = e, this.getGeometry = i, this.positionSize = r && r.size || ("XY" === s ? 2 : 3), this.buffers = n, this.normalize = a, r && (Mf(e.startIndices), this.getGeometry = this.getGeometryFromBuffer(r), a || (n.positions = r)), this.geometryBuffer = n.positions, Array.isArray(o))
                         for (const t of o) this._rebuildGeometry(t);
                     else this._rebuildGeometry()
                 }
                 updatePartialGeometry({
                     startRow: t,
                     endRow: e
                 }) {
                     this._rebuildGeometry({
                         startRow: t,
                         endRow: e
                     })
                 }
                 getGeometryFromBuffer(t) {
                     const e = t.value || t;
-                    return ArrayBuffer.isView(e) ? cv(e, {
+                    return ArrayBuffer.isView(e) ? xv(e, {
                         size: this.positionSize,
                         offset: t.offset,
                         stride: t.stride,
                         startIndices: this.data.startIndices
                     }) : null
                 }
                 _allocate(t, e) {
@@ -25258,15 +25290,15 @@
                 _forEachGeometry(t, e, n) {
                     const {
                         data: i,
                         getGeometry: r
                     } = this, {
                         iterable: s,
                         objectInfo: o
-                    } = av(i, e, n);
+                    } = yv(i, e, n);
                     for (const e of s) o.index++, t(r ? r(e, o) : null, o.index)
                 }
                 _rebuildGeometry(t) {
                     if (!this.data) return;
                     let {
                         indexStarts: e,
                         vertexStarts: n,
@@ -25280,15 +25312,15 @@
                         endRow: a = 1 / 0
                     } = t || {}, l = {};
                     if (t || (e = [0], n = [0]), this.normalize || !s) this._forEachGeometry(((t, e) => {
                         const i = t && this.normalizeGeometry(t);
                         l[e] = i, n[e + 1] = n[e] + (i ? this.getGeometrySize(i) : 0)
                     }), o, a), i = n[n.length - 1];
                     else if (n = r.startIndices, i = n[r.length] || 0, ArrayBuffer.isView(s)) i = i || s.length / this.positionSize;
-                    else if (s instanceof Wd) {
+                    else if (s instanceof Gd) {
                         const t = s.accessor.stride || 4 * this.positionSize;
                         i = i || s.byteLength / t
                     } else if (s.buffer) {
                         const t = s.stride || 4 * this.positionSize;
                         i = i || s.buffer.byteLength / t
                     } else if (s.value) {
                         const t = s.value,
@@ -25302,15 +25334,15 @@
                         c.vertexStart = n[r], c.indexStart = e[r];
                         const o = r < n.length - 1 ? n[r + 1] : i;
                         c.geometrySize = o - n[r], c.geometryIndex = r, this.updateGeometryAttributes(s, c)
                     }), o, a), this.vertexCount = e[e.length - 1]
                 }
             }
 
-            function Gy(t, e, n = {}) {
+            function Xy(t, e, n = {}) {
                 const i = function(t, e = {}) {
                     return Math.sign(function(t, e = {}) {
                         const {
                             start: n = 0,
                             end: i = t.length
                         } = e, r = e.size || 2;
                         let s = 0;
@@ -25331,92 +25363,92 @@
                             const n = t[i + e];
                             t[i + e] = t[o + e], t[o + e] = n
                         }
                     }
                 }(t, n), !0)
             }
 
-            function Wy(t, e, n, i, r = []) {
+            function Yy(t, e, n, i, r = []) {
                 let s, o;
                 if (8 & n) s = (i[3] - t[1]) / (e[1] - t[1]), o = 3;
                 else if (4 & n) s = (i[1] - t[1]) / (e[1] - t[1]), o = 1;
                 else if (2 & n) s = (i[2] - t[0]) / (e[0] - t[0]), o = 2;
                 else {
                     if (!(1 & n)) return null;
                     s = (i[0] - t[0]) / (e[0] - t[0]), o = 0
                 }
                 for (let n = 0; n < t.length; n++) r[n] = (1 & o) === n ? i[o] : s * (e[n] - t[n]) + t[n];
                 return r
             }
 
-            function Hy(t, e) {
+            function Ky(t, e) {
                 let n = 0;
                 return t[0] < e[0] ? n |= 1 : t[0] > e[2] && (n |= 2), t[1] < e[1] ? n |= 4 : t[1] > e[3] && (n |= 8), n
             }
 
-            function Zy(t, e) {
+            function Qy(t, e) {
                 const n = e.length,
                     i = t.length;
                 if (i > 0) {
                     let r = !0;
                     for (let s = 0; s < n; s++)
                         if (t[i - n + s] !== e[s]) {
                             r = !1;
                             break
                         } if (r) return !1
                 }
                 for (let r = 0; r < n; r++) t[i + r] = e[r];
                 return !0
             }
 
-            function qy(t, e) {
+            function Jy(t, e) {
                 const n = e.length;
                 for (let i = 0; i < n; i++) t[i] = e[i]
             }
 
-            function Xy(t, e, n, i, r = []) {
+            function $y(t, e, n, i, r = []) {
                 const s = i + e * n;
                 for (let e = 0; e < n; e++) r[e] = t[s + e];
                 return r
             }
 
-            function Yy(t, e) {
+            function t_(t, e) {
                 const {
                     size: n = 2,
                     broken: i = !1,
                     gridResolution: r = 10,
                     gridOffset: s = [0, 0],
                     startIndex: o = 0,
                     endIndex: a = t.length
                 } = e || {}, l = (a - o) / n;
                 let c = [];
                 const h = [c],
-                    u = Xy(t, 0, n, o);
+                    u = $y(t, 0, n, o);
                 let d, p;
-                const f = t_(u, r, s, []),
+                const f = s_(u, r, s, []),
                     g = [];
-                Zy(c, u);
+                Qy(c, u);
                 for (let e = 1; e < l; e++) {
-                    for (d = Xy(t, e, n, o, d), p = Hy(d, f); p;) {
-                        Wy(u, d, p, f, g);
-                        const t = Hy(g, f);
-                        t && (Wy(u, g, t, f, g), p = t), Zy(c, g), qy(u, g), e_(f, r, p), i && c.length > n && (c = [], h.push(c), Zy(c, u)), p = Hy(d, f)
+                    for (d = $y(t, e, n, o, d), p = Ky(d, f); p;) {
+                        Yy(u, d, p, f, g);
+                        const t = Ky(g, f);
+                        t && (Yy(u, g, t, f, g), p = t), Qy(c, g), Jy(u, g), o_(f, r, p), i && c.length > n && (c = [], h.push(c), Qy(c, u)), p = Ky(d, f)
                     }
-                    Zy(c, d), qy(u, d)
+                    Qy(c, d), Jy(u, d)
                 }
                 return i ? h : h[0]
             }
-            const Ky = 0;
+            const e_ = 0;
 
-            function Qy(t, e) {
+            function n_(t, e) {
                 for (let n = 0; n < e.length; n++) t.push(e[n]);
                 return t
             }
 
-            function Jy(t, e = null, n) {
+            function i_(t, e = null, n) {
                 if (!t.length) return [];
                 const {
                     size: i = 2,
                     gridResolution: r = 10,
                     gridOffset: s = [0, 0],
                     edgeTypes: o = !1
                 } = n || {}, a = [], l = [{
@@ -25430,123 +25462,123 @@
                 let h = [];
                 for (; l.length;) {
                     const {
                         pos: t,
                         types: e,
                         holes: n
                     } = l.shift();
-                    n_(t, i, n[0] || t.length, c), h = t_(c[0], r, s, h);
-                    const u = Hy(c[1], h);
+                    a_(t, i, n[0] || t.length, c), h = s_(c[0], r, s, h);
+                    const u = Ky(c[1], h);
                     if (u) {
-                        let r = $y(t, e, i, 0, n[0] || t.length, h, u);
+                        let r = r_(t, e, i, 0, n[0] || t.length, h, u);
                         const s = {
                                 pos: r[0].pos,
                                 types: r[0].types,
                                 holes: []
                             },
                             a = {
                                 pos: r[1].pos,
                                 types: r[1].types,
                                 holes: []
                             };
                         l.push(s, a);
-                        for (let l = 0; l < n.length; l++) r = $y(t, e, i, n[l], n[l + 1] || t.length, h, u), r[0] && (s.holes.push(s.pos.length), s.pos = Qy(s.pos, r[0].pos), o && (s.types = Qy(s.types, r[0].types))), r[1] && (a.holes.push(a.pos.length), a.pos = Qy(a.pos, r[1].pos), o && (a.types = Qy(a.types, r[1].types)))
+                        for (let l = 0; l < n.length; l++) r = r_(t, e, i, n[l], n[l + 1] || t.length, h, u), r[0] && (s.holes.push(s.pos.length), s.pos = n_(s.pos, r[0].pos), o && (s.types = n_(s.types, r[0].types))), r[1] && (a.holes.push(a.pos.length), a.pos = n_(a.pos, r[1].pos), o && (a.types = n_(a.types, r[1].types)))
                     } else {
                         const i = {
                             positions: t
                         };
                         o && (i.edgeTypes = e), n.length && (i.holeIndices = n), a.push(i)
                     }
                 }
                 return a
             }
 
-            function $y(t, e, n, i, r, s, o) {
+            function r_(t, e, n, i, r, s, o) {
                 const a = (r - i) / n,
                     l = [],
                     c = [],
                     h = [],
                     u = [],
                     d = [];
                 let p, f, g;
-                const m = Xy(t, a - 1, n, i);
+                const m = $y(t, a - 1, n, i);
                 let v = Math.sign(8 & o ? m[1] - s[3] : m[0] - s[2]),
                     b = e && e[a - 1],
                     y = 0,
                     _ = 0;
-                for (let r = 0; r < a; r++) p = Xy(t, r, n, i, p), f = Math.sign(8 & o ? p[1] - s[3] : p[0] - s[2]), g = e && e[i / n + r], f && v && v !== f && (Wy(m, p, o, s, d), Zy(l, d) && h.push(b), Zy(c, d) && u.push(b)), f <= 0 ? (Zy(l, p) && h.push(g), y -= f) : h.length && (h[h.length - 1] = Ky), f >= 0 ? (Zy(c, p) && u.push(g), _ += f) : u.length && (u[u.length - 1] = Ky), qy(m, p), v = f, b = g;
+                for (let r = 0; r < a; r++) p = $y(t, r, n, i, p), f = Math.sign(8 & o ? p[1] - s[3] : p[0] - s[2]), g = e && e[i / n + r], f && v && v !== f && (Yy(m, p, o, s, d), Qy(l, d) && h.push(b), Qy(c, d) && u.push(b)), f <= 0 ? (Qy(l, p) && h.push(g), y -= f) : h.length && (h[h.length - 1] = e_), f >= 0 ? (Qy(c, p) && u.push(g), _ += f) : u.length && (u[u.length - 1] = e_), Jy(m, p), v = f, b = g;
                 return [y ? {
                     pos: l,
                     types: e && h
                 } : null, _ ? {
                     pos: c,
                     types: e && u
                 } : null]
             }
 
-            function t_(t, e, n, i) {
+            function s_(t, e, n, i) {
                 const r = Math.floor((t[0] - n[0]) / e) * e + n[0],
                     s = Math.floor((t[1] - n[1]) / e) * e + n[1];
                 return i[0] = r, i[1] = s, i[2] = r + e, i[3] = s + e, i
             }
 
-            function e_(t, e, n) {
+            function o_(t, e, n) {
                 8 & n ? (t[1] += e, t[3] += e) : 4 & n ? (t[1] -= e, t[3] -= e) : 2 & n ? (t[0] += e, t[2] += e) : 1 & n && (t[0] -= e, t[2] -= e)
             }
 
-            function n_(t, e, n, i) {
+            function a_(t, e, n, i) {
                 let r = 1 / 0,
                     s = -1 / 0,
                     o = 1 / 0,
                     a = -1 / 0;
                 for (let i = 0; i < n; i += e) {
                     const e = t[i],
                         n = t[i + 1];
                     r = e < r ? e : r, s = e > s ? e : s, o = n < o ? n : o, a = n > a ? n : a
                 }
                 return i[0][0] = r, i[0][1] = o, i[1][0] = s, i[1][1] = a, i
             }
 
-            function i_(t, e, n, i) {
+            function l_(t, e, n, i) {
                 let r = -1,
                     s = -1;
                 for (let o = n + 1; o < i; o += e) {
                     const e = Math.abs(t[o]);
                     e > r && (r = e, s = o - 1)
                 }
                 return s
             }
 
-            function r_(t, e, n, i, r = 85.051129) {
+            function c_(t, e, n, i, r = 85.051129) {
                 const s = t[n],
                     o = t[i - e];
                 if (Math.abs(s - o) > 180) {
-                    const i = Xy(t, 0, e, n);
-                    i[0] += 360 * Math.round((o - s) / 360), Zy(t, i), i[1] = Math.sign(i[1]) * r, Zy(t, i), i[0] = s, Zy(t, i)
+                    const i = $y(t, 0, e, n);
+                    i[0] += 360 * Math.round((o - s) / 360), Qy(t, i), i[1] = Math.sign(i[1]) * r, Qy(t, i), i[0] = s, Qy(t, i)
                 }
             }
 
-            function s_(t, e, n, i) {
+            function h_(t, e, n, i) {
                 let r, s = t[0];
                 for (let o = n; o < i; o += e) {
                     r = t[o];
                     const e = r - s;
                     (e > 180 || e < -180) && (r -= 360 * Math.round(e / 360)), t[o] = s = r
                 }
             }
 
-            function o_(t, e) {
+            function u_(t, e) {
                 let n;
                 const i = t.length / e;
                 for (let r = 0; r < i && (n = t[r * e], (n + 180) % 360 == 0); r++);
                 const r = 360 * -Math.round(n / 360);
                 if (0 !== r)
                     for (let n = 0; n < i; n++) t[n * e] += r
             }
-            class a_ extends Uy {
+            class d_ extends qy {
                 constructor(t) {
                     super({
                         ...t,
                         attributes: {
                             positions: {
                                 size: 3,
                                 padding: 18,
@@ -25571,51 +25603,51 @@
                         let r;
                         if (Array.isArray(t[0])) {
                             const n = t.length * e;
                             r = new Array(n);
                             for (let n = 0; n < t.length; n++)
                                 for (let i = 0; i < e; i++) r[n * e + i] = t[n][i] || 0
                         } else r = t;
-                        return n ? Yy(r, {
+                        return n ? t_(r, {
                             size: e,
                             gridResolution: n
                         }) : i ? function(t, e) {
                             const {
                                 size: n = 2,
                                 startIndex: i = 0,
                                 endIndex: r = t.length,
                                 normalize: s = !0
                             } = e || {}, o = t.slice(i, r);
-                            s_(o, n, 0, r - i);
-                            const a = Yy(o, {
+                            h_(o, n, 0, r - i);
+                            const a = t_(o, {
                                 size: n,
                                 broken: !0,
                                 gridResolution: 360,
                                 gridOffset: [-180, -180]
                             });
                             if (s)
-                                for (const t of a) o_(t, n);
+                                for (const t of a) u_(t, n);
                             return a
                         }(r, {
                             size: e
                         }) : r
                     }(t, this.positionSize, this.opts.resolution, this.opts.wrapLongitude) : t
                 }
                 getGeometrySize(t) {
-                    if (l_(t)) {
+                    if (p_(t)) {
                         let e = 0;
                         for (const n of t) e += this.getGeometrySize(n);
                         return e
                     }
                     const e = this.getPathLength(t);
                     return e < 2 ? 0 : this.isClosed(t) ? e < 3 ? 0 : e + 2 : e
                 }
                 updateGeometryAttributes(t, e) {
                     if (0 !== e.geometrySize)
-                        if (t && l_(t))
+                        if (t && p_(t))
                             for (const n of t) {
                                 const t = this.getGeometrySize(n);
                                 e.geometrySize = t, this.updateGeometryAttributes(n, e), e.vertexStart += t
                             } else this._updateSegmentTypes(t, e), this._updatePositions(t, e)
                 }
                 _updateSegmentTypes(t, e) {
                     const n = this.attributes.segmentTypes,
@@ -25653,19 +25685,19 @@
                     const {
                         positionSize: e
                     } = this, n = t.length - e;
                     return t[0] === t[n] && t[1] === t[n + 1] && (2 === e || t[2] === t[n + 2])
                 }
             }
 
-            function l_(t) {
+            function p_(t) {
                 return Array.isArray(t[0])
             }
-            const c_ = [0, 0, 0, 255],
-                h_ = {
+            const f_ = [0, 0, 0, 255],
+                g_ = {
                     widthUnits: "meters",
                     widthScale: {
                         type: "number",
                         min: 0,
                         value: 1
                     },
                     widthMinPixels: {
@@ -25689,49 +25721,49 @@
                     _pathType: null,
                     getPath: {
                         type: "accessor",
                         value: t => t.path
                     },
                     getColor: {
                         type: "accessor",
-                        value: c_
+                        value: f_
                     },
                     getWidth: {
                         type: "accessor",
                         value: 1
                     },
                     rounded: {
                         deprecatedFor: ["jointRounded", "capRounded"]
                     }
                 },
-                u_ = {
+                m_ = {
                     enter: (t, e) => e.length ? e.subarray(e.length - t.length) : t
                 };
-            class d_ extends Fb {
+            class v_ extends Yb {
                 constructor(...t) {
                     super(...t), wo(this, "state", void 0)
                 }
                 getShaders() {
                     return super.getShaders({
-                        vs: "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",
-                        fs: "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
-                        modules: [ty, ny]
+                        vs: "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\n// calculate line join positions\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  // side of the segment - -1: left, 0: center, 1: right\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // direction of the segment\n  vec2 dir = isEnd ? dirA : dirB;\n  // direction of the extrusion\n  vec2 perp = isEnd ? perpA : perpB;\n  // length of the segment\n  float L = isEnd ? lenA : lenB;\n\n  // A = angle of the corner\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  // -1: right, 1: left\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  // trim if inside corner extends further than the line segment\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n\n  // special treatment for start cap and end cap\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n\n  // extend out a triangle to envelope the round cap\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n\n  // Generate variables for fragment shader\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\n\n// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    // Extrude in clipspace\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    // Extrude in commonspace\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",
+                        fs: "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n/*\n * vPathPosition represents the relative coordinates of the current fragment on the path segment.\n * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.\n * vPathPosition.y - position along the length of the path, between [0, L / width].\n */\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    // if joint is rounded, test distance from the corner\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    // trim miter\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
+                        modules: [oy, ly]
                     })
                 }
                 get wrapLongitude() {
                     return !1
                 }
                 initializeState() {
                     this.getAttributeManager().addInstanced({
                         positions: {
                             size: 3,
                             vertexOffset: 1,
                             type: 5130,
                             fp64: this.use64bitPositions(),
-                            transition: u_,
+                            transition: m_,
                             accessor: "getPath",
                             update: this.calculatePositions,
                             noAlloc: !0,
                             shaderAttributes: {
                                 instanceLeftPositions: {
                                     vertexOffset: 0
                                 },
@@ -25751,35 +25783,35 @@
                             type: 5121,
                             update: this.calculateSegmentTypes,
                             noAlloc: !0
                         },
                         instanceStrokeWidths: {
                             size: 1,
                             accessor: "getWidth",
-                            transition: u_,
+                            transition: m_,
                             defaultValue: 1
                         },
                         instanceColors: {
                             size: this.props.colorFormat.length,
                             type: 5121,
                             normalized: !0,
                             accessor: "getColor",
-                            transition: u_,
-                            defaultValue: c_
+                            transition: m_,
+                            defaultValue: f_
                         },
                         instancePickingColors: {
                             size: 3,
                             type: 5121,
                             accessor: (t, {
                                 index: e,
                                 target: n
                             }) => this.encodePickingColor(t && t.__source ? t.__source.index : e, n)
                         }
                     }), this.setState({
-                        pathTesselator: new a_({
+                        pathTesselator: new d_({
                             fp64: this.use64bitPositions()
                         })
                     })
                 }
                 updateState(t) {
                     super.updateState(t);
                     const {
@@ -25826,15 +25858,15 @@
                 }
                 disablePickingIndex(t) {
                     const {
                         data: e
                     } = this.props;
                     if (e[0] && e[0].__source)
                         for (let n = 0; n < e.length; n++) e[n].__source.index === t && this._disablePickingIndex(n);
-                    else super.disablePickingIndex(t)
+                    else this._disablePickingIndex(t)
                 }
                 draw({
                     uniforms: t
                 }) {
                     const {
                         jointRounded: e,
                         capRounded: n,
@@ -25845,26 +25877,26 @@
                         widthMinPixels: a,
                         widthMaxPixels: l
                     } = this.props;
                     this.state.model.setUniforms(t).setUniforms({
                         jointType: Number(e),
                         capType: Number(n),
                         billboard: i,
-                        widthUnits: Ih[s],
+                        widthUnits: Mh[s],
                         widthScale: o,
                         miterLimit: r,
                         widthMinPixels: a,
                         widthMaxPixels: l
                     }).draw()
                 }
                 _getModel(t) {
-                    return new Yv(t, {
+                    return new ab(t, {
                         ...this.getShaders(),
                         id: this.props.id,
-                        geometry: new ry({
+                        geometry: new hy({
                             drawMode: 4,
                             attributes: {
                                 indices: new Uint16Array([0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4]),
                                 positions: {
                                     value: new Float32Array([0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0]),
                                     size: 2
                                 }
@@ -25882,53 +25914,53 @@
                 calculateSegmentTypes(t) {
                     const {
                         pathTesselator: e
                     } = this.state;
                     t.startIndices = e.vertexStarts, t.value = e.get("segmentTypes")
                 }
             }
-            wo(d_, "defaultProps", h_), wo(d_, "layerName", "PathLayer");
-            const p_ = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",
-                f_ = {
+            wo(v_, "defaultProps", g_), wo(v_, "layerName", "PathLayer");
+            const b_ = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",
+                y_ = {
                     lightSources: {}
                 };
 
-            function g_() {
+            function __() {
                 let {
                     color: t = [0, 0, 0],
                     intensity: e = 1
                 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                 return t.map((t => t * e / 255))
             }
-            const m_ = {};
-            const v_ = {
+            const x_ = {};
+            const w_ = {
                 name: "gouraud-lighting",
                 dependencies: [{
                     name: "lights",
-                    vs: p_,
-                    fs: p_,
+                    vs: b_,
+                    fs: b_,
                     getUniforms: function t() {
-                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f_;
+                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : y_;
                         if ("lightSources" in e) {
                             const {
                                 ambientLight: t,
                                 pointLights: n,
                                 directionalLights: i
                             } = e.lightSources || {};
                             return t || n && n.length > 0 || i && i.length > 0 ? Object.assign({}, function(t) {
                                 let {
                                     ambientLight: e,
                                     pointLights: n = [],
                                     directionalLights: i = []
                                 } = t;
                                 const r = {};
-                                return r["lighting_uAmbientLight.color"] = e ? g_(e) : [0, 0, 0], n.forEach(((t, e) => {
-                                    r["lighting_uPointLight[".concat(e, "].color")] = g_(t), r["lighting_uPointLight[".concat(e, "].position")] = t.position, r["lighting_uPointLight[".concat(e, "].attenuation")] = t.attenuation || [1, 0, 0]
+                                return r["lighting_uAmbientLight.color"] = e ? __(e) : [0, 0, 0], n.forEach(((t, e) => {
+                                    r["lighting_uPointLight[".concat(e, "].color")] = __(t), r["lighting_uPointLight[".concat(e, "].position")] = t.position, r["lighting_uPointLight[".concat(e, "].attenuation")] = t.attenuation || [1, 0, 0]
                                 })), r.lighting_uPointLightCount = n.length, i.forEach(((t, e) => {
-                                    r["lighting_uDirectionalLight[".concat(e, "].color")] = g_(t), r["lighting_uDirectionalLight[".concat(e, "].direction")] = t.direction
+                                    r["lighting_uDirectionalLight[".concat(e, "].color")] = __(t), r["lighting_uDirectionalLight[".concat(e, "].direction")] = t.direction
                                 })), r.lighting_uDirectionalLightCount = i.length, r
                             }({
                                 ambientLight: t,
                                 pointLights: n,
                                 directionalLights: i
                             }), {
                                 lighting_uEnabled: !0
@@ -25962,15 +25994,15 @@
                     }
                 }],
                 vs: "\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",
                 defines: {
                     LIGHTING_VERTEX: 1
                 },
                 getUniforms: function() {
-                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m_;
+                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : x_;
                     if (!("material" in t)) return {};
                     const {
                         material: e
                     } = t;
                     return e ? function(t) {
                         const {
                             ambient: e = .35,
@@ -25985,77 +26017,56 @@
                             lighting_uSpecularColor: r.map((t => t / 255))
                         }
                     }(e) : {
                         lighting_uEnabled: !1
                     }
                 }
             };
-            var b_ = n(9187),
-                y_ = n.n(b_);
-            const __ = {
+            var E_ = n(9187),
+                P_ = n.n(E_);
+            const S_ = {
                 isClosed: !0
             };
 
-            function x_(t) {
+            function C_(t) {
                 return "positions" in t ? t.positions : t
             }
 
-            function w_(t) {
+            function T_(t) {
                 return "holeIndices" in t ? t.holeIndices : null
             }
 
-            function E_(t, e, n, i, r) {
+            function A_(t, e, n, i, r) {
                 let s = e;
                 const o = n.length;
                 for (let e = 0; e < o; e++)
                     for (let r = 0; r < i; r++) t[s++] = n[e][r] || 0;
                 if (! function(t) {
                         const e = t[0],
                             n = t[t.length - 1];
                         return e[0] === n[0] && e[1] === n[1] && e[2] === n[2]
                     }(n))
                     for (let e = 0; e < i; e++) t[s++] = n[0][e] || 0;
-                return __.start = e, __.end = s, __.size = i, Gy(t, r, __), s
+                return S_.start = e, S_.end = s, S_.size = i, Xy(t, r, S_), s
             }
 
-            function P_(t, e, n, i, r = 0, s, o) {
+            function M_(t, e, n, i, r = 0, s, o) {
                 const a = (s = s || n.length) - r;
                 if (a <= 0) return e;
                 let l = e;
                 for (let e = 0; e < a; e++) t[l++] = n[r + e];
                 if (! function(t, e, n, i) {
                         for (let r = 0; r < e; r++)
                             if (t[n + r] !== t[i - e + r]) return !1;
                         return !0
                     }(n, i, r, s))
                     for (let e = 0; e < i; e++) t[l++] = n[r + e];
-                return __.start = e, __.end = l, __.size = i, Gy(t, o, __), l
+                return S_.start = e, S_.end = l, S_.size = i, Xy(t, o, S_), l
             }
-
-            function S_(t, e, n) {
-                const i = t.length / 3;
-                let r = 0;
-                for (let s = 0; s < i; s++) {
-                    const o = (s + 1) % i;
-                    r += t[3 * s + e] * t[3 * o + n], r -= t[3 * o + e] * t[3 * s + n]
-                }
-                return Math.abs(r / 2)
-            }
-
-            function C_(t, e, n, i) {
-                const r = t.length / 3;
-                for (let s = 0; s < r; s++) {
-                    const r = 3 * s,
-                        o = t[r + 0],
-                        a = t[r + 1],
-                        l = t[r + 2];
-                    t[r + e] = o, t[r + n] = a, t[r + i] = l
-                }
-            }
-            class T_ extends Uy {
+            class O_ extends qy {
                 constructor(t) {
                     const {
                         fp64: e,
                         IndexType: n = Uint32Array
                     } = t;
                     super({
                         ...t,
@@ -26098,38 +26109,38 @@
                             if ("positions" in t) {
                                 const {
                                     positions: r,
                                     holeIndices: s
                                 } = t;
                                 if (s) {
                                     let t = 0;
-                                    for (let o = 0; o <= s.length; o++) t = P_(n, t, r, e, s[o - 1], s[o], 0 === o ? 1 : -1), i.push(t);
+                                    for (let o = 0; o <= s.length; o++) t = M_(n, t, r, e, s[o - 1], s[o], 0 === o ? 1 : -1), i.push(t);
                                     return i.pop(), {
                                         positions: n,
                                         holeIndices: i
                                     }
                                 }
                                 t = r
                             }
                             if (! function(t) {
                                     return Array.isArray(t[0])
-                                }(t)) return P_(n, 0, t, e, 0, n.length, 1), n;
+                                }(t)) return M_(n, 0, t, e, 0, n.length, 1), n;
                             if (! function(t) {
                                     return t.length >= 1 && t[0].length >= 2 && Number.isFinite(t[0][0])
                                 }(t)) {
                                 let r = 0;
-                                for (const [s, o] of t.entries()) r = E_(n, r, o, e, 0 === s ? 1 : -1), i.push(r);
+                                for (const [s, o] of t.entries()) r = A_(n, r, o, e, 0 === s ? 1 : -1), i.push(r);
                                 return i.pop(), {
                                     positions: n,
                                     holeIndices: i
                                 }
                             }
-                            return E_(n, 0, t, e, 1), n
+                            return A_(n, 0, t, e, 1), n
                         }(t, this.positionSize);
-                        return this.opts.resolution ? Jy(x_(e), w_(e), {
+                        return this.opts.resolution ? i_(C_(e), T_(e), {
                             size: this.positionSize,
                             gridResolution: this.opts.resolution,
                             edgeTypes: !0
                         }) : this.opts.wrapLongitude ? function(t, e = null, n) {
                             const {
                                 size: i = 2,
                                 normalize: r = !0,
@@ -26139,50 +26150,50 @@
                             const o = [],
                                 a = [];
                             let l = 0,
                                 c = 0;
                             for (let r = 0; r <= e.length; r++) {
                                 const s = e[r] || t.length,
                                     h = c,
-                                    u = i_(t, i, l, s);
+                                    u = l_(t, i, l, s);
                                 for (let e = u; e < s; e++) o[c++] = t[e];
                                 for (let e = l; e < u; e++) o[c++] = t[e];
-                                s_(o, i, h, c), r_(o, i, h, c, null == n ? void 0 : n.maxLatitude), l = s, a[r] = c
+                                h_(o, i, h, c), c_(o, i, h, c, null == n ? void 0 : n.maxLatitude), l = s, a[r] = c
                             }
                             a.pop();
-                            const h = Jy(o, a, {
+                            const h = i_(o, a, {
                                 size: i,
                                 gridResolution: 360,
                                 gridOffset: [-180, -180],
                                 edgeTypes: s
                             });
                             if (r)
-                                for (const t of h) o_(t.positions, i);
+                                for (const t of h) u_(t.positions, i);
                             return h
-                        }(x_(e), w_(e), {
+                        }(C_(e), T_(e), {
                             size: this.positionSize,
                             maxLatitude: 86,
                             edgeTypes: !0
                         }) : e
                     }
                     return t
                 }
                 getGeometrySize(t) {
-                    if (A_(t)) {
+                    if (L_(t)) {
                         let e = 0;
                         for (const n of t) e += this.getGeometrySize(n);
                         return e
                     }
-                    return x_(t).length / this.positionSize
+                    return C_(t).length / this.positionSize
                 }
                 getGeometryFromBuffer(t) {
                     return this.normalize || !this.buffers.indices ? super.getGeometryFromBuffer(t) : null
                 }
                 updateGeometryAttributes(t, e) {
-                    if (t && A_(t))
+                    if (t && L_(t))
                         for (const n of t) {
                             const t = this.getGeometrySize(n);
                             e.geometrySize = t, this.updateGeometryAttributes(n, e), e.vertexStart += t, e.indexStart = this.indexStarts[e.geometryIndex + 1]
                         } else this._updateIndices(t, e), this._updatePositions(t, e), this._updateVertexValid(t, e)
                 }
                 _updateIndices(t, {
                     geometryIndex: e,
@@ -26193,38 +26204,30 @@
                         attributes: r,
                         indexStarts: s,
                         typedArrayManager: o
                     } = this;
                     let a = r.indices;
                     if (!a || !t) return;
                     let l = i;
-                    const c = function(t, e, n, i) {
-                        let r = w_(t);
-                        r && (r = r.map((t => t / e)));
-                        let s = x_(t);
-                        const o = i && 3 === e;
+                    const c = function(t, e, n) {
+                        let i = T_(t);
+                        i && (i = i.map((t => t / e)));
+                        let r = C_(t);
                         if (n) {
-                            const t = s.length;
-                            s = s.slice();
+                            const t = r.length;
+                            r = r.slice();
                             const i = [];
-                            for (let r = 0; r < t; r += e) {
-                                i[0] = s[r], i[1] = s[r + 1], o && (i[2] = s[r + 2]);
+                            for (let s = 0; s < t; s += e) {
+                                i[0] = r[s], i[1] = r[s + 1];
                                 const t = n(i);
-                                s[r] = t[0], s[r + 1] = t[1], o && (s[r + 2] = t[2])
+                                r[s] = t[0], r[s + 1] = t[1]
                             }
                         }
-                        if (o) {
-                            const t = S_(s, 0, 1),
-                                e = S_(s, 0, 2),
-                                i = S_(s, 1, 2);
-                            if (!t && !e && !i) return [];
-                            t > e && t > i || (e > i ? (n || (s = s.slice()), C_(s, 0, 2, 1)) : (n || (s = s.slice()), C_(s, 2, 0, 1)))
-                        }
-                        return y_()(s, r, e)
-                    }(t, this.positionSize, this.opts.preproject, this.opts.full3d);
+                        return P_()(r, i, e)
+                    }(t, this.positionSize, this.opts.preproject);
                     a = o.allocate(a, i + c.length, {
                         copy: !0
                     });
                     for (let t = 0; t < c.length; t++) a[l++] = c[t] + n;
                     s[e + 1] = i + c.length, r.indices = a
                 }
                 _updatePositions(t, {
@@ -26234,49 +26237,48 @@
                     const {
                         attributes: {
                             positions: i
                         },
                         positionSize: r
                     } = this;
                     if (!i || !t) return;
-                    const s = x_(t);
+                    const s = C_(t);
                     for (let t = e, o = 0; o < n; t++, o++) {
                         const e = s[o * r],
                             n = s[o * r + 1],
                             a = r > 2 ? s[o * r + 2] : 0;
                         i[3 * t] = e, i[3 * t + 1] = n, i[3 * t + 2] = a
                     }
                 }
                 _updateVertexValid(t, {
                     vertexStart: e,
                     geometrySize: n
                 }) {
                     const {
                         positionSize: i
-                    } = this, r = this.attributes.vertexValid, s = t && w_(t);
+                    } = this, r = this.attributes.vertexValid, s = t && T_(t);
                     if (t && t.edgeTypes ? r.set(t.edgeTypes, e) : r.fill(1, e, e + n), s)
                         for (let t = 0; t < s.length; t++) r[e + s[t] / i - 1] = 0;
                     r[e + n - 1] = 0
                 }
             }
 
-            function A_(t) {
+            function L_(t) {
                 return Array.isArray(t) && t.length > 0 && !Number.isFinite(t[0])
             }
-            const M_ = "\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",
-                O_ = "#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(M_, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n"),
-                L_ = "#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(M_, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n"),
-                R_ = [0, 0, 0, 255],
-                I_ = {
+            const k_ = "\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",
+                R_ = "#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(k_, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n"),
+                I_ = "#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(k_, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n"),
+                j_ = [0, 0, 0, 255],
+                F_ = {
                     filled: !0,
                     extruded: !1,
                     wireframe: !1,
                     _normalize: !0,
                     _windingOrder: "CW",
-                    _full3d: !1,
                     elevationScale: {
                         type: "number",
                         min: 0,
                         value: 1
                     },
                     getPolygon: {
                         type: "accessor",
@@ -26284,79 +26286,75 @@
                     },
                     getElevation: {
                         type: "accessor",
                         value: 1e3
                     },
                     getFillColor: {
                         type: "accessor",
-                        value: R_
+                        value: j_
                     },
                     getLineColor: {
                         type: "accessor",
-                        value: R_
+                        value: j_
                     },
                     material: !0
                 },
-                k_ = {
+                z_ = {
                     enter: (t, e) => e.length ? e.subarray(e.length - t.length) : t
                 };
-            class j_ extends Fb {
+            class B_ extends Yb {
                 constructor(...t) {
                     super(...t), wo(this, "state", void 0)
                 }
                 getShaders(t) {
                     return super.getShaders({
-                        vs: "top" === t ? O_ : L_,
+                        vs: "top" === t ? R_ : I_,
                         fs: "#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
                         defines: {
                             RING_WINDING_ORDER_CW: this.props._normalize || "CCW" !== this.props._windingOrder ? 1 : 0
                         },
-                        modules: [ty, v_, ny]
+                        modules: [oy, w_, ly]
                     })
                 }
                 get wrapLongitude() {
                     return !1
                 }
                 initializeState() {
                     const {
                         gl: t,
                         viewport: e
                     } = this.context;
                     let {
                         coordinateSystem: n
                     } = this.props;
-                    const {
-                        _full3d: i
-                    } = this.props;
-                    let r;
-                    e.isGeospatial && n === Lh.DEFAULT && (n = Lh.LNGLAT), n === Lh.LNGLAT && (r = i ? e.projectPosition.bind(e) : e.projectFlat.bind(e)), this.setState({
+                    e.isGeospatial && n === Th.DEFAULT && (n = Th.LNGLAT), this.setState({
                         numInstances: 0,
-                        polygonTesselator: new T_({
-                            preproject: r,
+                        polygonTesselator: new O_({
+                            preproject: n === Th.LNGLAT && e.projectFlat.bind(e),
                             fp64: this.use64bitPositions(),
-                            IndexType: !t || gp(t, dp) ? Uint32Array : Uint16Array
+                            IndexType: !t || fp(t, up) ? Uint32Array : Uint16Array
                         })
                     });
-                    const s = this.getAttributeManager(),
-                        o = !0;
-                    s.remove(["instancePickingColors"]), s.add({
+                    const i = this.getAttributeManager(),
+                        r = !0;
+                    i.remove(["instancePickingColors"]), i.add({
                         indices: {
                             size: 1,
                             isIndexed: !0,
                             update: this.calculateIndices,
-                            noAlloc: o
+                            noAlloc: r
                         },
                         positions: {
                             size: 3,
                             type: 5130,
                             fp64: this.use64bitPositions(),
-                            transition: k_,
+                            transition: z_,
                             accessor: "getPolygon",
                             update: this.calculatePositions,
-                            noAlloc: o,
+                            noAlloc: r,
                             shaderAttributes: {
                                 positions: {
                                     vertexOffset: 0,
                                     divisor: 0
                                 },
                                 instancePositions: {
                                     vertexOffset: 0,
@@ -26369,52 +26367,52 @@
                             }
                         },
                         vertexValid: {
                             size: 1,
                             divisor: 1,
                             type: 5121,
                             update: this.calculateVertexValid,
-                            noAlloc: o
+                            noAlloc: r
                         },
                         elevations: {
                             size: 1,
-                            transition: k_,
+                            transition: z_,
                             accessor: "getElevation",
                             shaderAttributes: {
                                 elevations: {
                                     divisor: 0
                                 },
                                 instanceElevations: {
                                     divisor: 1
                                 }
                             }
                         },
                         fillColors: {
                             size: this.props.colorFormat.length,
                             type: 5121,
                             normalized: !0,
-                            transition: k_,
+                            transition: z_,
                             accessor: "getFillColor",
-                            defaultValue: R_,
+                            defaultValue: j_,
                             shaderAttributes: {
                                 fillColors: {
                                     divisor: 0
                                 },
                                 instanceFillColors: {
                                     divisor: 1
                                 }
                             }
                         },
                         lineColors: {
                             size: this.props.colorFormat.length,
                             type: 5121,
                             normalized: !0,
-                            transition: k_,
+                            transition: z_,
                             accessor: "getLineColor",
-                            defaultValue: R_,
+                            defaultValue: j_,
                             shaderAttributes: {
                                 lineColors: {
                                     divisor: 0
                                 },
                                 instanceLineColors: {
                                     divisor: 1
                                 }
@@ -26450,15 +26448,15 @@
                 }
                 disablePickingIndex(t) {
                     const {
                         data: e
                     } = this.props;
                     if (e[0] && e[0].__source)
                         for (let n = 0; n < e.length; n++) e[n].__source.index === t && this._disablePickingIndex(n);
-                    else super.disablePickingIndex(t)
+                    else this._disablePickingIndex(t)
                 }
                 draw({
                     uniforms: t
                 }) {
                     const {
                         extruded: e,
                         filled: n,
@@ -26504,16 +26502,15 @@
                             geometryBuffer: i.getPolygon,
                             buffers: i,
                             getGeometry: t.getPolygon,
                             positionFormat: t.positionFormat,
                             wrapLongitude: t.wrapLongitude,
                             resolution: this.context.viewport.resolution,
                             fp64: this.use64bitPositions(),
-                            dataChanged: n.dataChanged,
-                            full3d: t._full3d
+                            dataChanged: n.dataChanged
                         }), this.setState({
                             numInstances: e.instanceCount,
                             startIndices: e.vertexStarts
                         }), n.dataChanged || this.getAttributeManager().invalidateAll()
                     }
                 }
                 _getModels(t) {
@@ -26521,33 +26518,33 @@
                         id: e,
                         filled: n,
                         extruded: i
                     } = this.props;
                     let r, s;
                     if (n) {
                         const n = this.getShaders("top");
-                        n.defines.NON_INSTANCED_MODEL = 1, r = new Yv(t, {
+                        n.defines.NON_INSTANCED_MODEL = 1, r = new ab(t, {
                             ...n,
                             id: "".concat(e, "-top"),
                             drawMode: 4,
                             attributes: {
                                 vertexPositions: new Float32Array([0, 1])
                             },
                             uniforms: {
                                 isWireframe: !1,
                                 isSideVertex: !1
                             },
                             vertexCount: 0,
                             isIndexed: !0
                         })
                     }
-                    return i && (s = new Yv(t, {
+                    return i && (s = new ab(t, {
                         ...this.getShaders("side"),
                         id: "".concat(e, "-side"),
-                        geometry: new ry({
+                        geometry: new hy({
                             drawMode: 1,
                             vertexCount: 4,
                             attributes: {
                                 vertexPositions: {
                                     size: 2,
                                     value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
                                 }
@@ -26575,18 +26572,18 @@
                     } = this.state;
                     t.startIndices = e.vertexStarts, t.value = e.get("positions")
                 }
                 calculateVertexValid(t) {
                     t.value = this.state.polygonTesselator.get("vertexValid")
                 }
             }
-            wo(j_, "defaultProps", I_), wo(j_, "layerName", "SolidPolygonLayer");
-            const F_ = {
+            wo(B_, "defaultProps", F_), wo(B_, "layerName", "SolidPolygonLayer");
+            const D_ = {
                     circle: {
-                        type: my,
+                        type: wy,
                         props: {
                             filled: "filled",
                             stroked: "stroked",
                             lineWidthMaxPixels: "lineWidthMaxPixels",
                             lineWidthMinPixels: "lineWidthMinPixels",
                             lineWidthScale: "lineWidthScale",
                             lineWidthUnits: "lineWidthUnits",
@@ -26599,15 +26596,15 @@
                             getFillColor: "getFillColor",
                             getLineColor: "getLineColor",
                             getLineWidth: "getLineWidth",
                             getPointRadius: "getRadius"
                         }
                     },
                     icon: {
-                        type: py,
+                        type: yy,
                         props: {
                             iconAtlas: "iconAtlas",
                             iconMapping: "iconMapping",
                             iconSizeMaxPixels: "sizeMaxPixels",
                             iconSizeMinPixels: "sizeMinPixels",
                             iconSizeScale: "sizeScale",
                             iconSizeUnits: "sizeUnits",
@@ -26617,15 +26614,15 @@
                             getIconAngle: "getAngle",
                             getIconColor: "getColor",
                             getIconPixelOffset: "getPixelOffset",
                             getIconSize: "getSize"
                         }
                     },
                     text: {
-                        type: Vy,
+                        type: Zy,
                         props: {
                             textSizeMaxPixels: "sizeMaxPixels",
                             textSizeMinPixels: "sizeMinPixels",
                             textSizeScale: "sizeScale",
                             textSizeUnits: "sizeUnits",
                             textBackground: "background",
                             textBackgroundPadding: "backgroundPadding",
@@ -26648,54 +26645,53 @@
                             getTextAlignmentBaseline: "getAlignmentBaseline",
                             getTextBackgroundColor: "getBackgroundColor",
                             getTextBorderColor: "getBorderColor",
                             getTextBorderWidth: "getBorderWidth"
                         }
                     }
                 },
-                z_ = {
-                    type: d_,
+                N_ = {
+                    type: v_,
                     props: {
                         lineWidthUnits: "widthUnits",
                         lineWidthScale: "widthScale",
                         lineWidthMinPixels: "widthMinPixels",
                         lineWidthMaxPixels: "widthMaxPixels",
                         lineJointRounded: "jointRounded",
                         lineCapRounded: "capRounded",
                         lineMiterLimit: "miterLimit",
                         lineBillboard: "billboard",
                         getLineColor: "getColor",
                         getLineWidth: "getWidth"
                     }
                 },
-                B_ = {
-                    type: j_,
+                V_ = {
+                    type: B_,
                     props: {
                         extruded: "extruded",
                         filled: "filled",
                         wireframe: "wireframe",
                         elevationScale: "elevationScale",
                         material: "material",
-                        _full3d: "_full3d",
                         getElevation: "getElevation",
                         getFillColor: "getFillColor",
                         getLineColor: "getLineColor"
                     }
                 };
 
-            function D_({
+            function U_({
                 type: t,
                 props: e
             }) {
                 const n = {};
                 for (const i in e) n[i] = t.defaultProps[e[i]];
                 return n
             }
 
-            function N_(t, e) {
+            function G_(t, e) {
                 const {
                     transitions: n,
                     updateTriggers: i
                 } = t.props, r = {
                     updateTriggers: {},
                     transitions: n && {
                         getPosition: n.geometry
@@ -26705,55 +26701,55 @@
                     const o = e[s];
                     let a = t.props[s];
                     s.startsWith("get") && (a = t.getSubLayerAccessor(a), r.updateTriggers[o] = i[s], n && (r.transitions[o] = n[s])), r[o] = a
                 }
                 return r
             }
 
-            function V_(t, e, n = {}) {
+            function W_(t, e, n = {}) {
                 const i = {
                         pointFeatures: [],
                         lineFeatures: [],
                         polygonFeatures: [],
                         polygonOutlineFeatures: []
                     },
                     {
                         startRow: r = 0,
                         endRow: s = t.length
                     } = n;
                 for (let n = r; n < s; n++) {
-                    const r = t[n],
-                        {
-                            geometry: s
-                        } = r;
-                    if (s)
-                        if ("GeometryCollection" === s.type) {
-                            na.assert(Array.isArray(s.geometries), "GeoJSON does not have geometries array");
-                            const {
-                                geometries: t
-                            } = s;
-                            for (let s = 0; s < t.length; s++) U_(t[s], i, e, r, n)
-                        } else U_(s, i, e, r, n)
+                    const r = t[n];
+                    ta.assert(r && r.geometry, "GeoJSON does not have geometry");
+                    const {
+                        geometry: s
+                    } = r;
+                    if ("GeometryCollection" === s.type) {
+                        ta.assert(Array.isArray(s.geometries), "GeoJSON does not have geometries array");
+                        const {
+                            geometries: t
+                        } = s;
+                        for (let s = 0; s < t.length; s++) H_(t[s], i, e, r, n)
+                    } else H_(s, i, e, r, n)
                 }
                 return i
             }
 
-            function U_(t, e, n, i, r) {
+            function H_(t, e, n, i, r) {
                 const {
                     type: s,
                     coordinates: o
                 } = t, {
                     pointFeatures: a,
                     lineFeatures: l,
                     polygonFeatures: c,
                     polygonOutlineFeatures: h
                 } = e;
                 if (function(t, e) {
-                        let n = G_[t];
-                        for (na.assert(n, "Unknown GeoJSON type ".concat(t)); e && --n > 0;) e = e[0];
+                        let n = Z_[t];
+                        for (ta.assert(n, "Unknown GeoJSON type ".concat(t)); e && --n > 0;) e = e[0];
                         return e && Number.isFinite(e[0])
                     }(s, o)) switch (s) {
                     case "Point":
                         a.push(n({
                             geometry: t
                         }, i, r));
                         break;
@@ -26806,40 +26802,39 @@
                                     geometry: {
                                         type: "LineString",
                                         coordinates: t
                                     }
                                 }, i, r))
                             }))
                         }))
-                } else na.warn("".concat(s, " coordinates are malformed"))()
+                } else ta.warn("".concat(s, " coordinates are malformed"))()
             }
-            const G_ = {
+            const Z_ = {
                 Point: 1,
                 MultiPoint: 2,
                 LineString: 2,
                 MultiLineString: 3,
                 Polygon: 3,
                 MultiPolygon: 4
             };
 
-            function W_(t) {
+            function q_(t) {
                 return t.geometry.coordinates
             }
-            const H_ = ["points", "linestrings", "polygons"],
-                Z_ = {
-                    ...D_(F_.circle),
-                    ...D_(F_.icon),
-                    ...D_(F_.text),
-                    ...D_(z_),
-                    ...D_(B_),
+            const X_ = ["points", "linestrings", "polygons"],
+                Y_ = {
+                    ...U_(D_.circle),
+                    ...U_(D_.icon),
+                    ...U_(D_.text),
+                    ...U_(N_),
+                    ...U_(V_),
                     stroked: !0,
                     filled: !0,
                     extruded: !1,
                     wireframe: !1,
-                    _full3d: !1,
                     iconAtlas: {
                         type: "object",
                         value: null
                     },
                     iconMapping: {
                         type: "object",
                         value: {}
@@ -26853,15 +26848,15 @@
                         value: t => t.properties.text
                     },
                     pointType: "circle",
                     getRadius: {
                         deprecatedFor: "getPointRadius"
                     }
                 };
-            class q_ extends Jb {
+            class K_ extends ry {
                 initializeState() {
                     this.state = {
                         layerProps: {},
                         features: {}
                     }
                 }
                 updateState({
@@ -26975,101 +26970,101 @@
                 }
                 _updateStateJSON({
                     props: t,
                     changeFlags: e
                 }) {
                     const n = function(t) {
                             if (Array.isArray(t)) return t;
-                            switch (na.assert(t.type, "GeoJSON does not have type"), t.type) {
+                            switch (ta.assert(t.type, "GeoJSON does not have type"), t.type) {
                                 case "Feature":
                                     return [t];
                                 case "FeatureCollection":
-                                    return na.assert(Array.isArray(t.features), "GeoJSON does not have features array"), t.features;
+                                    return ta.assert(Array.isArray(t.features), "GeoJSON does not have features array"), t.features;
                                 default:
                                     return [{
                                         geometry: t
                                     }]
                             }
                         }(t.data),
                         i = this.getSubLayerRow.bind(this);
                     let r = {};
                     const s = {};
                     if (Array.isArray(e.dataChanged)) {
                         const t = this.state.features;
                         for (const e in t) r[e] = t[e].slice(), s[e] = [];
                         for (const o of e.dataChanged) {
-                            const e = V_(n, i, o);
-                            for (const n in t) s[n].push($b({
+                            const e = W_(n, i, o);
+                            for (const n in t) s[n].push(sy({
                                 data: r[n],
                                 getIndex: t => t.__source.index,
                                 dataRange: o,
                                 replace: e[n]
                             }))
                         }
-                    } else r = V_(n, i);
+                    } else r = W_(n, i);
                     const o = function(t, e) {
                         const n = {
                                 points: {},
                                 lines: {},
                                 polygons: {},
                                 polygonsOutline: {}
                             },
                             {
                                 pointFeatures: i,
                                 lineFeatures: r,
                                 polygonFeatures: s,
                                 polygonOutlineFeatures: o
                             } = t;
-                        return n.points.data = i, n.points._dataDiff = e.pointFeatures && (() => e.pointFeatures), n.points.getPosition = W_, n.lines.data = r, n.lines._dataDiff = e.lineFeatures && (() => e.lineFeatures), n.lines.getPath = W_, n.polygons.data = s, n.polygons._dataDiff = e.polygonFeatures && (() => e.polygonFeatures), n.polygons.getPolygon = W_, n.polygonsOutline.data = o, n.polygonsOutline._dataDiff = e.polygonOutlineFeatures && (() => e.polygonOutlineFeatures), n.polygonsOutline.getPath = W_, n
+                        return n.points.data = i, n.points._dataDiff = e.pointFeatures && (() => e.pointFeatures), n.points.getPosition = q_, n.lines.data = r, n.lines._dataDiff = e.lineFeatures && (() => e.lineFeatures), n.lines.getPath = q_, n.polygons.data = s, n.polygons._dataDiff = e.polygonFeatures && (() => e.polygonFeatures), n.polygons.getPolygon = q_, n.polygonsOutline.data = o, n.polygonsOutline._dataDiff = e.polygonOutlineFeatures && (() => e.polygonOutlineFeatures), n.polygonsOutline.getPath = q_, n
                     }(r, s);
                     this.setState({
                         features: r,
                         featuresDiff: s,
                         layerProps: o
                     })
                 }
                 getPickingInfo(t) {
                     const e = super.getPickingInfo(t),
                         {
                             index: n,
                             sourceLayer: i
                         } = e;
-                    return e.featureType = H_.find((t => i.id.startsWith("".concat(this.id, "-").concat(t, "-")))), n >= 0 && i.id.startsWith("".concat(this.id, "-points-text")) && this.state.binary && (e.index = this.props.data.points.globalFeatureIds.value[n]), e
+                    return e.featureType = X_.find((t => i.id.startsWith("".concat(this.id, "-").concat(t, "-")))), n >= 0 && i.id.startsWith("".concat(this.id, "-points-text")) && this.state.binary && (e.index = this.props.data.points.globalFeatureIds.value[n]), e
                 }
                 _updateAutoHighlight(t) {
                     const e = "".concat(this.id, "-points-"),
                         n = "points" === t.featureType;
                     for (const i of this.getSubLayers()) i.id.startsWith(e) === n && i.updateAutoHighlight(t)
                 }
                 _renderPolygonLayer() {
                     const {
                         extruded: t,
                         wireframe: e
                     } = this.props, {
                         layerProps: n
-                    } = this.state, i = "polygons-fill", r = this.shouldRenderSubLayer(i, n.polygons.data) && this.getSubLayerClass(i, B_.type);
+                    } = this.state, i = "polygons-fill", r = this.shouldRenderSubLayer(i, n.polygons.data) && this.getSubLayerClass(i, V_.type);
                     if (r) {
-                        const s = N_(this, B_.props),
+                        const s = G_(this, V_.props),
                             o = t && e;
                         return o || delete s.getLineColor, s.updateTriggers.lineColors = o, new r(s, this.getSubLayerProps({
                             id: i,
                             updateTriggers: s.updateTriggers
                         }), n.polygons)
                     }
                     return null
                 }
                 _renderLineLayers() {
                     const {
                         extruded: t,
                         stroked: e
                     } = this.props, {
                         layerProps: n
-                    } = this.state, i = "polygons-stroke", r = "linestrings", s = !t && e && this.shouldRenderSubLayer(i, n.polygonsOutline.data) && this.getSubLayerClass(i, z_.type), o = this.shouldRenderSubLayer(r, n.lines.data) && this.getSubLayerClass(r, z_.type);
+                    } = this.state, i = "polygons-stroke", r = "linestrings", s = !t && e && this.shouldRenderSubLayer(i, n.polygonsOutline.data) && this.getSubLayerClass(i, N_.type), o = this.shouldRenderSubLayer(r, n.lines.data) && this.getSubLayerClass(r, N_.type);
                     if (s || o) {
-                        const t = N_(this, z_.props);
+                        const t = G_(this, N_.props);
                         return [s && new s(t, this.getSubLayerProps({
                             id: i,
                             updateTriggers: t.updateTriggers
                         }), n.polygonsOutline), o && new o(t, this.getSubLayerProps({
                             id: r,
                             updateTriggers: t.updateTriggers
                         }), n.lines)]
@@ -27087,18 +27082,18 @@
                         highlightedObjectIndex: i
                     } = this.props;
                     !n && Number.isFinite(i) && (i = e.points.data.findIndex((t => t.__source.index === i)));
                     const r = new Set(t.split("+")),
                         s = [];
                     for (const t of r) {
                         const r = "points-".concat(t),
-                            o = F_[t],
+                            o = D_[t],
                             a = o && this.shouldRenderSubLayer(r, e.points.data) && this.getSubLayerClass(r, o.type);
                         if (a) {
-                            const l = N_(this, o.props);
+                            const l = G_(this, o.props);
                             let c = e.points;
                             if ("text" === t && n) {
                                 const {
                                     instancePickingColors: t,
                                     ...e
                                 } = c.data.attributes;
                                 c = {
@@ -27146,208 +27141,18 @@
                                 return i
                             }(t, i, n) : null
                         }(i, r);
                         return t(s, n)
                     } : super.getSubLayerAccessor(t)
                 }
             }
-            wo(q_, "layerName", "GeoJsonLayer"), wo(q_, "defaultProps", Z_);
-            var X_ = n(4155);
-
-            function Y_() {
-                let t;
-                if ("undefined" != typeof window && window.performance) t = window.performance.now();
-                else if (void 0 !== X_ && X_.hrtime) {
-                    const e = X_.hrtime();
-                    t = 1e3 * e[0] + e[1] / 1e6
-                } else t = Date.now();
-                return t
-            }
-            class K_ {
-                constructor(t, e) {
-                    wo(this, "name", void 0), wo(this, "type", void 0), wo(this, "sampleSize", 1), wo(this, "time", 0), wo(this, "count", 0), wo(this, "samples", 0), wo(this, "lastTiming", 0), wo(this, "lastSampleTime", 0), wo(this, "lastSampleCount", 0), wo(this, "_count", 0), wo(this, "_time", 0), wo(this, "_samples", 0), wo(this, "_startTime", 0), wo(this, "_timerPending", !1), this.name = t, this.type = e, this.reset()
-                }
-                reset() {
-                    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this
-                }
-                setSampleSize(t) {
-                    return this.sampleSize = t, this
-                }
-                incrementCount() {
-                    return this.addCount(1), this
-                }
-                decrementCount() {
-                    return this.subtractCount(1), this
-                }
-                addCount(t) {
-                    return this._count += t, this._samples++, this._checkSampling(), this
-                }
-                subtractCount(t) {
-                    return this._count -= t, this._samples++, this._checkSampling(), this
-                }
-                addTime(t) {
-                    return this._time += t, this.lastTiming = t, this._samples++, this._checkSampling(), this
-                }
-                timeStart() {
-                    return this._startTime = Y_(), this._timerPending = !0, this
-                }
-                timeEnd() {
-                    return this._timerPending ? (this.addTime(Y_() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this
-                }
-                getSampleAverageCount() {
-                    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0
-                }
-                getSampleAverageTime() {
-                    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0
-                }
-                getSampleHz() {
-                    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0
-                }
-                getAverageCount() {
-                    return this.samples > 0 ? this.count / this.samples : 0
-                }
-                getAverageTime() {
-                    return this.samples > 0 ? this.time / this.samples : 0
-                }
-                getHz() {
-                    return this.time > 0 ? this.samples / (this.time / 1e3) : 0
-                }
-                _checkSampling() {
-                    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0)
-                }
-            }
+            wo(K_, "layerName", "GeoJsonLayer"), wo(K_, "defaultProps", Y_);
             class Q_ {
                 constructor(t) {
-                    wo(this, "id", void 0), wo(this, "stats", {}), this.id = t.id, this.stats = {}, this._initializeStats(t.stats), Object.seal(this)
-                }
-                get(t) {
-                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "count";
-                    return this._getOrCreate({
-                        name: t,
-                        type: e
-                    })
-                }
-                get size() {
-                    return Object.keys(this.stats).length
-                }
-                reset() {
-                    for (const t of Object.values(this.stats)) t.reset();
-                    return this
-                }
-                forEach(t) {
-                    for (const e of Object.values(this.stats)) t(e)
-                }
-                getTable() {
-                    const t = {};
-                    return this.forEach((e => {
-                        t[e.name] = {
-                            time: e.time || 0,
-                            count: e.count || 0,
-                            average: e.getAverageTime() || 0,
-                            hz: e.getHz() || 0
-                        }
-                    })), t
-                }
-                _initializeStats() {
-                    (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).forEach((t => this._getOrCreate(t)))
-                }
-                _getOrCreate(t) {
-                    const {
-                        name: e,
-                        type: n
-                    } = t;
-                    let i = this.stats[e];
-                    return i || (i = t instanceof K_ ? t : new K_(e, n), this.stats[e] = i), i
-                }
-            }
-            const J_ = {
-                id: "request-scheduler",
-                throttleRequests: !0,
-                maxRequests: 6
-            };
-            class $_ {
-                constructor() {
-                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
-                    wo(this, "props", void 0), wo(this, "stats", void 0), wo(this, "activeRequestCount", 0), wo(this, "requestQueue", []), wo(this, "requestMap", new Map), wo(this, "deferredUpdate", null), this.props = {
-                        ...J_,
-                        ...t
-                    }, this.stats = new Q_({
-                        id: this.props.id
-                    }), this.stats.get("Queued Requests"), this.stats.get("Active Requests"), this.stats.get("Cancelled Requests"), this.stats.get("Queued Requests Ever"), this.stats.get("Active Requests Ever")
-                }
-                scheduleRequest(t) {
-                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : () => 0;
-                    if (!this.props.throttleRequests) return Promise.resolve({
-                        done: () => {}
-                    });
-                    if (this.requestMap.has(t)) return this.requestMap.get(t);
-                    const n = {
-                            handle: t,
-                            priority: 0,
-                            getPriority: e
-                        },
-                        i = new Promise((t => (n.resolve = t, n)));
-                    return this.requestQueue.push(n), this.requestMap.set(t, i), this._issueNewRequests(), i
-                }
-                _issueRequest(t) {
-                    const {
-                        handle: e,
-                        resolve: n
-                    } = t;
-                    let i = !1;
-                    const r = () => {
-                        i || (i = !0, this.requestMap.delete(e), this.activeRequestCount--, this._issueNewRequests())
-                    };
-                    return this.activeRequestCount++, n ? n({
-                        done: r
-                    }) : Promise.resolve({
-                        done: r
-                    })
-                }
-                _issueNewRequests() {
-                    this.deferredUpdate || (this.deferredUpdate = setTimeout((() => this._issueNewRequestsAsync()), 0))
-                }
-                _issueNewRequestsAsync() {
-                    this.deferredUpdate = null;
-                    const t = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
-                    if (0 !== t) {
-                        this._updateAllRequests();
-                        for (let e = 0; e < t; ++e) {
-                            const t = this.requestQueue.shift();
-                            t && this._issueRequest(t)
-                        }
-                    }
-                }
-                _updateAllRequests() {
-                    const t = this.requestQueue;
-                    for (let e = 0; e < t.length; ++e) {
-                        const n = t[e];
-                        this._updateRequest(n) || (t.splice(e, 1), this.requestMap.delete(n.handle), e--)
-                    }
-                    t.sort(((t, e) => t.priority - e.priority))
-                }
-                _updateRequest(t) {
-                    return t.priority = t.getPriority(t.handle), !(t.priority < 0 && (t.resolve(null), 1))
-                }
-            }
-            class tx {
-                constructor(t) {
-                    wo(this, "index", void 0), wo(this, "isVisible", void 0), wo(this, "isSelected", void 0), wo(this, "parent", void 0), wo(this, "children", void 0), wo(this, "content", void 0), wo(this, "state", void 0), wo(this, "layers", void 0), wo(this, "id", void 0), wo(this, "zoom", void 0), wo(this, "userData", void 0), wo(this, "boundingBox", void 0), wo(this, "_abortController", void 0), wo(this, "_loader", void 0), wo(this, "_loaderId", void 0), wo(this, "_isLoaded", void 0), wo(this, "_isCancelled", void 0), wo(this, "_needsReload", void 0), wo(this, "_bbox", void 0), this.index = t, this.isVisible = !1, this.isSelected = !1, this.parent = null, this.children = [], this.content = null, this._loader = void 0, this._abortController = null, this._loaderId = 0, this._isLoaded = !1, this._isCancelled = !1, this._needsReload = !1
-                }
-                get bbox() {
-                    return this._bbox
-                }
-                set bbox(t) {
-                    this._bbox || (this._bbox = t, this.boundingBox = "west" in t ? [
-                        [t.west, t.south],
-                        [t.east, t.north]
-                    ] : [
-                        [t.left, t.top],
-                        [t.right, t.bottom]
-                    ])
+                    wo(this, "index", void 0), wo(this, "isVisible", void 0), wo(this, "isSelected", void 0), wo(this, "parent", void 0), wo(this, "children", void 0), wo(this, "content", void 0), wo(this, "state", void 0), wo(this, "layers", void 0), wo(this, "id", void 0), wo(this, "bbox", void 0), wo(this, "zoom", void 0), wo(this, "userData", void 0), wo(this, "_abortController", void 0), wo(this, "_loader", void 0), wo(this, "_loaderId", void 0), wo(this, "_isLoaded", void 0), wo(this, "_isCancelled", void 0), wo(this, "_needsReload", void 0), this.index = t, this.isVisible = !1, this.isSelected = !1, this.parent = null, this.children = [], this.content = null, this._loader = void 0, this._abortController = null, this._loaderId = 0, this._isLoaded = !1, this._isCancelled = !1, this._needsReload = !1
                 }
                 get data() {
                     return this.isLoading && this._loader ? this._loader.then((() => this.data)) : this.content
                 }
                 get isLoaded() {
                     return this._isLoaded && !this._needsReload
                 }
@@ -27355,15 +27160,15 @@
                     return Boolean(this._loader) && !this._isCancelled
                 }
                 get needsReload() {
                     return this._needsReload || this._isCancelled
                 }
                 get byteLength() {
                     const t = this.content ? this.content.byteLength : 0;
-                    return Number.isFinite(t) || console.error("byteLength not defined in tile data"), t
+                    return Number.isFinite(t) || ta.error("byteLength not defined in tile data")(), t
                 }
                 async _loadData({
                     getData: t,
                     requestScheduler: e,
                     onLoad: n,
                     onError: i
                 }) {
@@ -27404,70 +27209,70 @@
                     this.isLoading && (this.abort(), this._loader = void 0), this._needsReload = !0
                 }
                 abort() {
                     var t;
                     this.isLoaded || (this._isCancelled = !0, null === (t = this._abortController) || void 0 === t || t.abort())
                 }
             }
-            const ex = Math.PI / 180,
-                nx = 180 / Math.PI,
-                ix = 6370972,
-                rx = 256;
+            const J_ = Math.PI / 180,
+                $_ = 180 / Math.PI,
+                tx = 6370972,
+                ex = 256;
 
-            function sx() {
+            function nx() {
                 const t = 4018225162502676e-20,
-                    e = Math.PI / 180 * rx;
+                    e = Math.PI / 180 * ex;
                 return {
                     unitsPerMeter: [t, t, t],
                     unitsPerMeter2: [0, 0, 0],
                     metersPerUnit: [24886.609375, 24886.609375, 24886.609375],
                     unitsPerDegree: [e, e, t],
                     unitsPerDegree2: [0, 0, 0],
                     degreesPerUnit: [1 / e, 1 / e, 24886.609375]
                 }
             }
-            class ox extends Dh {
+            class ix extends zh {
                 constructor(t = {}) {
                     const {
                         latitude: e = 0,
                         longitude: n = 0,
                         zoom: i = 0,
                         nearZMultiplier: r = .1,
                         farZMultiplier: s = 2,
                         resolution: o = 10
                     } = t;
                     let {
                         height: a,
                         altitude: l = 1.5
                     } = t;
                     a = a || 1, l = Math.max(.75, l);
-                    const c = (new ih).lookAt({
+                    const c = (new $c).lookAt({
                             eye: [0, -l, 0],
                             up: [0, 0, 1]
                         }),
                         h = Math.pow(2, i);
-                    c.rotateX(e * ex), c.rotateZ(-n * ex), c.scale(h / a);
+                    c.rotateX(e * J_), c.rotateZ(-n * J_), c.scale(h / a);
                     const u = Math.atan(.5 / l),
                         d = 512 * h / a;
                     super({
                         ...t,
                         height: a,
                         viewMatrix: c,
                         longitude: n,
                         latitude: e,
                         zoom: i,
-                        distanceScales: sx(),
+                        distanceScales: nx(),
                         fovyRadians: 2 * u,
                         focalDistance: l,
                         near: r,
                         far: Math.min(2, 1 / d + 1) * l * s
                     }), wo(this, "longitude", void 0), wo(this, "latitude", void 0), wo(this, "resolution", void 0), this.latitude = e, this.longitude = n, this.resolution = o
                 }
                 get projectionMode() {
-                    return Rh.GLOBE
+                    return Ah.GLOBE
                 }
                 getDistanceScales() {
                     return this.distanceScales
                 }
                 getBounds(t = {}) {
                     const e = {
                             targetZ: t.z || 0
@@ -27482,40 +27287,40 @@
                     topLeft: e = !0,
                     targetZ: n
                 } = {}) {
                     const [i, r, s] = t, o = e ? r : this.height - r, {
                         pixelUnprojectionMatrix: a
                     } = this;
                     let l;
-                    if (Number.isFinite(s)) l = ax(a, [i, o, s, 1]);
+                    if (Number.isFinite(s)) l = rx(a, [i, o, s, 1]);
                     else {
-                        const t = ax(a, [i, o, -1, 1]),
-                            e = ax(a, [i, o, 1, 1]),
-                            r = ((n || 0) / ix + 1) * rx,
-                            s = Ac(Cc([], t, e)),
-                            c = Ac(t),
-                            h = Ac(e),
+                        const t = rx(a, [i, o, -1, 1]),
+                            e = rx(a, [i, o, 1, 1]),
+                            r = ((n || 0) / tx + 1) * ex,
+                            s = Sc(Ec([], t, e)),
+                            c = Sc(t),
+                            h = Sc(e),
                             u = (4 * c * h - (s - c - h) ** 2) / 16 * 4 / s;
                         l = function(t, e, n, i) {
                             var r = e[0],
                                 s = e[1],
                                 o = e[2];
                             return t[0] = r + i * (n[0] - r), t[1] = s + i * (n[1] - s), t[2] = o + i * (n[2] - o), t
                         }([], t, e, (Math.sqrt(c - u) - Math.sqrt(Math.max(0, r * r - u))) / Math.sqrt(s))
                     }
                     const [c, h, u] = this.unprojectPosition(l);
                     return Number.isFinite(s) ? [c, h, u] : Number.isFinite(n) ? [c, h, n] : [c, h]
                 }
                 projectPosition(t) {
-                    const [e, n, i = 0] = t, r = e * ex, s = n * ex, o = Math.cos(s), a = (i / ix + 1) * rx;
+                    const [e, n, i = 0] = t, r = e * J_, s = n * J_, o = Math.cos(s), a = (i / tx + 1) * ex;
                     return [Math.sin(r) * o * a, -Math.cos(r) * o * a, Math.sin(s) * a]
                 }
                 unprojectPosition(t) {
-                    const [e, n, i] = t, r = Tc(t), s = Math.asin(i / r);
-                    return [Math.atan2(e, -n) * nx, s * nx, (r / rx - 1) * ix]
+                    const [e, n, i] = t, r = Pc(t), s = Math.asin(i / r);
+                    return [Math.atan2(e, -n) * $_, s * $_, (r / ex - 1) * tx]
                 }
                 projectFlat(t) {
                     return t
                 }
                 unprojectFlat(t) {
                     return t
                 }
@@ -27524,84 +27329,84 @@
                     return {
                         longitude: t[0] - n[0] + this.longitude,
                         latitude: t[1] - n[1] + this.latitude
                     }
                 }
             }
 
-            function ax(t, e) {
-                const n = Qc([], e, t);
-                return Kc(n, n, 1 / n[3]), n
-            }
-            const lx = -1,
-                cx = new Ic,
-                hx = new Ic;
-            class ux {
+            function rx(t, e) {
+                const n = qc([], e, t);
+                return Zc(n, n, 1 / n[3]), n
+            }
+            const sx = -1,
+                ox = new Oc,
+                ax = new Oc;
+            class lx {
                 constructor(t = [0, 0, 0], e = [0, 0, 0], n) {
-                    wo(this, "center", void 0), wo(this, "halfDiagonal", void 0), wo(this, "minimum", void 0), wo(this, "maximum", void 0), n = n || cx.copy(t).add(e).scale(.5), this.center = new Ic(n), this.halfDiagonal = new Ic(e).subtract(this.center), this.minimum = new Ic(t), this.maximum = new Ic(e)
+                    wo(this, "center", void 0), wo(this, "halfDiagonal", void 0), wo(this, "minimum", void 0), wo(this, "maximum", void 0), n = n || ox.copy(t).add(e).scale(.5), this.center = new Oc(n), this.halfDiagonal = new Oc(e).subtract(this.center), this.minimum = new Oc(t), this.maximum = new Oc(e)
                 }
                 clone() {
-                    return new ux(this.minimum, this.maximum, this.center)
+                    return new lx(this.minimum, this.maximum, this.center)
                 }
                 equals(t) {
                     return this === t || Boolean(t) && this.minimum.equals(t.minimum) && this.maximum.equals(t.maximum)
                 }
                 transform(t) {
                     return this.center.transformAsPoint(t), this.halfDiagonal.transform(t), this.minimum.transform(t), this.maximum.transform(t), this
                 }
                 intersectPlane(t) {
                     const {
                         halfDiagonal: e
-                    } = this, n = hx.from(t.normal), i = e.x * Math.abs(n.x) + e.y * Math.abs(n.y) + e.z * Math.abs(n.z), r = this.center.dot(n) + t.distance;
-                    return r - i > 0 ? 1 : r + i < 0 ? lx : 0
+                    } = this, n = ax.from(t.normal), i = e.x * Math.abs(n.x) + e.y * Math.abs(n.y) + e.z * Math.abs(n.z), r = this.center.dot(n) + t.distance;
+                    return r - i > 0 ? 1 : r + i < 0 ? sx : 0
                 }
                 distanceTo(t) {
                     return Math.sqrt(this.distanceSquaredTo(t))
                 }
                 distanceSquaredTo(t) {
-                    const e = cx.from(t).subtract(this.center),
+                    const e = ox.from(t).subtract(this.center),
                         {
                             halfDiagonal: n
                         } = this;
                     let i, r = 0;
                     return i = Math.abs(e.x) - n.x, i > 0 && (r += i * i), i = Math.abs(e.y) - n.y, i > 0 && (r += i * i), i = Math.abs(e.z) - n.z, i > 0 && (r += i * i), r
                 }
             }
-            const dx = new Ic,
-                px = new Ic;
-            class fx {
+            const cx = new Oc,
+                hx = new Oc;
+            class ux {
                 constructor(t = [0, 0, 0], e = 0) {
-                    wo(this, "center", void 0), wo(this, "radius", void 0), this.radius = -0, this.center = new Ic, this.fromCenterRadius(t, e)
+                    wo(this, "center", void 0), wo(this, "radius", void 0), this.radius = -0, this.center = new Oc, this.fromCenterRadius(t, e)
                 }
                 fromCenterRadius(t, e) {
                     return this.center.from(t), this.radius = e, this
                 }
                 fromCornerPoints(t, e) {
-                    return e = dx.from(e), this.center = (new Ic).from(t).add(e).scale(.5), this.radius = this.center.distance(e), this
+                    return e = cx.from(e), this.center = (new Oc).from(t).add(e).scale(.5), this.radius = this.center.distance(e), this
                 }
                 equals(t) {
                     return this === t || Boolean(t) && this.center.equals(t.center) && this.radius === t.radius
                 }
                 clone() {
-                    return new fx(this.center, this.radius)
+                    return new ux(this.center, this.radius)
                 }
                 union(t) {
                     const e = this.center,
                         n = this.radius,
                         i = t.center,
                         r = t.radius,
-                        s = dx.copy(i).subtract(e),
+                        s = cx.copy(i).subtract(e),
                         o = s.magnitude();
                     if (n >= o + r) return this.clone();
                     if (r >= o + n) return t.clone();
                     const a = .5 * (n + o + r);
-                    return px.copy(s).scale((-n + a) / o).add(e), this.center.copy(px), this.radius = a, this
+                    return hx.copy(s).scale((-n + a) / o).add(e), this.center.copy(hx), this.radius = a, this
                 }
                 expand(t) {
-                    const e = dx.from(t).subtract(this.center).magnitude();
+                    const e = cx.from(t).subtract(this.center).magnitude();
                     return e > this.radius && (this.radius = e), this
                 }
                 transform(t) {
                     this.center.transform(t);
                     const e = function(t, e) {
                         var n = e[0],
                             i = e[1],
@@ -27609,34 +27414,34 @@
                             s = e[4],
                             o = e[5],
                             a = e[6],
                             l = e[8],
                             c = e[9],
                             h = e[10];
                         return t[0] = Math.hypot(n, i, r), t[1] = Math.hypot(s, o, a), t[2] = Math.hypot(l, c, h), t
-                    }(dx, t);
+                    }(cx, t);
                     return this.radius = Math.max(e[0], Math.max(e[1], e[2])) * this.radius, this
                 }
                 distanceSquaredTo(t) {
                     const e = this.distanceTo(t);
                     return e * e
                 }
                 distanceTo(t) {
-                    const e = dx.from(t).subtract(this.center);
+                    const e = cx.from(t).subtract(this.center);
                     return Math.max(0, e.len() - this.radius)
                 }
                 intersectPlane(t) {
                     const e = this.center,
                         n = this.radius,
                         i = t.normal.dot(e) + t.distance;
-                    return i < -n ? lx : i < n ? 0 : 1
+                    return i < -n ? sx : i < n ? 0 : 1
                 }
             }
 
-            function gx(t, e, n) {
+            function dx(t, e, n) {
                 var i = e[0],
                     r = e[1],
                     s = e[2],
                     o = e[3],
                     a = e[4],
                     l = e[5],
                     c = e[6],
@@ -27650,48 +27455,48 @@
                     v = n[5],
                     b = n[6],
                     y = n[7],
                     _ = n[8];
                 return t[0] = d * i + p * o + f * c, t[1] = d * r + p * a + f * h, t[2] = d * s + p * l + f * u, t[3] = g * i + m * o + v * c, t[4] = g * r + m * a + v * h, t[5] = g * s + m * l + v * u, t[6] = b * i + y * o + _ * c, t[7] = b * r + y * a + _ * h, t[8] = b * s + y * l + _ * u, t
             }
 
-            function mx(t, e, n) {
+            function px(t, e, n) {
                 var i = n[0],
                     r = n[1];
                 return t[0] = i * e[0], t[1] = i * e[1], t[2] = i * e[2], t[3] = r * e[3], t[4] = r * e[4], t[5] = r * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t
             }
-            var vx;
+            var fx;
             ! function(t) {
                 t[t.COL0ROW0 = 0] = "COL0ROW0", t[t.COL0ROW1 = 1] = "COL0ROW1", t[t.COL0ROW2 = 2] = "COL0ROW2", t[t.COL1ROW0 = 3] = "COL1ROW0", t[t.COL1ROW1 = 4] = "COL1ROW1", t[t.COL1ROW2 = 5] = "COL1ROW2", t[t.COL2ROW0 = 6] = "COL2ROW0", t[t.COL2ROW1 = 7] = "COL2ROW1", t[t.COL2ROW2 = 8] = "COL2ROW2"
-            }(vx || (vx = {}));
-            const bx = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
-            class yx extends Dc {
+            }(fx || (fx = {}));
+            const gx = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
+            class mx extends jc {
                 static get IDENTITY() {
-                    return xx || (xx = new yx, Object.freeze(xx)), xx
+                    return bx || (bx = new mx, Object.freeze(bx)), bx
                 }
                 static get ZERO() {
-                    return _x || (_x = new yx([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(_x)), _x
+                    return vx || (vx = new mx([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(vx)), vx
                 }
                 get ELEMENTS() {
                     return 9
                 }
                 get RANK() {
                     return 3
                 }
                 get INDICES() {
-                    return vx
+                    return fx
                 }
                 constructor(t, ...e) {
                     super(-0, -0, -0, -0, -0, -0, -0, -0, -0), 1 === arguments.length && Array.isArray(t) ? this.copy(t) : e.length > 0 ? this.copy([t, ...e]) : this.identity()
                 }
                 copy(t) {
                     return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this.check()
                 }
                 identity() {
-                    return this.copy(bx)
+                    return this.copy(gx)
                 }
                 fromObject(t) {
                     return this.check()
                 }
                 fromQuaternion(t) {
                     return function(t, e) {
                         var n = e[0],
@@ -27734,25 +27539,25 @@
                     }(this, this), this.check()
                 }
                 invert() {
                     var t, e, n, i, r, s, o, a, l, c, h, u, d, p, f;
                     return t = this, n = (e = this)[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], (f = n * (u = (h = e[8]) * o - a * c) + i * (d = -h * s + a * l) + r * (p = c * s - o * l)) && (f = 1 / f, t[0] = u * f, t[1] = (-h * i + r * c) * f, t[2] = (a * i - r * o) * f, t[3] = d * f, t[4] = (h * n - r * l) * f, t[5] = (-a * n + r * s) * f, t[6] = p * f, t[7] = (-c * n + i * l) * f, t[8] = (o * n - i * s) * f), this.check()
                 }
                 multiplyLeft(t) {
-                    return gx(this, t, this), this.check()
+                    return dx(this, t, this), this.check()
                 }
                 multiplyRight(t) {
-                    return gx(this, this, t), this.check()
+                    return dx(this, this, t), this.check()
                 }
                 rotate(t) {
                     var e, n, i, r, s, o, a, l, c, h, u, d, p, f;
                     return e = this, i = t, r = (n = this)[0], s = n[1], o = n[2], a = n[3], l = n[4], c = n[5], h = n[6], u = n[7], d = n[8], p = Math.sin(i), f = Math.cos(i), e[0] = f * r + p * a, e[1] = f * s + p * l, e[2] = f * o + p * c, e[3] = f * a - p * r, e[4] = f * l - p * s, e[5] = f * c - p * o, e[6] = h, e[7] = u, e[8] = d, this.check()
                 }
                 scale(t) {
-                    return Array.isArray(t) ? mx(this, this, t) : mx(this, this, [t, t]), this.check()
+                    return Array.isArray(t) ? px(this, this, t) : px(this, this, [t, t]), this.check()
                 }
                 translate(t) {
                     var e, n, i, r, s, o, a, l, c, h, u, d, p, f;
                     return e = this, i = t, r = (n = this)[0], s = n[1], o = n[2], a = n[3], l = n[4], c = n[5], h = n[6], u = n[7], d = n[8], p = i[0], f = i[1], e[0] = r, e[1] = s, e[2] = o, e[3] = a, e[4] = l, e[5] = c, e[6] = p * r + f * a + h, e[7] = p * s + f * l + u, e[8] = p * o + f * c + d, this.check()
                 }
                 transform(t, e) {
                     let n;
@@ -27761,147 +27566,147 @@
                             n = function(t, e, n) {
                                 var i = e[0],
                                     r = e[1];
                                 return t[0] = n[0] * i + n[3] * r + n[6], t[1] = n[1] * i + n[4] * r + n[7], t
                             }(e || [-0, -0], t, this);
                             break;
                         case 3:
-                            n = Pc(e || [-0, -0, -0], t, this);
+                            n = xc(e || [-0, -0, -0], t, this);
                             break;
                         case 4:
-                            n = Oc(e || [-0, -0, -0, -0], t, this);
+                            n = Tc(e || [-0, -0, -0, -0], t, this);
                             break;
                         default:
                             throw new Error("Illegal vector")
                     }
-                    return fc(n, t.length), n
+                    return uc(n, t.length), n
                 }
                 transformVector(t, e) {
                     return this.transform(t, e)
                 }
                 transformVector2(t, e) {
                     return this.transform(t, e)
                 }
                 transformVector3(t, e) {
                     return this.transform(t, e)
                 }
             }
-            let _x, xx, wx;
-            class Ex extends mc {
+            let vx, bx, yx;
+            class _x extends pc {
                 static get ZERO() {
-                    return wx || (wx = new Ex(0, 0, 0, 0), Object.freeze(wx)), wx
+                    return yx || (yx = new _x(0, 0, 0, 0), Object.freeze(yx)), yx
                 }
                 constructor(t = 0, e = 0, n = 0, i = 0) {
-                    super(-0, -0, -0, -0), lc(t) && 1 === arguments.length ? this.copy(t) : (oc.debug && (pc(t), pc(e), pc(n), pc(i)), this[0] = t, this[1] = e, this[2] = n, this[3] = i)
+                    super(-0, -0, -0, -0), sc(t) && 1 === arguments.length ? this.copy(t) : (ic.debug && (hc(t), hc(e), hc(n), hc(i)), this[0] = t, this[1] = e, this[2] = n, this[3] = i)
                 }
                 set(t, e, n, i) {
                     return this[0] = t, this[1] = e, this[2] = n, this[3] = i, this.check()
                 }
                 copy(t) {
                     return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check()
                 }
                 fromObject(t) {
-                    return oc.debug && (pc(t.x), pc(t.y), pc(t.z), pc(t.w)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this
+                    return ic.debug && (hc(t.x), hc(t.y), hc(t.z), hc(t.w)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this
                 }
                 toObject(t) {
                     return t.x = this[0], t.y = this[1], t.z = this[2], t.w = this[3], t
                 }
                 get ELEMENTS() {
                     return 4
                 }
                 get z() {
                     return this[2]
                 }
                 set z(t) {
-                    this[2] = pc(t)
+                    this[2] = hc(t)
                 }
                 get w() {
                     return this[3]
                 }
                 set w(t) {
-                    this[3] = pc(t)
+                    this[3] = hc(t)
                 }
                 transform(t) {
-                    return Ec(this, this, t), this.check()
+                    return _c(this, this, t), this.check()
                 }
                 transformByMatrix3(t) {
-                    return Oc(this, this, t), this.check()
+                    return Tc(this, this, t), this.check()
                 }
                 transformByMatrix2(t) {
                     return function(t, e, n) {
                         const i = e[0],
                             r = e[1];
                         t[0] = n[0] * i + n[2] * r, t[1] = n[1] * i + n[3] * r, t[2] = e[2], t[3] = e[3]
                     }(this, this, t), this.check()
                 }
                 transformByQuaternion(t) {
-                    return Sc(this, this, t), this.check()
+                    return wc(this, this, t), this.check()
                 }
                 applyMatrix4(t) {
                     return t.transform(this, this), this
                 }
             }
 
-            function Px() {
-                var t = new bc(4);
-                return bc != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t
+            function xx() {
+                var t = new gc(4);
+                return gc != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t
             }
 
-            function Sx(t, e, n) {
+            function wx(t, e, n) {
                 n *= .5;
                 var i = Math.sin(n);
                 return t[0] = i * e[0], t[1] = i * e[1], t[2] = i * e[2], t[3] = Math.cos(n), t
             }
 
-            function Cx(t, e, n) {
+            function Ex(t, e, n) {
                 var i = e[0],
                     r = e[1],
                     s = e[2],
                     o = e[3],
                     a = n[0],
                     l = n[1],
                     c = n[2],
                     h = n[3];
                 return t[0] = i * h + o * a + r * c - s * l, t[1] = r * h + o * l + s * a - i * c, t[2] = s * h + o * c + i * l - r * a, t[3] = o * h - i * a - r * l - s * c, t
             }
-            var Tx, Ax, Mx, Ox, Lx = Kc,
-                Rx = function(t) {
+            var Px, Sx, Cx, Tx, Ax = Zc,
+                Mx = function(t) {
                     var e = t[0],
                         n = t[1],
                         i = t[2],
                         r = t[3];
                     return Math.hypot(e, n, i, r)
                 },
-                Ix = function(t) {
+                Ox = function(t) {
                     var e = t[0],
                         n = t[1],
                         i = t[2],
                         r = t[3];
                     return e * e + n * n + i * i + r * r
                 },
-                kx = (Tx = yc(), Ax = _c(1, 0, 0), Mx = _c(0, 1, 0), function(t, e, n) {
-                    var i = xc(e, n);
-                    return i < -.999999 ? (wc(Tx, Ax, e), Tc(Tx) < 1e-6 && wc(Tx, Mx, e), function(t, e) {
+                Lx = (Px = mc(), Sx = vc(1, 0, 0), Cx = vc(0, 1, 0), function(t, e, n) {
+                    var i = bc(e, n);
+                    return i < -.999999 ? (yc(Px, Sx, e), Pc(Px) < 1e-6 && yc(Px, Cx, e), function(t, e) {
                         var n = e[0],
                             i = e[1],
                             r = e[2],
                             s = n * n + i * i + r * r;
                         s > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s
-                    }(Tx, Tx), Sx(t, Tx, Math.PI), t) : i > .999999 ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t) : (wc(Tx, e, n), t[0] = Tx[0], t[1] = Tx[1], t[2] = Tx[2], t[3] = 1 + i, function(t, e) {
+                    }(Px, Px), wx(t, Px, Math.PI), t) : i > .999999 ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t) : (yc(Px, e, n), t[0] = Px[0], t[1] = Px[1], t[2] = Px[2], t[3] = 1 + i, function(t, e) {
                         var n = e[0],
                             i = e[1],
                             r = e[2],
                             s = e[3],
                             o = n * n + i * i + r * r + s * s;
                         return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = n * o, t[1] = i * o, t[2] = r * o, t[3] = s * o, t
                     }(t, t))
                 });
-            Px(), Px(), Ox = new bc(9), bc != Float32Array && (Ox[1] = 0, Ox[2] = 0, Ox[3] = 0, Ox[5] = 0, Ox[6] = 0, Ox[7] = 0), Ox[0] = 1, Ox[4] = 1, Ox[8] = 1;
-            const jx = [0, 0, 0, 1];
-            class Fx extends dc {
+            xx(), xx(), Tx = new gc(9), gc != Float32Array && (Tx[1] = 0, Tx[2] = 0, Tx[3] = 0, Tx[5] = 0, Tx[6] = 0, Tx[7] = 0), Tx[0] = 1, Tx[4] = 1, Tx[8] = 1;
+            const kx = [0, 0, 0, 1];
+            class Rx extends cc {
                 constructor(t = 0, e = 0, n = 0, i = 1) {
                     super(-0, -0, -0, -0), Array.isArray(t) && 1 === arguments.length ? this.copy(t) : this.set(t, e, n, i)
                 }
                 copy(t) {
                     return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check()
                 }
                 set(t, e, n, i) {
@@ -27920,15 +27725,15 @@
                             var s = (r + 1) % 3,
                                 o = (r + 2) % 3;
                             n = Math.sqrt(e[3 * r + r] - e[3 * s + s] - e[3 * o + o] + 1), t[r] = .5 * n, n = .5 / n, t[3] = (e[3 * s + o] - e[3 * o + s]) * n, t[s] = (e[3 * s + r] + e[3 * r + s]) * n, t[o] = (e[3 * o + r] + e[3 * r + o]) * n
                         }
                     }(this, t), this.check()
                 }
                 fromAxisRotation(t, e) {
-                    return Sx(this, t, e), this.check()
+                    return wx(this, t, e), this.check()
                 }
                 identity() {
                     return function(t) {
                         t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1
                     }(this), this.check()
                 }
                 setAxisAngle(t, e) {
@@ -27937,47 +27742,47 @@
                 get ELEMENTS() {
                     return 4
                 }
                 get x() {
                     return this[0]
                 }
                 set x(t) {
-                    this[0] = pc(t)
+                    this[0] = hc(t)
                 }
                 get y() {
                     return this[1]
                 }
                 set y(t) {
-                    this[1] = pc(t)
+                    this[1] = hc(t)
                 }
                 get z() {
                     return this[2]
                 }
                 set z(t) {
-                    this[2] = pc(t)
+                    this[2] = hc(t)
                 }
                 get w() {
                     return this[3]
                 }
                 set w(t) {
-                    this[3] = pc(t)
+                    this[3] = hc(t)
                 }
                 len() {
-                    return Rx(this)
+                    return Mx(this)
                 }
                 lengthSquared() {
-                    return Ix(this)
+                    return Ox(this)
                 }
                 dot(t) {
                     return function(t, e) {
                         return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3]
                     }(this, t)
                 }
                 rotationTo(t, e) {
-                    return kx(this, t, e), this.check()
+                    return Lx(this, t, e), this.check()
                 }
                 add(t) {
                     return function(t, e, n) {
                         t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3]
                     }(this, this, t), this.check()
                 }
                 calculateW() {
@@ -28010,18 +27815,18 @@
                             s = e[1],
                             o = e[2],
                             a = e[3];
                         t[0] = r + i * (n[0] - r), t[1] = s + i * (n[1] - s), t[2] = o + i * (n[2] - o), t[3] = a + i * (n[3] - a)
                     }(this, t, e, n), this.check())
                 }
                 multiplyRight(t) {
-                    return Cx(this, this, t), this.check()
+                    return Ex(this, this, t), this.check()
                 }
                 multiplyLeft(t) {
-                    return Cx(this, t, this), this.check()
+                    return Ex(this, t, this), this.check()
                 }
                 normalize() {
                     const t = this.len(),
                         e = t > 0 ? 1 / t : 0;
                     return this[0] = this[0] * e, this[1] = this[1] * e, this[2] = this[2] * e, this[3] = this[3] * e, 0 === t && (this[3] = 1), this.check()
                 }
                 rotateX(t) {
@@ -28057,22 +27862,22 @@
                             o = e[3],
                             a = Math.sin(n),
                             l = Math.cos(n);
                         t[0] = i * l + r * a, t[1] = r * l - i * a, t[2] = s * l + o * a, t[3] = o * l - s * a
                     }(this, this, t), this.check()
                 }
                 scale(t) {
-                    return Lx(this, this, t), this.check()
+                    return Ax(this, this, t), this.check()
                 }
                 slerp(t, e, n) {
                     let i, r, s;
                     switch (arguments.length) {
                         case 1:
                             ({
-                                start: i = jx,
+                                start: i = kx,
                                 target: r,
                                 ratio: s
                             } = t);
                             break;
                         case 2:
                             i = this, r = t, s = e;
                             break;
@@ -28084,234 +27889,234 @@
                             h = e[1],
                             u = e[2],
                             d = e[3],
                             p = n[0],
                             f = n[1],
                             g = n[2],
                             m = n[3];
-                        (s = c * p + h * f + u * g + d * m) < 0 && (s = -s, p = -p, f = -f, g = -g, m = -m), 1 - s > vc ? (r = Math.acos(s), o = Math.sin(r), a = Math.sin((1 - i) * r) / o, l = Math.sin(i * r) / o) : (a = 1 - i, l = i), t[0] = a * c + l * p, t[1] = a * h + l * f, t[2] = a * u + l * g, t[3] = a * d + l * m
+                        (s = c * p + h * f + u * g + d * m) < 0 && (s = -s, p = -p, f = -f, g = -g, m = -m), 1 - s > fc ? (r = Math.acos(s), o = Math.sin(r), a = Math.sin((1 - i) * r) / o, l = Math.sin(i * r) / o) : (a = 1 - i, l = i), t[0] = a * c + l * p, t[1] = a * h + l * f, t[2] = a * u + l * g, t[3] = a * d + l * m
                     }(this, i, r, s), this.check()
                 }
-                transformVector4(t, e = new Ex) {
+                transformVector4(t, e = new _x) {
                     return function(t, e, n) {
                         var i = e[0],
                             r = e[1],
                             s = e[2],
                             o = n[0],
                             a = n[1],
                             l = n[2],
                             c = n[3],
                             h = c * i + a * s - l * r,
                             u = c * r + l * i - o * s,
                             d = c * s + o * r - a * i,
                             p = -o * i - a * r - l * s;
                         t[0] = h * c + p * -o + u * -l - d * -a, t[1] = u * c + p * -a + d * -o - h * -l, t[2] = d * c + p * -l + h * -a - u * -o, t[3] = e[3]
-                    }(e, t, this), fc(e, 4)
+                    }(e, t, this), uc(e, 4)
                 }
                 lengthSq() {
                     return this.lengthSquared()
                 }
                 setFromAxisAngle(t, e) {
                     return this.setAxisAngle(t, e)
                 }
                 premultiply(t) {
                     return this.multiplyLeft(t)
                 }
                 multiply(t) {
                     return this.multiplyRight(t)
                 }
             }
-            const zx = new Ic,
-                Bx = new Ic,
-                Dx = new Ic,
-                Nx = new Ic,
-                Vx = new Ic,
-                Ux = new Ic,
-                Gx = new Ic;
-            class Wx {
+            const Ix = new Oc,
+                jx = new Oc,
+                Fx = new Oc,
+                zx = new Oc,
+                Bx = new Oc,
+                Dx = new Oc,
+                Nx = new Oc;
+            class Vx {
                 constructor(t = [0, 0, 0], e = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
-                    wo(this, "center", void 0), wo(this, "halfAxes", void 0), this.center = (new Ic).from(t), this.halfAxes = new yx(e)
+                    wo(this, "center", void 0), wo(this, "halfAxes", void 0), this.center = (new Oc).from(t), this.halfAxes = new mx(e)
                 }
                 get halfSize() {
                     const t = this.halfAxes.getColumn(0),
                         e = this.halfAxes.getColumn(1),
                         n = this.halfAxes.getColumn(2);
-                    return [new Ic(t).len(), new Ic(e).len(), new Ic(n).len()]
+                    return [new Oc(t).len(), new Oc(e).len(), new Oc(n).len()]
                 }
                 get quaternion() {
                     const t = this.halfAxes.getColumn(0),
                         e = this.halfAxes.getColumn(1),
                         n = this.halfAxes.getColumn(2),
-                        i = new Ic(t).normalize(),
-                        r = new Ic(e).normalize(),
-                        s = new Ic(n).normalize();
-                    return (new Fx).fromMatrix3(new yx([...i, ...r, ...s]))
+                        i = new Oc(t).normalize(),
+                        r = new Oc(e).normalize(),
+                        s = new Oc(n).normalize();
+                    return (new Rx).fromMatrix3(new mx([...i, ...r, ...s]))
                 }
                 fromCenterHalfSizeQuaternion(t, e, n) {
-                    const i = new Fx(n),
-                        r = (new yx).fromQuaternion(i);
-                    return r[0] = r[0] * e[0], r[1] = r[1] * e[0], r[2] = r[2] * e[0], r[3] = r[3] * e[1], r[4] = r[4] * e[1], r[5] = r[5] * e[1], r[6] = r[6] * e[2], r[7] = r[7] * e[2], r[8] = r[8] * e[2], this.center = (new Ic).from(t), this.halfAxes = r, this
+                    const i = new Rx(n),
+                        r = (new mx).fromQuaternion(i);
+                    return r[0] = r[0] * e[0], r[1] = r[1] * e[0], r[2] = r[2] * e[0], r[3] = r[3] * e[1], r[4] = r[4] * e[1], r[5] = r[5] * e[1], r[6] = r[6] * e[2], r[7] = r[7] * e[2], r[8] = r[8] * e[2], this.center = (new Oc).from(t), this.halfAxes = r, this
                 }
                 clone() {
-                    return new Wx(this.center, this.halfAxes)
+                    return new Vx(this.center, this.halfAxes)
                 }
                 equals(t) {
                     return this === t || Boolean(t) && this.center.equals(t.center) && this.halfAxes.equals(t.halfAxes)
                 }
-                getBoundingSphere(t = new fx) {
+                getBoundingSphere(t = new ux) {
                     const e = this.halfAxes,
-                        n = e.getColumn(0, Dx),
-                        i = e.getColumn(1, Nx),
-                        r = e.getColumn(2, Vx),
-                        s = zx.copy(n).add(i).add(r);
+                        n = e.getColumn(0, Fx),
+                        i = e.getColumn(1, zx),
+                        r = e.getColumn(2, Bx),
+                        s = Ix.copy(n).add(i).add(r);
                     return t.center.copy(this.center), t.radius = s.magnitude(), t
                 }
                 intersectPlane(t) {
                     const e = this.center,
                         n = t.normal,
                         i = this.halfAxes,
                         r = n.x,
                         s = n.y,
                         o = n.z,
                         a = Math.abs(r * i[0] + s * i[1] + o * i[2]) + Math.abs(r * i[3] + s * i[4] + o * i[5]) + Math.abs(r * i[6] + s * i[7] + o * i[8]),
                         l = n.dot(e) + t.distance;
-                    return l <= -a ? lx : l >= a ? 1 : 0
+                    return l <= -a ? sx : l >= a ? 1 : 0
                 }
                 distanceTo(t) {
                     return Math.sqrt(this.distanceSquaredTo(t))
                 }
                 distanceSquaredTo(t) {
-                    const e = Bx.from(t).subtract(this.center),
+                    const e = jx.from(t).subtract(this.center),
                         n = this.halfAxes,
-                        i = n.getColumn(0, Dx),
-                        r = n.getColumn(1, Nx),
-                        s = n.getColumn(2, Vx),
+                        i = n.getColumn(0, Fx),
+                        r = n.getColumn(1, zx),
+                        s = n.getColumn(2, Bx),
                         o = i.magnitude(),
                         a = r.magnitude(),
                         l = s.magnitude();
                     i.normalize(), r.normalize(), s.normalize();
                     let c, h = 0;
                     return c = Math.abs(e.dot(i)) - o, c > 0 && (h += c * c), c = Math.abs(e.dot(r)) - a, c > 0 && (h += c * c), c = Math.abs(e.dot(s)) - l, c > 0 && (h += c * c), h
                 }
                 computePlaneDistances(t, e, n = [-0, -0]) {
                     let i = Number.POSITIVE_INFINITY,
                         r = Number.NEGATIVE_INFINITY;
                     const s = this.center,
                         o = this.halfAxes,
-                        a = o.getColumn(0, Dx),
-                        l = o.getColumn(1, Nx),
-                        c = o.getColumn(2, Vx),
-                        h = Ux.copy(a).add(l).add(c).add(s),
-                        u = Gx.copy(h).subtract(t);
+                        a = o.getColumn(0, Fx),
+                        l = o.getColumn(1, zx),
+                        c = o.getColumn(2, Bx),
+                        h = Dx.copy(a).add(l).add(c).add(s),
+                        u = Nx.copy(h).subtract(t);
                     let d = e.dot(u);
                     return i = Math.min(d, i), r = Math.max(d, r), h.copy(s).add(a).add(l).subtract(c), u.copy(h).subtract(t), d = e.dot(u), i = Math.min(d, i), r = Math.max(d, r), h.copy(s).add(a).subtract(l).add(c), u.copy(h).subtract(t), d = e.dot(u), i = Math.min(d, i), r = Math.max(d, r), h.copy(s).add(a).subtract(l).subtract(c), u.copy(h).subtract(t), d = e.dot(u), i = Math.min(d, i), r = Math.max(d, r), s.copy(h).subtract(a).add(l).add(c), u.copy(h).subtract(t), d = e.dot(u), i = Math.min(d, i), r = Math.max(d, r), s.copy(h).subtract(a).add(l).subtract(c), u.copy(h).subtract(t), d = e.dot(u), i = Math.min(d, i), r = Math.max(d, r), s.copy(h).subtract(a).subtract(l).add(c), u.copy(h).subtract(t), d = e.dot(u), i = Math.min(d, i), r = Math.max(d, r), s.copy(h).subtract(a).subtract(l).subtract(c), u.copy(h).subtract(t), d = e.dot(u), i = Math.min(d, i), r = Math.max(d, r), n[0] = i, n[1] = r, n
                 }
                 transform(t) {
                     this.center.transformAsPoint(t);
-                    const e = this.halfAxes.getColumn(0, Dx);
+                    const e = this.halfAxes.getColumn(0, Fx);
                     e.transformAsPoint(t);
-                    const n = this.halfAxes.getColumn(1, Nx);
+                    const n = this.halfAxes.getColumn(1, zx);
                     n.transformAsPoint(t);
-                    const i = this.halfAxes.getColumn(2, Vx);
-                    return i.transformAsPoint(t), this.halfAxes = new yx([...e, ...n, ...i]), this
+                    const i = this.halfAxes.getColumn(2, Bx);
+                    return i.transformAsPoint(t), this.halfAxes = new mx([...e, ...n, ...i]), this
                 }
                 getTransform() {
                     throw new Error("not implemented")
                 }
             }
-            const Hx = new Ic,
-                Zx = new Ic;
-            class qx {
+            const Ux = new Oc,
+                Gx = new Oc;
+            class Wx {
                 constructor(t = [0, 0, 1], e = 0) {
-                    wo(this, "normal", void 0), wo(this, "distance", void 0), this.normal = new Ic, this.distance = -0, this.fromNormalDistance(t, e)
+                    wo(this, "normal", void 0), wo(this, "distance", void 0), this.normal = new Oc, this.distance = -0, this.fromNormalDistance(t, e)
                 }
                 fromNormalDistance(t, e) {
-                    return gc(Number.isFinite(e)), this.normal.from(t).normalize(), this.distance = e, this
+                    return dc(Number.isFinite(e)), this.normal.from(t).normalize(), this.distance = e, this
                 }
                 fromPointNormal(t, e) {
-                    t = Hx.from(t), this.normal.from(e).normalize();
+                    t = Ux.from(t), this.normal.from(e).normalize();
                     const n = -this.normal.dot(t);
                     return this.distance = n, this
                 }
                 fromCoefficients(t, e, n, i) {
-                    return this.normal.set(t, e, n), gc(uc(this.normal.len(), 1)), this.distance = i, this
+                    return this.normal.set(t, e, n), dc(lc(this.normal.len(), 1)), this.distance = i, this
                 }
                 clone() {
-                    return new qx(this.normal, this.distance)
+                    return new Wx(this.normal, this.distance)
                 }
                 equals(t) {
-                    return uc(this.distance, t.distance) && uc(this.normal, t.normal)
+                    return lc(this.distance, t.distance) && lc(this.normal, t.normal)
                 }
                 getPointDistance(t) {
                     return this.normal.dot(t) + this.distance
                 }
                 transform(t) {
-                    const e = Zx.copy(this.normal).transformAsVector(t).normalize(),
+                    const e = Gx.copy(this.normal).transformAsVector(t).normalize(),
                         n = this.normal.scale(-this.distance).transform(t);
                     return this.fromPointNormal(n, e)
                 }
                 projectPointOntoPlane(t, e = [0, 0, 0]) {
-                    t = Hx.from(t);
+                    t = Ux.from(t);
                     const n = this.getPointDistance(t),
-                        i = Zx.copy(this.normal).scale(n);
+                        i = Gx.copy(this.normal).scale(n);
                     return t.subtract(i).to(e)
                 }
             }
-            const Xx = [new Ic([1, 0, 0]), new Ic([0, 1, 0]), new Ic([0, 0, 1])],
-                Yx = new Ic,
-                Kx = new Ic;
-            new qx(new Ic(1, 0, 0), 0);
-            class Qx {
+            const Hx = [new Oc([1, 0, 0]), new Oc([0, 1, 0]), new Oc([0, 0, 1])],
+                Zx = new Oc,
+                qx = new Oc;
+            new Wx(new Oc(1, 0, 0), 0);
+            class Xx {
                 constructor(t = []) {
                     wo(this, "planes", void 0), this.planes = t
                 }
                 fromBoundingSphere(t) {
-                    this.planes.length = 2 * Xx.length;
+                    this.planes.length = 2 * Hx.length;
                     const e = t.center,
                         n = t.radius;
                     let i = 0;
-                    for (const t of Xx) {
+                    for (const t of Hx) {
                         let r = this.planes[i],
                             s = this.planes[i + 1];
-                        r || (r = this.planes[i] = new qx), s || (s = this.planes[i + 1] = new qx);
-                        const o = Yx.copy(t).scale(-n).add(e);
+                        r || (r = this.planes[i] = new Wx), s || (s = this.planes[i + 1] = new Wx);
+                        const o = Zx.copy(t).scale(-n).add(e);
                         t.dot(o), r.fromPointNormal(o, t);
-                        const a = Yx.copy(t).scale(n).add(e),
-                            l = Kx.copy(t).negate();
+                        const a = Zx.copy(t).scale(n).add(e),
+                            l = qx.copy(t).negate();
                         l.dot(a), s.fromPointNormal(a, l), i += 2
                     }
                     return this
                 }
                 computeVisibility(t) {
                     let e = 1;
                     for (const n of this.planes) switch (t.intersectPlane(n)) {
-                        case lx:
-                            return lx;
+                        case sx:
+                            return sx;
                         case 0:
                             e = 0
                     }
                     return e
                 }
                 computeVisibilityWithPlaneMask(t, e) {
-                    if (gc(Number.isFinite(e), "parentPlaneMask is required."), e === Qx.MASK_OUTSIDE || e === Qx.MASK_INSIDE) return e;
-                    let n = Qx.MASK_INSIDE;
+                    if (dc(Number.isFinite(e), "parentPlaneMask is required."), e === Xx.MASK_OUTSIDE || e === Xx.MASK_INSIDE) return e;
+                    let n = Xx.MASK_INSIDE;
                     const i = this.planes;
                     for (let r = 0; r < this.planes.length; ++r) {
                         const s = r < 31 ? 1 << r : 0;
                         if (r < 31 && 0 == (e & s)) continue;
                         const o = i[r],
                             a = t.intersectPlane(o);
-                        if (a === lx) return Qx.MASK_OUTSIDE;
+                        if (a === sx) return Xx.MASK_OUTSIDE;
                         0 === a && (n |= s)
                     }
                     return n
                 }
             }
-            wo(Qx, "MASK_OUTSIDE", 4294967295), wo(Qx, "MASK_INSIDE", 0), wo(Qx, "MASK_INDETERMINATE", 2147483647), new Ic, new Ic, new Ic, new Ic, new Ic, new Ic, new Ic, new Ic, new Ic, new Ic, new Ic, new Ic, new Ic, new Ic, new Ic, new Ic, new Ic, Math.PI;
-            const Jx = {
+            wo(Xx, "MASK_OUTSIDE", 4294967295), wo(Xx, "MASK_INSIDE", 0), wo(Xx, "MASK_INDETERMINATE", 2147483647), new Oc, new Oc, new Oc, new Oc, new Oc, new Oc, new Oc, new Oc, new Oc, new Oc, new Oc, new Oc, new Oc, new Oc, new Oc, new Oc, new Oc, Math.PI;
+            const Yx = {
                     EPSILON1: .1,
                     EPSILON2: .01,
                     EPSILON3: .001,
                     EPSILON4: 1e-4,
                     EPSILON5: 1e-5,
                     EPSILON6: 1e-6,
                     EPSILON7: 1e-7,
@@ -28329,88 +28134,88 @@
                     EPSILON19: 1e-19,
                     EPSILON20: 1e-20,
                     PI_OVER_TWO: Math.PI / 2,
                     PI_OVER_FOUR: Math.PI / 4,
                     PI_OVER_SIX: Math.PI / 6,
                     TWO_PI: 2 * Math.PI
                 },
-                $x = new yx,
-                tw = new yx,
-                ew = new yx,
-                nw = new yx,
-                iw = new yx;
-            const rw = [1, 0, 0],
-                sw = [2, 2, 1];
+                Kx = new mx,
+                Qx = new mx,
+                Jx = new mx,
+                $x = new mx,
+                tw = new mx;
+            const ew = [1, 0, 0],
+                nw = [2, 2, 1];
 
-            function ow(t) {
+            function iw(t) {
                 let e = 0;
                 for (let n = 0; n < 3; ++n) {
-                    const i = t[$x.getElementIndex(sw[n], rw[n])];
+                    const i = t[Kx.getElementIndex(nw[n], ew[n])];
                     e += 2 * i * i
                 }
                 return Math.sqrt(e)
             }
 
-            function aw(t, e) {
-                const n = Jx.EPSILON15;
+            function rw(t, e) {
+                const n = Yx.EPSILON15;
                 let i = 0,
                     r = 1;
                 for (let e = 0; e < 3; ++e) {
-                    const n = Math.abs(t[$x.getElementIndex(sw[e], rw[e])]);
+                    const n = Math.abs(t[Kx.getElementIndex(nw[e], ew[e])]);
                     n > i && (r = e, i = n)
                 }
-                const s = rw[r],
-                    o = sw[r];
+                const s = ew[r],
+                    o = nw[r];
                 let a = 1,
                     l = 0;
-                if (Math.abs(t[$x.getElementIndex(o, s)]) > n) {
-                    const e = (t[$x.getElementIndex(o, o)] - t[$x.getElementIndex(s, s)]) / 2 / t[$x.getElementIndex(o, s)];
+                if (Math.abs(t[Kx.getElementIndex(o, s)]) > n) {
+                    const e = (t[Kx.getElementIndex(o, o)] - t[Kx.getElementIndex(s, s)]) / 2 / t[Kx.getElementIndex(o, s)];
                     let n;
                     n = e < 0 ? -1 / (-e + Math.sqrt(1 + e * e)) : 1 / (e + Math.sqrt(1 + e * e)), a = 1 / Math.sqrt(1 + n * n), l = n * a
                 }
-                return yx.IDENTITY.to(e), e[$x.getElementIndex(s, s)] = e[$x.getElementIndex(o, o)] = a, e[$x.getElementIndex(o, s)] = l, e[$x.getElementIndex(s, o)] = -l, e
+                return mx.IDENTITY.to(e), e[Kx.getElementIndex(s, s)] = e[Kx.getElementIndex(o, o)] = a, e[Kx.getElementIndex(o, s)] = l, e[Kx.getElementIndex(s, o)] = -l, e
             }
-            const lw = new Ic,
-                cw = new Ic,
-                hw = new Ic,
-                uw = new Ic,
-                dw = new Ic,
-                pw = new yx,
-                fw = {
-                    diagonal: new yx,
-                    unitary: new yx
+            const sw = new Oc,
+                ow = new Oc,
+                aw = new Oc,
+                lw = new Oc,
+                cw = new Oc,
+                hw = new mx,
+                uw = {
+                    diagonal: new mx,
+                    unitary: new mx
                 },
-                gw = 512,
-                mw = [
+                dw = 512,
+                pw = [
                     [.5, .5],
                     [0, 0],
                     [0, 1],
                     [1, 0],
                     [1, 1]
                 ],
-                vw = mw.concat([
+                fw = pw.concat([
                     [0, .5],
                     [.5, 0],
                     [1, .5],
                     [.5, 1]
                 ]),
-                bw = vw.concat([
+                gw = fw.concat([
                     [.25, .5],
                     [.75, .5]
                 ]);
-            class yw {
+            class mw {
                 constructor(t, e, n) {
                     wo(this, "x", void 0), wo(this, "y", void 0), wo(this, "z", void 0), wo(this, "childVisible", void 0), wo(this, "selected", void 0), wo(this, "_children", void 0), this.x = t, this.y = e, this.z = n
                 }
                 get children() {
                     if (!this._children) {
                         const t = 2 * this.x,
                             e = 2 * this.y,
                             n = this.z + 1;
-                        this._children = [new yw(t, e, n), new yw(t, e + 1, n), new yw(t + 1, e, n), new yw(t + 1, e + 1, n)]
+                        this._children = [new mw(t, e, n), new mw(t, e + 1, n), new mw(t + 1, e, n), new mw(t + 1, e + 1, n)]
                     }
                     return this._children
                 }
                 update(t) {
                     const {
                         viewport: e,
                         cullingVolume: n,
@@ -28440,209 +28245,213 @@
                 getSelected(t = []) {
                     if (this.selected && t.push(this), this._children)
                         for (const e of this._children) e.getSelected(t);
                     return t
                 }
                 insideBounds([t, e, n, i]) {
                     const r = Math.pow(2, this.z),
-                        s = gw / r;
+                        s = dw / r;
                     return this.x * s < n && this.y * s < i && (this.x + 1) * s > t && (this.y + 1) * s > e
                 }
                 getBoundingVolume(t, e, n) {
                     if (n) {
-                        const e = this.z < 1 ? bw : this.z < 2 ? vw : mw,
+                        const e = this.z < 1 ? gw : this.z < 2 ? fw : pw,
                             i = [];
                         for (const r of e) {
-                            const e = Tw(this.x + r[0], this.y + r[1], this.z);
+                            const e = Ew(this.x + r[0], this.y + r[1], this.z);
                             e[2] = t[0], i.push(n(e)), t[0] !== t[1] && (e[2] = t[1], i.push(n(e)))
                         }
-                        return function(t, e = new Wx) {
-                            if (!t || 0 === t.length) return e.halfAxes = new yx([0, 0, 0, 0, 0, 0, 0, 0, 0]), e.center = new Ic, e;
+                        return function(t, e = new Vx) {
+                            if (!t || 0 === t.length) return e.halfAxes = new mx([0, 0, 0, 0, 0, 0, 0, 0, 0]), e.center = new Oc, e;
                             const n = t.length,
-                                i = new Ic(0, 0, 0);
+                                i = new Oc(0, 0, 0);
                             for (const e of t) i.add(e);
                             const r = 1 / n;
                             i.multiplyByScalar(r);
                             let s = 0,
                                 o = 0,
                                 a = 0,
                                 l = 0,
                                 c = 0,
                                 h = 0;
                             for (const e of t) {
-                                const t = lw.copy(e).subtract(i);
+                                const t = sw.copy(e).subtract(i);
                                 s += t.x * t.x, o += t.x * t.y, a += t.x * t.z, l += t.y * t.y, c += t.y * t.z, h += t.z * t.z
                             }
                             s *= r, o *= r, a *= r, l *= r, c *= r, h *= r;
-                            const u = pw;
+                            const u = hw;
                             u[0] = s, u[1] = o, u[2] = a, u[3] = o, u[4] = l, u[5] = c, u[6] = a, u[7] = c, u[8] = h;
                             const {
                                 unitary: d
                             } = function(t, e = {}) {
-                                const n = Jx.EPSILON20;
+                                const n = Yx.EPSILON20;
                                 let i = 0,
                                     r = 0;
-                                const s = tw,
-                                    o = ew;
+                                const s = Qx,
+                                    o = Jx;
                                 s.identity(), o.copy(t);
                                 const a = n * function(t) {
                                     let e = 0;
                                     for (let n = 0; n < 9; ++n) {
                                         const i = t[n];
                                         e += i * i
                                     }
                                     return Math.sqrt(e)
                                 }(o);
-                                for (; r < 10 && ow(o) > a;) aw(o, nw), iw.copy(nw).transpose(), o.multiplyRight(nw), o.multiplyLeft(iw), s.multiplyRight(nw), ++i > 2 && (++r, i = 0);
+                                for (; r < 10 && iw(o) > a;) rw(o, $x), tw.copy($x).transpose(), o.multiplyRight($x), o.multiplyLeft(tw), s.multiplyRight($x), ++i > 2 && (++r, i = 0);
                                 return e.unitary = s.toTarget(e.unitary), e.diagonal = o.toTarget(e.diagonal), e
-                            }(u, fw), p = e.halfAxes.copy(d);
-                            let f = p.getColumn(0, hw),
-                                g = p.getColumn(1, uw),
-                                m = p.getColumn(2, dw),
+                            }(u, uw), p = e.halfAxes.copy(d);
+                            let f = p.getColumn(0, aw),
+                                g = p.getColumn(1, lw),
+                                m = p.getColumn(2, cw),
                                 v = -Number.MAX_VALUE,
                                 b = -Number.MAX_VALUE,
                                 y = -Number.MAX_VALUE,
                                 _ = Number.MAX_VALUE,
                                 x = Number.MAX_VALUE,
                                 w = Number.MAX_VALUE;
-                            for (const e of t) lw.copy(e), v = Math.max(lw.dot(f), v), b = Math.max(lw.dot(g), b), y = Math.max(lw.dot(m), y), _ = Math.min(lw.dot(f), _), x = Math.min(lw.dot(g), x), w = Math.min(lw.dot(m), w);
+                            for (const e of t) sw.copy(e), v = Math.max(sw.dot(f), v), b = Math.max(sw.dot(g), b), y = Math.max(sw.dot(m), y), _ = Math.min(sw.dot(f), _), x = Math.min(sw.dot(g), x), w = Math.min(sw.dot(m), w);
                             f = f.multiplyByScalar(.5 * (_ + v)), g = g.multiplyByScalar(.5 * (x + b)), m = m.multiplyByScalar(.5 * (w + y)), e.center.copy(f).add(g).add(m);
-                            const E = cw.set(v - _, b - x, y - w).multiplyByScalar(.5),
-                                P = new yx([E[0], 0, 0, 0, E[1], 0, 0, 0, E[2]]);
+                            const E = ow.set(v - _, b - x, y - w).multiplyByScalar(.5),
+                                P = new mx([E[0], 0, 0, 0, E[1], 0, 0, 0, E[2]]);
                             return e.halfAxes.multiplyRight(P), e
                         }(i)
                     }
                     const i = Math.pow(2, this.z),
-                        r = gw / i,
-                        s = this.x * r + e * gw,
-                        o = gw - (this.y + 1) * r;
-                    return new ux([s, o, t[0]], [s + r, o + r, t[1]])
+                        r = dw / i,
+                        s = this.x * r + e * dw,
+                        o = dw - (this.y + 1) * r;
+                    return new lx([s, o, t[0]], [s + r, o + r, t[1]])
                 }
             }
-            const _w = 512,
-                xw = [-1 / 0, -1 / 0, 1 / 0, 1 / 0],
-                ww = {
-                    type: "object",
+            const vw = 512,
+                bw = [-1 / 0, -1 / 0, 1 / 0, 1 / 0],
+                yw = {
+                    type: "url",
                     value: null,
                     validate: (t, e) => e.optional && null === t || "string" == typeof t || Array.isArray(t) && t.every((t => "string" == typeof t)),
-                    equal: (t, e) => {
+                    equals: (t, e) => {
                         if (t === e) return !0;
                         if (!Array.isArray(t) || !Array.isArray(e)) return !1;
                         const n = t.length;
                         if (n !== e.length) return !1;
                         for (let i = 0; i < n; i++)
                             if (t[i] !== e[i]) return !1;
                         return !0
                     }
                 };
 
-            function Ew(t, e) {
+            function _w(t, e) {
                 const n = [e.transformAsPoint([t[0], t[1]]), e.transformAsPoint([t[2], t[1]]), e.transformAsPoint([t[0], t[3]]), e.transformAsPoint([t[2], t[3]])];
                 return [Math.min(...n.map((t => t[0]))), Math.min(...n.map((t => t[1]))), Math.max(...n.map((t => t[0]))), Math.max(...n.map((t => t[1])))]
             }
 
-            function Pw({
+            function xw({
                 viewport: t,
-                z: e = 0,
+                z: e,
                 cullRect: n
             }) {
-                return (t.subViewports || [t]).map((t => Sw(t, e, n)))
-            }
-
-            function Sw(t, e, n) {
+                const i = n.x - t.x,
+                    r = n.y - t.y,
+                    {
+                        width: s,
+                        height: o
+                    } = n;
                 if (!Array.isArray(e)) {
-                    const i = n.x - t.x,
-                        r = n.y - t.y,
-                        {
-                            width: s,
-                            height: o
-                        } = n,
-                        a = {
-                            targetZ: e
+                    const n = {
+                            targetZ: e || 0
                         },
-                        l = t.unproject([i, r], a),
-                        c = t.unproject([i + s, r], a),
-                        h = t.unproject([i, r + o], a),
-                        u = t.unproject([i + s, r + o], a);
-                    return [Math.min(l[0], c[0], h[0], u[0]), Math.min(l[1], c[1], h[1], u[1]), Math.max(l[0], c[0], h[0], u[0]), Math.max(l[1], c[1], h[1], u[1])]
+                        a = t.unproject([i, r], n),
+                        l = t.unproject([i + s, r], n),
+                        c = t.unproject([i, r + o], n),
+                        h = t.unproject([i + s, r + o], n);
+                    return [Math.min(a[0], l[0], c[0], h[0]), Math.min(a[1], l[1], c[1], h[1]), Math.max(a[0], l[0], c[0], h[0]), Math.max(a[1], l[1], c[1], h[1])]
                 }
-                const i = Sw(t, e[0], n),
-                    r = Sw(t, e[1], n);
-                return [Math.min(i[0], r[0]), Math.min(i[1], r[1]), Math.max(i[2], r[2]), Math.max(i[3], r[3])]
+                const a = xw({
+                        viewport: t,
+                        z: e[0],
+                        cullRect: n
+                    }),
+                    l = xw({
+                        viewport: t,
+                        z: e[1],
+                        cullRect: n
+                    });
+                return [Math.min(a[0], l[0]), Math.min(a[1], l[1]), Math.max(a[2], l[2]), Math.max(a[3], l[3])]
             }
 
-            function Cw(t, e) {
-                return Math.pow(2, t) * _w / e
+            function ww(t, e) {
+                return Math.pow(2, t) * vw / e
             }
 
-            function Tw(t, e, n) {
-                const i = Cw(n, _w),
+            function Ew(t, e, n) {
+                const i = ww(n, vw),
                     r = t / i * 360 - 180,
                     s = Math.PI - 2 * Math.PI * e / i;
                 return [r, 180 / Math.PI * Math.atan(.5 * (Math.exp(s) - Math.exp(-s)))]
             }
 
-            function Aw(t, e, n, i) {
-                const r = Cw(n, i);
-                return [t / r * _w, e / r * _w]
+            function Pw(t, e, n, i) {
+                const r = ww(n, i);
+                return [t / r * vw, e / r * vw]
             }
 
-            function Mw(t, e, n, i, r = _w) {
+            function Sw(t, e, n, i, r = vw) {
                 if (t.isGeospatial) {
-                    const [t, r] = Tw(e, n, i), [s, o] = Tw(e + 1, n + 1, i);
+                    const [t, r] = Ew(e, n, i), [s, o] = Ew(e + 1, n + 1, i);
                     return {
                         west: t,
                         north: r,
                         east: s,
                         south: o
                     }
                 }
-                const [s, o] = Aw(e, n, i, r), [a, l] = Aw(e + 1, n + 1, i, r);
+                const [s, o] = Pw(e, n, i, r), [a, l] = Pw(e + 1, n + 1, i, r);
                 return {
                     left: s,
                     top: o,
                     right: a,
                     bottom: l
                 }
             }
 
-            function Ow({
+            function Cw({
                 viewport: t,
                 maxZoom: e,
                 minZoom: n,
                 zRange: i,
                 extent: r,
-                tileSize: s = _w,
+                tileSize: s = vw,
                 modelMatrix: o,
                 modelMatrixInverse: a,
                 zoomOffset: l = 0
             }) {
-                let c = t.isGeospatial ? Math.round(t.zoom + Math.log2(_w / s)) + l : Math.ceil(t.zoom) + l;
+                let c = t.isGeospatial ? Math.round(t.zoom + Math.log2(vw / s)) + l : Math.ceil(t.zoom) + l;
                 if ("number" == typeof n && Number.isFinite(n) && c < n) {
                     if (!r) return [];
                     c = n
                 }
                 "number" == typeof e && Number.isFinite(e) && c > e && (c = e);
                 let h = r;
-                return o && a && r && !t.isGeospatial && (h = Ew(r, o)), t.isGeospatial ? function(t, e, n, i) {
-                    const r = t instanceof ox && t.resolution ? t.projectPosition : null,
+                return o && a && r && !t.isGeospatial && (h = _w(r, o)), t.isGeospatial ? function(t, e, n, i) {
+                    const r = t instanceof ix && t.resolution ? t.projectPosition : null,
                         s = Object.values(t.getFrustumPlanes()).map((({
                             normal: t,
                             distance: e
-                        }) => new qx(t.clone().negate(), e))),
-                        o = new Qx(s),
+                        }) => new Wx(t.clone().negate(), e))),
+                        o = new Xx(s),
                         a = t.distanceScales.unitsPerMeter[2],
                         l = n && n[0] * a || 0,
                         c = n && n[1] * a || 0,
                         h = t instanceof Rf && t.pitch <= 60 ? e : 0;
                     if (i) {
-                        const [t, e, n, r] = i, s = _h([t, r]), o = _h([n, e]);
-                        i = [s[0], gw - s[1], o[0], gw - o[1]]
+                        const [t, e, n, r] = i, s = mh([t, r]), o = mh([n, e]);
+                        i = [s[0], dw - s[1], o[0], dw - o[1]]
                     }
-                    const u = new yw(0, 0, 0),
+                    const u = new mw(0, 0, 0),
                         d = {
                             viewport: t,
                             project: r,
                             cullingVolume: o,
                             elevationBounds: [l, c],
                             minZ: h,
                             maxZ: e,
@@ -28655,39 +28464,205 @@
                     }
                     return u.getSelected()
                 }(t, c, i, r) : function(t, e, n, i, r) {
                     const s = function(t, e, n) {
                             let i;
                             return i = t.getBounds(), t.isGeospatial ? [Math.max(i[0], n[0]), Math.max(i[1], n[1]), Math.min(i[2], n[2]), Math.min(i[3], n[3])] : [Math.max(Math.min(i[0], n[2]), n[0]), Math.max(Math.min(i[1], n[3]), n[1]), Math.min(Math.max(i[2], n[0]), n[2]), Math.min(Math.max(i[3], n[1]), n[3])]
                         }(t, 0, i),
-                        o = Cw(e, n),
+                        o = ww(e, n),
                         [a, l, c, h] = function(t, e, n) {
-                            return n ? Ew(t, n).map((t => t * e / _w)) : t.map((t => t * e / _w))
+                            return n ? _w(t, n).map((t => t * e / vw)) : t.map((t => t * e / vw))
                         }(s, o, r),
                         u = [];
                     for (let t = Math.floor(a); t < c; t++)
                         for (let n = Math.floor(l); n < h; n++) u.push({
                             x: t,
                             y: n,
                             z: e
                         });
                     return u
-                }(t, c, s, h || xw, a)
+                }(t, c, s, h || bw, a)
             }
+            var Tw = n(4155);
 
-            function Lw(t, e) {
-                if (t === e) return !0;
-                if (Array.isArray(t)) {
-                    const n = t.length;
-                    if (!e || e.length !== n) return !1;
-                    for (let i = 0; i < n; i++)
-                        if (t[i] !== e[i]) return !1;
-                    return !0
+            function Aw() {
+                let t;
+                if ("undefined" != typeof window && window.performance) t = window.performance.now();
+                else if (void 0 !== Tw && Tw.hrtime) {
+                    const e = Tw.hrtime();
+                    t = 1e3 * e[0] + e[1] / 1e6
+                } else t = Date.now();
+                return t
+            }
+            class Mw {
+                constructor(t, e) {
+                    wo(this, "name", void 0), wo(this, "type", void 0), wo(this, "sampleSize", 1), wo(this, "time", 0), wo(this, "count", 0), wo(this, "samples", 0), wo(this, "lastTiming", 0), wo(this, "lastSampleTime", 0), wo(this, "lastSampleCount", 0), wo(this, "_count", 0), wo(this, "_time", 0), wo(this, "_samples", 0), wo(this, "_startTime", 0), wo(this, "_timerPending", !1), this.name = t, this.type = e, this.reset()
+                }
+                reset() {
+                    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this
+                }
+                setSampleSize(t) {
+                    return this.sampleSize = t, this
+                }
+                incrementCount() {
+                    return this.addCount(1), this
+                }
+                decrementCount() {
+                    return this.subtractCount(1), this
+                }
+                addCount(t) {
+                    return this._count += t, this._samples++, this._checkSampling(), this
+                }
+                subtractCount(t) {
+                    return this._count -= t, this._samples++, this._checkSampling(), this
+                }
+                addTime(t) {
+                    return this._time += t, this.lastTiming = t, this._samples++, this._checkSampling(), this
+                }
+                timeStart() {
+                    return this._startTime = Aw(), this._timerPending = !0, this
+                }
+                timeEnd() {
+                    return this._timerPending ? (this.addTime(Aw() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this
+                }
+                getSampleAverageCount() {
+                    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0
+                }
+                getSampleAverageTime() {
+                    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0
+                }
+                getSampleHz() {
+                    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0
+                }
+                getAverageCount() {
+                    return this.samples > 0 ? this.count / this.samples : 0
+                }
+                getAverageTime() {
+                    return this.samples > 0 ? this.time / this.samples : 0
+                }
+                getHz() {
+                    return this.time > 0 ? this.samples / (this.time / 1e3) : 0
+                }
+                _checkSampling() {
+                    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0)
+                }
+            }
+            class Ow {
+                constructor(t) {
+                    wo(this, "id", void 0), wo(this, "stats", {}), this.id = t.id, this.stats = {}, this._initializeStats(t.stats), Object.seal(this)
+                }
+                get(t) {
+                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "count";
+                    return this._getOrCreate({
+                        name: t,
+                        type: e
+                    })
+                }
+                get size() {
+                    return Object.keys(this.stats).length
+                }
+                reset() {
+                    for (const t of Object.values(this.stats)) t.reset();
+                    return this
+                }
+                forEach(t) {
+                    for (const e of Object.values(this.stats)) t(e)
+                }
+                getTable() {
+                    const t = {};
+                    return this.forEach((e => {
+                        t[e.name] = {
+                            time: e.time || 0,
+                            count: e.count || 0,
+                            average: e.getAverageTime() || 0,
+                            hz: e.getHz() || 0
+                        }
+                    })), t
+                }
+                _initializeStats() {
+                    (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).forEach((t => this._getOrCreate(t)))
+                }
+                _getOrCreate(t) {
+                    const {
+                        name: e,
+                        type: n
+                    } = t;
+                    let i = this.stats[e];
+                    return i || (i = t instanceof Mw ? t : new Mw(e, n), this.stats[e] = i), i
+                }
+            }
+            const Lw = {
+                id: "request-scheduler",
+                throttleRequests: !0,
+                maxRequests: 6
+            };
+            class kw {
+                constructor() {
+                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
+                    wo(this, "props", void 0), wo(this, "stats", void 0), wo(this, "activeRequestCount", 0), wo(this, "requestQueue", []), wo(this, "requestMap", new Map), wo(this, "deferredUpdate", null), this.props = {
+                        ...Lw,
+                        ...t
+                    }, this.stats = new Ow({
+                        id: this.props.id
+                    }), this.stats.get("Queued Requests"), this.stats.get("Active Requests"), this.stats.get("Cancelled Requests"), this.stats.get("Queued Requests Ever"), this.stats.get("Active Requests Ever")
+                }
+                scheduleRequest(t) {
+                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : () => 0;
+                    if (!this.props.throttleRequests) return Promise.resolve({
+                        done: () => {}
+                    });
+                    if (this.requestMap.has(t)) return this.requestMap.get(t);
+                    const n = {
+                            handle: t,
+                            priority: 0,
+                            getPriority: e
+                        },
+                        i = new Promise((t => (n.resolve = t, n)));
+                    return this.requestQueue.push(n), this.requestMap.set(t, i), this._issueNewRequests(), i
+                }
+                _issueRequest(t) {
+                    const {
+                        handle: e,
+                        resolve: n
+                    } = t;
+                    let i = !1;
+                    const r = () => {
+                        i || (i = !0, this.requestMap.delete(e), this.activeRequestCount--, this._issueNewRequests())
+                    };
+                    return this.activeRequestCount++, n ? n({
+                        done: r
+                    }) : Promise.resolve({
+                        done: r
+                    })
+                }
+                _issueNewRequests() {
+                    this.deferredUpdate || (this.deferredUpdate = setTimeout((() => this._issueNewRequestsAsync()), 0))
+                }
+                _issueNewRequestsAsync() {
+                    this.deferredUpdate = null;
+                    const t = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
+                    if (0 !== t) {
+                        this._updateAllRequests();
+                        for (let e = 0; e < t; ++e) {
+                            const t = this.requestQueue.shift();
+                            t && this._issueRequest(t)
+                        }
+                    }
+                }
+                _updateAllRequests() {
+                    const t = this.requestQueue;
+                    for (let e = 0; e < t.length; ++e) {
+                        const n = t[e];
+                        this._updateRequest(n) || (t.splice(e, 1), this.requestMap.delete(n.handle), e--)
+                    }
+                    t.sort(((t, e) => t.priority - e.priority))
+                }
+                _updateRequest(t) {
+                    return t.priority = t.getPriority(t.handle), !(t.priority < 0 && (t.resolve(null), 1))
                 }
-                return !1
             }
             const Rw = "best-available",
                 Iw = {
                     [Rw]: function(t) {
                         for (const e of t) e.state = 0;
                         for (const e of t) e.isSelected && !jw(e) && Fw(e);
                         for (const e of t) e.isVisible = Boolean(2 & e.state)
@@ -28698,29 +28673,14 @@
                         const e = Array.from(t).sort(((t, e) => t.zoom - e.zoom));
                         for (const t of e)
                             if (t.isVisible = Boolean(2 & t.state), t.children && (t.isVisible || 1 & t.state))
                                 for (const e of t.children) e.state = 1;
                             else t.isSelected && Fw(t)
                     },
                     never: () => {}
-                },
-                kw = {
-                    extent: null,
-                    tileSize: 512,
-                    maxZoom: null,
-                    minZoom: null,
-                    maxCacheSize: null,
-                    maxCacheByteSize: null,
-                    refinementStrategy: "best-available",
-                    zRange: null,
-                    maxRequests: 6,
-                    zoomOffset: 0,
-                    onTileLoad: () => {},
-                    onTileUnload: () => {},
-                    onTileError: () => {}
                 };
 
             function jw(t) {
                 let e = t;
                 for (; e;) {
                     if (e.isLoaded || e.content) return e.state |= 2, !0;
                     e = e.parent
@@ -28730,33 +28690,20 @@
 
             function Fw(t) {
                 for (const e of t.children) e.isLoaded || e.content ? e.state |= 2 : Fw(e)
             }
             const zw = {
                 TilesetClass: class {
                     constructor(t) {
-                        wo(this, "opts", void 0), wo(this, "_requestScheduler", void 0), wo(this, "_cache", void 0), wo(this, "_dirty", void 0), wo(this, "_tiles", void 0), wo(this, "_cacheByteSize", void 0), wo(this, "_viewport", void 0), wo(this, "_zRange", void 0), wo(this, "_selectedTiles", void 0), wo(this, "_frameNumber", void 0), wo(this, "_modelMatrix", void 0), wo(this, "_modelMatrixInverse", void 0), wo(this, "_maxZoom", void 0), wo(this, "_minZoom", void 0), wo(this, "onTileLoad", void 0), wo(this, "_getCullBounds", function(t) {
-                            let e, n = {};
-                            return i => {
-                                for (const r in i)
-                                    if (!Lw(i[r], n[r])) {
-                                        e = t(i), n = i;
-                                        break
-                                    } return e
-                            }
-                        }(Pw)), this.opts = {
-                            ...kw,
-                            ...t
-                        }, this.onTileLoad = t => {
-                            var e, n;
-                            null === (e = (n = this.opts).onTileLoad) || void 0 === e || e.call(n, t), this.opts.maxCacheByteSize && (this._cacheByteSize += t.byteLength, this._resizeCache())
-                        }, this._requestScheduler = new $_({
+                        wo(this, "opts", void 0), wo(this, "_requestScheduler", void 0), wo(this, "_cache", void 0), wo(this, "_dirty", void 0), wo(this, "_tiles", void 0), wo(this, "_cacheByteSize", void 0), wo(this, "_viewport", void 0), wo(this, "_zRange", void 0), wo(this, "_selectedTiles", void 0), wo(this, "_frameNumber", void 0), wo(this, "_modelMatrix", void 0), wo(this, "_modelMatrixInverse", void 0), wo(this, "_maxZoom", void 0), wo(this, "_minZoom", void 0), wo(this, "onTileLoad", void 0), wo(this, "_getCullBounds", hf(xw)), this.opts = t, this.onTileLoad = t => {
+                            this.opts.onTileLoad(t), this.opts.maxCacheByteSize && (this._cacheByteSize += t.byteLength, this._resizeCache())
+                        }, this._requestScheduler = new kw({
                             maxRequests: t.maxRequests,
-                            throttleRequests: Boolean(t.maxRequests && t.maxRequests > 0)
-                        }), this._cache = new Map, this._tiles = [], this._dirty = !1, this._cacheByteSize = 0, this._viewport = null, this._selectedTiles = null, this._frameNumber = 0, this._modelMatrix = new ih, this._modelMatrixInverse = new ih, this.setOptions(t)
+                            throttleRequests: t.maxRequests > 0
+                        }), this._cache = new Map, this._tiles = [], this._dirty = !1, this._cacheByteSize = 0, this._viewport = null, this._selectedTiles = null, this._frameNumber = 0, this._modelMatrix = new $c, this._modelMatrixInverse = new $c, this.setOptions(t)
                     }
                     get tiles() {
                         return this._tiles
                     }
                     get selectedTiles() {
                         return this._selectedTiles
                     }
@@ -28779,17 +28726,17 @@
                             this._selectedTiles && this._selectedTiles.includes(e) ? e.setNeedsReload() : this._cache.delete(t)
                         }
                     }
                     update(t, {
                         zRange: e,
                         modelMatrix: n
                     } = {}) {
-                        const i = new ih(n),
+                        const i = new $c(n),
                             r = !i.equals(this._modelMatrix);
-                        if (this._viewport && t.equals(this._viewport) && uc(this._zRange, e) && !r) this.needsReload && (this._selectedTiles = this._selectedTiles.map((t => this._getTile(t.index, !0))));
+                        if (this._viewport && t.equals(this._viewport) && lc(this._zRange, e) && !r) this.needsReload && (this._selectedTiles = this._selectedTiles.map((t => this._getTile(t.index, !0))));
                         else {
                             r && (this._modelMatrixInverse = i.clone().invert(), this._modelMatrix = i), this._viewport = t, this._zRange = e;
                             const n = this.getTileIndices({
                                 viewport: t,
                                 maxZoom: this._maxZoom,
                                 minZoom: this._minZoom,
                                 zRange: e,
@@ -28800,33 +28747,25 @@
                         }
                         const s = this.updateTileStates();
                         return this._pruneRequests(), this._dirty && this._resizeCache(), s && this._frameNumber++, this._frameNumber
                     }
                     isTileVisible(t, e) {
                         if (!t.isVisible) return !1;
                         if (e && this._viewport) {
-                            const n = this._getCullBounds({
-                                    viewport: this._viewport,
-                                    z: this._zRange,
-                                    cullRect: e
-                                }),
-                                {
-                                    bbox: i
-                                } = t;
-                            for (const [t, e, r, s] of n) {
-                                let n;
-                                if ("west" in i) n = i.west < r && i.east > t && i.south < s && i.north > e;
-                                else {
-                                    const o = Math.min(i.top, i.bottom),
-                                        a = Math.max(i.top, i.bottom);
-                                    n = i.left < r && i.right > t && o < s && a > e
-                                }
-                                if (n) return !0
-                            }
-                            return !1
+                            const [n, i, r, s] = xw({
+                                viewport: this._viewport,
+                                z: this._zRange,
+                                cullRect: e
+                            }), {
+                                bbox: o
+                            } = t;
+                            if ("west" in o) return o.west < r && o.east > n && o.south < s && o.north > i;
+                            const a = Math.min(o.top, o.bottom),
+                                l = Math.max(o.top, o.bottom);
+                            return o.left < r && o.right > n && a < s && l > i
                         }
                         return !0
                     }
                     getTileIndices({
                         viewport: t,
                         maxZoom: e,
                         minZoom: n,
@@ -28835,15 +28774,15 @@
                         modelMatrixInverse: s
                     }) {
                         const {
                             tileSize: o,
                             extent: a,
                             zoomOffset: l
                         } = this.opts;
-                        return Ow({
+                        return Cw({
                             viewport: t,
                             maxZoom: e,
                             minZoom: n,
                             zRange: i,
                             tileSize: o,
                             extent: a,
                             modelMatrix: r,
@@ -28858,15 +28797,15 @@
                         return t.z
                     }
                     getTileMetadata(t) {
                         const {
                             tileSize: e
                         } = this.opts;
                         return {
-                            bbox: Mw(this._viewport, t.x, t.y, t.z, e)
+                            bbox: Sw(this._viewport, t.x, t.y, t.z, e)
                         }
                     }
                     getParentIndex(t) {
                         return {
                             x: Math.floor(t.x / 2),
                             y: Math.floor(t.y / 2),
                             z: t.z - 1
@@ -28881,15 +28820,15 @@
                         ("function" == typeof t ? t : Iw[t])(Array.from(this._cache.values())), n = 0;
                         for (const t of this._cache.values())
                             if (e[n++] !== t.isVisible) return !0;
                         return !1
                     }
                     _pruneRequests() {
                         const {
-                            maxRequests: t = 0
+                            maxRequests: t
                         } = this.opts, e = [];
                         let n = 0;
                         for (const t of this._cache.values()) t.isLoading && (n++, t.isSelected || t.isVisible || e.push(t));
                         for (; t > 0 && n > t && e.length > 0;) e.shift().abort(), n--
                     }
                     _rebuildTree() {
                         const {
@@ -28903,27 +28842,25 @@
                     }
                     _resizeCache() {
                         const {
                             _cache: t,
                             opts: e
                         } = this, n = e.maxCacheSize || (e.maxCacheByteSize ? 1 / 0 : 5 * this.selectedTiles.length), i = e.maxCacheByteSize || 1 / 0;
                         if (t.size > n || this._cacheByteSize > i) {
-                            for (const [o, a] of t) {
-                                var r, s;
-                                if (a.isVisible || a.isSelected || (this._cacheByteSize -= e.maxCacheByteSize ? a.byteLength : 0, t.delete(o), null === (r = (s = this.opts).onTileUnload) || void 0 === r || r.call(s, a)), t.size <= n && this._cacheByteSize <= i) break
-                            }
+                            for (const [r, s] of t)
+                                if (s.isVisible || (this._cacheByteSize -= e.maxCacheByteSize ? s.byteLength : 0, t.delete(r), this.opts.onTileUnload(s)), t.size <= n && this._cacheByteSize <= i) break;
                             this._rebuildTree(), this._dirty = !0
                         }
                         this._dirty && (this._tiles = Array.from(this._cache.values()).sort(((t, e) => t.zoom - e.zoom)), this._dirty = !1)
                     }
                     _getTile(t, e) {
                         const n = this.getTileId(t);
                         let i = this._cache.get(n),
                             r = !1;
-                        return !i && e ? (i = new tx(t), Object.assign(i, this.getTileMetadata(i.index)), Object.assign(i, {
+                        return !i && e ? (i = new Q_(t), Object.assign(i, this.getTileMetadata(i.index)), Object.assign(i, {
                             id: n,
                             zoom: this.getTileZoom(i.index)
                         }), r = !0, this._cache.set(n, i), this._dirty = !0) : i && i.needsReload && (r = !0), i && r && i.loadData({
                             getData: this.opts.getTileData,
                             requestScheduler: this._requestScheduler,
                             onLoad: this.onTileLoad,
                             onError: this.opts.onTileError
@@ -28942,40 +28879,46 @@
                         return null
                     }
                 },
                 data: {
                     type: "data",
                     value: []
                 },
-                dataComparator: ww.equal,
+                dataComparator: yw.equals,
                 renderSubLayers: {
                     type: "function",
-                    value: t => new q_(t)
+                    value: t => new K_(t),
+                    compare: !1
                 },
                 getTileData: {
                     type: "function",
                     optional: !0,
-                    value: null
+                    value: null,
+                    compare: !1
                 },
                 onViewportLoad: {
                     type: "function",
                     optional: !0,
-                    value: null
+                    value: null,
+                    compare: !1
                 },
                 onTileLoad: {
                     type: "function",
-                    value: t => {}
+                    value: t => {},
+                    compare: !1
                 },
                 onTileUnload: {
                     type: "function",
-                    value: t => {}
+                    value: t => {},
+                    compare: !1
                 },
                 onTileError: {
                     type: "function",
-                    value: t => console.error(t)
+                    value: t => console.error(t),
+                    compare: !1
                 },
                 extent: {
                     type: "array",
                     optional: !0,
                     value: null,
                     compare: !0
                 },
@@ -28985,15 +28928,15 @@
                 maxCacheSize: null,
                 maxCacheByteSize: null,
                 refinementStrategy: Rw,
                 zRange: null,
                 maxRequests: 6,
                 zoomOffset: 0
             };
-            class Bw extends Jb {
+            class Bw extends ry {
                 initializeState() {
                     this.state = {
                         tileset: null,
                         isLoaded: !1
                     }
                 }
                 finalizeState() {
@@ -29118,36 +29061,33 @@
                 getSubLayerPropsByTile(t) {
                     return null
                 }
                 getPickingInfo({
                     info: t,
                     sourceLayer: e
                 }) {
-                    const n = e.props.tile;
-                    return t.picked && (t.tile = n), t.sourceTile = n, t
+                    return t.tile = e.props.tile, t
                 }
                 _updateAutoHighlight(t) {
-                    const e = t.sourceTile;
-                    if (e && e.layers)
-                        for (const n of e.layers) n.updateAutoHighlight(t)
+                    t.sourceLayer && t.sourceLayer.updateAutoHighlight(t)
                 }
                 renderLayers() {
                     return this.state.tileset.tiles.map((t => {
                         const e = this.getSubLayerPropsByTile(t);
                         if (t.isLoaded || t.content)
                             if (t.layers) e && t.layers[0] && Object.keys(e).some((n => t.layers[0].props[n] !== e[n])) && (t.layers = t.layers.map((t => t.clone(e))));
                             else {
                                 const n = this.renderSubLayers({
                                     ...this.props,
                                     id: "".concat(this.id, "-").concat(t.id),
                                     data: t.content,
                                     _offset: 0,
                                     tile: t
                                 });
-                                t.layers = oa(n, Boolean).map((n => n.clone({
+                                t.layers = ia(n, Boolean).map((n => n.clone({
                                     tile: t,
                                     ...e
                                 })))
                             } return t.layers
                     }))
                 }
                 filterSubLayer({
@@ -29328,27 +29268,27 @@
                         }
                     }
                 },
                 Gw = {
                     fs: "#version 300 es\n#define SHADER_NAME image-layer-fragment-shader\n#define num_channels CHANNEL_NUMBER\n#define sampler_type SAMPLER_TYPE\n#define normalization_value NORMALIZATION_VALUE\n\nprecision highp sampler_type;\nprecision highp float;\nprecision highp int;\n\nuniform sampler_type texture_arr;\nuniform float intensities[num_channels];\nuniform int channelMapping[num_channels];\nuniform vec4 colors[num_channels];\n\nin vec2 vTexCoord;\n\nvoid main() {\n  vec4 color = vec4(0);\n\n  for (int i = 0; i < num_channels; ++i)\n  {\n    if (channelMapping[i] == -1) continue;\n\n    color += colors[i] * float(texture(texture_arr, vec3(vTexCoord.xy, channelMapping[i])).r) / normalization_value / 255.0 * intensities[i];\n  }\n\n  gl_FragColor = vec4(color.rgb, 1.0);\n  \n  geometry.uv = vTexCoord;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
                     vs: "#version 300 es\n#define SHADER_NAME image-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute vec3 instancePickingColors;\nvarying vec2 vTexCoord;\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = instancePickingColors;\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vTexCoord = texCoords;\n  vec4 color = vec4(0.);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n"
                 };
-            class Ww extends Fb {
+            class Ww extends Yb {
                 constructor(t) {
                     super(t), this.state = {
                         texture: null
                     }
                 }
                 getShaders() {
                     const t = {
                         ...Gw
                     };
                     return t.fs = t.fs.replace("CHANNEL_NUMBER", `${this.props.channels.length}`), t.fs = t.fs.replace("SAMPLER_TYPE", Uw[this.props.format].samplerType), t.fs = t.fs.replace("NORMALIZATION_VALUE", Uw[this.props.format].max.toFixed(1)), super.getShaders({
                         ...t,
-                        modules: [ty, ny]
+                        modules: [oy, ly]
                     })
                 }
                 generateTexture(t) {
                     const e = t.createTexture();
                     return t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D_ARRAY, e), t.texParameteri(t.TEXTURE_2D_ARRAY, t.TEXTURE_MAG_FILTER, Uw[this.props.format].filtering), t.texParameteri(t.TEXTURE_2D_ARRAY, t.TEXTURE_MIN_FILTER, Uw[this.props.format].filtering), t.texParameteri(t.TEXTURE_2D_ARRAY, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D_ARRAY, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texImage3D(t.TEXTURE_2D_ARRAY, 0, Uw[this.props.format].internalFormat, this.props.width, this.props.height, this.props.activeChannels, 0, Uw[this.props.format].format, Uw[this.props.format].type, this.props.data), e
                 }
                 initializeState() {
@@ -29402,18 +29342,18 @@
                             model: this._getModel(t)
                         }), this.getAttributeManager()?.invalidateAll()
                     }
                     const r = this.getAttributeManager();
                     t.bounds !== e.bounds && r?.invalidate("positions")
                 }
                 _getModel(t) {
-                    return t ? new Yv(t, {
+                    return t ? new ab(t, {
                         ...this.getShaders(),
                         id: this.props.id,
-                        geometry: new ry({
+                        geometry: new hy({
                             drawMode: Dw.Z.TRIANGLE_FAN,
                             vertexCount: 4,
                             attributes: {
                                 texCoords: new Float32Array([0, 1, 0, 0, 1, 0, 1, 1])
                             }
                         }),
                         isInstanced: !1
@@ -29443,15 +29383,15 @@
                         }).draw()
                     }
                 }
             }
             Ww.layerName = "ImageLayer", Ww.defaultProps = {
                 bounds: [],
                 pickable: !1,
-                coordinateSystem: Lh.CARTESIAN,
+                coordinateSystem: Th.CARTESIAN,
                 data: null,
                 width: 0,
                 height: 0,
                 format: "uint8",
                 channels: [],
                 channelMapping: [],
                 activeChannels: 0
@@ -29520,15 +29460,15 @@
                         data: t.data?.data,
                         width: t.data?.width,
                         height: t.data?.height,
                         format: this.props.format,
                         channels: this.props.channels,
                         activeChannels: t.data.channels,
                         channelMapping: this.props.channelMapping,
-                        bounds: [cc(e, 0, t.extent[2]), cc(n, 0, t.extent[3]), cc(i, 0, t.extent[2]), cc(r, 0, t.extent[3])]
+                        bounds: [oc(e, 0, t.extent[2]), oc(n, 0, t.extent[3]), oc(i, 0, t.extent[2]), oc(r, 0, t.extent[3])]
                     })
                 }
             }
             Zw.defaultProps = {
                 api: "",
                 namespace: "",
                 metadata: [],
@@ -29719,25 +29659,25 @@
                                 target: [t[0].width / 2, t[0].height / 2, 0],
                                 loaded: !0
                             }))), r?.(), s.current = a
                         })).catch((e => {
                             t.errorHandler?.(e)
                         })))
                     }), [e, n]);
-                    const h = (0, c.useMemo)((() => new Qb({
+                    const h = (0, c.useMemo)((() => new Lg({
                             id: "ortho",
                             controller: {
                                 scrollZoom: {
                                     speed: .01,
                                     smooth: !0
                                 },
                                 inertia: !0,
                                 doubleClickZoom: !1
                             }
-                        })), [Qb]),
+                        })), [Lg]),
                         u = (0, c.useMemo)((() => Jw((t => {
                             l((e => ({
                                 ...e,
                                 ...t.viewState
                             })))
                         }), 200)), [Jw]);
                     return t.channels.length ? (0, o.jsxs)("div", {
@@ -29753,21 +29693,21 @@
                             zoom: a.zoom,
                             setZoom: t => {
                                 l((e => ({
                                     ...e,
                                     zoom: t
                                 })))
                             }
-                        }), a.loaded && (0, o.jsx)(Wb, {
+                        }), a.loaded && (0, o.jsx)(iy, {
                             views: [h],
                             layers: [new qw({
                                 tileSize: 1024,
                                 minZoom: a.metadata[0].zoom_level,
                                 maxZoom: a.metadata.at(-1)?.zoom_level,
-                                coordinateSystem: Lh.CARTESIAN,
+                                coordinateSystem: Th.CARTESIAN,
                                 extent: [0, 0, a.metadata[0].width, a.metadata[0].height],
                                 metadata: a.metadata,
                                 namespace: t.groupNamespace,
                                 channels: t.channels,
                                 channelRanges: t.channelRanges,
                                 channelMapping: t.channelMapping,
                                 getChannels: t => t,
@@ -30338,39 +30278,39 @@
                     return -1
                 }
 
                 function L(t) {
                     return Array.prototype.slice.call(t, 0)
                 }
 
-                function R(t, e, n) {
+                function k(t, e, n) {
                     for (var i = [], r = [], s = 0; s < t.length;) {
                         var o = e ? t[s][e] : t[s];
                         O(r, o) < 0 && i.push(t[s]), r[s] = o, s++
                     }
                     return n && (i = e ? i.sort((function(t, n) {
                         return t[e] > n[e]
                     })) : i.sort()), i
                 }
 
-                function I(t, e) {
+                function R(t, e) {
                     for (var n, i, r = e[0].toUpperCase() + e.slice(1), s = 0; s < c.length;) {
                         if ((i = (n = c[s]) ? n + r : e) in t) return i;
                         s++
                     }
                     return a
                 }
-                var k = 1;
+                var I = 1;
 
                 function j(t) {
                     var e = t.ownerDocument || t;
                     return e.defaultView || e.parentWindow || r
                 }
                 var F = "ontouchstart" in r,
-                    z = I(r, "PointerEvent") !== a,
+                    z = R(r, "PointerEvent") !== a,
                     B = F && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),
                     D = "touch",
                     N = "mouse",
                     V = 25,
                     U = 1,
                     G = 4,
                     W = 8,
@@ -30569,15 +30509,15 @@
                 function yt() {
                     this.evTarget = "touchstart", this.evWin = "touchstart touchmove touchend touchcancel", this.started = !1, et.apply(this, arguments)
                 }
 
                 function _t(t, e) {
                     var n = L(t.touches),
                         i = L(t.changedTouches);
-                    return e & (G | W) && (n = R(n.concat(i), "identifier", !0)), [n, i]
+                    return e & (G | W) && (n = k(n.concat(i), "identifier", !0)), [n, i]
                 }
                 x(yt, et, {
                     handler: function(t) {
                         var e = bt[t.type];
                         if (e === U && (this.started = !0), this.started) {
                             var n = _t.call(this, t, e);
                             e & (G | W) && n[0].length - n[1].length == 0 && (this.started = !1), this.callback(this.manager, e, {
@@ -30609,15 +30549,15 @@
                         a = [],
                         l = this.target;
                     if (s = n.filter((function(t) {
                             return T(t.target, l)
                         })), e === U)
                         for (r = 0; r < s.length;) i[s[r].identifier] = !0, r++;
                     for (r = 0; r < o.length;) i[o[r].identifier] && a.push(o[r]), e & (G | W) && delete i[o[r].identifier], r++;
-                    return a.length ? [R(s.concat(a), "identifier", !0), a] : void 0
+                    return a.length ? [k(s.concat(a), "identifier", !0), a] : void 0
                 }
                 x(Et, et, {
                     handler: function(t) {
                         var e = xt[t.type],
                             n = Pt.call(this, t, e);
                         n && this.callback(this.manager, e, {
                             pointers: n[0],
@@ -30674,19 +30614,19 @@
                             this.callback(t, e, n)
                         }
                     },
                     destroy: function() {
                         this.touch.destroy(), this.mouse.destroy()
                     }
                 });
-                var Ot = I(h.style, "touchAction"),
+                var Ot = R(h.style, "touchAction"),
                     Lt = Ot !== a,
-                    Rt = "compute",
-                    It = "auto",
-                    kt = "manipulation",
+                    kt = "compute",
+                    Rt = "auto",
+                    It = "manipulation",
                     jt = "none",
                     Ft = "pan-x",
                     zt = "pan-y",
                     Bt = function() {
                         if (!Lt) return !1;
                         var t = {},
                             e = r.CSS && r.CSS.supports;
@@ -30696,29 +30636,29 @@
                     }();
 
                 function Dt(t, e) {
                     this.manager = t, this.set(e)
                 }
                 Dt.prototype = {
                     set: function(t) {
-                        t == Rt && (t = this.compute()), Lt && this.manager.element.style && Bt[t] && (this.manager.element.style[Ot] = t), this.actions = t.toLowerCase().trim()
+                        t == kt && (t = this.compute()), Lt && this.manager.element.style && Bt[t] && (this.manager.element.style[Ot] = t), this.actions = t.toLowerCase().trim()
                     },
                     update: function() {
                         this.set(this.manager.options.touchAction)
                     },
                     compute: function() {
                         var t = [];
                         return v(this.manager.recognizers, (function(e) {
                                 E(e.options.enable, [e]) && (t = t.concat(e.getTouchAction()))
                             })),
                             function(t) {
                                 if (A(t, jt)) return jt;
                                 var e = A(t, Ft),
                                     n = A(t, zt);
-                                return e && n ? jt : e || n ? e ? Ft : zt : A(t, kt) ? kt : It
+                                return e && n ? jt : e || n ? e ? Ft : zt : A(t, It) ? It : Rt
                             }(t.join(" "))
                     },
                     preventDefaults: function(t) {
                         var e = t.srcEvent,
                             n = t.offsetDirection;
                         if (this.manager.session.prevented) e.preventDefault();
                         else {
@@ -30739,15 +30679,15 @@
                         this.manager.session.prevented = !0, t.preventDefault()
                     }
                 };
                 var Nt = 1,
                     Vt = 32;
 
                 function Ut(t) {
-                    this.options = l({}, this.defaults, t || {}), this.id = k++, this.manager = null, this.options.enable = P(this.options.enable, !0), this.state = Nt, this.simultaneous = {}, this.requireFail = []
+                    this.options = l({}, this.defaults, t || {}), this.id = I++, this.manager = null, this.options.enable = P(this.options.enable, !0), this.state = Nt, this.simultaneous = {}, this.requireFail = []
                 }
 
                 function Gt(t) {
                     return 16 & t ? "cancel" : 8 & t ? "end" : 4 & t ? "move" : 2 & t ? "start" : ""
                 }
 
                 function Wt(t) {
@@ -30797,15 +30737,15 @@
                         t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3])
                     }), this)
                 }
 
                 function ee(t, e) {
                     var n, i = t.element;
                     i.style && (v(t.options.cssProps, (function(r, s) {
-                        n = I(i.style, s), e ? (t.oldCssProps[n] = i.style[n], i.style[n] = r) : i.style[n] = t.oldCssProps[n] || ""
+                        n = R(i.style, s), e ? (t.oldCssProps[n] = i.style[n], i.style[n] = r) : i.style[n] = t.oldCssProps[n] || ""
                     })), e || (t.oldCssProps = {}))
                 }
                 Ut.prototype = {
                     defaults: {},
                     set: function(t) {
                         return l(this.options, t), this.manager && this.manager.touchAction.update(), this
                     },
@@ -30929,15 +30869,15 @@
                     defaults: {
                         event: "press",
                         pointers: 1,
                         time: 251,
                         threshold: 9
                     },
                     getTouchAction: function() {
-                        return [It]
+                        return [Rt]
                     },
                     process: function(t) {
                         var e = this.options,
                             n = t.pointers.length === e.pointers,
                             i = t.distance < e.threshold,
                             r = t.deltaTime > e.time;
                         if (this._input = t, !i || !n || t.eventType & (G | W) && !r) this.reset();
@@ -30991,15 +30931,15 @@
                         taps: 1,
                         interval: 300,
                         time: 250,
                         threshold: 9,
                         posThreshold: 10
                     },
                     getTouchAction: function() {
-                        return [kt]
+                        return [It]
                     },
                     process: function(t) {
                         var e = this.options,
                             n = t.pointers.length === e.pointers,
                             i = t.distance < e.threshold,
                             r = t.deltaTime < e.time;
                         if (this.reset(), t.eventType & U && 0 === this.count) return this.failTimeout();
@@ -31022,15 +30962,15 @@
                         clearTimeout(this._timer)
                     },
                     emit: function() {
                         8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
                     }
                 }), $t.VERSION = "2.0.7", $t.defaults = {
                     domEvents: !1,
-                    touchAction: Rt,
+                    touchAction: kt,
                     enable: !0,
                     inputTarget: null,
                     inputClass: null,
                     preset: [
                         [Kt, {
                             enable: !1
                         }],
@@ -31173,15 +31113,15 @@
                     off: C,
                     each: v,
                     merge: _,
                     extend: y,
                     assign: l,
                     inherit: x,
                     bindFn: w,
-                    prefixed: I
+                    prefixed: R
                 }), (void 0 !== r ? r : "undefined" != typeof self ? self : {}).Hammer = $t, (i = function() {
                     return $t
                 }.call(e, n, e, t)) === a || (t.exports = i)
             }(window, document)
         },
         2896: (t, e, n) => {
             "use strict";
@@ -31316,46 +31256,46 @@
                 w = n(2928),
                 E = n(3674),
                 P = n(1704),
                 S = "[object Arguments]",
                 C = "[object Function]",
                 T = "[object Object]",
                 A = {};
-            A[S] = A["[object Array]"] = A["[object ArrayBuffer]"] = A["[object DataView]"] = A["[object Boolean]"] = A["[object Date]"] = A["[object Float32Array]"] = A["[object Float64Array]"] = A["[object Int8Array]"] = A["[object Int16Array]"] = A["[object Int32Array]"] = A["[object Map]"] = A["[object Number]"] = A[T] = A["[object RegExp]"] = A["[object Set]"] = A["[object String]"] = A["[object Symbol]"] = A["[object Uint8Array]"] = A["[object Uint8ClampedArray]"] = A["[object Uint16Array]"] = A["[object Uint32Array]"] = !0, A["[object Error]"] = A[C] = A["[object WeakMap]"] = !1, t.exports = function t(e, n, M, O, L, R) {
-                var I, k = 1 & n,
+            A[S] = A["[object Array]"] = A["[object ArrayBuffer]"] = A["[object DataView]"] = A["[object Boolean]"] = A["[object Date]"] = A["[object Float32Array]"] = A["[object Float64Array]"] = A["[object Int8Array]"] = A["[object Int16Array]"] = A["[object Int32Array]"] = A["[object Map]"] = A["[object Number]"] = A[T] = A["[object RegExp]"] = A["[object Set]"] = A["[object String]"] = A["[object Symbol]"] = A["[object Uint8Array]"] = A["[object Uint8ClampedArray]"] = A["[object Uint16Array]"] = A["[object Uint32Array]"] = !0, A["[object Error]"] = A[C] = A["[object WeakMap]"] = !1, t.exports = function t(e, n, M, O, L, k) {
+                var R, I = 1 & n,
                     j = 2 & n,
                     F = 4 & n;
-                if (M && (I = L ? M(e, O, L, R) : M(e)), void 0 !== I) return I;
+                if (M && (R = L ? M(e, O, L, k) : M(e)), void 0 !== R) return R;
                 if (!x(e)) return e;
                 var z = b(e);
                 if (z) {
-                    if (I = g(e), !k) return c(e, I)
+                    if (R = g(e), !I) return c(e, R)
                 } else {
                     var B = f(e),
                         D = B == C || "[object GeneratorFunction]" == B;
-                    if (y(e)) return l(e, k);
+                    if (y(e)) return l(e, I);
                     if (B == T || B == S || D && !L) {
-                        if (I = j || D ? {} : v(e), !k) return j ? u(e, a(I, e)) : h(e, o(I, e))
+                        if (R = j || D ? {} : v(e), !I) return j ? u(e, a(R, e)) : h(e, o(R, e))
                     } else {
                         if (!A[B]) return L ? e : {};
-                        I = m(e, B, k)
+                        R = m(e, B, I)
                     }
                 }
-                R || (R = new i);
-                var N = R.get(e);
+                k || (k = new i);
+                var N = k.get(e);
                 if (N) return N;
-                R.set(e, I), w(e) ? e.forEach((function(i) {
-                    I.add(t(i, n, M, i, e, R))
+                k.set(e, R), w(e) ? e.forEach((function(i) {
+                    R.add(t(i, n, M, i, e, k))
                 })) : _(e) && e.forEach((function(i, r) {
-                    I.set(r, t(i, n, M, r, e, R))
+                    R.set(r, t(i, n, M, r, e, k))
                 }));
                 var V = z ? void 0 : (F ? j ? p : d : j ? P : E)(e);
                 return r(V || e, (function(i, r) {
-                    V && (i = e[r = i]), s(I, r, t(i, n, M, r, e, R))
-                })), I
+                    V && (i = e[r = i]), s(R, r, t(i, n, M, r, e, k))
+                })), R
             }
         },
         3118: (t, e, n) => {
             var i = n(3218),
                 r = Object.create,
                 s = function() {
                     function t() {}
```

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/633.1125117a0017a3fcb647.js` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/633.f2676ca35060e71f16a0.js`

 * *Files 6% similar despite different names*

#### js-beautify {}

```diff
@@ -121,15 +121,15 @@
             a: t
         }), t
     }, n.d = (e, t) => {
         for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {
             enumerable: !0,
             get: t[r]
         })
-    }, n.f = {}, n.e = e => Promise.all(Object.keys(n.f).reduce(((t, r) => (n.f[r](e, t), t)), [])), n.u = e => e + ".812cb387a85b4a4dd127.js?v=812cb387a85b4a4dd127", n.g = function() {
+    }, n.f = {}, n.e = e => Promise.all(Object.keys(n.f).reduce(((t, r) => (n.f[r](e, t), t)), [])), n.u = e => e + ".f8f404497739316e801c.js?v=f8f404497739316e801c", n.g = function() {
         if ("object" == typeof globalThis) return globalThis;
         try {
             return this || new Function("return this")()
         } catch (e) {
             if ("object" == typeof window) return window
         }
     }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.r = e => {
```

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/635.812cb387a85b4a4dd127.js` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/635.f8f404497739316e801c.js`

 * *Files 1% similar despite different names*

#### js-beautify {}

```diff
@@ -1,8 +1,8 @@
-/*! For license information please see 635.812cb387a85b4a4dd127.js.LICENSE.txt */
+/*! For license information please see 635.f8f404497739316e801c.js.LICENSE.txt */
 (self.webpackChunk_tiledb_inc_jupyter_bioimage_viewer = self.webpackChunk_tiledb_inc_jupyter_bioimage_viewer || []).push([
     [635], {
         9757: (t, e, r) => {
             "use strict";
             r.d(e, {
                 Z: () => i
             });
@@ -12180,15 +12180,15 @@
             }
         },
         9669: (t, e, r) => {
             t.exports = r(1609)
         },
         5448: (t, e, r) => {
             "use strict";
-            var i = r(3837),
+            var i = r(4867),
                 s = r(6026),
                 n = r(4372),
                 a = r(5327),
                 o = r(4097),
                 c = r(4109),
                 u = r(7985),
                 p = r(5061);
@@ -12239,15 +12239,15 @@
                         g && (g.abort(), r(t), g = null)
                     })), d || (d = null), g.send(d)
                 }))
             }
         },
         1609: (t, e, r) => {
             "use strict";
-            var i = r(3837),
+            var i = r(4867),
                 s = r(1849),
                 n = r(321),
                 a = r(7185);
 
             function o(t) {
                 var e = new n(t),
                     r = s(n.prototype.request, e);
@@ -12301,15 +12301,15 @@
             "use strict";
             t.exports = function(t) {
                 return !(!t || !t.__CANCEL__)
             }
         },
         321: (t, e, r) => {
             "use strict";
-            var i = r(3837),
+            var i = r(4867),
                 s = r(5327),
                 n = r(782),
                 a = r(3572),
                 o = r(7185),
                 c = r(4875),
                 u = c.validators;
 
@@ -12375,15 +12375,15 @@
                         data: r
                     }))
                 }
             })), t.exports = p
         },
         782: (t, e, r) => {
             "use strict";
-            var i = r(3837);
+            var i = r(4867);
 
             function s() {
                 this.handlers = []
             }
             s.prototype.use = function(t, e, r) {
                 return this.handlers.push({
                     fulfilled: t,
@@ -12413,15 +12413,15 @@
             t.exports = function(t, e, r, s, n) {
                 var a = new Error(t);
                 return i(a, e, r, s, n)
             }
         },
         3572: (t, e, r) => {
             "use strict";
-            var i = r(3837),
+            var i = r(4867),
                 s = r(8527),
                 n = r(6502),
                 a = r(5655);
 
             function o(t) {
                 t.cancelToken && t.cancelToken.throwIfRequested()
             }
@@ -12452,15 +12452,15 @@
                         code: this.code
                     }
                 }, t
             }
         },
         7185: (t, e, r) => {
             "use strict";
-            var i = r(3837);
+            var i = r(4867);
             t.exports = function(t, e) {
                 e = e || {};
                 var r = {},
                     s = ["url", "method", "data"],
                     n = ["headers", "auth", "proxy", "params"],
                     a = ["baseURL", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "timeoutMessage", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "decompress", "maxContentLength", "maxBodyLength", "maxRedirects", "transport", "httpAgent", "httpsAgent", "cancelToken", "socketPath", "responseEncoding"],
                     o = ["validateStatus"];
@@ -12492,27 +12492,27 @@
             t.exports = function(t, e, r) {
                 var s = r.config.validateStatus;
                 r.status && s && !s(r.status) ? e(i("Request failed with status code " + r.status, r.config, null, r.request, r)) : t(r)
             }
         },
         8527: (t, e, r) => {
             "use strict";
-            var i = r(3837),
+            var i = r(4867),
                 s = r(5655);
             t.exports = function(t, e, r) {
                 var n = this || s;
                 return i.forEach(r, (function(r) {
                     t = r.call(n, t, e)
                 })), t
             }
         },
         5655: (t, e, r) => {
             "use strict";
             var i = r(4155),
-                s = r(3837),
+                s = r(4867),
                 n = r(6016),
                 a = r(481),
                 o = {
                     "Content-Type": "application/x-www-form-urlencoded"
                 };
 
             function c(t, e) {
@@ -12577,15 +12577,15 @@
                     for (var r = new Array(arguments.length), i = 0; i < r.length; i++) r[i] = arguments[i];
                     return t.apply(e, r)
                 }
             }
         },
         5327: (t, e, r) => {
             "use strict";
-            var i = r(3837);
+            var i = r(4867);
 
             function s(t) {
                 return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
             }
             t.exports = function(t, e, r) {
                 if (!e) return t;
                 var n;
@@ -12609,15 +12609,15 @@
             "use strict";
             t.exports = function(t, e) {
                 return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t
             }
         },
         4372: (t, e, r) => {
             "use strict";
-            var i = r(3837);
+            var i = r(4867);
             t.exports = i.isStandardBrowserEnv() ? {
                 write: function(t, e, r, s, n, a) {
                     var o = [];
                     o.push(t + "=" + encodeURIComponent(e)), i.isNumber(r) && o.push("expires=" + new Date(r).toGMTString()), i.isString(s) && o.push("path=" + s), i.isString(n) && o.push("domain=" + n), !0 === a && o.push("secure"), document.cookie = o.join("; ")
                 },
                 read: function(t) {
                     var e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
@@ -12644,15 +12644,15 @@
             "use strict";
             t.exports = function(t) {
                 return "object" == typeof t && !0 === t.isAxiosError
             }
         },
         7985: (t, e, r) => {
             "use strict";
-            var i = r(3837);
+            var i = r(4867);
             t.exports = i.isStandardBrowserEnv() ? function() {
                 var t, e = /(msie|trident)/i.test(navigator.userAgent),
                     r = document.createElement("a");
 
                 function s(t) {
                     var i = t;
                     return e && (r.setAttribute("href", i), i = r.href), r.setAttribute("href", i), {
@@ -12673,24 +12673,24 @@
                     }
             }() : function() {
                 return !0
             }
         },
         6016: (t, e, r) => {
             "use strict";
-            var i = r(3837);
+            var i = r(4867);
             t.exports = function(t, e) {
                 i.forEach(t, (function(r, i) {
                     i !== e && i.toUpperCase() === e.toUpperCase() && (t[e] = r, delete t[i])
                 }))
             }
         },
         4109: (t, e, r) => {
             "use strict";
-            var i = r(3837),
+            var i = r(4867),
                 s = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
             t.exports = function(t) {
                 var e, r, n, a = {};
                 return t ? (i.forEach(t.split("\n"), (function(t) {
                     if (n = t.indexOf(":"), e = i.trim(t.substr(0, n)).toLowerCase(), r = i.trim(t.substr(n + 1)), e) {
                         if (a[e] && s.indexOf(e) >= 0) return;
                         a[e] = "set-cookie" === e ? (a[e] ? a[e] : []).concat([r]) : a[e] ? a[e] + ", " + r : r
@@ -12748,15 +12748,15 @@
                             if (!0 !== c) throw new TypeError("option " + n + " must be " + c)
                         } else if (!0 !== r) throw Error("Unknown option " + n)
                     }
                 },
                 validators: s
             }
         },
-        3837: (t, e, r) => {
+        4867: (t, e, r) => {
             "use strict";
             var i = r(1849),
                 s = Object.prototype.toString;
 
             function n(t) {
                 return "[object Array]" === s.call(t)
             }
@@ -12876,15 +12876,15 @@
                 value: !0
             });
             var i = r(9874);
             e.ListElementSize = i.ListElementSize, e.Message = i.Message, e.ObjectSize = i.ObjectSize, e.readRawPointer = i.readRawPointer, e.AnyPointerList = i.AnyPointerList, e.BoolList = i.BoolList, e.CompositeList = i.CompositeList, e.Data = i.Data, e.DataList = i.DataList, e.Float32List = i.Float32List, e.Float64List = i.Float64List, e.Int16List = i.Int16List, e.Int32List = i.Int32List, e.Int64List = i.Int64List, e.Int8List = i.Int8List, e.Interface = i.Interface, e.InterfaceList = i.InterfaceList, e.List = i.List, e.Orphan = i.Orphan, e.PointerList = i.PointerList, e.PointerType = i.PointerType, e.Pointer = i.Pointer, e.Struct = i.Struct, e.Text = i.Text, e.TextList = i.TextList, e.Uint16List = i.Uint16List, e.Uint32List = i.Uint32List, e.Uint64List = i.Uint64List, e.Uint8List = i.Uint8List, e.VoidList = i.VoidList, e.Void = i.Void, e.getBitMask = i.getBitMask, e.getFloat32Mask = i.getFloat32Mask, e.getFloat64Mask = i.getFloat64Mask, e.getInt16Mask = i.getInt16Mask, e.getInt32Mask = i.getInt32Mask, e.getInt64Mask = i.getInt64Mask, e.getInt8Mask = i.getInt8Mask, e.getUint16Mask = i.getUint16Mask, e.getUint32Mask = i.getUint32Mask, e.getUint64Mask = i.getUint64Mask, e.getUint8Mask = i.getUint8Mask;
             var s = r(9661);
             e.Int64 = s.Int64, e.Uint64 = s.Uint64
         },
-        3361: (t, e, r) => {
+        344: (t, e, r) => {
             "use strict";
             Object.defineProperty(e, "__esModule", {
                 value: !0
             });
             var i = r(3834).default("capnp:serialization:arena:arena-allocation-result");
             i("load");
             e.ArenaAllocationResult = function(t, e) {
@@ -12967,15 +12967,15 @@
             Object.defineProperty(e, "__esModule", {
                 value: !0
             });
             var i = r(3834),
                 s = r(2336),
                 n = r(4655),
                 a = r(3806),
-                o = r(3361),
+                o = r(344),
                 c = r(8422),
                 u = i.default("capnp:arena:multi");
             u("load");
             var p = function() {
                 function t(t) {
                     void 0 === t && (t = []), this.kind = c.ArenaKind.MULTI_SEGMENT, this.buffers = t, u("new %s", this)
                 }
@@ -13004,15 +13004,15 @@
             Object.defineProperty(e, "__esModule", {
                 value: !0
             });
             var i = r(3834),
                 s = r(2336),
                 n = r(4655),
                 a = r(3806),
-                o = r(3361),
+                o = r(344),
                 c = r(8422),
                 u = i.default("capnp:arena:single");
             u("load");
             var p = function() {
                 function t(t) {
                     if (void 0 === t && (t = new ArrayBuffer(s.DEFAULT_BUFFER_SIZE)), this.kind = c.ArenaKind.SINGLE_SEGMENT, 0 != (7 & t.byteLength)) throw new Error(a.format(n.SEG_NOT_WORD_ALIGNED, t.byteLength));
                     this.buffer = t, u("new %s", this)
```

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/635.812cb387a85b4a4dd127.js.LICENSE.txt` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/635.f8f404497739316e801c.js.LICENSE.txt`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/713.44bebcfa12a45c30ff83.js` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/713.44bebcfa12a45c30ff83.js`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/744.ca2ab2033fd1289054ea.js` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/744.d153a5e460cf3f20c96b.js`

 * *Files 19% similar despite different names*

#### js-beautify {}

```diff
@@ -1,65 +1,65 @@
 "use strict";
 (self.webpackChunk_tiledb_inc_jupyter_bioimage_viewer = self.webpackChunk_tiledb_inc_jupyter_bioimage_viewer || []).push([
     [744], {
-        1744: (e, i, t) => {
-            t.r(i), t.d(i, {
-                MODULE_NAME: () => o,
+        1744: (e, i, l) => {
+            l.r(i), l.d(i, {
+                MODULE_NAME: () => a,
                 MODULE_VERSION: () => r,
                 default: () => c
             });
-            var l = {};
-            t.r(l), t.d(l, {
-                BioImageViewerModel: () => u,
+            var t = {};
+            l.r(t), l.d(t, {
+                BioImageViewerModel: () => d,
                 BioImageViewerView: () => p
             });
-            var s = t(8233);
-            const n = t(4147),
+            var s = l(8233);
+            const n = l(4147),
                 r = n.version,
-                o = n.name;
-            var a = t(2832),
-                d = t.n(a);
-            class u extends s.DOMWidgetModel {
+                a = n.name;
+            var o = l(2832),
+                u = l.n(o);
+            class d extends s.DOMWidgetModel {
                 defaults() {
                     return Object.assign(Object.assign({}, super.defaults()), {
-                        _model_name: u.model_name,
-                        _model_module: u.model_module,
-                        _model_module_version: u.model_module_version,
-                        _view_name: u.view_name,
-                        _view_module: u.view_module,
-                        _view_module_version: u.view_module_version
+                        _model_name: d.model_name,
+                        _model_module: d.model_module,
+                        _model_module_version: d.model_module_version,
+                        _view_name: d.view_name,
+                        _view_module: d.view_module,
+                        _view_module_version: d.view_module_version
                     })
                 }
             }
-            u.model_module = o, u.model_module_version = r, u.view_module = o, u.view_module_version = r, u.serializers = Object.assign({}, s.DOMWidgetModel.serializers), u.model_name = "BioImageViewerModel", u.view_name = "BioImageViewerView";
+            d.model_module = a, d.model_module_version = r, d.view_module = a, d.view_module_version = r, d.serializers = Object.assign({}, s.DOMWidgetModel.serializers), d.model_name = "BioImageViewerModel", d.view_name = "BioImageViewerView";
             class p extends s.DOMWidgetView {
                 constructor() {
                     super(...arguments), this.values = this.model.get("value")
                 }
                 render() {
                     const e = document.createElement("div");
-                    this.el.appendChild(e), d()({
+                    this.el.appendChild(e), u()({
                         rootElement: e,
                         apiKey: this.values.token,
                         groupID: this.values.groupID,
                         namespace: this.values.namespace
                     })
                 }
             }
             const c = {
                 id: "@tiledb-inc/jupyter-bioimage-viewer",
                 autoStart: !0,
                 requires: [s.IJupyterWidgetRegistry],
                 activate: function(e, i) {
                     i.registerWidget({
-                        name: o,
+                        name: a,
                         version: r,
-                        exports: l
+                        exports: t
                     })
                 }
             }
         },
         4147: e => {
-            e.exports = JSON.parse('{"name":"@tiledb-inc/jupyter-bioimage-viewer","version":"0.1.1-alpha.7","description":"A jupyterlab extension to visualize bioimages in TileDB format","keywords":["jupyter","jupyterlab","jupyterlab-extension"],"homepage":"https://github.com/TileDB-Inc/TileDB-Jupyter-BioImage-Viewer","bugs":{"url":"https://github.com/TileDB-Inc/TileDB-Jupyter-BioImage-Viewer/issues"},"license":"BSD-3-Clause","author":"TileDB","files":["lib/**/*.{d.ts,eot,gif,html,jpg,js,js.map,json,png,svg,woff2,ttf}","style/**/*.{css,.js,eot,gif,html,jpg,json,png,svg,woff2,ttf}","style/*.css","style/index.js"],"main":"lib/index.js","types":"lib/index.d.ts","style":"style/index.css","repository":{"type":"git","url":"https://github.com/TileDB-Inc/TileDB-Jupyter-BioImage-Viewer.git"},"scripts":{"test":"echo No tests yet","build":"jlpm run build:lib && jlpm run build:labextension:dev","build:prod":"jlpm run build:lib && jlpm run build:labextension","build:labextension":"jupyter labextension build .","build:labextension:dev":"jupyter labextension build --development True .","build:lib":"tsc","clean":"jlpm run clean:lib","clean:lib":"rimraf lib tsconfig.tsbuildinfo","clean:labextension":"rimraf tiledb_jupyter_bioimg/labextension","clean:all":"jlpm run clean:lib && jlpm run clean:labextension","eslint":"eslint . --ext .ts,.tsx --fix","eslint:check":"eslint . --ext .ts,.tsx","install:extension":"jupyter labextension develop --overwrite .","prepare":"jlpm run clean && jlpm run build:prod","watch":"run-p watch:src watch:labextension","watch:src":"tsc -w","watch:labextension":"jupyter labextension watch ."},"dependencies":{"@jupyter-widgets/base":"^1.1.10 || ^2 || ^3 || ^4","@jupyterlab/application":"^3.4.5","@tiledb-inc/bioimage-viewer":"^0.1.0-alpha.7"},"devDependencies":{"@jupyterlab/builder":"^3.1.0","@typescript-eslint/eslint-plugin":"^2.27.0","@typescript-eslint/parser":"^2.27.0","eslint":"^7.5.0","eslint-config-prettier":"^6.10.1","eslint-plugin-prettier":"^3.1.2","npm-run-all":"^4.1.5","prettier":"^1.19.0","rimraf":"^3.0.2","typescript":"~4.1.3"},"resolutions":{"@luma.gl/constants":"^8.5.16","@deck.gl/aggregation-layers":"^8.8.12","@deck.gl/core":"^8.8.12","@deck.gl/carto":"^8.8.12","@deck.gl/extensions":"^8.8.12","@deck.gl/geo-layers":"^8.8.12","@deck.gl/google-maps":"^8.8.12","@deck.gl/mapbox":"^8.8.12","@deck.gl/json":"^8.8.12","@deck.gl/layers":"^8.8.12","@deck.gl/mesh-layers":"^8.8.12","@deck.gl/react":"^8.8.12"},"sideEffects":["style/*.css","style/index.js"],"styleModule":"style/index.js","jupyterlab":{"extension":"lib/index","outputDir":"tiledb_jupyter_bioimg/labextension","webpackConfig":"./webpack.config.js"}}')
+            e.exports = JSON.parse('{"name":"@tiledb-inc/jupyter-bioimage-viewer","version":"0.1.1-alpha.8","description":"A jupyterlab extension to visualize bioimages in TileDB format","keywords":["jupyter","jupyterlab","jupyterlab-extension"],"homepage":"https://github.com/TileDB-Inc/TileDB-Jupyter-BioImage-Viewer","bugs":{"url":"https://github.com/TileDB-Inc/TileDB-Jupyter-BioImage-Viewer/issues"},"license":"BSD-3-Clause","author":"TileDB","files":["lib/**/*.{d.ts,eot,gif,html,jpg,js,js.map,json,png,svg,woff2,ttf}","style/**/*.{css,.js,eot,gif,html,jpg,json,png,svg,woff2,ttf}","style/*.css","style/index.js"],"main":"lib/index.js","types":"lib/index.d.ts","style":"style/index.css","repository":{"type":"git","url":"https://github.com/TileDB-Inc/TileDB-Jupyter-BioImage-Viewer.git"},"scripts":{"test":"echo No tests yet","build":"jlpm run build:lib && jlpm run build:labextension:dev","build:prod":"jlpm run build:lib && jlpm run build:labextension","build:labextension":"jupyter labextension build .","build:labextension:dev":"jupyter labextension build --development True .","build:lib":"tsc","clean":"jlpm run clean:lib","clean:lib":"rimraf lib tsconfig.tsbuildinfo","clean:labextension":"rimraf tiledb_jupyter_bioimg/labextension","clean:all":"jlpm run clean:lib && jlpm run clean:labextension","eslint":"eslint . --ext .ts,.tsx --fix","eslint:check":"eslint . --ext .ts,.tsx","install:extension":"jupyter labextension develop --overwrite .","prepare":"jlpm run clean && jlpm run build:prod","watch":"run-p watch:src watch:labextension","watch:src":"tsc -w","watch:labextension":"jupyter labextension watch ."},"dependencies":{"@jupyter-widgets/base":"^1.1.10 || ^2 || ^3 || ^4","@jupyterlab/application":"^3.4.5","@tiledb-inc/bioimage-viewer":"^0.1.0-alpha.7"},"devDependencies":{"@jupyterlab/builder":"^3.1.0","@typescript-eslint/eslint-plugin":"^2.27.0","@typescript-eslint/parser":"^2.27.0","eslint":"^7.5.0","eslint-config-prettier":"^6.10.1","eslint-plugin-prettier":"^3.1.2","npm-run-all":"^4.1.5","prettier":"^1.19.0","rimraf":"^3.0.2","typescript":"~4.1.3"},"resolutions":{"@luma.gl/constants":"8.5.16","@luma.gl/core":"8.5.16","@luma.gl/engine":"8.5.16","@luma.gl/experimental":"8.5.16","@luma.gl/gltools":"8.5.16","@luma.gl/shadertools":"8.5.16","@luma.gl/webgl":"8.5.16","@deck.gl/aggregation-layers":"8.8.12","@deck.gl/core":"8.8.12","@deck.gl/carto":"8.8.12","@deck.gl/extensions":"8.8.12","@deck.gl/geo-layers":"8.8.12","@deck.gl/google-maps":"8.8.12","@deck.gl/mapbox":"8.8.12","@deck.gl/json":"8.8.12","@deck.gl/layers":"8.8.12","@deck.gl/mesh-layers":"8.8.12","@deck.gl/react":"8.8.12"},"sideEffects":["style/*.css","style/index.js"],"styleModule":"style/index.js","jupyterlab":{"extension":"lib/index","outputDir":"tiledb_jupyter_bioimg/labextension","webpackConfig":"./webpack.config.js"}}')
         }
     }
 ]);
```

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/747.433530952542f03ebc71.js` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/747.433530952542f03ebc71.js`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/remoteEntry.5cdbd27cab7657a97979.js` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/remoteEntry.d5c184be36166b094633.js`

 * *Files 11% similar despite different names*

#### js-beautify {}

```diff
@@ -1,11 +1,11 @@
 var _JUPYTERLAB;
 (() => {
     "use strict";
-    var e, r, t, a, n, i, o, d, l, u, s, c, f, p, h, b, v, m, g, y = {
+    var e, r, t, a, n, i, o, d, l, u, c, s, f, p, h, b, v, m, g, y = {
             5290: (e, r, t) => {
                 var a = {
                         "./index": () => t.e(744).then((() => () => t(1744))),
                         "./extension": () => t.e(744).then((() => () => t(1744))),
                         "./style": () => t.e(747).then((() => () => t(9747)))
                     },
                     n = (e, r) => (t.R = r, r = t.o(a, e) ? a[e]() : Promise.resolve().then((() => {
@@ -46,30 +46,30 @@
         for (var t in r) j.o(r, t) && !j.o(e, t) && Object.defineProperty(e, t, {
             enumerable: !0,
             get: r[t]
         })
     }, j.f = {}, j.e = e => Promise.all(Object.keys(j.f).reduce(((r, t) => (j.f[t](e, r), r)), [])), j.u = e => e + "." + {
         38: "06c00f555d53e8ae5aa5",
         172: "6267f3dd3063477e34ed",
-        344: "8db93920a8ca0f0600d9",
+        287: "6f9268acd2e30d19aed9",
         446: "3bf34f45c93ace9c0f28",
-        633: "1125117a0017a3fcb647",
-        635: "812cb387a85b4a4dd127",
+        633: "f2676ca35060e71f16a0",
+        635: "f8f404497739316e801c",
         713: "44bebcfa12a45c30ff83",
-        744: "ca2ab2033fd1289054ea",
+        744: "d153a5e460cf3f20c96b",
         747: "433530952542f03ebc71"
     } [e] + ".js?v=" + {
         38: "06c00f555d53e8ae5aa5",
         172: "6267f3dd3063477e34ed",
-        344: "8db93920a8ca0f0600d9",
+        287: "6f9268acd2e30d19aed9",
         446: "3bf34f45c93ace9c0f28",
-        633: "1125117a0017a3fcb647",
-        635: "812cb387a85b4a4dd127",
+        633: "f2676ca35060e71f16a0",
+        635: "f8f404497739316e801c",
         713: "44bebcfa12a45c30ff83",
-        744: "ca2ab2033fd1289054ea",
+        744: "d153a5e460cf3f20c96b",
         747: "433530952542f03ebc71"
     } [e], j.g = function() {
         if ("object" == typeof globalThis) return globalThis;
         try {
             return this || new Function("return this")()
         } catch (e) {
             if ("object" == typeof window) return window
@@ -81,31 +81,31 @@
         }
     }), e), j.o = (e, r) => Object.prototype.hasOwnProperty.call(e, r), e = {}, r = "@tiledb-inc/jupyter-bioimage-viewer:", j.l = (t, a, n, i) => {
         if (e[t]) e[t].push(a);
         else {
             var o, d;
             if (void 0 !== n)
                 for (var l = document.getElementsByTagName("script"), u = 0; u < l.length; u++) {
-                    var s = l[u];
-                    if (s.getAttribute("src") == t || s.getAttribute("data-webpack") == r + n) {
-                        o = s;
+                    var c = l[u];
+                    if (c.getAttribute("src") == t || c.getAttribute("data-webpack") == r + n) {
+                        o = c;
                         break
                     }
                 }
             o || (d = !0, (o = document.createElement("script")).charset = "utf-8", o.timeout = 120, j.nc && o.setAttribute("nonce", j.nc), o.setAttribute("data-webpack", r + n), o.src = t), e[t] = [a];
-            var c = (r, a) => {
+            var s = (r, a) => {
                     o.onerror = o.onload = null, clearTimeout(f);
                     var n = e[t];
                     if (delete e[t], o.parentNode && o.parentNode.removeChild(o), n && n.forEach((e => e(a))), r) return r(a)
                 },
-                f = setTimeout(c.bind(null, void 0, {
+                f = setTimeout(s.bind(null, void 0, {
                     type: "timeout",
                     target: o
                 }), 12e4);
-            o.onerror = c.bind(null, o.onerror), o.onload = c.bind(null, o.onload), d && document.head.appendChild(o)
+            o.onerror = s.bind(null, o.onerror), o.onload = s.bind(null, o.onload), d && document.head.appendChild(o)
         }
     }, j.r = e => {
         "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
             value: "Module"
         }), Object.defineProperty(e, "__esModule", {
             value: !0
         })
@@ -127,15 +127,15 @@
                         (!d || !d.loaded && (!a != !d.eager ? a : o > d.from)) && (n[r] = {
                             get: t,
                             from: o,
                             eager: !!a
                         })
                     },
                     l = [];
-                return "default" === t && (d("@jupyter-widgets/base", "4.1.1", (() => Promise.all([j.e(172), j.e(713), j.e(38)]).then((() => () => j(2713))))), d("@tiledb-inc/bioimage-viewer", "0.1.0-alpha.7", (() => Promise.all([j.e(635), j.e(172), j.e(344), j.e(446)]).then((() => () => j(344))))), d("@tiledb-inc/jupyter-bioimage-viewer", "0.1.1-alpha.7", (() => j.e(744).then((() => () => j(1744)))))), e[t] = l.length ? Promise.all(l).then((() => e[t] = 1)) : 1
+                return "default" === t && (d("@jupyter-widgets/base", "4.1.1", (() => Promise.all([j.e(172), j.e(713), j.e(38)]).then((() => () => j(2713))))), d("@tiledb-inc/bioimage-viewer", "0.1.0-alpha.7", (() => Promise.all([j.e(635), j.e(172), j.e(287), j.e(446)]).then((() => () => j(7287))))), d("@tiledb-inc/jupyter-bioimage-viewer", "0.1.1-alpha.8", (() => j.e(744).then((() => () => j(1744)))))), e[t] = l.length ? Promise.all(l).then((() => e[t] = 1)) : 1
             }
         }
     })(), (() => {
         var e;
         j.g.importScripts && (e = j.g.location + "");
         var r = j.g.document;
         if (!e && r && (r.currentScript && (e = r.currentScript.src), !e)) {
@@ -185,33 +185,33 @@
     }, i = (e, r) => {
         if (0 in e) {
             r = t(r);
             var a = e[0],
                 n = a < 0;
             n && (a = -a - 1);
             for (var o = 0, d = 1, l = !0;; d++, o++) {
-                var u, s, c = d < e.length ? (typeof e[d])[0] : "";
-                if (o >= r.length || "o" == (s = (typeof(u = r[o]))[0])) return !l || ("u" == c ? d > a && !n : "" == c != n);
-                if ("u" == s) {
-                    if (!l || "u" != c) return !1
+                var u, c, s = d < e.length ? (typeof e[d])[0] : "";
+                if (o >= r.length || "o" == (c = (typeof(u = r[o]))[0])) return !l || ("u" == s ? d > a && !n : "" == s != n);
+                if ("u" == c) {
+                    if (!l || "u" != s) return !1
                 } else if (l)
-                    if (c == s)
+                    if (s == c)
                         if (d <= a) {
                             if (u != e[d]) return !1
                         } else {
                             if (n ? u > e[d] : u < e[d]) return !1;
                             u != e[d] && (l = !1)
                         }
-                else if ("s" != c && "n" != c) {
+                else if ("s" != s && "n" != s) {
                     if (n || d <= a) return !1;
                     l = !1, d--
                 } else {
-                    if (d <= a || s < c != n) return !1;
+                    if (d <= a || c < s != n) return !1;
                     l = !1
-                } else "s" != c && "n" != c && (l = !1, d--)
+                } else "s" != s && "n" != s && (l = !1, d--)
             }
         }
         var f = [],
             p = f.pop.bind(f);
         for (o = 1; o < e.length; o++) {
             var h = e[o];
             f.push(1 == h ? p() | p() : 2 == h ? p() & p() : h ? i(h, r) : !p())
@@ -222,28 +222,28 @@
         if (!t || !j.o(t, r)) throw new Error("Shared module " + r + " doesn't exist in shared scope " + e);
         return t
     }, d = (e, r) => {
         var t = e[r];
         return Object.keys(t).reduce(((e, r) => !e || !t[e].loaded && a(e, r) ? r : e), 0)
     }, l = (e, r, t, a) => "Unsatisfied version " + t + " from " + (t && e[r][t].from) + " of shared singleton module " + r + " (required " + n(a) + ")", u = (e, r, t, a) => {
         var n = d(e, t);
-        return i(a, n) || c(l(e, t, n, a)), f(e[t][n])
-    }, s = (e, r, t) => {
+        return i(a, n) || s(l(e, t, n, a)), f(e[t][n])
+    }, c = (e, r, t) => {
         var n = e[r];
         return (r = Object.keys(n).reduce(((e, r) => !i(t, r) || e && !a(e, r) ? e : r), 0)) && n[r]
-    }, c = e => {
+    }, s = e => {
         "undefined" != typeof console && console.warn && console.warn(e)
     }, f = e => (e.loaded = 1, e.get()), h = (p = e => function(r, t, a, n) {
         var i = j.I(r);
         return i && i.then ? i.then(e.bind(e, r, j.S[r], t, a, n)) : e(r, j.S[r], t, a, n)
     })(((e, r, t, a) => (o(e, t), u(r, 0, t, a)))), b = p(((e, r, t, a, n) => {
-        var i = r && j.o(r, t) && s(r, t, a);
+        var i = r && j.o(r, t) && c(r, t, a);
         return i ? f(i) : n()
     })), v = {}, m = {
-        2832: () => b("default", "@tiledb-inc/bioimage-viewer", [2, 0, 1, 0, , "alpha", 7], (() => Promise.all([j.e(635), j.e(172), j.e(344), j.e(446)]).then((() => () => j(344))))),
+        2832: () => b("default", "@tiledb-inc/bioimage-viewer", [2, 0, 1, 0, , "alpha", 7], (() => Promise.all([j.e(635), j.e(172), j.e(287), j.e(446)]).then((() => () => j(7287))))),
         8233: () => b("default", "@jupyter-widgets/base", [, [1, 4],
             [1, 3],
             [1, 2],
             [1, 1, 1, 10], 1, 1, 1
         ], (() => Promise.all([j.e(172), j.e(713), j.e(38)]).then((() => () => j(2713))))),
         1526: () => h("default", "@lumino/coreutils", [1, 1, 11, 0]),
         2720: () => h("default", "@lumino/messaging", [1, 1, 10, 0]),
```

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/labextension/static/third-party-licenses.json` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/labextension/static/third-party-licenses.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9889112903225806%*

 * *Differences: {"'packages'": "{1: {'versionInfo': '8.8.12'}, 2: {'versionInfo': '8.8.12'}, 3: {'versionInfo': "*

 * *               "'8.8.12'}, 4: {'versionInfo': '8.8.12'}, 11: {'versionInfo': '8.5.16'}, 12: "*

 * *               "{'versionInfo': '8.5.16'}, 13: {'versionInfo': '8.5.16'}, 14: {'versionInfo': "*

 * *               "'8.5.16'}, 15: {'versionInfo': '8.5.16'}, 16: {'versionInfo': '1.2.5', "*

 * *               "'extractedText': 'Copyright © 2016-2021 Mapbox, Inc.\\nThis code available under "*

 * *               'the terms of the BSD […]*

```diff
@@ -6,33 +6,33 @@
             "name": "@babel/runtime",
             "versionInfo": "7.21.5"
         },
         {
             "extractedText": "Copyright (c) 2020 Urban Computing Foundation\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n",
             "licenseId": "MIT",
             "name": "@deck.gl/core",
-            "versionInfo": "8.9.16"
+            "versionInfo": "8.8.12"
         },
         {
             "extractedText": "Copyright (c) 2020 Urban Computing Foundation\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n",
             "licenseId": "MIT",
             "name": "@deck.gl/geo-layers",
-            "versionInfo": "8.9.16"
+            "versionInfo": "8.8.12"
         },
         {
             "extractedText": "Copyright (c) 2020 Urban Computing Foundation\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n",
             "licenseId": "MIT",
             "name": "@deck.gl/layers",
-            "versionInfo": "8.9.16"
+            "versionInfo": "8.8.12"
         },
         {
             "extractedText": "Copyright (c) 2020 Urban Computing Foundation\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n",
             "licenseId": "MIT",
             "name": "@deck.gl/react",
-            "versionInfo": "8.9.16"
+            "versionInfo": "8.8.12"
         },
         {
             "extractedText": "",
             "licenseId": "MIT",
             "name": "@icons/material",
             "versionInfo": "0.2.4"
         },
@@ -66,45 +66,45 @@
             "name": "@loaders.gl/worker-utils",
             "versionInfo": "3.4.4"
         },
         {
             "extractedText": "Copyright (c) 2015 Uber Technologies, Inc.\n\nThis software includes parts of PhiloGL (https://github.com/philogb/philogl)\nunder MIT license. PhiloGL parts Copyright \u00a9 2013 Sencha Labs.\n\nThis software includes adaptations of postprocessing code from THREE.js (https://github.com/mrdoob/three.js/) under MIT license. Additional attribution given in specific source files. THREE.js parts Copyright \u00a9 2010-2018 three.js authors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n",
             "licenseId": "MIT",
             "name": "@luma.gl/constants",
-            "versionInfo": "8.5.20"
+            "versionInfo": "8.5.16"
         },
         {
             "extractedText": "Copyright (c) 2015 Uber Technologies, Inc.\n\nThis software includes parts of PhiloGL (https://github.com/philogb/philogl)\nunder MIT license. PhiloGL parts Copyright \u00a9 2013 Sencha Labs.\n\nThis software includes adaptations of postprocessing code from THREE.js (https://github.com/mrdoob/three.js/) under MIT license. Additional attribution given in specific source files. THREE.js parts Copyright \u00a9 2010-2018 three.js authors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n",
             "licenseId": "MIT",
             "name": "@luma.gl/engine",
-            "versionInfo": "8.5.20"
+            "versionInfo": "8.5.16"
         },
         {
             "extractedText": "Copyright (c) 2015 Uber Technologies, Inc.\n\nThis software includes parts of PhiloGL (https://github.com/philogb/philogl)\nunder MIT license. PhiloGL parts Copyright \u00a9 2013 Sencha Labs.\n\nThis software includes adaptations of postprocessing code from THREE.js (https://github.com/mrdoob/three.js/) under MIT license. Additional attribution given in specific source files. THREE.js parts Copyright \u00a9 2010-2018 three.js authors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n",
             "licenseId": "MIT",
             "name": "@luma.gl/gltools",
-            "versionInfo": "8.5.20"
+            "versionInfo": "8.5.16"
         },
         {
             "extractedText": "Copyright (c) 2015 Uber Technologies, Inc.\n\nThis software includes parts of PhiloGL (https://github.com/philogb/philogl)\nunder MIT license. PhiloGL parts Copyright \u00a9 2013 Sencha Labs.\n\nThis software includes adaptations of postprocessing code from THREE.js (https://github.com/mrdoob/three.js/) under MIT license. Additional attribution given in specific source files. THREE.js parts Copyright \u00a9 2010-2018 three.js authors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n",
             "licenseId": "MIT",
             "name": "@luma.gl/shadertools",
-            "versionInfo": "8.5.20"
+            "versionInfo": "8.5.16"
         },
         {
             "extractedText": "Copyright (c) 2015 Uber Technologies, Inc.\n\nThis software includes parts of PhiloGL (https://github.com/philogb/philogl)\nunder MIT license. PhiloGL parts Copyright \u00a9 2013 Sencha Labs.\n\nThis software includes adaptations of postprocessing code from THREE.js (https://github.com/mrdoob/three.js/) under MIT license. Additional attribution given in specific source files. THREE.js parts Copyright \u00a9 2010-2018 three.js authors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n",
             "licenseId": "MIT",
             "name": "@luma.gl/webgl",
-            "versionInfo": "8.5.20"
+            "versionInfo": "8.5.16"
         },
         {
-            "extractedText": "BSD-2-Clause\nCopyright (c) 2016-2022 Mapbox, Inc.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
+            "extractedText": "Copyright \u00a9 2016-2021 Mapbox, Inc.\nThis code available under the terms of the BSD 2-Clause license.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
             "licenseId": "BSD-2-Clause",
             "name": "@mapbox/tiny-sdf",
-            "versionInfo": "2.0.6"
+            "versionInfo": "1.2.5"
         },
         {
             "extractedText": "MIT License\n\nCopyright (c) 2017 Uber Technologies, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---\n\nmath.gl builds on docs and code from \"gl-matrix\", which is MIT licensed as follows:\n\nCopyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n--\n\nmath.gl builds on docs and code from THREE.js, which is MIT licensed as follows:\n\nThe MIT License\n\nCopyright \u00a9 2010-2017 three.js authors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---\n\nmath.gl includes certain files from Cesium (https://github.com/AnalyticalGraphicsInc/cesium) under the Apache 2 License:\n\nCopyright 2011-2018 CesiumJS Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and limitations under the License.\n\nCesium-derived code can be found in the submodule: modules/3d-tiles\n",
             "licenseId": "MIT",
             "name": "@math.gl/core",
             "versionInfo": "3.6.3"
         },
```

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg/render.py` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg/render.py`

 * *Files identical despite different names*

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg.egg-info/PKG-INFO` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: tiledb-jupyter-bioimg
-Version: 0.1.1a7
+Version: 0.1.1a8
 Summary: A jupyterlab extension to visualize bioimages in TileDB format
 Home-page: https://github.com/TileDB-Inc/TileDB-Jupyter-BioImage-Viewer
 Author: TileDB
 License: BSD-3-Clause
 Keywords: Jupyter,JupyterLab,JupyterLab3
 Platform: Linux
 Platform: Mac OS X
```

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tiledb_jupyter_bioimg.egg-info/SOURCES.txt` & `tiledb_jupyter_bioimg-0.1.1a8/tiledb_jupyter_bioimg.egg-info/SOURCES.txt`

 * *Files 11% similar despite different names*

```diff
@@ -21,20 +21,20 @@
 tiledb_jupyter_bioimg.egg-info/dependency_links.txt
 tiledb_jupyter_bioimg.egg-info/not-zip-safe
 tiledb_jupyter_bioimg.egg-info/requires.txt
 tiledb_jupyter_bioimg.egg-info/top_level.txt
 tiledb_jupyter_bioimg/labextension/package.json
 tiledb_jupyter_bioimg/labextension/static/08450fe724517d116eb4ec755231ced4eb5bf019b478cb080efd58ad83c5e211.svg
 tiledb_jupyter_bioimg/labextension/static/172.6267f3dd3063477e34ed.js
-tiledb_jupyter_bioimg/labextension/static/344.8db93920a8ca0f0600d9.js
-tiledb_jupyter_bioimg/labextension/static/344.8db93920a8ca0f0600d9.js.LICENSE.txt
+tiledb_jupyter_bioimg/labextension/static/287.6f9268acd2e30d19aed9.js
+tiledb_jupyter_bioimg/labextension/static/287.6f9268acd2e30d19aed9.js.LICENSE.txt
 tiledb_jupyter_bioimg/labextension/static/446.3bf34f45c93ace9c0f28.js
-tiledb_jupyter_bioimg/labextension/static/633.1125117a0017a3fcb647.js
-tiledb_jupyter_bioimg/labextension/static/635.812cb387a85b4a4dd127.js
-tiledb_jupyter_bioimg/labextension/static/635.812cb387a85b4a4dd127.js.LICENSE.txt
+tiledb_jupyter_bioimg/labextension/static/633.f2676ca35060e71f16a0.js
+tiledb_jupyter_bioimg/labextension/static/635.f8f404497739316e801c.js
+tiledb_jupyter_bioimg/labextension/static/635.f8f404497739316e801c.js.LICENSE.txt
 tiledb_jupyter_bioimg/labextension/static/713.44bebcfa12a45c30ff83.js
 tiledb_jupyter_bioimg/labextension/static/713.44bebcfa12a45c30ff83.js.LICENSE.txt
-tiledb_jupyter_bioimg/labextension/static/744.ca2ab2033fd1289054ea.js
+tiledb_jupyter_bioimg/labextension/static/744.d153a5e460cf3f20c96b.js
 tiledb_jupyter_bioimg/labextension/static/747.433530952542f03ebc71.js
-tiledb_jupyter_bioimg/labextension/static/remoteEntry.5cdbd27cab7657a97979.js
+tiledb_jupyter_bioimg/labextension/static/remoteEntry.d5c184be36166b094633.js
 tiledb_jupyter_bioimg/labextension/static/style.js
 tiledb_jupyter_bioimg/labextension/static/third-party-licenses.json
```

### Comparing `tiledb_jupyter_bioimg-0.1.1a7/tsconfig.json` & `tiledb_jupyter_bioimg-0.1.1a8/tsconfig.json`

 * *Files identical despite different names*

