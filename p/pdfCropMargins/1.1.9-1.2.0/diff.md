# Comparing `tmp/pdfCropMargins-1.1.9-py2.py3-none-any.whl.zip` & `tmp/pdfCropMargins-1.2.0-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,26 @@
-Zip file size: 1832933 bytes, number of entries: 23
--rw-rw-r--  2.0 unx      215 b- defN 22-Dec-29 21:48 pdfCropMargins/__init__.py
+Zip file size: 1839751 bytes, number of entries: 24
+-rw-rw-r--  2.0 unx      215 b- defN 23-May-31 00:03 pdfCropMargins/__init__.py
 -rw-rw-r--  2.0 unx      197 b- defN 22-Dec-07 15:25 pdfCropMargins/__main__.py
--rw-rw-r--  2.0 unx    13904 b- defN 22-Dec-07 17:49 pdfCropMargins/calculate_bounding_boxes.py
+-rw-rw-r--  2.0 unx    13904 b- defN 23-May-31 00:03 pdfCropMargins/calculate_bounding_boxes.py
 -rw-rw-r--  2.0 unx      181 b- defN 22-Dec-07 15:25 pdfCropMargins/directory_locator.py
--rw-rw-r--  2.0 unx    31258 b- defN 22-Dec-07 15:25 pdfCropMargins/external_program_calls.py
--rw-rw-r--  2.0 unx    53028 b- defN 22-Dec-15 19:05 pdfCropMargins/gui.py
--rw-rw-r--  2.0 unx    74626 b- defN 22-Dec-16 19:25 pdfCropMargins/main_pdfCropMargins.py
--rw-rw-r--  2.0 unx    47887 b- defN 22-Dec-16 19:39 pdfCropMargins/manpage_data.py
--rw-rw-r--  2.0 unx     8204 b- defN 22-Dec-07 15:25 pdfCropMargins/pdfCropMargins.py
+-rw-rw-r--  2.0 unx    31258 b- defN 23-May-31 00:03 pdfCropMargins/external_program_calls.py
+-rw-rw-r--  2.0 unx     8673 b- defN 23-Mar-12 21:58 pdfCropMargins/get_window_sizing_info.py
+-rw-rw-r--  2.0 unx    58643 b- defN 23-Mar-12 22:46 pdfCropMargins/gui.py
+-rw-rw-r--  2.0 unx    79226 b- defN 23-May-31 00:03 pdfCropMargins/main_pdfCropMargins.py
+-rw-rw-r--  2.0 unx    49723 b- defN 23-May-31 00:03 pdfCropMargins/manpage_data.py
+-rw-rw-r--  2.0 unx     8262 b- defN 22-Dec-31 02:09 pdfCropMargins/pdfCropMargins.py
 -rw-rw-r--  2.0 unx     8924 b- defN 22-Dec-07 15:25 pdfCropMargins/prettified_argparse.py
--rw-rw-r--  2.0 unx    11017 b- defN 22-Dec-16 22:50 pdfCropMargins/pymupdf_routines.py
+-rw-rw-r--  2.0 unx    12497 b- defN 23-May-31 00:03 pdfCropMargins/pymupdf_routines.py
 -rw-rw-r--  2.0 unx        0 b- defN 17-Mar-05 00:20 pdfCropMargins/pdftoppm_windows_local/__init__.py
 -rw-rw-r--  2.0 unx        0 b- defN 19-Aug-19 00:10 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/__init__.py
 -rw-rw-r--  2.0 unx        0 b- defN 19-Aug-19 00:32 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/__init__.py
 -rwxr-xr--  2.0 unx  1690624 b- defN 19-Aug-19 00:06 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/pdftoppm.exe
 -rw-rw-r--  2.0 unx        0 b- defN 19-Aug-19 00:32 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/__init__.py
 -rwxr-xr--  2.0 unx  2090496 b- defN 19-Aug-19 00:06 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/pdftoppm.exe
--rw-rw-r--  2.0 unx    35546 b- defN 22-Dec-29 22:12 pdfCropMargins-1.1.9.dist-info/LICENSE
--rw-rw-r--  2.0 unx    60115 b- defN 22-Dec-29 22:12 pdfCropMargins-1.1.9.dist-info/METADATA
--rw-rw-r--  2.0 unx      110 b- defN 22-Dec-29 22:12 pdfCropMargins-1.1.9.dist-info/WHEEL
--rw-rw-r--  2.0 unx      125 b- defN 22-Dec-29 22:12 pdfCropMargins-1.1.9.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx       15 b- defN 22-Dec-29 22:12 pdfCropMargins-1.1.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2288 b- defN 22-Dec-29 22:12 pdfCropMargins-1.1.9.dist-info/RECORD
-23 files, 4128760 bytes uncompressed, 1829091 bytes compressed:  55.7%
+-rw-rw-r--  2.0 unx    35546 b- defN 23-May-31 00:07 pdfCropMargins-1.2.0.dist-info/LICENSE
+-rw-rw-r--  2.0 unx    61810 b- defN 23-May-31 00:07 pdfCropMargins-1.2.0.dist-info/METADATA
+-rw-rw-r--  2.0 unx      110 b- defN 23-May-31 00:07 pdfCropMargins-1.2.0.dist-info/WHEEL
+-rw-rw-r--  2.0 unx      125 b- defN 23-May-31 00:07 pdfCropMargins-1.2.0.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx       15 b- defN 23-May-31 00:07 pdfCropMargins-1.2.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2385 b- defN 23-May-31 00:07 pdfCropMargins-1.2.0.dist-info/RECORD
+24 files, 4152814 bytes uncompressed, 1835753 bytes compressed:  55.8%
```

## zipnote {}

```diff
@@ -9,14 +9,17 @@
 
 Filename: pdfCropMargins/directory_locator.py
 Comment: 
 
 Filename: pdfCropMargins/external_program_calls.py
 Comment: 
 
+Filename: pdfCropMargins/get_window_sizing_info.py
+Comment: 
+
 Filename: pdfCropMargins/gui.py
 Comment: 
 
 Filename: pdfCropMargins/main_pdfCropMargins.py
 Comment: 
 
 Filename: pdfCropMargins/manpage_data.py
@@ -45,26 +48,26 @@
 
 Filename: pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/__init__.py
 Comment: 
 
 Filename: pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/pdftoppm.exe
 Comment: 
 
-Filename: pdfCropMargins-1.1.9.dist-info/LICENSE
+Filename: pdfCropMargins-1.2.0.dist-info/LICENSE
 Comment: 
 
-Filename: pdfCropMargins-1.1.9.dist-info/METADATA
+Filename: pdfCropMargins-1.2.0.dist-info/METADATA
 Comment: 
 
-Filename: pdfCropMargins-1.1.9.dist-info/WHEEL
+Filename: pdfCropMargins-1.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: pdfCropMargins-1.1.9.dist-info/entry_points.txt
+Filename: pdfCropMargins-1.2.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: pdfCropMargins-1.1.9.dist-info/top_level.txt
+Filename: pdfCropMargins-1.2.0.dist-info/top_level.txt
 Comment: 
 
-Filename: pdfCropMargins-1.1.9.dist-info/RECORD
+Filename: pdfCropMargins-1.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pdfCropMargins/__init__.py

```diff
@@ -1,9 +1,9 @@
 """
 pdfCropMargins
 """
 
-__version__ = "1.1.9" # major version, minor version, patch (see PEP440)
+__version__ = "1.2.0" # major version, minor version, patch (see PEP440)
 
 # The only function designed to be called from a user's Python code.
 from pdfCropMargins.pdfCropMargins import crop
```

## pdfCropMargins/gui.py

```diff
@@ -30,53 +30,59 @@
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 """
 
-# Todo: Consider setting up so if no input file argument and the gui is used then
-# the file chooser will pop up.
-
-# Todo: It would be nice to have a resolution option for spinners, so you
-# could have floats (like sliders).  Also, an increment option setting the
-# increment value would be nice.
-
-# Todo: Look into the new Sizer in pySimpleGUI to see if the size of the PDF
-# window can (or should) be fixed to the initial size or something similar.
-# See the existing attempt commented out below.
-
 import sys
 import os
 import warnings
 import textwrap
+import time
+import threading
+import math
+import io
 from types import SimpleNamespace
+from PIL import Image
 
-from . import __version__
 from . import external_program_calls as ex
-from . pymupdf_routines import has_mupdf, MuPdfDocument
+from .pymupdf_routines import has_mupdf, MuPdfDocument
 
 if not has_mupdf:
     print("\nError in pdfCropMargins: The GUI feature requires a recent PyMuPDF version."
           "\n\nExiting pdf-crop-margins...")
     ex.cleanup_and_exit(1)
 
-try: # Extra dependencies for the GUI version.  Make sure they are installed.
+try:
     requires = "PySimpleGUI"
     import PySimpleGUI as sg
     requires = "tkinter"
     import tkinter as tk
 except ImportError:
     print("\nError in pdfCropMargins: The GUI feature requires {}."
           "\n\nExiting pdf-crop-margins...".format(requires), file=sys.stderr)
     ex.cleanup_and_exit(1)
 
+from .get_window_sizing_info import (get_usable_image_size, get_window_size,
+                                     INITIAL_IMAGE_SIZE, FALLBACK_MAX_IMAGE_SIZE,
+                                     FALLBACK_FULL_SCREEN_SIZE, parse_geometry_string)
 from .main_pdfCropMargins import (process_pdf_file, parse_page_range_specifiers,
                                   parse_page_ratio_argument)
 
+# Todo: Consider setting up so if no input file argument and the gui is used then
+# the file chooser will pop up.
+
+# Todo: It would be nice to have a resolution option for spinners, so you
+# could have floats (like sliders).  Also, an increment option setting the
+# increment value per click would be nice.
+
+# Todo: If you hold the window at larger sizes until it resizes the GUI it doesn't
+# resize the window when you let go.  Might be OK behavior, though...
+
 # Uncomment for look and feel preview.
 #print(sg.ListOfLookAndFeelValues())
 #print(sg.LOOK_AND_FEEL_TABLE)
 
 if ex.system_os == "Windows":
     sg.ChangeLookAndFeel("TanBlue")
     sg.theme_text_color("black")
@@ -156,14 +162,15 @@
     args_attr = args_dict[attr]
 
     def update_all_from_args_dict():
         for i in [0,1,2,3]:
             update_value_and_return_it(element_list[i], value=args_attr[i])
 
     try:
+        # This comprehension is just to test that the format is correct and casts work.
         element_text4 = [str(value_type(element_list[i].Get())) for i in [0,1,2,3]]
     except ValueError:
         update_all_from_args_dict() # Replace bad text with saved version.
         return
 
     for i in [0,1,2,3]:
         args_attr[i] = update_value_and_return_it(element_list[i],
@@ -277,14 +284,22 @@
 
     def is_paired_single_and_quadruple_change(btn):
         return btn.startswith("uniformOrderStat")
 
     def is_evenodd(btn):
         return btn.startswith("evenodd")
 
+    def is_general_checkbox_click(btn):
+        # Note is_evenodd is a separate event.
+        return (btn.startswith("uniform") or btn.startswith("samePageSize")
+                or btn.startswith("percentText") or btn.startswith("cropSafe"))
+
+    def is_configure(btn):
+        return btn.startswith("Configure")
+
 #
 # The main function with the event loop.
 #
 
 def create_gui(input_doc_fname, fixed_input_doc_fname, output_doc_fname,
                cmd_parser, parsed_args):
     """Create a GUI for running pdfCropMargins with parsed arguments `parsed_args`
@@ -308,26 +323,26 @@
     sg.SetOptions(tooltip_time=500)
     window_title = f"pdfCropMargins: {os.path.basename(input_doc_fname)}"
 
     ##
     ## Code for the image element, holding the page preview.
     ##
 
-    # Note this max size here must make the image height exceed the size of widgets next to
-    # it. This is needed to accurately calculate the maximum image height below.
-    max_image_size = (700, 700) # This is temporary; it will be calculated and reset below.
-    data, clip_pos, im_ht, im_wid = document_pages.get_display_page(curr_page,
-                                             max_image_size=max_image_size,
-                                             zoom=False,)
-
-    image_element = sg.Image(data=data)  # make image element
-    # TODO: This sort of works to keep constant size pages, but need to select sizes somehow.
-    # Or at least turn on the scrolling option for overflowing images.  Image scaling algorithm
-    # sometimes does strange things; refactor and reconsider.
-    #image_column = sg.Column([[image_element]], size=(750,750))
+    # Note for future: if you pass a small test window you get the GUI controls AND
+    # the non-image height.  Gives an upper bound, anyway, so you could size
+    # the next test image better.  Detects GUI too big to fit in window.
+    INITIAL_IMAGE = Image.new("L", INITIAL_IMAGE_SIZE, color=(222,)) # L = grey
+    with io.BytesIO() as output:
+        INITIAL_IMAGE.save(output, format="png")
+        INITIAL_IMAGE = output.getvalue() # An in-memory PNG image.
+
+    max_image_size = INITIAL_IMAGE_SIZE # This is temporary; size calculated and reset below.
+    im_wid, im_ht = INITIAL_IMAGE_SIZE
+    image_element = sg.Image(data=INITIAL_IMAGE, key="image_element",
+                             pad=((0,5), (0,0)), expand_y=True) # make image element
 
     ##
     ## Code for handling page numbers.
     ##
 
     input_text_page_num = sg.Spin(values=spinner_values, initial_value=str(curr_page + 1),
                                   size=(5, 1), enable_events=True, key="PageNumber")
@@ -564,16 +579,16 @@
     ## Code for restore.
     ##
 
     text_restore = sg.Text("restore", pad=(0,0),
                       tooltip=get_help_text_string_for_tooltip(cmd_parser, "restore"))
 
     combo_box_restore = sg.Combo(["True", "False"], readonly=True,
-                                         default_value=str(args.restore), size=(5, 1),
-                                         key="restore", enable_events=True)
+                                 default_value=str(args.restore), size=(5, 1),
+                                 key="restore", enable_events=True)
 
     def update_restore(values_dict):
         """Update the restore values."""
         update_combo_box(values_dict, combo_box_restore, "restore", args, "restore",
                         fun_to_apply=str_to_bool)
 
     update_funs.append(update_restore)
@@ -801,26 +816,111 @@
             page_num = delta_page_nums[delta_index][index] - 1
             toggle = not toggle
         else:
             page_num = delta_page_nums[delta_index] - 1
         return page_num, toggle
 
     ##
+    ## Page image update and thread to redraw images on a configure/resize event.
+    ##
+
+    def get_max_image_size(window):
+        """Return the largest size rectangle for the PDF image to fit into (after
+        subtracting off the size of the non-image parts of the GUI).  This function
+        should be called on a zoomed/fullscreen window."""
+        max_image_size = (max(window.size[0]-non_image_size[0], FALLBACK_MAX_IMAGE_SIZE[0]),
+                          max(window.size[1]-non_image_size[1], FALLBACK_MAX_IMAGE_SIZE[1]))
+        return max_image_size
+
+    def update_page_image(window, reset_cached=False, zoom=False, max_image_size=None,
+                          update_image_element=True):
+        """Calculate and return data for the image in the PDF preview.  If
+        `max_image_size` is not passed in (the default) it will be calculated.
+        If `update_image_element` is true (the default) then the GUI image is
+        updated with the newly calculated image data."""
+        if max_image_size is None:
+            max_image_size = get_max_image_size(window)
+        image_data, clip_pos, im_ht, im_wid = document_pages.get_display_page(curr_page,
+                                                    max_image_size=max_image_size,
+                                                    zoom=zoom, reset_cached=reset_cached)
+        if update_image_element:
+            image_element.Update(data=image_data)
+        return image_data, clip_pos, im_ht, im_wid
+
+    def resize_window(window, document_pages, max_image_size, non_image_size,
+                      im_wid=None, im_ht=None):
+        """Calculate and set the window size based on the `non_image_size`
+        of the GUI controls and borders and the image's width and height."""
+        if im_wid and im_ht:
+            wid = im_wid
+            ht = im_ht
+        else:
+            max_wid, max_ht = document_pages.get_max_width_and_height()
+            scale_to_pixels = min(max_image_size[0]/max_wid, max_image_size[1]/max_ht)
+            wid = math.ceil(scale_to_pixels * max_wid) # Note: these NEED to be made int, unlike
+            ht = math.ceil(scale_to_pixels * max_ht)   # Postscript points that can be fractional.
+
+        new_window_size = (non_image_size[0] + wid,
+                           non_image_size[1] + ht)
+        window.size = new_window_size
+
+    RESIZE_DELAY_SECS = 0.5 # Time to delay while user resizes window.
+    resize_thread_running = False # Flag to only run one update thread.
+    request_thread_exit = False # Flag used to kill thread on exit.
+
+    def resize_page_on_configure_event(delay_secs=RESIZE_DELAY_SECS,
+                                       max_image_size=None):
+        """This function is run as a thread to redraw preview pages on configure
+        events once the size stabilizes.  Note that this routine sets the nonlocal
+        variables `user_selected_max_image_size`, `old_window_size` (and the flag
+        `resize_thread_running`).  Resize scaling is to make the image fit in
+        the max window size, according to it's largest dimension (width or height)"""
+        nonlocal resize_thread_running, old_window_size, user_selected_max_image_size
+        resize_thread_running = True
+
+        # Wait for user to finish resizing.
+        time.sleep(delay_secs)
+        while window.size != old_window_size:
+            if request_thread_exit:
+                return
+            old_window_size = window.size
+            time.sleep(delay_secs)
+
+        if max_image_size is None:
+            max_image_size = get_max_image_size(window)
+        # Note that if user_selected_max_image_size is passed in it gets reset to itself.
+        user_selected_max_image_size = max_image_size # Saved as a user preference.
+
+        if request_thread_exit:
+            return
+        resize_window(window, document_pages, max_image_size, non_image_size)
+
+        if request_thread_exit:
+            return
+        # TODO: Is this update_page_image really necessary?  Should it come before
+        # or after resize of window?
+        image_data, clip_pos, im_ht, im_wid = update_page_image(window,
+                                                                reset_cached=True,
+                                                                zoom=zoom)
+
+        # Set the old window size and exit thread.
+        old_window_size = window.size
+        resize_thread_running = False
+
+    ##
     ## Code for disabling options that are implied by others.
     ##
 
     backing_uniform_checkbox_value = [args.uniform]
 
     def update_disabled_states(values_dict):
         """Disable widgets that are implied by other selected options."""
         # Disable the uniform checkbox (this option implies uniform cropping).
         # TODO: This should check when disabled then return to previous value, but that
         # is currently not working so it just disables/enables in whatever state.
-        # Also, evenodd should really disable it, too, but needs to do it as an event
-        # in case you uncheck without re-cropping.
         if args.uniformOrderStat4 or values_dict["evenodd"]:
             backing_uniform_checkbox_value[0] = values_dict["uniform"]
             checkbox_uniform.Update(True, disabled=True) # Show that these options imply uniform.
         else:
             if checkbox_uniform.Disabled:
                 checkbox_uniform.Update(backing_uniform_checkbox_value[0], disabled=False)
 
@@ -835,21 +935,42 @@
             sg.Button("Prev"),
             sg.Button("Next"),
             text_page_num,
             input_text_page_num,
             sg.Text(f"({num_pages})      "), # Show max page count.
             sg.Button("Toggle Zoom"),
             sg.Text("(arrow keys navigate while zooming)"),
+            #sg.Push(),
+            #sg.Text("Quadruples are left, top, bottom, and right margins.\n"
+            #                 "Mouse left over option names to show descriptions.",
+            #                 expand_x=True,
+            #                 relief=sg.RELIEF_GROOVE, justification="right", pad=((0,0), (0,0)))
             ],
         [
             image_element,
+            sg.Push(),
             sg.Column([
+                    # TODO: Consider this new layout, commented out, image to right
+                    # and top controls moved to be with other controls.  Could move
+                    # page controls and keep image to left, alternatively.
+                    #[
+                    # text_page_num,
+                    # input_text_page_num,
+                    # sg.Text(f"({num_pages}) "),
+                    # sg.Button("Prev"),
+                    # sg.Button("Next"),
+                    # ],
+                    #
+                    #[sg.Text("Arrow keys move while zooming.", pad=(None, 0)),
+                    # sg.Button("Toggle Zoom"),],
+                    #[sg.Text("", size=(1,1))], # This is for vertical space.
+
                     [sg.Text("Quadruples are left, top, bottom, and right margins.\n"
                              "Mouse left over option names to show descriptions.",
-                             relief=sg.RELIEF_GROOVE, pad=(None, (0,5)))],
+                             relief=sg.RELIEF_GROOVE, pad=(None, (0,5)))], # Extra pad on bottom.
 
                     [checkbox_uniform, checkbox_samePageSize, checkbox_evenodd],
 
                     # percentRetain
                     [sg.Text("", size=input_text_percentRetain.Size,
                              pad=input_text_percentRetain4[0].Pad), # Empty text is space.
                         input_text_percentRetain, text_percentRetain, checkbox_percentText],
@@ -905,56 +1026,113 @@
                     # threshold, numBlurs, numSmooths
                     [input_num_threshold, text_threshold, input_num_numBlurs,
                         text_numBlurs, input_num_numSmooths, text_numSmooths],
 
                     # pages
                     [input_text_pages, text_pages, combo_box_restore, text_restore],
 
-                    # Buttons.
+                    # buttons
                     [sg.Button("Crop"), sg.Button("Original"), sg.Button("Exit"),],
                     #[sg.Text("", size=(1,1))], # This is for vertical space.
                     [smallest_delta_label_text],
                     smallest_delta_values_display,
                     [sg.Text("")], # This is for vertical space.
                     [sg.Text("", size=(5, 2)), wait_indicator_text],
-                ], pad=(None,0)),
+                ], pad=(None,0), vertical_alignment="top", size=(None, None)), # End of column.
+            #image_element,
             ],
         ]
 
     ##
-    ## Create the main window.
+    ## Get the full window size.
     ##
 
+    scaling = 1.0 # Note setting to None vs. 1.0 causes sizing issue on smaller-screen laptop.
+    x_res, y_res, x_pos, y_pos = parse_geometry_string(args)
+
     left_pixels = 20
+    top_pixels = 0
+    if x_pos is None or y_pos is None:
+        x_pos = left_pixels
+        y_pos = 0
+    else:
+        left_pixels = x_pos
+        top_pixels = y_pos
+
+    if x_res and y_res:
+        full_window_width, full_window_height = x_res, y_res
+    else:
+        full_window_width, full_window_height = get_window_size(scaling)
+
+    ##
+    ## Setup the fonts.
+    ##
+
+    if args.guiFontSize:
+        gui_font_size = args.guiFontSize
+    elif ex.system_os == "Windows":
+        gui_font_size = 12
+    else:
+        gui_font_size = 11
+
+    try:
+        gui_font_size = int(gui_font_size)
+    except TypeError:
+        print("Error in pdfCropMargins: Font size specification could not be made"
+              " an integer.", file=sys.stdout)
+        ex.cleanup_and_exit(1)
+
+    gui_font_name = "Helvetica"
+    font = (gui_font_name, gui_font_size)
+
+    if ex.system_os == "Windows":
+        tooltip_font_size = gui_font_size + 1
+    else:
+        tooltip_font_size = gui_font_size - 1
+
+    tooltip_font_name = "Ariel"
+    sg.set_options(tooltip_font=(f"{tooltip_font_name} {tooltip_font_size}"))
+
+    ##
+    ## Create the main window.
+    ##
+
     with warnings.catch_warnings():
         warnings.filterwarnings("ignore", message="Your title is not a string.")
         window = sg.Window(title=window_title, layout=layout, return_keyboard_events=True,
-                           location=(left_pixels, 0), resizable=True, no_titlebar=False,
+                           location=(x_pos, y_pos), resizable=True, no_titlebar=False,
+                           scaling=scaling,
                            #use_ttk_buttons=True, ttk_theme=sg.THEME_DEFAULT,
-                           use_default_focus=False, alpha_channel=0,)# finalize=True)
+                           use_default_focus=False, font=font, alpha_channel=0, finalize=True)
 
-    #window.Layout(layout) # Old way, now in Window call, delete after testing.
-    window.Finalize() # Newer pySimpleGui versions have finalize kwarg in window def.
-    wait_indicator_text.Update(visible=False)
-    set_delta_values_null()
+    window.bind('<Configure>', "Configure") # Detect tkinter window-resize events.
 
     ##
     ## Find the usable window size.
     ##
 
-    max_image_size = get_usable_image_size(window, im_wid, im_ht, left_pixels)
+    max_image_size, non_image_size = get_usable_image_size(args, window, full_window_width,
+                                                           full_window_height,
+                                                           im_wid, im_ht, left_pixels,
+                                                           top_pixels)
+
+    user_selected_max_image_size = max_image_size # Saved as a user preference.
 
-    # Update the page image (currently to a small size above) to fit window.
-    data, clip_pos, im_ht, im_wid = document_pages.get_display_page(curr_page,
-                                                     max_image_size=max_image_size,
-                                                     reset_cached=True)
+    # Update visibility of invisible elements after getting full size.
+    set_delta_values_null() # Set the delta values buttons to visible=False and null text.
+    wait_indicator_text.Update(visible=False)
 
+    # Update the page image (currently set to a small size above) to fit resized window.
+    resize_window(window, document_pages, max_image_size, non_image_size)
+    image_data, clip_pos, im_ht, im_wid = update_page_image(window,
+                                                            reset_cached=True,
+                                                            zoom=False,
+                                                            max_image_size=max_image_size)
+    old_window_size = window.size
 
-    # Set the correct first page in the image element (after sizing data gathered above).
-    image_element.Update(data=data)
     window.alpha_channel = 1 # Make the window visible.
 
     ##
     ## Run the main event loop.
     ##
 
     zoom = False
@@ -962,74 +1140,87 @@
     bounding_box_list = None
 
     last_pre_crop = None
     last_threshold = None
     last_numSmooths = None
     last_numBlurs = None
 
+    old_window_size = window.size
+
     while True:
         page_change_event = False
+        update_page_image_event = False
+        resize_window_event = False
+
         prev_curr_page = curr_page
         event, values_dict = window.Read()
 
         if event is None and (values_dict is None or values_dict["PageNumber"] is None):
             break
 
         if event == sg.WIN_CLOSED or Events.is_exit(event):
+            if resize_thread_running:
+                request_thread_exit = True
             break
 
         if Events.is_enter(event):
+            # This is for when a page number is manually entered in the window.
             call_all_update_funs(update_funs, values_dict)
             try:
                 curr_page = int(values_dict["PageNumber"]) - 1  # check if valid
-            except:
+            except: # TODO: Use explicit exceptions,
                 curr_page = prev_curr_page
             page_change_event = True
 
         if Events.is_page_num_change(event):
             call_all_update_funs(update_funs, values_dict)
             try:
                 curr_page = int(values_dict["PageNumber"]) - 1  # check if valid
-            except:
+            except: # TODO: use explicit exceptions.
                 curr_page = prev_curr_page
             page_change_event = True
 
         elif Events.is_next(event):
             curr_page += 1
             page_change_event = True
 
         elif Events.is_prev(event):
             curr_page -= 1
             page_change_event = True
 
         elif Events.is_up(event) and zoom:
             zoom = (clip_pos, 0, -1)
+            update_page_image_event = True
 
         elif Events.is_down(event) and zoom:
             zoom = (clip_pos, 0, 1)
+            update_page_image_event = True
 
         elif Events.is_home(event):
             curr_page = 0
             page_change_event = True
 
         elif Events.is_end(event):
             curr_page = num_pages - 1
             page_change_event = True
 
         elif Events.is_left(event) and zoom:
             zoom = (clip_pos, -1, 0)
+            update_page_image_event = True
 
         elif Events.is_right(event) and zoom:
             zoom = (clip_pos, 1, 0)
+            update_page_image_event = True
 
         elif Events.is_zoom(event): # Toggle.
             if not zoom:
                 zoom = (clip_pos, 0, 0)
             else:
                 zoom = False
+            update_page_image_event = True
 
         elif Events.is_crop(event):
             call_all_update_funs(update_funs, values_dict)
             document_pages.close_document()
 
             # Display the wait message as a popup (unused alternative).
             #nonblock_popup = sg.PopupNoWait(
@@ -1085,23 +1276,28 @@
                 combo_box_restore.Update("False")
 
             # Change the view to the new cropped file.
             num_pages = document_pages.open_document(output_doc_fname)
             did_crop = True
             wait_indicator_text.Update(visible=False)
 
+            update_page_image_event = True
+            resize_window_event = True
+
             if parsed_args.verbose:
                 print("\nWaiting for the GUI...")
 
         elif Events.is_original(event):
             call_all_update_funs(update_funs, values_dict)
             document_pages.close_document()
             num_pages = document_pages.open_document(fixed_input_doc_fname)
             did_crop = False
             set_delta_values_null()
+            update_page_image_event = True
+            resize_window_event = True
 
         elif Events.is_left_smallest_delta(event):
             curr_page, left_smallest_toggle = get_page_from_delta_page_nums(
                                                               delta_page_nums,
                                                               left_smallest_toggle, 0)
             page_change_event = True
 
@@ -1125,22 +1321,44 @@
 
         elif Events.is_paired_single_and_quadruple_change(event):
             call_all_update_funs(update_funs, values_dict)
 
         elif Events.is_evenodd(event):
             call_all_update_funs(update_funs, values_dict)
 
+        elif Events.is_general_checkbox_click(event):
+            # This was added to try to make things more responsive on Windows, where multiple
+            # checkbox clicks become unresponsive until something else is clicked or return
+            # is entered in a box.  Doesn't help much.
+            call_all_update_funs(update_funs, values_dict)
+
+        elif Events.is_configure(event): # Capture tkinter window resizes.
+            if window.size != old_window_size and not resize_thread_running:
+                # Note possible threading bug, calling pysimplegui from a thread:
+                # https://github.com/PySimpleGUI/PySimpleGUI/issues/4051
+                request_thread_exit = False
+                proc = threading.Thread(target=resize_page_on_configure_event)
+                proc.daemon = True
+                proc.start()
+
         if page_change_event:
             curr_page = update_page_number(curr_page, prev_curr_page, num_pages, event,
                                       values_dict["PageNumber"], input_text_page_num)
 
+        # Resize the main GUI window if such an event was triggered.
+        if resize_window_event:
+            resize_page_on_configure_event(delay_secs=0,
+                                           max_image_size=user_selected_max_image_size)
+
         # Get the current page and display it.
-        data, clip_pos, im_ht, im_wid = document_pages.get_display_page(curr_page,
-                                                 max_image_size=max_image_size, zoom=zoom)
-        image_element.Update(data=data)
+        if update_page_image_event or page_change_event:
+            reset_cached = Events.is_crop(event)
+            image_data, clip_pos, im_ht, im_wid = update_page_image(window,
+                                                                    reset_cached=reset_cached,
+                                                                    zoom=zoom)
 
     window.Close()
     document_pages.close_document() # Be sure document is closed (bug with -mo without this).
     return did_crop, bounding_box_list, delta_page_nums
 
 #
 # General helper functions.
@@ -1161,105 +1379,14 @@
         return None
     help_text = textwrap.dedent(help_text)
     formatted_para = wrapper.fill(help_text)
     combined_para = " ".join(option_list) + "\n\n" + formatted_para
     combined_para = combined_para.replace("^^n", "\n")
     return combined_para
 
-def get_usable_image_size(window, test_im_wid, test_im_ht, left_pixels):
-    """Get the approximate size of the largest possible PDF preview image that
-    can be drawn in `window` in the current screen.
-
-    Pass in an invisible pySimpleGui window with all the usual widgets and
-    controls as `window`.
-
-    The `im_wid` and `im_ht` parameters are the width and height of a known
-    test image that is "displayed" in the (invisible) window.  The
-    `left_pixels` parameter is the number of pixels added to the left side of
-    window position."""
-    usable_width, usable_height = get_window_size(window)
-    win_width, win_height = window.Size
-
-    non_im_width, non_im_height = win_width-test_im_wid, win_height-test_im_ht
-    usable_im_width, usable_im_height = (usable_width - non_im_width-left_pixels,
-                                         usable_height - non_im_height)
-    return usable_im_width, usable_im_height
-
-def get_window_size(window):
-    """Get physical screen dimension to determine the page image max size.  Some
-    extra space is reserved for titlebars/borders or other unaccounted-for space
-    in the windows."""
-    os = ex.system_os
-    if os == "Linux":
-        width, height = get_window_size_tk()
-        width *= .95
-        height *= .95
-    elif os == "Windows":
-        width, height = get_window_size_sg()
-        width *= .95
-        height *= .95
-    else:
-        # Note this method doesn't always work for multiple-monitor setups
-        # on non-Windows systems.  It reports the combined monitor window sizes.
-        width, height = window.get_screen_size()
-        width *= .90
-        height *= .90
-    return width, height
-
-def get_window_size_sg():
-    """Get size from a big pySimpleGui window.  Not recommended for non-Windows
-    because sg uses fullscreen mode there instead of zoomed mode for `maximize`,
-    which doesn't account for taskbar size."""
-    with warnings.catch_warnings():
-        warnings.filterwarnings("ignore", message="Your title is not a string.")
-        layout = [  [sg.Text('Sizer...')], ]
-        window = sg.Window('Sizer', alpha_channel=0,
-                    no_titlebar=False, # Cannot maximize/zoom without a titlebar.
-                    resizable=True, size=(200,200), layout=layout, finalize=True)
-    window.Maximize()
-    window.Read(timeout=20) # Needs this to maximize correctly.
-    zoomed_wid, zoomed_ht = window.Size
-    window.close()
-    return zoomed_wid, zoomed_ht
-
-def get_window_size_tk():
-    """Use tk to get an approximation to the usable screen area."""
-    # Tkinter universal calls: https://anzeljg.github.io/rin2/book2/2405/docs/tkinter/universal.html
-    # Mac, Linux, Windows attributes here: https://wiki.tcl-lang.org/page/wm+attributes
-    root = tk.Tk()
-    try:
-        if ex.system_os == "Linux":
-            # Go to fullscreen mode to get screen size.  This seems to work with
-            # multiple monitors (which otherwise get counted at a combined size).
-            root.attributes("-alpha", 0) # Invisible on most systems.
-            #root.attributes("-fullscreen", True) # Set to actual full-screen size.
-            root.attributes("-zoomed", True)
-            # This seems to eliminate the flash that occurs on the update below.
-            root.attributes("-type", "splash") # https://www.tcl.tk/man/tcl8.6/TkCmd/wm.htm#M12
-
-            #root.update()
-            root.update_idletasks() # This works in place of .update, on Linux.
-
-            width = root.winfo_width()
-            height = root.winfo_height()
-        elif ex.system_os == "Windows":
-            root.state("zoomed") # Maximize the window on Windows.
-            root.attributes("-alpha", 0) # Invisible on most systems.
-            root.update_idletasks()
-            width = root.winfo_width()
-            height = root.winfo_height()
-        else:
-            width = root.winfo_screenwidth()
-            height = root.winfo_screenheight()
-    except tk.TclError as e:
-        width = root.winfo_screenwidth()
-        height = root.winfo_screenheight()
-    root.destroy()
-    return width, height
-
 def get_filename():
     """Get the filename of the PDF file via GUI if one was not passed in."""
     # TODO: This isn't used now, but the code works to pop up a file chooser.
     # Incorporate it to interactively find the file to crop if none passed in.
     fname = sg.PopupGetFile("Select file and filetype to open:",
                             title="pdfCropMargins: Document Browser",
                             file_types=[ # Only PDF files.
```

## pdfCropMargins/main_pdfCropMargins.py

```diff
@@ -26,14 +26,17 @@
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 Source code site: https://github.com/abarker/pdfCropMargins
 
 """
 
+# TODO: Make --evenodd option equalize the pages after separately calculating
+# the crops, just do the max over them.
+
 # Some general notes, useful for reading the code.
 #
 # Margins are conveniently described as left, bottom, right, and top, but boxes
 # in PDF files are usually defined by the lower-left point's x and y values
 # followed by the upper-right point's x and y values.  This is equivalent
 # information (since x and y is implicit in the margin names) but the viewpoint
 # is slightly different.  The origin is at the lower left.
@@ -45,14 +48,17 @@
 # routine of Pillow returns ltrb instead of lbrt.  Keep in mind that the program
 # needs to make these conversions when rendering explicitly to images.
 
 import sys
 import os
 import shutil
 import time
+from decimal import Decimal
+from warnings import warn
+
 try:
     import readline # Makes prompts go to stdout rather than stderr.
 except ImportError: # Not available on Windows.
     pass
 
 from . import __version__ # Get the version number from the __init__.py file.
 from .manpage_data import cmd_parser, DEFAULT_THRESHOLD_VALUE
@@ -88,14 +94,17 @@
 ##
 ## Some data used by the program.
 ##
 
 # The string which is appended to Producer metadata in cropped PDFs.
 PRODUCER_MODIFIER = " (Cropped by pdfCropMargins.)"
 
+# Limit precision to some reasonable amount to prevent problems in some PDF viewers.
+DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES = 8
+
 args = None # Global set during cmd-line processing (since almost all funs use it).
 
 ##
 ## Begin general function definitions.
 ##
 
 def generate_output_filepath(infile_path, is_cropped_file=True,
@@ -255,16 +264,16 @@
     # Save the rotation value in the page's namespace so we can restore it later.
     page.rotationAngle = rotation
 
     # Un-rotate the page, leaving it with an rotation of 0.
     page.rotate(-rotation)
 
     # Save copies of some values in the page's namespace, to possibly restore later.
-    page.originalMediaBox = page.mediabox
-    page.originalCropBox = page.cropbox
+    page.original_media_box = page.mediabox
+    page.original_crop_box = page.cropbox
 
     first_loop = True
     for box_string in args.fullPageBox:
         if box_string == "m": f_box = page.mediabox
         if box_string == "c": f_box = page.cropbox
         if box_string == "t": f_box = page.trimbox
         if box_string == "a": f_box = page.artbox
@@ -298,27 +307,30 @@
     input_doc should be a `PdfReader` object.  The boxes on the list are in the
     simple 4-float list format used by this program, not `RectangleObject` format."""
 
     full_page_box_list = []
     rotation_list = []
 
     if args.verbose and not quiet:
-        print("\nOriginal full page sizes, in PDF format (lbrt):")
+        print(f"\nOriginal full page sizes (rounded to "
+              f"{DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES} digits) in PDF format (lbrt):")
 
     for page_num in range(len(input_doc.pages)):
 
         # Get the current page and find the full-page box.
         curr_page = input_doc.pages[page_num]
         full_page_box = get_full_page_box_assigning_media_and_crop(curr_page,
                                                                    skip_pre_crop)
 
         if args.verbose and not quiet:
             # want to display page num numbering from 1, so add one
-            print("\t"+str(page_num+1), "  rot =",
-                  curr_page.rotationAngle, "\t", list(full_page_box))
+            rounded_box_string = ", ".join([str(round(f,
+                        DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES)) for f in full_page_box])
+            print(f"\t{str(page_num+1)}   rot = "
+                  f"{curr_page.rotationAngle}  \t [{rounded_box_string}]")
 
         # Convert the `RectangleObject` to floats in an ordinary list and append.
         ordinary_box = [float(b) for b in full_page_box]
         full_page_box_list.append(ordinary_box)
 
         # Append the rotation value to the rotation_list.
         rotation_list.append(curr_page.rotationAngle)
@@ -620,48 +632,58 @@
                 top_weight /= total_tb_weight
                 ratio_set_crop_list.append((left, bottom - difference * bottom_weight,
                                            right, top + difference * top_weight))
         final_crop_list = ratio_set_crop_list
 
     return final_crop_list, delta_page_nums
 
-def set_cropped_metadata(input_doc, output_doc, metadata_info):
+def check_producer_modifier(metadata_info):
+    """Check Producer metadata attribute to see if this program cropped document before.
+    Returns the new producer modifier string to add to the producer metadata along with
+    a boolean `already_cropped_by_this_program`."""
+    producer_mod = PRODUCER_MODIFIER # String added to the producer metadata, marks when cropped.
+    if metadata_info:
+        old_producer_string = metadata_info.producer
+    else:
+        return PRODUCER_MODIFIER, False # Can't read metadata, but maybe can set it.
+    if old_producer_string and old_producer_string.endswith(producer_mod):
+        producer_mod = "" # No need to pile up suffixes each time on Producer.
+        if args.verbose:
+            print("\nThe document was already cropped at least once by pdfCropMargins.")
+        already_cropped_by_this_program = True
+    else:
+        if args.verbose:
+            print("\nThe document was not previously cropped by pdfCropMargins.")
+        already_cropped_by_this_program = False
+    return producer_mod, already_cropped_by_this_program
+
+def set_cropped_metadata(input_doc, output_doc, metadata_info, producer_mod):
     """Set the metadata for the output document.  Mostly just copied over, but
     "Producer" has a string appended to indicate that this program modified the
     file.  That allows for the undo operation to make sure that this
     program cropped the file in the first place."""
 
     # Setting metadata with pyPdf requires low-level pyPdf operations, see
     # http://stackoverflow.com/questions/2574676/change-metadata-of-pdf-file-with-pypdf
+    #
+    # TODO: Later versions support metadata directly:
+    #    https://pypdf2.readthedocs.io/en/latest/user/metadata.html
     if not metadata_info:
         # In case it's null, just set values to empty strings.  This class just holds
         # data temporary in the same format; this is not sent into PyPDF2.
         class MetadataInfo:
             author = ""
             creator = ""
             producer = ""
             subject = ""
             title = ""
         metadata_info = MetadataInfo()
 
     output_info_dict = output_doc._info.get_object()
 
-    # Check Producer metadata attribute to see if this program cropped document before.
-    producer_mod = PRODUCER_MODIFIER
-    old_producer_string = metadata_info.producer
-    if old_producer_string and old_producer_string.endswith(producer_mod):
-        producer_mod = "" # No need to pile up suffixes each time on Producer.
-        if args.verbose:
-            print("\nThe document was already cropped at least once by pdfCropMargins.")
-        already_cropped_by_this_program = True
-    else:
-        if args.verbose:
-            print("\nThe document was not previously cropped by pdfCropMargins.")
-        already_cropped_by_this_program = False
-
     # Note that all None metadata attributes are currently set to the empty string
     # when passing along the metadata information.
     def st(item):
         if item is None: return ""
         else: return item
 
     output_info_dict.update({
@@ -669,20 +691,17 @@
           NameObject("/Creator"): create_string_object(st(metadata_info.creator)),
           NameObject("/Producer"): create_string_object(st(metadata_info.producer)
                                                                  + producer_mod),
           NameObject("/Subject"): create_string_object(st(metadata_info.subject)),
           NameObject("/Title"): create_string_object(st(metadata_info.title))
           })
 
-    return already_cropped_by_this_program
-
 def apply_crop_list(crop_list, input_doc, page_nums_to_crop,
                                           already_cropped_by_this_program):
     """Apply the crop list to the pages of the input `PdfReader` object."""
-
     if args.restore and not already_cropped_by_this_program:
         print("\nWarning from pdfCropMargins: The Producer string indicates that"
               "\neither this document was not previously cropped by pdfCropMargins"
               "\nor else it was modified by another program after that.  Ignoring the"
               "\nrestore operation.", file=sys.stderr)
         return
 
@@ -713,61 +732,71 @@
                 continue
             curr_page.mediabox = curr_page.artbox
             curr_page.cropbox = curr_page.artbox
             continue
 
         # Do the save to ArtBox if that option is chosen and Producer is set.
         if not args.noundosave and not already_cropped_by_this_program:
-            curr_page.artbox = intersect_boxes(curr_page.originalMediaBox,
-                                               curr_page.originalCropBox)
+            curr_page.artbox = intersect_boxes(curr_page.original_media_box,
+                                               curr_page.original_crop_box)
 
         # Reset the CropBox and MediaBox to their saved original values
         # (they were saved by `get_full_page_box_assigning_media_and_crop`
         # in the `curr_page` object's namespace).
-        curr_page.mediabox = curr_page.originalMediaBox
-        curr_page.cropbox = curr_page.originalCropBox
+        curr_page.mediabox = curr_page.original_media_box
+        curr_page.cropbox = curr_page.original_crop_box
 
         # Copy the original page without further mods if it wasn't in the range
         # selected for cropping.
         if page_num not in page_nums_to_crop:
             continue
 
         # Convert the computed "box to crop to" into a `RectangleObject` (for pyPdf).
-        new_cropped_box = RectangleObject(crop_list[page_num])
+        rounded_values = [round(Decimal(f), DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES)
+                          for f in crop_list[page_num]] # RectangleObject converts to Decimal.
+        new_cropped_box = RectangleObject(rounded_values)
 
         if args.verbose:
             print("\t"+str(page_num+1)+"\t", list(new_cropped_box)) # page numbering from 1
         if args.writeCropDataToFile:
             print("\t"+str(page_num+1)+"\t", list(new_cropped_box), file=f)
 
         if not args.boxesToSet:
             args.boxesToSet = ["m", "c"]
 
         # Now set any boxes which were selected to be set via the '--boxesToSet' option.
-        if "m" in args.boxesToSet: curr_page.mediabox = new_cropped_box
-        if "c" in args.boxesToSet: curr_page.cropbox = new_cropped_box
-        if "t" in args.boxesToSet: curr_page.trimbox = new_cropped_box
-        if "a" in args.boxesToSet: curr_page.artbox = new_cropped_box
-        if "b" in args.boxesToSet: curr_page.bleedbox = new_cropped_box
+        if "m" in args.boxesToSet:
+            curr_page.mediabox = new_cropped_box
+        if "c" in args.boxesToSet:
+            curr_page.cropbox = new_cropped_box
+        if "t" in args.boxesToSet:
+            curr_page.trimbox = new_cropped_box
+        if "a" in args.boxesToSet:
+            curr_page.artbox = new_cropped_box
+        if "b" in args.boxesToSet:
+            curr_page.bleedbox = new_cropped_box
 
     if args.writeCropDataToFile:
         f.close()
         ex.cleanup_and_exit(0)
 
-def setup_output_document(input_doc, tmp_input_doc, metadata_info,
+def setup_output_document(input_doc, tmp_input_doc, metadata_info, producer_mod,
                                                     copy_document_catalog=True):
     """Create the output `PdfWriter` objects and copy over the relevant info.
     Returns the writer objects `output_doc`, `tmp_output_doc`, and the boolean
     `already_cropped_by_this_program`.  This function also sets the metadata for
     the cropped output file."""
     # NOTE: Inserting pages from a PdfReader into multiple PdfWriters
     # seems to cause problems (writer can hang on write), so only one is used.
     # This is why the tmp_input_doc file was created earlier, to get copies of
     # the page objects which are independent of those in input_doc.  An ugly
     # hack for a nasty bug to track down.
+    #
+    # Possible thing to try, copying pages:
+    #    https://stackoverflow.com/questions/52315259
 
     # NOTE: You can get the `_root_object` attribute (dict for the document
     # catalog) from the output document after calling `cloneReaderDocumentRoot`
     # or else you can just directly get it from the `input_doc.trailer dict`, as
     # below (which is from the code for `cloneReaderDocumentRoot`), but you
     # CANNOT set the full `_root_object` to be the `_root_object` attribute for
     # the actual output_doc or else only blank pages show up in acroread (whether
@@ -798,14 +827,18 @@
         elif isinstance(root_object, list):
             return [root_objects_not_indirect(input_doc, item) for item in root_object]
         elif isinstance(root_object, IndirectObject):
             return input_doc.get_object(root_object)
         else:
             return root_object
 
+    if args.docCatBlacklist or args.docCatWhitelist:
+        warn("\nThe blacklist and whitelist options for the document catalog are deprecated"
+                " and will be removed in version 3.0.", DeprecationWarning, 2)
+
     doc_cat_whitelist = args.docCatWhitelist.split()
     if "ALL" in doc_cat_whitelist:
         doc_cat_whitelist = ["ALL"]
 
     doc_cat_blacklist = args.docCatBlacklist.split()
     if "ALL" in doc_cat_blacklist:
         doc_cat_blacklist = ["ALL"]
@@ -814,14 +847,16 @@
     if not copy_document_catalog or (
             not doc_cat_whitelist and doc_cat_blacklist == ["ALL"]):
         # Check this first, to completely skip the possibly problematic code getting
         # document catalog items when possible.  Does not print a skipped list, though.
         if args.verbose:
             print("\nNot copying any document catalog items to the cropped document.")
     else:
+        # TODO: Try using the clone_reader_document_root function instead.
+        # https://pypdf2.readthedocs.io/en/latest/modules/PdfWriter.html#PyPDF2.PdfWriter.clone_reader_document_root
         try:
             root_object = input_doc.trailer["/Root"]
 
             copied_items = []
             skipped_items = []
             for key, value in root_object.items():
                 # Some possible keys can be:
@@ -875,42 +910,56 @@
 
     ##
     ## Copy the metadata from input_doc to output_doc, modifying the Producer string
     ## if this program didn't already set it.  Get bool for whether this program
     ## cropped the document already.
     ##
 
-    already_cropped_by_this_program = set_cropped_metadata(input_doc, output_doc,
-                                                           metadata_info)
-    return output_doc, tmp_output_doc, already_cropped_by_this_program
-
+    set_cropped_metadata(input_doc, output_doc, metadata_info, producer_mod)
+    return output_doc, tmp_output_doc
 
 ##############################################################################
 #
 # Functions implementing the major operations.
 #
 ##############################################################################
 
-def process_command_line_arguments(parsed_args):
+def process_command_line_arguments(parsed_args, cmd_parser):
     """Perform an initial processing on the some of the command-line arguments.  This
     is called first, before any PDF processing is done."""
-    global args # This is global o nly to avoid passing it to essentially every function.
+    global args # This is global to avoid passing it to essentially every function.
     args = parsed_args
 
+    if args.prevCropped:
+        args.gui = False # Ignore the GUI when --prevCropped option is selected.
+        args.verbose = False # Wants to eval the text in Bash script.
+
     if args.verbose:
         print("\nProcessing the PDF with pdfCropMargins (version", __version__+")...")
         print("Python version:", ex.python_version)
         print("System type:", ex.system_os)
 
     if len(args.pdf_input_doc) > 1:
         print("\nError in pdfCropMargins: Only one input PDF document is allowed."
               "\nFound more than one on the command line:", file=sys.stderr)
         for f in args.pdf_input_doc:
             print("   ", f, file=sys.stderr)
+        print(file=sys.stderr)
+        if not args.prevCropped: # Because Bash script conditionals try to evaluate `usage` on fail.
+            cmd_parser.print_usage()
+        #cmd_parser.exit() # Exits whole program.
         ex.cleanup_and_exit(1)
+    # Note: Below code currently handled by the argparse + option, not *, on pdf_input_doc.
+    #elif len(args.pdf_input_doc) < 1:
+    #    print("\nError in pdfCropMargins: No PDF document argument passed in.",
+    #          file=sys.stderr)
+    #    print()
+    #    cmd_parser.print_usage()
+    #    #cmd_parser.exit() # Exits whole program.
+    #    ex.cleanup_and_exit(1)
 
     #
     # Process input and output filenames.
     #
 
     input_doc_path = args.pdf_input_doc[0]
     input_doc_path = ex.get_expanded_path(input_doc_path) # Expand vars and user.
@@ -997,15 +1046,19 @@
 
     #
     # Process options dealing with rendering and external programs.
     #
 
     if args.gsRender:
         args.calcbb = "gr" # Backward compat.
+        warn("\nThe --gsRender option is deprecated and will be removed in "
+                "version 3.0.  Use '-c gr' instead.", DeprecationWarning, 2)
     if args.gsBbox:
+        warn("\nThe --gsBbox option is deprecated and will be removed in "
+                "version 3.0.  Use '-c gb' instead.", DeprecationWarning, 2)
         args.calcbb = "gb" # Backward compat.
     if args.calcbb == "m" and not has_mupdf:
         print("Error in pdfCropMargins: The option '--calcbb m' was selected"
               "\nbut PyMuPDF (at least v1.14.5) was not installed in Python."
               "\nInstalling pdfCropMargins with the GUI option will include that"
               "\ndependency.", file=sys.stderr)
         ex.cleanup_and_exit(1)
@@ -1101,24 +1154,19 @@
             print("\nAttempting to fix the PDF input file before reading it...")
         fixed_input_doc_pathname = ex.fix_pdf_with_ghostscript_to_tmp_file(input_doc_path)
     else:
         fixed_input_doc_pathname = input_doc_path
 
     return input_doc_path, fixed_input_doc_pathname, output_doc_path
 
-def process_pdf_file(input_doc_pathname, fixed_input_doc_pathname, output_doc_pathname,
-                     bounding_box_list=None):
-    """This function does the real work.  It is called by `main()` in
-    `pdfCropMargins.py`, which just handles catching exceptions and cleaning
-    up.  It returns the name of the modified file that was written to disk.
-
-    If a bounding box list is passed in then the calculation is skipped and
-    that list is used.
-
-    Returns the bounding box list."""
+def open_file_in_pdfreader(fixed_input_doc_pathname):
+    """Open the file in a `PdfFileReader` object and return readers for the input
+    document, and the temp input document (bug workaround) as well as metadata
+    information, an open file object for the fixed input document, and the number
+    of pages in the document.  The open file object will need to be closed."""
     ##
     ## Open the input document in a PdfReader object.  Due to an apparent bug
     ## in pyPdf we open two PdfReader objects for the file.  The time required
     ## should still be small relative to finding the bounding boxes of pages.  The bug
     ## is that writing a PdfWriter tends to hang on certain files if 1) pages from
     ## the same PdfReader are shared between two PdfWriter objects, or 2)
     ## the PdfWriter is written, the pages are modified, and there is an attempt
@@ -1213,26 +1261,19 @@
             print("   The Title attribute set in the input document is:\n      %s"
                   % (metadata_info.title))
         # Some metadata cannot be decoded or encoded, at least on Windows.  Could
         # print from a function instead to write all the lines which can be written.
         except (UnicodeDecodeError, UnicodeEncodeError):
             print("\nWarning: Could not write all the document's metadata to the screen."
                   "\nGot a UnicodeEncodeError or a UnicodeDecodeError.", file=sys.stderr)
+    return input_doc, tmp_input_doc, metadata_info, fixed_input_doc_file_object, input_doc_num_pages
 
-    ##
-    ## Now compute the set containing the pyPdf page number of all the pages
-    ## which the user has selected for cropping from the command line.  Most
-    ## calculations are still carried-out for all the pages in the document.
-    ## (There are a few optimizations for expensive operations like finding
-    ## bounding boxes; the rest is negligible).  This keeps the correspondence
-    ## between page numbers and the positions of boxes in the box lists.  The
-    ## function `apply_crop_list` then just ignores the cropping information
-    ## for any pages which were not selected.
-    ##
-
+def get_set_of_page_numbers_to_crop(input_doc_num_pages):
+    """Compute the set containing the pyPdf page number of all the pages
+    which the user has selected for cropping from the command line."""
     all_page_nums = set(range(0, input_doc_num_pages))
     if args.pages:
         try:
             page_nums_to_crop = parse_page_range_specifiers(args.pages, all_page_nums)
         except ValueError:
             print(
                 "\nError in pdfCropMargins: The page range specified on the command",
@@ -1250,14 +1291,112 @@
         for i in range(num_pages_to_crop):
             if i % 10 == 0 and i != num_pages_to_crop - 1:
                 print("\n   ", end="")
             print("%5d" % (p_num_list[i]+1), " ", end="")
         print()
     elif args.verbose:
         print("\nAll the pages of the document will be cropped.")
+    return page_nums_to_crop
+
+def write_pdf_file(output_doc_pathname, output_doc, tmp_output_doc, input_doc, tmp_input_doc,
+                   metadata_info, producer_mod):
+    """Write out the pdf file from `output_doc` to the file at `output_doc_filename`."""
+    if args.verbose:
+        print("\nWriting the cropped PDF file.")
+
+    try:
+        output_doc_stream = open(output_doc_pathname, "wb")
+    except OSError:
+        print("Error in pdfCropMargins: Could not open output document with "
+              "filename '{}'".format(output_doc_pathname))
+        ex.cleanup_and_exit(1)
+
+    try:
+        output_doc.write(output_doc_stream)
+    except (KeyboardInterrupt, EOFError):
+        raise
+    except PyPdfError: # PyPDF2 can raise various exceptions.
+        try:
+            # We know the write succeeded on tmp_output_doc or we wouldn't be here.
+            # Malformed document catalog info can cause write failures, so get
+            # a new output_doc without that data and try the write again.
+            print("\nWrite failure, trying one more time...", file=sys.stderr)
+            output_doc_stream.close()
+            output_doc_stream = open(output_doc_pathname, "wb")
+            output_doc, tmp_output_doc, setup_output_document(
+                    input_doc, tmp_input_doc, metadata_info, producer_mod,
+                    copy_document_catalog=False)
+            output_doc.write(output_doc_stream)
+            print("\nWarning: Document catalog data caused a write failure.  A retry"
+                  "\nwithout that data succeeded.  No document catalog information was"
+                  "\ncopied to the cropped output file.  Try fixing the PDF file.  If"
+                  "\nyou have ghostscript installed, run pdfCropMargins with the '--gsFix'"
+                  "\noption.  You can also try blacklisting some of the document catalog"
+                  "\nitems using the '--dcb' option.", file=sys.stderr)
+        except (KeyboardInterrupt, EOFError):
+            raise
+        except: # Give up... PyPDF2 can raise many errors for many reasons.
+            print("\nError in pdfCropMargins: The pyPdf program failed in trying to"
+                  "\nwrite out a PDF file of the document.  The document may be"
+                  "\ncorrupted.  If you have Ghostscript, try using the '--gsFix'"
+                  "\noption (assuming you are not already using it).", file=sys.stderr)
+            ex.cleanup_and_exit(1)
+
+    output_doc_stream.close()
+
+def process_pdf_file(input_doc_pathname, fixed_input_doc_pathname, output_doc_pathname,
+                     bounding_box_list=None):
+    """This function does the real work.  It is called by `main()` in
+    `pdfCropMargins.py`, which just handles catching exceptions and cleaning
+    up.  It returns the name of the modified file that was written to disk.
+
+    If a bounding box list is passed in then the calculation is skipped and
+    that list is used.
+
+    Returns the bounding box list."""
+
+    # Open the input file object.
+    (input_doc,
+     tmp_input_doc, # Bug workaround, see the function for comment.
+     metadata_info,
+     fixed_input_doc_file_object, # Note this file object is opened and needs to be closed.
+     input_doc_num_pages) = open_file_in_pdfreader(fixed_input_doc_pathname)
+
+    producer_mod, already_cropped_by_this_program = check_producer_modifier(
+                                                              metadata_info)
+
+    if args.prevCropped:
+        fixed_input_doc_file_object.close()
+        if already_cropped_by_this_program:
+            #print("code 0")
+            exit_code = 0
+        else:
+            #print("code 1")
+            exit_code = 1
+        ex.cleanup_and_exit(exit_code)
+
+    # TODO: This doesn't work yet with GUI because GUI calls this fun only when cropping...
+    #if args.exitPrevCropped and already_cropped_by_this_program:
+    #    fixed_input_doc_file_object.close()
+    #    if args.verbose:
+    #        print("The file was previously cropped by pdfCropMargins, exiting.")
+    #    ex.cleanup_and_exit(0)
+
+    ##
+    ## Now compute the set containing the pyPdf page number of all the pages
+    ## which the user has selected for cropping from the command line.  Most
+    ## calculations are still carried-out for all the pages in the document.
+    ## (There are a few optimizations for expensive operations like finding
+    ## bounding boxes; the rest is negligible).  This keeps the correspondence
+    ## between page numbers and the positions of boxes in the box lists.  The
+    ## function `apply_crop_list` then just ignores the cropping information
+    ## for any pages which were not selected.
+    ##
+
+    page_nums_to_crop = get_set_of_page_numbers_to_crop(input_doc_num_pages)
 
     ##
     ## Get a list with the full-page boxes for each page: (left,bottom,right,top)
     ## This function also sets the MediaBox and CropBox of the pages to the
     ## chosen full-page size as a side-effect, saving the old boxes.  Any absolute
     ## pre-crop is also applied here.
     ##
@@ -1269,29 +1408,16 @@
     tmp_full_page_box_list, tmp_rotation_list = get_full_page_box_list_assigning_media_and_crop(
                                             tmp_input_doc, quiet=True, skip_pre_crop=False)
 
     ##
     ## Define a `PdfWriter` object and copy `input_doc` info over to it.
     ##
 
-    output_doc, tmp_output_doc, already_cropped_by_this_program = setup_output_document(
-                                                input_doc, tmp_input_doc, metadata_info)
-
-    if False: #args.prevCropped:
-        # TODO: Consider as new options.  But a lot of work done above to get this info...
-        # How do the other options interact with these if they are set?  Don't want GUI.
-        if already_cropped_by_this_program and args.skipPrevCropped:
-            ex.cleanup_and_exit(0)
-        fixed_input_doc_file_object.close()
-        if already_cropped_by_this_program:
-            print("y", end="")
-            ex.cleanup_and_exit(0)
-        else:
-            print("n", end="")
-            ex.cleanup_and_exit(1)
+    output_doc, tmp_output_doc = setup_output_document(input_doc, tmp_input_doc,
+                                                       metadata_info, producer_mod)
 
     ##
     ## Write out the PDF document again, with the CropBox and MediaBox reset.
     ## This temp version is ONLY used for calculating the bounding boxes of
     ## pages.  Note we are writing from `tmp_output_doc` (due to an apparent bug
     ## discussed above).  After this `tmp_input_doc` and `tmp_output_doc` are no
     ## longer needed.
@@ -1350,57 +1476,19 @@
     apply_crop_list(crop_list, input_doc, page_nums_to_crop,
                                           already_cropped_by_this_program)
 
     ##
     ## Write the final PDF out to a file.
     ##
 
-    if args.verbose:
-        print("\nWriting the cropped PDF file.")
-
-    try:
-        output_doc_stream = open(output_doc_pathname, "wb")
-    except OSError:
-        print("Error in pdfCropMargins: Could not open output document with "
-              "filename '{}'".format(output_doc_pathname))
-        ex.cleanup_and_exit(1)
-
-    try:
-        output_doc.write(output_doc_stream)
-    except (KeyboardInterrupt, EOFError):
-        raise
-    except: # PyPDF2 can raise various exceptions.
-        try:
-            # We know the write succeeded on tmp_output_doc or we wouldn't be here.
-            # Malformed document catalog info can cause write failures, so get
-            # a new output_doc without that data and try the write again.
-            print("\nWrite failure, trying one more time...", file=sys.stderr)
-            output_doc_stream.close()
-            output_doc_stream = open(output_doc_pathname, "wb")
-            output_doc, tmp_output_doc, already_cropped = setup_output_document(
-                    input_doc, tmp_input_doc, metadata_info, copy_document_catalog=False)
-            output_doc.write(output_doc_stream)
-            print("\nWarning: Document catalog data caused a write failure.  A retry"
-                  "\nwithout that data succeeded.  No document catalog information was"
-                  "\ncopied to the cropped output file.  Try fixing the PDF file.  If"
-                  "\nyou have ghostscript installed, run pdfCropMargins with the '--gsFix'"
-                  "\noption.  You can also try blacklisting some of the document catalog"
-                  "\nitems using the '--dcb' option.", file=sys.stderr)
-        except (KeyboardInterrupt, EOFError):
-            raise
-        except: # Give up... PyPDF2 can raise many errors for many reasons.
-            print("\nError in pdfCropMargins: The pyPdf program failed in trying to"
-                  "\nwrite out a PDF file of the document.  The document may be"
-                  "\ncorrupted.  If you have Ghostscript, try using the '--gsFix'"
-                  "\noption (assuming you are not already using it).", file=sys.stderr)
-            ex.cleanup_and_exit(1)
-
-    output_doc_stream.close()
+    write_pdf_file(output_doc_pathname, output_doc, tmp_output_doc, input_doc, tmp_input_doc,
+                                                               metadata_info, producer_mod)
 
     # We're finished with this open file; close it and let temp dir removal delete it.
+    # Note that the PdfReader object has opened it, so be careful where it is closed.
     fixed_input_doc_file_object.close()
     return bounding_box_list, delta_page_nums
 
 def handle_options_on_cropped_file(input_doc_pathname, output_doc_pathname):
     """Handle the options which apply after the file is written such as previewing
     and renaming."""
 
@@ -1421,18 +1509,15 @@
             # Give preview time to start; it may write startup garbage to the terminal...
             query_wait_time = 2 # seconds
             time.sleep(query_wait_time)
             print()
         while True:
             query_string = "\nModify the original file to the cropped file " \
                 "(saving the original)? [yn] "
-            if ex.python_version[0] == "2":
-                query_result = raw_input(query_string).decode("utf-8").strip()
-            else:
-                query_result = input(query_string).strip()
+            query_result = input(query_string).strip()
             if query_result in ["y", "Y"]:
                 args.modifyOriginal = True
                 print("\nModifying the original file.")
                 break
             elif query_result in ["n", "N"]:
                 print("\nNot modifying the original file.  The cropped file is saved"
                       " as:\n   {}".format(output_doc_pathname))
@@ -1497,15 +1582,16 @@
     """Process command-line arguments, do the PDF processing, and then perform final
     processing on the filenames.  If `argv_list` is set then it is used instead of
     `sys.argv`.  Returns the pathname of the output document."""
     parsed_args = parse_command_line_arguments(cmd_parser, argv_list=argv_list)
 
     # Process some of the command-line arguments (also sets `args` globally).
     input_doc_pathname, fixed_input_doc_pathname, output_doc_pathname = (
-                                           process_command_line_arguments(parsed_args))
+                                           process_command_line_arguments(parsed_args,
+                                                                          cmd_parser))
 
     if args.gui:
         from .gui import create_gui # Import here; tkinter might not be installed.
         if args.verbose:
             print("\nWaiting for the GUI...")
 
         did_crop, bounding_box_list, delta_page_nums = create_gui(input_doc_pathname,
```

## pdfCropMargins/manpage_data.py

```diff
@@ -360,15 +360,15 @@
    information on the units.^^n""")
 
 cmd_parser.add_argument("-cs", "--cropSafe", action="store_true", help="""
 
    Guarantee that all crops are safe in the sense that no crop ever goes beyond
    the tight bounding box on any margin.  This does not apply to pre-crops
    using the '--absolutePreCrop' option.  It also does not apply to any margins
-   on a pages where that margin is ignored due to the '--uniformOrderStat' or
+   on pages where that margin is ignored due to the '--uniformOrderStat' or
    '--uniformOrderStat4' option.  The latter effect works well with uniform
    cropping in the GUI: the value of 'uniformOrderStat' can be incremented for
    the margin with the minimum delta value (as seen by clicking that button) if
    no useful text would be cropped out.  The '--cropSafeMin' option allows for
    modifying the minimum margin value, adding to the bounding box.^^n""")
 
 cmd_parser.add_argument("-csm4", "--cropSafeMin4", nargs=4, type=float,
@@ -484,15 +484,16 @@
 
 cmd_parser.add_argument("-e", "--evenodd", action="store_true", help="""
 
    Crop all the odd pages uniformly, and all the even pages uniformly.  The
    largest amount of cropping that works for all the pages in each group is
    chosen.  If the '--uniform' ('-u') option is simultaneously set then the
    vertical cropping will be uniform over all the pages and only the
-   horizontal cropping will differ between even and odd pages.^^n""")
+   horizontal cropping will differ between even and odd pages.  See also
+   the '--percentText' option which can be used for a similar effect.^^n""")
 
 cmd_parser.add_argument("-g", "-pg", "--pages", metavar="PAGESTR", help="""
 
    Apply the cropping operation only to the selected pages.  The argument
    should be a list of the usual form such as "2-4,5,9,20-30".  The
    page-numbering is assumed to start at 1.  Ordering in the argument list is
    unimportant, negative ranges are ignored, and pages falling outside the
@@ -577,14 +578,30 @@
 cmd_parser.add_argument("-y", "--resY", type=int, default=72,
                         metavar="DPI", help="""
 
    The y-resolution in dots per inch to use when the image is rendered to find
    the bounding boxes.  The default is 150.  Higher values produce more precise
    bounding boxes but require more time and memory.^^n""")
 
+cmd_parser.add_argument("-sr", "--screenRes", default=None, metavar="STR", help="""
+
+   Pass in an X-windows style geometry string for the GUI to use as the
+   fullscreen resolution and for the upper-left placement of the window.  This
+   is mainly for when the screen-size detection algorithm fails for a
+   particular system.  For example, with a screen of size "1024x720" that
+   string should be used with the option.  To also place the window at (0,0)
+   the string would be "1024x728+0+0".  See also the '--guiFontSize' option
+   which can be used to decrease the overall size of the GUI window.^^n""")
+
+cmd_parser.add_argument("-gf", "--guiFontSize", default=None, metavar="INT", help="""
+
+   Choose the GUI font size.  Making this smaller than the default of 11 can
+   also make the GUI smaller if it does not fit on a smaller monitor.
+   +0+0".^^n""")
+
 cmd_parser.add_argument("-b", "--boxesToSet", choices=["m", "c", "t", "a", "b"],
                         metavar="[m|c|t|a|b]", action="append", default=[], help="""
 
    By default the pdfCropMargins program sets both the MediaBox and the CropBox
    for each page of the cropped PDF document to the new, cropped page size.
    This default setting is usually sufficient, but this option can be used to
    select different PDF boxes to set.  The option takes one argument, which is
@@ -640,23 +657,23 @@
    (which is rare).  Note that the '--restore' operation will not work
    correctly for the cropped document if this option is included in the
    cropping command.  (The program does not currently check for this when doing
    a restore.)^^n""")
 
 cmd_parser.add_argument("-gsf", "--gsFix", action="store_true", help="""
 
-   Attempt to repair the input PDF file with Ghostscript before it is read-in
-   with PyPdf.  This requires that Ghostscript be available.  (See the general
-   description text above for the actual command that is run.)  This can also
-   be used to automatically convert some PostScript files (.ps) to PDF for
-   cropping.  The repaired PDF is written to a temporary file; the original PDF
-   file is not modified.  The original filename is treated as usual as far as
-   automatic name-generation, the '--modify-original' option, and so forth.
-   This option is often helpful if the program hangs or raises an error due to
-   a corrupted PDF file.  Note that when re-cropping a file already cropped by
+   Attempt to repair the input PDF file with Ghostscript before it is read-in.
+   This requires that Ghostscript be available.  (See the general description
+   text above for the actual command that is run.)  This can also be used to
+   automatically convert some PostScript files (.ps) to PDF for cropping.  The
+   repaired PDF is written to a temporary file; the original PDF file is not
+   modified.  The original filename is treated as usual as far as automatic
+   name-generation, the '--modify-original' option, and so forth.  This option
+   is often helpful if the program hangs or raises an error due to a corrupted
+   PDF file.  Note that when re-cropping a file already cropped by
    pdfCropMargins this option is probably not necessary, and if it is used in a
    re-crop (at least with current versions of Ghostscript) it will reset the
    Producer metadata which the pdfCropMargins program uses to tell if the file
    was already cropped by the program (so the '--restore' option will not work
    in combination with this option).  This option is not recommended as
    something to use by default unless you encounter many corrupted PDF files
    and do not need to restore back to the original margins.^^n""")
@@ -755,14 +772,30 @@
 cmd_parser.add_argument("-pw", "--password", metavar="PASSWD", help="""
 
    Specify a password to be used to decrypt an encrypted PDF file.  Note that
    decrypting with an empty password is always tried, so this option is only
    needed for non-empty passwords.  The resulting cropped file will not be
    encrypted, so use caution if important data is involved.^^n""")
 
+cmd_parser.add_argument("-pc", "--prevCropped", action="store_true", help="""
+
+   Test whether or not the document was previously cropped with the
+   pdfCropMargins program.  If so, exit with exit code 0.  If not, exit with
+   exit code 1.  This option is intended mainly for scripting, for example to
+   only crop documents that have not been previously cropped.  Requires a
+   document filename option.  No other options are honored when this option is
+   selected except '--gsFix', '--version', and '--help'.^^n""")
+
+# NOTE: This doesn't work with GUI because GUI calls process_pdf_file only on crop button.
+#cmd_parser.add_argument("-epc", "--exitPrevCropped", action="store_true", help="""
+#
+#   Test whether or not the document was previously cropped with the pdfCropMargins
+#   program.  It so, print 'y' to stdout and exit with exit code 0.  It not, print
+#   'n' and exit with exit code 1.^^n""")
+
 #cmd_parser.add_argument("-k", "--keepOriginalRotations", action="store_true",
 #                        help="""
 #
 #   Skip the original un-rotation of the rotated pages before bounding boxes
 #   are calculated (and also the later re-rotation).^^n""")
 
 cmd_parser.add_argument("-khc", "--keepHorizCenter", action="store_true",
```

## pdfCropMargins/pdfCropMargins.py

```diff
@@ -52,15 +52,16 @@
 
         # Call cleanup_and_exit at system exit, even with signal kills.
         # Note SIGINT for Ctrl-C is already handled by the except/finally.
         for s in ["SIGABRT", "SIGTERM", "SIGHUP"]:
             if hasattr(signal, s): # Not all systems define the same signals.
                 signal.signal(getattr(signal, s), cleanup_and_exit)
 
-        crop()
+        output_doc_pathname, exit_code, stdout_str, stderr_str = crop()
+
     except (KeyboardInterrupt, EOFError): # Windows raises EOFError on ^C.
         print("\nGot a KeyboardInterrupt, cleaning up and exiting...\n",
               file=sys.stderr)
     except SystemExit as e:
         #exit_code = int(str(sys.exc_info()[1])) # The number sys.exit(n) called with.
         exit_code = e.code
         print()
```

## pdfCropMargins/pymupdf_routines.py

```diff
@@ -99,25 +99,62 @@
                         ex.cleanup_and_exit(1)
 
             self.num_pages = len(self.document)
             self.page_display_list_cache = [None] * self.num_pages
             self.page_crop_display_list_cache = [None] * self.num_pages
             return self.num_pages
 
+        def get_page_sizes(self):
+            """Return a list of the page sizes."""
+            size_list = []
+            for page in self.document:
+                size_list.append((page.rect.width, page.rect.height))
+            return size_list
+
+        def get_max_and_min_page_sizes(self):
+            """Return tuples (max_wid, max_ht) and (min_wid, min_ht)."""
+            page_sizes = self.get_page_sizes()
+            max_page_sizes = (max(p[0] for p in page_sizes), max(p[1] for p in page_sizes))
+            min_page_sizes = (min(p[0] for p in page_sizes), min(p[1] for p in page_sizes))
+            return max_page_sizes, min_page_sizes
+
+        def get_max_and_min_aspect_ratios(self):
+            """Return the maximum and minimum aspect ratios over all the pages."""
+            page_sizes = self.get_page_sizes()
+            max_ratio = max(p[0]/p[1] for p in page_sizes)
+            min_ratio = min(p[0]/p[1] for p in page_sizes)
+            return max_ratio, min_ratio
+
+        def get_max_width_and_height(self):
+            """Return the maximum width and height (in points) of PDF pages in the
+            document."""
+            max_wid = -1
+            max_ht = -1
+            for page in self.document:
+                if page.rect.width > max_wid:
+                    max_wid = page.rect.width
+                if page.rect.height > max_ht:
+                    max_ht = page.rect.height
+            return max_wid, max_ht
+
         def save_document(self):
             """Save a document, possibly repairing/cleaning it."""
             # See here:
             #    https://pymupdf.readthedocs.io/en/latest/document.html#Document.save
             raise NotImplementedError
 
         def close_document(self):
             """Close the document and clear its pages."""
             self.document.close()
             self.clear_cache()
 
+        def return_pypdf_pdfreader(self):
+            """Return a PyPDF `PdfReader` class instance for the current document."""
+            # TODO, just write out (maybe to memory) and open one on it...
+
         def get_page_ppm_for_crop(self, page_num, cache=False):
             """Return an unscaled and unclipped `.ppm` file suitable for cropping the page.
             Not indended for displaying in the GUI."""
             # NOTE: The calculated bounding boxes are already saved in GUI, so
             # there is no need to cache these.  After crops the PDF is written
             # out and re-read, which would clear the cache, anyway.
 
@@ -160,40 +197,39 @@
             pixmap.set_dpi(*resolution)
 
             # Maybe pgm below??
             image_ppm = pixmap.tobytes("ppm")  # Make PPM image from pixmap for tkinter.
             return image_ppm
 
         def get_display_page(self, page_num, max_image_size, zoom=False,
-                             fit_screen=True, reset_cached=False):
-            """Return a `tkinter.PhotoImage` or a PNG image for a document page number.
-                - The `page_num` argument is a 0-based page number.
-                - The `zoom` argument is the top-left of old clip rect, and one of -1, 0,
-                  +1 for dim. x or y to indicate the arrow key pressed.
-                - The `max_image_size` argument is the (width, height) of available image area.
-            """
-            zoom_x = 1
-            zoom_y = 1
-            scale = fitz.Matrix(zoom_x, zoom_y)
+                             reset_cached=False):
+            """Return a `tkinter.PhotoImage` or a PNG image for a document page
+            number.  The `page_num` argument is a 0-based page number.  The
+            `zoom` argument is the top-left of old clip rect, and one of -1, 0,
+            +1 for dim. x or y to indicate the arrow key pressed.  The
+            `max_image_size` argument is the (width, height) of available image
+            area."""
+            if not reset_cached:
+                page_display_list = self.page_display_list_cache[page_num]
+            else:
+                page_display_list = None
 
-            page_display_list = self.page_display_list_cache[page_num] if not reset_cached else None
             if not page_display_list:  # Create if not yet there.
                 self.page_display_list_cache[page_num] = self.document[page_num].get_displaylist()
                 page_display_list = self.page_display_list_cache[page_num]
 
             page_rect = page_display_list.rect  # The page rectangle.
             clip = page_rect
 
-            # Make sure that the image will fit the screen.
-            zoom_0 = 1
-            if max_image_size: # TODO: this is currently a required param...
-                zoom_0 = min(1, max_image_size[0] / page_rect.width, max_image_size[1] / page_rect.height)
-                if zoom_0 == 1:
-                    zoom_0 = min(max_image_size[0] / page_rect.width, max_image_size[1] / page_rect.height)
-            mat_0 = fitz.Matrix(zoom_0, zoom_0)
+            # Make sure that all the images across the document will fit the screen.
+            max_wid, max_ht = self.get_max_width_and_height()
+
+            nozoom_scale = min(max_image_size[0]/max_wid,
+                               max_image_size[1]/max_ht)
+            nozoom_mat = fitz.Matrix(nozoom_scale, nozoom_scale)
 
             if zoom:
                 width2 = page_rect.width / 2
                 height2 = page_rect.height / 2
 
                 clip = page_rect * 0.5     # Clip rect size is a quarter page.
                 top_left = zoom[0]
@@ -202,19 +238,19 @@
                 top_left.x = min(width2, top_left.x)     # arrow key ...
                 top_left.y += zoom[2] * (height2 / 2)    # provided, but ...
                 top_left.y = max(0, top_left.y)          # stay within ...
                 top_left.y = min(height2, top_left.y)    # the page rect
                 clip = fitz.Rect(top_left, top_left.x + width2, top_left.y + height2)
 
                 # Clip rect is ready, now fill it.
-                mat = mat_0 * fitz.Matrix(2, 2)  # The zoom matrix.
-                pixmap = page_display_list.get_pixmap(alpha=False, matrix=mat, clip=clip)
+                zoom_mat = nozoom_mat * fitz.Matrix(2, 2)  # The zoom matrix.
+                pixmap = page_display_list.get_pixmap(alpha=False, matrix=zoom_mat, clip=clip)
 
             else:  # Show the total page.
-                pixmap = page_display_list.get_pixmap(matrix=mat_0, alpha=False)
+                pixmap = page_display_list.get_pixmap(matrix=nozoom_mat, alpha=False)
 
             #image_png = pixmap.tobytes()  # get the PNG image
             image_height, image_width = pixmap.height, pixmap.width
-            image_ppm = pixmap.tobytes("ppm")  # Make PPM image from pixmap for tkinter.
+            image_ppm = pixmap.tobytes("png")  # Make PPM image from pixmap for tkinter.
             image_tl = clip.tl # Clip position (top left).
             return image_ppm, image_tl, image_height, image_width
```

## Comparing `pdfCropMargins-1.1.9.dist-info/LICENSE` & `pdfCropMargins-1.2.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pdfCropMargins-1.1.9.dist-info/METADATA` & `pdfCropMargins-1.2.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pdfCropMargins
-Version: 1.1.9
+Version: 1.2.0
 Summary: A command-line program to crop the margins of PDF files, with many options.
 Home-page: https://github.com/abarker/pdfCropMargins
 Author: Allen Barker
 Author-email: Allen.L.Barker@gmail.com
 License: GPL
 Keywords: pdf,crop,margins,resize
 Platform: UNKNOWN
@@ -12,27 +12,26 @@
 Classifier: Intended Audience :: End Users/Desktop
 Classifier: License :: OSI Approved :: GNU General Public License (GPL)
 Classifier: Operating System :: Unix
 Classifier: Operating System :: POSIX
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: Implementation :: CPython
 Classifier: Programming Language :: Python :: Implementation :: PyPy
 Classifier: Topic :: Utilities
 Requires-Dist: wheel
 Requires-Dist: pillow (>=9.3.0)
 Requires-Dist: PyPDF2 (<3.0.0,>=2.11.0)
-Requires-Dist: PySimpleGUI (>=4.40.0)
-Requires-Dist: PyMuPDF (>=1.20.0)
+Requires-Dist: PySimpleGUI (>=4.19.0.6)
+Requires-Dist: PyMuPDF (>=1.19.6)
 
 ==============
 pdfCropMargins
 ==============
 
 The pdfCropMargins program is a command-line application to automatically crop
 the margins of PDF files.  Cropping the margins can make it easier to read the
@@ -76,21 +75,18 @@
 What's New
 ==========
 
 See the `CHANGELOG
 <https://github.com/abarker/pdfCropMargins/blob/master/CHANGELOG.rst>`_ for
 recent changes and new features.
 
-**New in recent versions (Dec 2022):**
+**New in recent versions (Mar 2023):**
 
-* Python 3.6 is now the minimum supported version.
-
-* The GUI dependencies are now part of the standard install.  The program will
-  still work without them, however, if the GUI is not required.  Note that without
-  PyMuPDF either pdftoppm or Ghostscript must be installed.
+* The minimimum Python version is now Python 3.7 due to several dependencies
+  requiring it.
 
 * You can now use either ``pdf-crop-margins`` or ``pdfcropmargins`` to launch the
   program from the command line.
 
 * The GUI layout has been updated for more intuitive use of the options that take
   four values, for the left, bottom, right, and top margins.
 
@@ -104,14 +100,21 @@
   margin beyond the bounding box.
 
 * The new options ``--keepHorizCenter`` (``-khz``) and ``--keepVertCenter``
   (``-kvc``) have been added.  They force equal cropping on the left and right
   or top and bottom pages, respectively.  The minimum of the delta values is
   used on each page.
 
+* Added an option ``--prevCropped`` (``-pc``) which just tests whether or not
+  the document was previously cropped with pdfCropMargins.  This is meant for
+  scripting use.
+
+* The PDF preview in the GUI now resizes properly when the window is reconfigured.
+  The new ``--guiFontSize`` argument can be used to size the font.
+
 Installing 
 ==========
 
 The easiest way to install the pdfCropMargins program is by using pip.
 
 The basic features work out of the box with the GUI install, but the default
 install and some of the options require either the external program
@@ -302,18 +305,18 @@
 
    Usage: pdf-crop-margins [-h] [-o OUTFILE_PATH_OR_DIR] [-v] [-gui] [-p PCT]
                            [-p4 PCT PCT PCT PCT] [-pt] [-a BP] [-a4 BP BP BP BP]
                            [-cs] [-csm4 BP BP BP BP] [-ap BP] [-ap4 BP BP BP BP]
                            [-u] [-m INT] [-m4 INT INT INT INT] [-mp INT] [-s]
                            [-ms INT] [-e] [-g PAGESTR] [-c [d|m|p|gr|gb|o]] [-gs]
                            [-gsr] [-t BYTEVAL] [-nb INT] [-ns INT] [-x DPI]
-                           [-y DPI] [-b [m|c|t|a|b]] [-f [m|c|t|a|b]] [-r] [-A]
-                           [-gsf] [-nc] [-pv PROG] [-mo] [-q] [-nco] [-pf]
-                           [-sc STR] [-su STR] [-ss STR] [-pw PASSWD] [-khc]
-                           [-kvc] [-spr FLOAT:FLOAT]
+                           [-y DPI] [-sr STR] [-gf INT] [-b [m|c|t|a|b]]
+                           [-f [m|c|t|a|b]] [-r] [-A] [-gsf] [-nc] [-pv PROG]
+                           [-mo] [-q] [-nco] [-pf] [-sc STR] [-su STR] [-ss STR]
+                           [-pw PASSWD] [-pc] [-khc] [-kvc] [-spr FLOAT:FLOAT]
                            [-prw FLOAT FLOAT FLOAT FLOAT] [-dcb STR] [-dcw STR]
                            [-i] [-pdl] [-gsp PATH] [-ppp PATH] [--version]
                            [-wcdf FILEPATH]
                            PDF_FILE [PDF_FILE ...]
 
    Description:
 
@@ -585,15 +588,15 @@
                   left, bottom, right, and top offset values, respectively. See
                   the '--absoluteOffset' option for information on the units.
 
      -cs, --cropSafe
                   Guarantee that all crops are safe in the sense that no crop
                   ever goes beyond the tight bounding box on any margin. This
                   does not apply to pre-crops using the '--absolutePreCrop'
-                  option. It also does not apply to any margins on a pages where
+                  option. It also does not apply to any margins on pages where
                   that margin is ignored due to the '--uniformOrderStat' or '--
                   uniformOrderStat4' option. The latter effect works well with
                   uniform cropping in the GUI: the value of 'uniformOrderStat'
                   can be incremented for the margin with the minimum delta value
                   (as seen by clicking that button) if no useful text would be
                   cropped out. The '--cropSafeMin' option allows for modifying
                   the minimum margin value, adding to the bounding box.
@@ -707,15 +710,16 @@
 
      -e, --evenodd
                   Crop all the odd pages uniformly, and all the even pages
                   uniformly. The largest amount of cropping that works for all
                   the pages in each group is chosen. If the '--uniform' ('-u')
                   option is simultaneously set then the vertical cropping will be
                   uniform over all the pages and only the horizontal cropping
-                  will differ between even and odd pages.
+                  will differ between even and odd pages. See also the '--
+                  percentText' option which can be used for a similar effect.
 
      -g PAGESTR, -pg PAGESTR, --pages PAGESTR
                   Apply the cropping operation only to the selected pages. The
                   argument should be a list of the usual form such as
                   "2-4,5,9,20-30". The page-numbering is assumed to start at 1.
                   Ordering in the argument list is unimportant, negative ranges
                   are ignored, and pages falling outside the document are
@@ -796,14 +800,30 @@
 
      -y DPI, --resY DPI
                   The y-resolution in dots per inch to use when the image is
                   rendered to find the bounding boxes. The default is 150. Higher
                   values produce more precise bounding boxes but require more
                   time and memory.
 
+     -sr STR, --screenRes STR
+                  Pass in an X-windows style geometry string for the GUI to use
+                  as the fullscreen resolution and for the upper-left placement
+                  of the window. This is mainly for when the screen-size
+                  detection algorithm fails for a particular system. For example,
+                  with a screen of size "1024x720" that string should be used
+                  with the option. To also place the window at (0,0) the string
+                  would be "1024x728+0+0". See also the '--guiFontSize' option
+                  which can be used to decrease the overall size of the GUI
+                  window.
+
+     -gf INT, --guiFontSize INT
+                  Choose the GUI font size. Making this smaller than the default
+                  of 11 can also make the GUI smaller if it does not fit on a
+                  smaller monitor. +0+0".
+
      -b [m|c|t|a|b], --boxesToSet [m|c|t|a|b]
                   By default the pdfCropMargins program sets both the MediaBox
                   and the CropBox for each page of the cropped PDF document to
                   the new, cropped page size. This default setting is usually
                   sufficient, but this option can be used to select different PDF
                   boxes to set. The option takes one argument, which is the first
                   letter (lowercase) of a type of box. The choices are MediaBox
@@ -975,14 +995,23 @@
      -pw PASSWD, --password PASSWD
                   Specify a password to be used to decrypt an encrypted PDF file.
                   Note that decrypting with an empty password is always tried, so
                   this option is only needed for non-empty passwords. The
                   resulting cropped file will not be encrypted, so use caution if
                   important data is involved.
 
+     -pc, --prevCropped
+                  Test whether or not the document was previously cropped with
+                  the pdfCropMargins program. If so, exit with exit code 0. If
+                  not, exit with exit code 1. This option is intended mainly for
+                  scripting, for example to only crop documents that have not
+                  been previously cropped. Requires a document filename option.
+                  No other options are honored when this option is selected
+                  except '--gsFix', '--version', and '--help'.
+
      -khc, --keepHorizCenter
                   This option keeps the horizontal center point of a PDF fixed.
                   The usual crops are calculated, but for each page the left and
                   right delta values are both set to the smallest of the two
                   values (so the cropping amount is the same on each side). This
                   option does not apply to pre-crops.
```

## Comparing `pdfCropMargins-1.1.9.dist-info/RECORD` & `pdfCropMargins-1.2.0.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,23 +1,24 @@
-pdfCropMargins/__init__.py,sha256=mVYdm3Mjx7BZ-CT5QBLlXGJLtfx9CKBNpZQESWUZqpY,215
+pdfCropMargins/__init__.py,sha256=BW9vP0Pd3fZYCzbLWjOP1Lw1xaA6jiyTU9xtCGOBR_Q,215
 pdfCropMargins/__main__.py,sha256=eqembSzHFaMzW0tHq9tLGzlVhpaTnGd7WEDBYFw-ynk,197
 pdfCropMargins/calculate_bounding_boxes.py,sha256=y0J7TVEAJIRSeKNTOrGy4P30uiRLpuUp7LKhIrLq7Z8,13904
 pdfCropMargins/directory_locator.py,sha256=L3vgSdGVtBDJf8RVAVX0WxcDhqR8j5O3uv37X96lxmg,181
 pdfCropMargins/external_program_calls.py,sha256=7TtLspyfW-KxaLNLiyuh_9dtEPmZTfxg8wX8iDhAj2s,31258
-pdfCropMargins/gui.py,sha256=OpnPB-fEce4lB9bI88kH6InoOJr7DI6mdv5upTm9ZPc,53028
-pdfCropMargins/main_pdfCropMargins.py,sha256=6XIqKBVpP-FY48r3_WtL89NGcdQQBNvDf4O46JeZAc8,74626
-pdfCropMargins/manpage_data.py,sha256=e6GP6R82VrFbSn4P--TnSIlhHft8hD1KjybxNtsvy4M,47887
-pdfCropMargins/pdfCropMargins.py,sha256=pJghj_EuKo4AZhtKlxdVcvjvIadXe4iawNKqTzg7T1Q,8204
+pdfCropMargins/get_window_sizing_info.py,sha256=mYsxadWzL5x0CaAzVaaOD79b7rJcAfxQ6HlDz6FsU0k,8673
+pdfCropMargins/gui.py,sha256=KG8iWXzG1qCjiQlBGfU2jEPyW9O6b5CY3Sk6OP_xT0M,58643
+pdfCropMargins/main_pdfCropMargins.py,sha256=W-0ov7aHjWG4tx2bHoaq2qBW2ihGlHyUCSjFhtEi0WA,79226
+pdfCropMargins/manpage_data.py,sha256=ReTR_Y3ENmBx25ReXape03SRaSb41PPlVz1x5psGhOI,49723
+pdfCropMargins/pdfCropMargins.py,sha256=4kCvbjNMl8xcXy62jb-GrvWaMJ31wJd9ZncVddr8yjs,8262
 pdfCropMargins/prettified_argparse.py,sha256=OxtStEDN8UdU7OkSBeGxudJ_McwYArYmupVqiAfXK74,8924
-pdfCropMargins/pymupdf_routines.py,sha256=PkmNmUKCcONV4Bx7gqgpL5rRH47dEibgzLxW16NX_kw,11017
+pdfCropMargins/pymupdf_routines.py,sha256=hOgU8Euip1YT2nryfUTmo6nKS4CHpwd6Ln7QjYzOW2M,12497
 pdfCropMargins/pdftoppm_windows_local/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/pdftoppm.exe,sha256=paogYneEsikm1y6Q8wRcYxAGYwbZYMi5v0KctOSsQwI,1690624
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/pdftoppm.exe,sha256=SIlcH87t54NMT_9s8RWV4x4CCMnlKLURNsKVVUbzI7Y,2090496
-pdfCropMargins-1.1.9.dist-info/LICENSE,sha256=Je6hz-X3DSxDtjXaCDoczW7YB4RuX2zpU0PPiD410us,35546
-pdfCropMargins-1.1.9.dist-info/METADATA,sha256=Ik5JqFdCI8CPiQBzmWw0EtvQANzonam72Zokhf1cCQE,60115
-pdfCropMargins-1.1.9.dist-info/WHEEL,sha256=Z-nyYpwrcSqxfdux5Mbn_DQ525iP7J2DG3JgGvOYyTQ,110
-pdfCropMargins-1.1.9.dist-info/entry_points.txt,sha256=BAuD78hKbj7Par2JQxg5x_1KRI_Op3LXjRZMKR-bkOY,125
-pdfCropMargins-1.1.9.dist-info/top_level.txt,sha256=8xlp0kBdEXsm3mBVRnpsjvl5VIxXhjw8xKOq3q2iFjI,15
-pdfCropMargins-1.1.9.dist-info/RECORD,,
+pdfCropMargins-1.2.0.dist-info/LICENSE,sha256=Je6hz-X3DSxDtjXaCDoczW7YB4RuX2zpU0PPiD410us,35546
+pdfCropMargins-1.2.0.dist-info/METADATA,sha256=RBZEokvqFtcltfNoVICSnSBv88vlXImTzuNNsAzm9rE,61810
+pdfCropMargins-1.2.0.dist-info/WHEEL,sha256=Z-nyYpwrcSqxfdux5Mbn_DQ525iP7J2DG3JgGvOYyTQ,110
+pdfCropMargins-1.2.0.dist-info/entry_points.txt,sha256=BAuD78hKbj7Par2JQxg5x_1KRI_Op3LXjRZMKR-bkOY,125
+pdfCropMargins-1.2.0.dist-info/top_level.txt,sha256=8xlp0kBdEXsm3mBVRnpsjvl5VIxXhjw8xKOq3q2iFjI,15
+pdfCropMargins-1.2.0.dist-info/RECORD,,
```

