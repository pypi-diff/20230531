# Comparing `tmp/pyquickhelper-1.9.3396-py3-none-any.whl.zip` & `tmp/pyquickhelper-1.9.3418-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,22 @@
-Zip file size: 2162713 bytes, number of entries: 328
--rw-rw-rw-  2.0 fat     2798 b- defN 20-Jun-08 10:15 pyquickhelper/__init__.py
+Zip file size: 2164601 bytes, number of entries: 329
+-rw-rw-rw-  2.0 fat     2818 b- defN 20-Jul-09 00:15 pyquickhelper/__init__.py
 -rw-rw-rw-  2.0 fat     2852 b- defN 20-Feb-20 11:46 pyquickhelper/__main__.py
 -rw-rw-rw-  2.0 fat      129 b- defN 17-Aug-25 11:48 pyquickhelper/benchhelper/__init__.py
--rw-rw-rw-  2.0 fat    30626 b- defN 20-May-16 14:14 pyquickhelper/benchhelper/benchmark.py
--rw-rw-rw-  2.0 fat     7912 b- defN 18-Jul-22 14:42 pyquickhelper/benchhelper/grid_benchmark.py
+-rw-rw-rw-  2.0 fat    31360 b- defN 20-Jun-08 15:56 pyquickhelper/benchhelper/benchmark.py
+-rw-rw-rw-  2.0 fat     8212 b- defN 20-Jun-08 15:56 pyquickhelper/benchhelper/grid_benchmark.py
 -rw-rw-rw-  2.0 fat      124 b- defN 18-Nov-28 22:08 pyquickhelper/cli/__init__.py
--rw-rw-rw-  2.0 fat    16975 b- defN 20-May-08 16:37 pyquickhelper/cli/cli_helper.py
--rw-rw-rw-  2.0 fat     6491 b- defN 19-Jan-12 10:58 pyquickhelper/cli/encryption_cli.py
--rw-rw-rw-  2.0 fat     4011 b- defN 19-Jan-12 10:58 pyquickhelper/cli/encryption_file_cli.py
--rw-rw-rw-  2.0 fat     2808 b- defN 20-May-08 16:37 pyquickhelper/cli/ftp_cli.py
--rw-rw-rw-  2.0 fat     4752 b- defN 20-May-02 10:45 pyquickhelper/cli/notebook.py
--rw-rw-rw-  2.0 fat     1366 b- defN 19-Jan-08 10:35 pyquickhelper/cli/pyq_sync_cli.py
+-rw-rw-rw-  2.0 fat    16960 b- defN 20-Jun-08 15:48 pyquickhelper/cli/cli_helper.py
+-rw-rw-rw-  2.0 fat     6591 b- defN 20-Jun-08 15:50 pyquickhelper/cli/encryption_cli.py
+-rw-rw-rw-  2.0 fat     4111 b- defN 20-Jun-08 15:50 pyquickhelper/cli/encryption_file_cli.py
+-rw-rw-rw-  2.0 fat     2814 b- defN 20-Jun-08 15:58 pyquickhelper/cli/ftp_cli.py
+-rw-rw-rw-  2.0 fat     4854 b- defN 20-Jun-08 15:52 pyquickhelper/cli/notebook.py
+-rw-rw-rw-  2.0 fat     1406 b- defN 20-Jun-08 15:51 pyquickhelper/cli/pyq_sync_cli.py
 -rw-rw-rw-  2.0 fat     1528 b- defN 20-Feb-19 18:42 pyquickhelper/cli/script_exec.py
--rw-rw-rw-  2.0 fat     4828 b- defN 20-May-02 10:59 pyquickhelper/cli/simplified_fct.py
+-rw-rw-rw-  2.0 fat     4862 b- defN 20-Jun-08 15:56 pyquickhelper/cli/simplified_fct.py
 -rw-rw-rw-  2.0 fat     1507 b- defN 19-Nov-25 22:05 pyquickhelper/filehelper/__init__.py
 -rw-rw-rw-  2.0 fat     8485 b- defN 20-Jun-01 10:03 pyquickhelper/filehelper/anyfhelper.py
 -rw-rw-rw-  2.0 fat    23998 b- defN 20-May-08 15:04 pyquickhelper/filehelper/compression_helper.py
 -rw-rw-rw-  2.0 fat    11721 b- defN 17-Apr-18 14:24 pyquickhelper/filehelper/difflib.js
 -rw-rw-rw-  2.0 fat     2694 b- defN 17-Apr-18 14:24 pyquickhelper/filehelper/diffview.css
 -rw-rw-rw-  2.0 fat     8185 b- defN 17-Apr-18 14:24 pyquickhelper/filehelper/diffview.js
 -rw-rw-rw-  2.0 fat     6773 b- defN 19-Jan-12 11:30 pyquickhelper/filehelper/download_helper.py
@@ -40,15 +40,16 @@
 -rw-rw-rw-  2.0 fat      721 b- defN 19-Nov-10 17:36 pyquickhelper/helpgen/__init__.py
 -rw-rw-rw-  2.0 fat     1096 b- defN 18-Apr-22 09:40 pyquickhelper/helpgen/_fake_function_to_documentation.py
 -rw-rw-rw-  2.0 fat    21783 b- defN 20-May-16 14:02 pyquickhelper/helpgen/_my_doxypy.py
 -rw-rw-rw-  2.0 fat      501 b- defN 19-Jul-13 08:41 pyquickhelper/helpgen/_nbconvert_config.py
 -rw-rw-rw-  2.0 fat     1099 b- defN 18-Dec-20 00:05 pyquickhelper/helpgen/_nbconvert_preprocessor.py
 -rw-rw-rw-  2.0 fat     7560 b- defN 20-May-02 12:13 pyquickhelper/helpgen/_single_file_html_builder.py
 -rw-rw-rw-  2.0 fat     6868 b- defN 20-Feb-12 14:22 pyquickhelper/helpgen/conf_path_tools.py
--rw-rw-rw-  2.0 fat    44777 b- defN 20-May-08 14:55 pyquickhelper/helpgen/default_conf.py
+-rw-rw-rw-  2.0 fat    44619 b- defN 20-Jun-30 12:59 pyquickhelper/helpgen/default_conf.py
+-rw-rw-rw-  2.0 fat     1809 b- defN 20-Jul-07 00:04 pyquickhelper/helpgen/graphviz_helper.py
 -rw-rw-rw-  2.0 fat      516 b- defN 17-Aug-25 11:48 pyquickhelper/helpgen/help_usage.py
 -rw-rw-rw-  2.0 fat      986 b- defN 18-Oct-14 09:34 pyquickhelper/helpgen/helpgen_exceptions.py
 -rw-rw-rw-  2.0 fat     5203 b- defN 18-Aug-27 09:07 pyquickhelper/helpgen/install_custom.py
 -rw-rw-rw-  2.0 fat     1814 b- defN 19-Mar-23 21:15 pyquickhelper/helpgen/install_js_dep.py
 -rw-rw-rw-  2.0 fat     1971 b- defN 18-Sep-21 15:26 pyquickhelper/helpgen/markdown_helper.py
 -rw-rw-rw-  2.0 fat     4441 b- defN 19-Nov-10 18:12 pyquickhelper/helpgen/notebook_exporter.py
 -rw-rw-rw-  2.0 fat     1932 b- defN 19-Jan-12 11:30 pyquickhelper/helpgen/pandoc_helper.py
@@ -62,29 +63,29 @@
 -rw-rw-rw-  2.0 fat    24659 b- defN 19-Dec-12 11:16 pyquickhelper/helpgen/rst_converters.py
 -rw-rw-rw-  2.0 fat      393 b- defN 18-Mar-26 15:45 pyquickhelper/helpgen/rst_modified.tpl
 -rw-rw-rw-  2.0 fat     2761 b- defN 19-Jan-12 11:30 pyquickhelper/helpgen/sphinx_helper.py
 -rw-rw-rw-  2.0 fat    61383 b- defN 20-May-08 16:30 pyquickhelper/helpgen/sphinx_main.py
 -rw-rw-rw-  2.0 fat    20014 b- defN 19-Mar-20 00:38 pyquickhelper/helpgen/sphinx_main_helper.py
 -rw-rw-rw-  2.0 fat     8722 b- defN 19-Apr-15 22:42 pyquickhelper/helpgen/sphinx_main_missing_html_files.py
 -rw-rw-rw-  2.0 fat     4291 b- defN 19-Dec-18 19:46 pyquickhelper/helpgen/sphinx_main_verification.py
--rw-rw-rw-  2.0 fat    63272 b- defN 20-May-08 15:14 pyquickhelper/helpgen/sphinxm_convert_doc_sphinx_helper.py
+-rw-rw-rw-  2.0 fat    64057 b- defN 20-Jun-21 13:22 pyquickhelper/helpgen/sphinxm_convert_doc_sphinx_helper.py
 -rw-rw-rw-  2.0 fat     5848 b- defN 19-Dec-12 11:22 pyquickhelper/helpgen/sphinxm_custom_app.py
 -rw-rw-rw-  2.0 fat    17252 b- defN 20-Apr-06 09:45 pyquickhelper/helpgen/sphinxm_mock_app.py
 -rw-rw-rw-  2.0 fat     3677 b- defN 19-Jan-09 22:01 pyquickhelper/helpgen/stat_helper.py
 -rw-rw-rw-  2.0 fat     2272 b- defN 18-Oct-14 09:34 pyquickhelper/helpgen/style_css_template.py
 -rw-rw-rw-  2.0 fat     2247 b- defN 19-Mar-20 00:38 pyquickhelper/helpgen/utils_pywin32.py
 -rw-rw-rw-  2.0 fat     4895 b- defN 20-Feb-12 13:15 pyquickhelper/helpgen/utils_sphinx_config.py
 -rw-rw-rw-  2.0 fat    76539 b- defN 20-May-08 16:33 pyquickhelper/helpgen/utils_sphinx_doc.py
 -rw-rw-rw-  2.0 fat    37584 b- defN 20-May-16 14:03 pyquickhelper/helpgen/utils_sphinx_doc_helpers.py
 -rw-rw-rw-  2.0 fat      110 b- defN 19-Oct-25 15:05 pyquickhelper/imghelper/__init__.py
 -rw-rw-rw-  2.0 fat      166 b- defN 18-Mar-12 22:32 pyquickhelper/imghelper/excs.py
--rw-rw-rw-  2.0 fat     1552 b- defN 20-May-02 11:04 pyquickhelper/imghelper/img_export.py
--rw-rw-rw-  2.0 fat     2928 b- defN 20-May-02 11:03 pyquickhelper/imghelper/img_helper.py
--rw-rw-rw-  2.0 fat     7269 b- defN 19-Mar-20 00:47 pyquickhelper/imghelper/js_helper.py
--rw-rw-rw-  2.0 fat     2053 b- defN 18-May-10 15:21 pyquickhelper/imghelper/svg_helper.py
+-rw-rw-rw-  2.0 fat     1592 b- defN 20-Jun-08 16:03 pyquickhelper/imghelper/img_export.py
+-rw-rw-rw-  2.0 fat     2968 b- defN 20-Jun-08 16:02 pyquickhelper/imghelper/img_helper.py
+-rw-rw-rw-  2.0 fat     7418 b- defN 20-Jun-08 16:01 pyquickhelper/imghelper/js_helper.py
+-rw-rw-rw-  2.0 fat     1976 b- defN 20-Jun-08 15:59 pyquickhelper/imghelper/svg_helper.py
 -rw-rw-rw-  2.0 fat     1199 b- defN 19-Mar-12 11:48 pyquickhelper/ipythonhelper/__init__.py
 -rw-rw-rw-  2.0 fat     4773 b- defN 18-Oct-14 09:34 pyquickhelper/ipythonhelper/html_forms.py
 -rw-rw-rw-  2.0 fat     7467 b- defN 19-Sep-24 23:20 pyquickhelper/ipythonhelper/interact.py
 -rw-rw-rw-  2.0 fat     4433 b- defN 18-Jan-19 13:57 pyquickhelper/ipythonhelper/kindofcompletion.py
 -rw-rw-rw-  2.0 fat     3174 b- defN 19-Jun-27 13:23 pyquickhelper/ipythonhelper/magic_class.py
 -rw-rw-rw-  2.0 fat     2712 b- defN 18-Oct-14 09:34 pyquickhelper/ipythonhelper/magic_class_compress.py
 -rw-rw-rw-  2.0 fat     4575 b- defN 19-Jan-12 11:30 pyquickhelper/ipythonhelper/magic_class_crypt.py
@@ -105,15 +106,15 @@
 -rw-rw-rw-  2.0 fat     4917 b- defN 19-Jan-03 22:13 pyquickhelper/jenkinshelper/jenkins_server_template.py
 -rw-rw-rw-  2.0 fat    27865 b- defN 20-Jun-03 14:04 pyquickhelper/jenkinshelper/yaml_helper.py
 -rw-rw-rw-  2.0 fat      481 b- defN 20-Feb-12 12:51 pyquickhelper/jenkinshelper/yaml_helper_yaml.py
 -rw-rw-rw-  2.0 fat      806 b- defN 19-Mar-22 08:44 pyquickhelper/loghelper/__init__.py
 -rw-rw-rw-  2.0 fat      883 b- defN 20-May-30 11:11 pyquickhelper/loghelper/buffered_flog.py
 -rw-rw-rw-  2.0 fat     1737 b- defN 18-Oct-14 09:45 pyquickhelper/loghelper/convert_helper.py
 -rw-rw-rw-  2.0 fat     3833 b- defN 20-May-16 14:05 pyquickhelper/loghelper/custom_log.py
--rw-rw-rw-  2.0 fat    36641 b- defN 20-May-16 14:22 pyquickhelper/loghelper/flog.py
+-rw-rw-rw-  2.0 fat    36842 b- defN 20-Jun-23 09:24 pyquickhelper/loghelper/flog.py
 -rw-rw-rw-  2.0 fat     2294 b- defN 18-Oct-14 09:34 pyquickhelper/loghelper/flog_fake_classes.py
 -rw-rw-rw-  2.0 fat     1840 b- defN 19-Jan-18 16:37 pyquickhelper/loghelper/github_api.py
 -rw-rw-rw-  2.0 fat    10534 b- defN 20-Apr-24 10:20 pyquickhelper/loghelper/history_helper.py
 -rw-rw-rw-  2.0 fat     1218 b- defN 18-Oct-14 09:34 pyquickhelper/loghelper/os_helper.py
 -rw-rw-rw-  2.0 fat      707 b- defN 18-Apr-13 22:49 pyquickhelper/loghelper/pqh_exception.py
 -rw-rw-rw-  2.0 fat     1555 b- defN 18-Oct-14 09:34 pyquickhelper/loghelper/process_helper.py
 -rw-rw-rw-  2.0 fat     5498 b- defN 20-May-08 16:34 pyquickhelper/loghelper/process_script.py
@@ -125,18 +126,18 @@
 -rw-rw-rw-  2.0 fat     1504 b- defN 18-Dec-31 14:16 pyquickhelper/loghelper/url_helper.py
 -rw-rw-rw-  2.0 fat        0 b- defN 17-Aug-25 00:11 pyquickhelper/loghelper/repositories/__init__.py
 -rw-rw-rw-  2.0 fat     3014 b- defN 18-May-10 16:24 pyquickhelper/loghelper/repositories/gitlab_helper.py
 -rw-rw-rw-  2.0 fat    31656 b- defN 20-May-08 15:14 pyquickhelper/loghelper/repositories/pygit_helper.py
 -rw-rw-rw-  2.0 fat    13085 b- defN 20-May-10 09:25 pyquickhelper/loghelper/repositories/pysvn_helper.py
 -rw-rw-rw-  2.0 fat      161 b- defN 18-Mar-17 11:25 pyquickhelper/pandashelper/__init__.py
 -rw-rw-rw-  2.0 fat     2879 b- defN 19-Jan-28 13:19 pyquickhelper/pandashelper/readh.py
--rw-rw-rw-  2.0 fat    14618 b- defN 20-May-16 14:12 pyquickhelper/pandashelper/tblformat.py
--rw-rw-rw-  2.0 fat      982 b- defN 19-Jan-12 14:20 pyquickhelper/pandashelper/tblfunction.py
+-rw-rw-rw-  2.0 fat    14759 b- defN 20-Jun-08 15:55 pyquickhelper/pandashelper/tblformat.py
+-rw-rw-rw-  2.0 fat      983 b- defN 20-Jun-08 15:54 pyquickhelper/pandashelper/tblfunction.py
 -rw-rw-rw-  2.0 fat     1309 b- defN 20-Jun-07 22:35 pyquickhelper/pycode/__init__.py
--rw-rw-rw-  2.0 fat     6266 b- defN 20-May-02 12:13 pyquickhelper/pycode/_pylint_common.py
+-rw-rw-rw-  2.0 fat     6341 b- defN 20-Jun-25 23:13 pyquickhelper/pycode/_pylint_common.py
 -rw-rw-rw-  2.0 fat     2095 b- defN 19-Jul-13 08:37 pyquickhelper/pycode/blog_helper.py
 -rw-rw-rw-  2.0 fat    23989 b- defN 19-Apr-25 11:23 pyquickhelper/pycode/build_helper.py
 -rw-rw-rw-  2.0 fat     6324 b- defN 19-Jul-13 08:39 pyquickhelper/pycode/call_setup_hook.py
 -rw-rw-rw-  2.0 fat     1163 b- defN 19-Jan-12 10:15 pyquickhelper/pycode/ci_helper.py
 -rw-rw-rw-  2.0 fat     3454 b- defN 20-May-02 10:48 pyquickhelper/pycode/clean_helper.py
 -rw-rw-rw-  2.0 fat      311 b- defN 17-Aug-25 11:48 pyquickhelper/pycode/code_exceptions.py
 -rw-rw-rw-  2.0 fat     9335 b- defN 20-Feb-28 21:11 pyquickhelper/pycode/code_helper.py
@@ -145,58 +146,58 @@
 -rw-rw-rw-  2.0 fat      421 b- defN 18-Oct-14 09:34 pyquickhelper/pycode/default_regular_expression.py
 -rw-rw-rw-  2.0 fat     2459 b- defN 19-Oct-17 14:06 pyquickhelper/pycode/insetup_helper.py
 -rw-rw-rw-  2.0 fat     1154 b- defN 18-Oct-14 09:34 pyquickhelper/pycode/linux_scripts.py
 -rw-rw-rw-  2.0 fat     1044 b- defN 19-Jan-12 11:27 pyquickhelper/pycode/open_script_file.py
 -rw-rw-rw-  2.0 fat     2850 b- defN 20-May-16 14:09 pyquickhelper/pycode/pip_helper.py
 -rw-rw-rw-  2.0 fat     6066 b- defN 19-Oct-23 08:27 pyquickhelper/pycode/profiling.py
 -rw-rw-rw-  2.0 fat    10559 b- defN 19-Sep-24 23:20 pyquickhelper/pycode/py3to2.py
--rw-rw-rw-  2.0 fat     3385 b- defN 20-May-02 12:59 pyquickhelper/pycode/pytest_helper.py
+-rw-rw-rw-  2.0 fat     3841 b- defN 20-Jun-23 22:02 pyquickhelper/pycode/pytest_helper.py
 -rw-rw-rw-  2.0 fat     1391 b- defN 18-Oct-14 09:34 pyquickhelper/pycode/readme_helper.py
--rw-rw-rw-  2.0 fat    55256 b- defN 20-May-10 09:20 pyquickhelper/pycode/setup_helper.py
+-rw-rw-rw-  2.0 fat    55845 b- defN 20-Jun-20 00:22 pyquickhelper/pycode/setup_helper.py
 -rw-rw-rw-  2.0 fat     5565 b- defN 18-Oct-14 09:45 pyquickhelper/pycode/tkinter_helper.py
 -rw-rw-rw-  2.0 fat      460 b- defN 19-Jan-12 11:27 pyquickhelper/pycode/trace_execution.py
 -rw-rw-rw-  2.0 fat    22964 b- defN 20-Jun-08 09:49 pyquickhelper/pycode/unittestclass.py
 -rw-rw-rw-  2.0 fat    24505 b- defN 20-May-08 15:00 pyquickhelper/pycode/utils_tests.py
 -rw-rw-rw-  2.0 fat    20796 b- defN 20-Feb-28 21:43 pyquickhelper/pycode/utils_tests_helper.py
--rw-rw-rw-  2.0 fat    23090 b- defN 20-May-24 14:20 pyquickhelper/pycode/utils_tests_private.py
+-rw-rw-rw-  2.0 fat    23442 b- defN 20-Jun-20 00:30 pyquickhelper/pycode/utils_tests_private.py
 -rw-rw-rw-  2.0 fat     2386 b- defN 19-Jan-12 11:27 pyquickhelper/pycode/utils_tests_stringio.py
 -rw-rw-rw-  2.0 fat    17981 b- defN 20-May-10 09:25 pyquickhelper/pycode/venv_helper.py
 -rw-rw-rw-  2.0 fat    26868 b- defN 19-Nov-10 17:28 pyquickhelper/pycode/windows_scripts.py
 -rw-rw-rw-  2.0 fat      147 b- defN 18-Aug-20 15:03 pyquickhelper/serverdoc/__init__.py
--rw-rw-rw-  2.0 fat    21812 b- defN 20-May-16 14:12 pyquickhelper/serverdoc/documentation_server.py
+-rw-rw-rw-  2.0 fat    21996 b- defN 20-Jun-25 23:59 pyquickhelper/serverdoc/documentation_server.py
 -rw-rw-rw-  2.0 fat     1759 b- defN 19-Sep-24 23:20 pyquickhelper/serverdoc/server_helper.py
 -rw-rw-rw-  2.0 fat     7977 b- defN 19-Jul-17 09:24 pyquickhelper/sphinxext/__init__.py
 -rw-rw-rw-  2.0 fat      139 b- defN 18-Oct-14 09:34 pyquickhelper/sphinxext/_private_for_unittest.py
--rw-rw-rw-  2.0 fat     8935 b- defN 18-Oct-14 10:20 pyquickhelper/sphinxext/_sphinx_common_builder.py
+-rw-rw-rw-  2.0 fat     9129 b- defN 20-Jun-25 23:52 pyquickhelper/sphinxext/_sphinx_common_builder.py
 -rw-rw-rw-  2.0 fat    11818 b- defN 19-Mar-20 00:31 pyquickhelper/sphinxext/blog_post.py
 -rw-rw-rw-  2.0 fat    26101 b- defN 20-May-16 14:04 pyquickhelper/sphinxext/blog_post_list.py
 -rw-rw-rw-  2.0 fat     3005 b- defN 17-Aug-31 15:44 pyquickhelper/sphinxext/build_rss.py
 -rw-rw-rw-  2.0 fat      975 b- defN 18-Oct-14 09:34 pyquickhelper/sphinxext/documentation_link.py
 -rw-rw-rw-  2.0 fat      764 b- defN 17-Apr-18 14:24 pyquickhelper/sphinxext/feed-icon-16x16.png
 -rw-rw-rw-  2.0 fat     9633 b- defN 20-May-02 12:12 pyquickhelper/sphinxext/import_object_helper.py
--rw-rw-rw-  2.0 fat    20132 b- defN 20-May-10 13:00 pyquickhelper/sphinxext/sphinx_autosignature.py
+-rw-rw-rw-  2.0 fat    20442 b- defN 20-Jun-25 23:49 pyquickhelper/sphinxext/sphinx_autosignature.py
 -rw-rw-rw-  2.0 fat     3995 b- defN 20-Feb-12 10:16 pyquickhelper/sphinxext/sphinx_bigger_extension.py
--rw-rw-rw-  2.0 fat    20832 b- defN 19-Jun-15 22:49 pyquickhelper/sphinxext/sphinx_blocref_extension.py
+-rw-rw-rw-  2.0 fat    20993 b- defN 20-Jun-25 23:56 pyquickhelper/sphinxext/sphinx_blocref_extension.py
 -rw-rw-rw-  2.0 fat    17333 b- defN 20-May-08 16:26 pyquickhelper/sphinxext/sphinx_blog_extension.py
--rw-rw-rw-  2.0 fat    12460 b- defN 19-Aug-26 13:12 pyquickhelper/sphinxext/sphinx_cmdref_extension.py
+-rw-rw-rw-  2.0 fat    12500 b- defN 20-Jun-25 23:50 pyquickhelper/sphinxext/sphinx_cmdref_extension.py
 -rw-rw-rw-  2.0 fat     5384 b- defN 18-Sep-19 09:41 pyquickhelper/sphinxext/sphinx_collapse_extension.py
--rw-rw-rw-  2.0 fat    11499 b- defN 20-Feb-12 14:24 pyquickhelper/sphinxext/sphinx_docassert_extension.py
--rw-rw-rw-  2.0 fat     9751 b- defN 20-Feb-12 14:24 pyquickhelper/sphinxext/sphinx_doctree_builder.py
+-rw-rw-rw-  2.0 fat    12150 b- defN 20-Jun-23 12:45 pyquickhelper/sphinxext/sphinx_docassert_extension.py
+-rw-rw-rw-  2.0 fat     9771 b- defN 20-Jun-25 23:52 pyquickhelper/sphinxext/sphinx_doctree_builder.py
 -rw-rw-rw-  2.0 fat    11139 b- defN 20-Apr-05 23:35 pyquickhelper/sphinxext/sphinx_downloadlink_extension.py
--rw-rw-rw-  2.0 fat     7928 b- defN 18-Nov-05 11:05 pyquickhelper/sphinxext/sphinx_epkg_extension.py
+-rw-rw-rw-  2.0 fat     8025 b- defN 20-Jun-25 23:53 pyquickhelper/sphinxext/sphinx_epkg_extension.py
 -rw-rw-rw-  2.0 fat     6426 b- defN 19-Jan-12 11:25 pyquickhelper/sphinxext/sphinx_exref_extension.py
 -rw-rw-rw-  2.0 fat     3653 b- defN 19-Mar-30 11:44 pyquickhelper/sphinxext/sphinx_ext_helper.py
 -rw-rw-rw-  2.0 fat     6428 b- defN 19-Jan-12 11:25 pyquickhelper/sphinxext/sphinx_faqref_extension.py
 -rw-rw-rw-  2.0 fat    10390 b- defN 19-Jun-19 12:57 pyquickhelper/sphinxext/sphinx_gdot_extension.py
 -rw-rw-rw-  2.0 fat     7943 b- defN 19-Dec-06 12:38 pyquickhelper/sphinxext/sphinx_githublink_extension.py
 -rw-rw-rw-  2.0 fat     4370 b- defN 19-Apr-03 23:09 pyquickhelper/sphinxext/sphinx_gitlog_extension.py
 -rw-rw-rw-  2.0 fat    13437 b- defN 20-May-10 10:57 pyquickhelper/sphinxext/sphinx_image_extension.py
 -rw-rw-rw-  2.0 fat    10578 b- defN 20-Feb-12 14:24 pyquickhelper/sphinxext/sphinx_latex_builder.py
 -rw-rw-rw-  2.0 fat    17121 b- defN 19-Jun-03 21:37 pyquickhelper/sphinxext/sphinx_mathdef_extension.py
--rw-rw-rw-  2.0 fat    34253 b- defN 20-May-10 10:57 pyquickhelper/sphinxext/sphinx_md_builder.py
+-rw-rw-rw-  2.0 fat    34327 b- defN 20-Jun-25 23:49 pyquickhelper/sphinxext/sphinx_md_builder.py
 -rw-rw-rw-  2.0 fat     6266 b- defN 19-Jan-12 11:25 pyquickhelper/sphinxext/sphinx_nbref_extension.py
 -rw-rw-rw-  2.0 fat     8552 b- defN 19-Dec-06 12:39 pyquickhelper/sphinxext/sphinx_postcontents_extension.py
 -rw-rw-rw-  2.0 fat     6694 b- defN 18-Dec-28 22:58 pyquickhelper/sphinxext/sphinx_quote_extension.py
 -rw-rw-rw-  2.0 fat    39270 b- defN 20-May-08 16:27 pyquickhelper/sphinxext/sphinx_rst_builder.py
 -rw-rw-rw-  2.0 fat    31317 b- defN 20-May-08 16:25 pyquickhelper/sphinxext/sphinx_runpython_extension.py
 -rw-rw-rw-  2.0 fat     9545 b- defN 20-Feb-12 10:20 pyquickhelper/sphinxext/sphinx_sharenet_extension.py
 -rw-rw-rw-  2.0 fat     5166 b- defN 20-Apr-26 23:15 pyquickhelper/sphinxext/sphinx_template_extension.py
@@ -314,17 +315,17 @@
 -rw-rw-rw-  2.0 fat     4096 b- defN 18-Sep-16 10:19 pyquickhelper/sphinxext/sphinximages/sphinxtrib/missing.png
 -rw-rw-rw-  2.0 fat        0 b- defN 20-Feb-12 11:03 pyquickhelper/sphinxext/templates/__init__.py
 -rw-rw-rw-  2.0 fat      644 b- defN 20-Feb-12 11:03 pyquickhelper/sphinxext/templates/tabular.tex_t.txt
 -rw-rw-rw-  2.0 fat      265 b- defN 18-Oct-04 13:29 pyquickhelper/texthelper/__init__.py
 -rw-rw-rw-  2.0 fat     1923 b- defN 18-Oct-04 20:10 pyquickhelper/texthelper/code_helper.py
 -rw-rw-rw-  2.0 fat      488 b- defN 18-Nov-15 14:45 pyquickhelper/texthelper/diacritic_helper.py
 -rw-rw-rw-  2.0 fat      568 b- defN 18-Nov-11 14:15 pyquickhelper/texthelper/html_helper.py
--rw-rw-rw-  2.0 fat     2355 b- defN 20-Jun-03 08:31 pyquickhelper/texthelper/templating.py
+-rw-rw-rw-  2.0 fat     2375 b- defN 20-Jun-08 15:53 pyquickhelper/texthelper/templating.py
 -rw-rw-rw-  2.0 fat     3323 b- defN 18-Aug-19 09:32 pyquickhelper/texthelper/texts_language.py
 -rw-rw-rw-  2.0 fat     1916 b- defN 18-Nov-11 11:41 pyquickhelper/texthelper/version_helper.py
--rw-rw-rw-  2.0 fat     1083 b- defN 20-Jun-08 10:15 pyquickhelper-1.9.3396.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat    24062 b- defN 20-Jun-08 10:15 pyquickhelper-1.9.3396.dist-info/METADATA
--rw-rw-rw-  2.0 fat       97 b- defN 20-Jun-08 10:15 pyquickhelper-1.9.3396.dist-info/WHEEL
--rw-rw-rw-  2.0 fat      304 b- defN 20-Jun-08 10:15 pyquickhelper-1.9.3396.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat       14 b- defN 20-Jun-08 10:15 pyquickhelper-1.9.3396.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat    36701 b- defN 20-Jun-08 10:15 pyquickhelper-1.9.3396.dist-info/RECORD
-328 files, 4903667 bytes uncompressed, 2101587 bytes compressed:  57.2%
+-rw-rw-rw-  2.0 fat     1083 b- defN 20-Jul-09 00:15 pyquickhelper-1.9.3418.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat    24527 b- defN 20-Jul-09 00:15 pyquickhelper-1.9.3418.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       97 b- defN 20-Jul-09 00:15 pyquickhelper-1.9.3418.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat      304 b- defN 20-Jul-09 00:15 pyquickhelper-1.9.3418.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat       14 b- defN 20-Jul-09 00:15 pyquickhelper-1.9.3418.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat    36798 b- defN 20-Jul-09 00:15 pyquickhelper-1.9.3418.dist-info/RECORD
+329 files, 4911804 bytes uncompressed, 2103319 bytes compressed:  57.2%
```

## zipnote {}

```diff
@@ -132,14 +132,17 @@
 
 Filename: pyquickhelper/helpgen/conf_path_tools.py
 Comment: 
 
 Filename: pyquickhelper/helpgen/default_conf.py
 Comment: 
 
+Filename: pyquickhelper/helpgen/graphviz_helper.py
+Comment: 
+
 Filename: pyquickhelper/helpgen/help_usage.py
 Comment: 
 
 Filename: pyquickhelper/helpgen/helpgen_exceptions.py
 Comment: 
 
 Filename: pyquickhelper/helpgen/install_custom.py
@@ -960,26 +963,26 @@
 
 Filename: pyquickhelper/texthelper/texts_language.py
 Comment: 
 
 Filename: pyquickhelper/texthelper/version_helper.py
 Comment: 
 
-Filename: pyquickhelper-1.9.3396.dist-info/LICENSE.txt
+Filename: pyquickhelper-1.9.3418.dist-info/LICENSE.txt
 Comment: 
 
-Filename: pyquickhelper-1.9.3396.dist-info/METADATA
+Filename: pyquickhelper-1.9.3418.dist-info/METADATA
 Comment: 
 
-Filename: pyquickhelper-1.9.3396.dist-info/WHEEL
+Filename: pyquickhelper-1.9.3418.dist-info/WHEEL
 Comment: 
 
-Filename: pyquickhelper-1.9.3396.dist-info/entry_points.txt
+Filename: pyquickhelper-1.9.3418.dist-info/entry_points.txt
 Comment: 
 
-Filename: pyquickhelper-1.9.3396.dist-info/top_level.txt
+Filename: pyquickhelper-1.9.3418.dist-info/top_level.txt
 Comment: 
 
-Filename: pyquickhelper-1.9.3396.dist-info/RECORD
+Filename: pyquickhelper-1.9.3418.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pyquickhelper/__init__.py

```diff
@@ -2,15 +2,15 @@
 """
 @file
 @brief Module *pyquickhelper*.
 Helpers to produce documentation, test notebooks, walk through files,
 sphinx extension, jenkins helpers...
 """
 
-__version__ = "1.9.3397"
+__version__ = "1.9.3418"
 __author__ = "Xavier Dupré"
 __github__ = "https://github.com/sdpython/pyquickhelper"
 __url__ = "http://www.xavierdupre.fr/app/pyquickhelper/helpsphinx/index.html"
 __license__ = "MIT License"
 __blog__ = """
 <?xml version="1.0" encoding="UTF-8"?>
 <opml version="1.0">
@@ -49,15 +49,15 @@
 
     @param      add_print       print *Success: _setup_hook*
     @param      unit_test       used only for unit testing purpose
     """
     # it can check many things, needed module
     # any others things before unit tests are started
     if add_print:
-        print("Success: _setup_hook")
+        print("Success: _setup_hook")  # pragma: no cover
 
 
 def load_ipython_extension(ip):  # pragma: no cover
     """
     to allow the call ``%load_ext pyquickhelper``
 
     @param      ip      from ``get_ipython()``
```

### html2text {}

```diff
@@ -1,27 +1,28 @@
 # -*- coding: utf-8 -*- """ @file @brief Module *pyquickhelper*. Helpers to
 produce documentation, test notebooks, walk through files, sphinx extension,
-jenkins helpers... """ __version__ = "1.9.3397" __author__ = "Xavier DuprÃ©"
+jenkins helpers... """ __version__ = "1.9.3418" __author__ = "Xavier DuprÃ©"
 __github__ = "https://github.com/sdpython/pyquickhelper" __url__ = "http://
 www.xavierdupre.fr/app/pyquickhelper/helpsphinx/index.html" __license__ = "MIT
 License" __blog__ = """ <?xml version="1.0" encoding="UTF-8"?>
  """ def check(): """ Checks the library is working. It raises an exception if
 it does not. @return boolean """ from .loghelper import check_log check_log()
 return True def _setup_hook(add_print=False, unit_test=False): """ if this
 function is added to the module, the help automation and unit tests call it
 first before anything goes on as an initialization step. It should be run in a
 separate process. @param add_print print *Success: _setup_hook* @param
 unit_test used only for unit testing purpose """ # it can check many things,
 needed module # any others things before unit tests are started if add_print:
-print("Success: _setup_hook") def load_ipython_extension(ip): # pragma: no
-cover """ to allow the call ``%load_ext pyquickhelper`` @param ip from
-``get_ipython()`` """ from .ipythonhelper.magic_class_example import
-register_file_magics as freg freg(ip) from .ipythonhelper.magic_class_compress
-import register_file_magics as creg creg(ip) from
-.ipythonhelper.magic_class_diff import register_file_magics as dreg dreg(ip)
-from .ipythonhelper.magic_class_crypt import register_file_magics as ereg ereg
-(ip) def get_fLOG(log=True): """ return a logging function @param log True,
-return @see fn fLOG, otherwise @see fn noLOG @return function """ if log: from
-.loghelper import fLOG return fLOG else: from .loghelper import noLOG return
-noLOG def get_insetup_functions(): """ Returns function used when a module
-includes C++ parts. @return tuple of functions """ from .pycode.insetup_helper
-import must_build, run_build_ext return must_build, run_build_ext
+print("Success: _setup_hook") # pragma: no cover def load_ipython_extension
+(ip): # pragma: no cover """ to allow the call ``%load_ext pyquickhelper``
+@param ip from ``get_ipython()`` """ from .ipythonhelper.magic_class_example
+import register_file_magics as freg freg(ip) from
+.ipythonhelper.magic_class_compress import register_file_magics as creg creg
+(ip) from .ipythonhelper.magic_class_diff import register_file_magics as dreg
+dreg(ip) from .ipythonhelper.magic_class_crypt import register_file_magics as
+ereg ereg(ip) def get_fLOG(log=True): """ return a logging function @param log
+True, return @see fn fLOG, otherwise @see fn noLOG @return function """ if log:
+from .loghelper import fLOG return fLOG else: from .loghelper import noLOG
+return noLOG def get_insetup_functions(): """ Returns function used when a
+module includes C++ parts. @return tuple of functions """ from
+.pycode.insetup_helper import must_build, run_build_ext return must_build,
+run_build_ext
```

## pyquickhelper/benchhelper/benchmark.py

```diff
@@ -56,32 +56,35 @@
     # methods to overwrite
     ##
 
     def init(self):
         """
         Initialisation. Overwrite this method.
         """
-        raise NotImplementedError("It should be overwritten.")
+        raise NotImplementedError(
+            "It should be overwritten.")  # pragma: no cover
 
     def bench(self, **params):
         """
         Runs the benchmark. Overwrite this method.
 
         @param      params      parameters
         @return                 metrics as a dictionary, appendix as a dictionary
 
         The results of this method will be cached if a *cache_file* was specified in the constructor.
         """
-        raise NotImplementedError("It should be overwritten.")
+        raise NotImplementedError(
+            "It should be overwritten.")  # pragma: no cover
 
     def end(self):
         """
         Cleans. Overwrites this method.
         """
-        raise NotImplementedError("It should be overwritten.")
+        raise NotImplementedError(
+            "It should be overwritten.")  # pragma: no cover
 
     def graphs(self, path_to_images):
         """
         Builds graphs after the benchmark was run.
 
         @param      path_to_images      path to images
         @return                         a list of LocalGraph
@@ -139,15 +142,15 @@
             """
             @param      func_gen        function generating the graph
             @param      filename        filename
             @param      title           title
             @param      root            path should be relative to this one
             """
             if func_gen is None:
-                raise ValueError("func_gen cannot be None")
+                raise ValueError("func_gen cannot be None")  # pragma: no cover
             if filename is not None:
                 self.filename = filename
             if title is not None:
                 self.title = title
             self.root = root
             self.func_gen = func_gen
 
@@ -187,15 +190,16 @@
                     filename = get_relative_path(
                         self.root, self.filename, exists=False, absolute=False)
                 else:
                     filename = self.filename
                 filename = filename.replace("\\", "/")
                 return '<img src="{0}" {1}/>'.format(filename, merge)
             else:
-                raise NotImplementedError("only files are allowed")
+                raise NotImplementedError(
+                    "only files are allowed")  # pragma: no cover
 
         def to_rst(self):
             """
             Renders as :ekg:`rst`.
             """
             # do not consider width or height
             # deal with relatif path
@@ -204,15 +208,16 @@
                     filename = get_relative_path(
                         self.root, self.filename, exists=False, absolute=False)
                 else:
                     filename = self.filename
                 filename = filename.replace("\\", "/")
                 return '.. image:: {0}'.format(filename)
             else:
-                raise NotImplementedError("only files are allowed")
+                raise NotImplementedError(
+                    "only files are allowed")  # pragma: no cover
 
     @property
     def Name(self):
         """
         Returns the name of the benchmark.
         """
         return self._name
@@ -235,18 +240,19 @@
     def run(self, params_list):
         """
         Runs the benchmark.
 
         @param      params_list     list of dictionaries
         """
         if not isinstance(params_list, list):
-            raise TypeError("params_list must be a list")
+            raise TypeError("params_list must be a list")  # pragma: no cover
         for di in params_list:
             if not isinstance(di, dict):
-                raise TypeError("params_list must be a list of dictionaries")
+                raise TypeError(  # pragma: no cover
+                    "params_list must be a list of dictionaries")
 
         # shared variables
         cached = {}
         meta = dict(level="BenchMark", name=self.Name, nb=len(
             params_list), time_begin=datetime.now())
         self._metadata = []
         self._metadata.append(meta)
@@ -322,44 +328,47 @@
                 cl = perf_counter() - cl
 
                 if isinstance(tu, tuple):
                     tus = [tu]
                 elif isinstance(tu, list):
                     tus = tu
                 else:
-                    raise TypeError(
+                    raise TypeError(  # pragma: no cover
                         "return of method bench must be a tuple of a list")
 
                 # checkings
                 for tu in tus:
                     met, app = tu
                     if len(tu) != 2:
-                        raise TypeError(
+                        raise TypeError(  # pragma: no cover
                             "Method run should return a tuple with 2 elements.")
                     if "_btry" not in met:
-                        raise KeyError("Metrics should contain key '_btry'.")
+                        raise KeyError(  # pragma: no cover
+                            "Metrics should contain key '_btry'.")
                     if "_btry" not in app:
-                        raise KeyError("Appendix should contain key '_btry'.")
+                        raise KeyError(  # pragma: no cover
+                            "Appendix should contain key '_btry'.")
 
                 for met, app in tus:
                     met["_date"] = dt
                     dt = datetime.now() - dt
                     if not isinstance(met, dict):
-                        raise TypeError("metrics should be a dictionary")
+                        raise TypeError(  # pragma: no cover
+                            "metrics should be a dictionary")
                     if "_time" in met:
-                        raise KeyError(
+                        raise KeyError(  # pragma: no cover
                             "key _time should not be the returned metrics")
                     if "_span" in met:
-                        raise KeyError(
+                        raise KeyError(  # pragma: no cover
                             "key _span should not be the returned metrics")
                     if "_i" in met:
-                        raise KeyError(
+                        raise KeyError(  # pragma: no cover
                             "key _i should not be in the returned metrics")
                     if "_name" in met:
-                        raise KeyError(
+                        raise KeyError(  # pragma: no cover
                             "key _name should not be the returned metrics")
                     met["_time"] = cl
                     met["_span"] = dt
                     met["_i"] = i
                     met["_name"] = self.Name
                     self._metrics.append(met)
                     app["_i"] = i
@@ -368,18 +377,19 @@
                         "[BenchMark.run] {0}/{1} end {2}".format(i + 1, len(params_list), met))
 
         def graph_():
             "local function"
             self.fLOG("[BenchMark.run] graph {0} do".format(self.Name))
             self._graphs = self.graphs(self._path_to_images)
             if self._graphs is None or not isinstance(self._graphs, list):
-                raise TypeError("Method graphs does not return anything.")
+                raise TypeError(  # pragma: no cover
+                    "Method graphs does not return anything.")
             for tu in self._graphs:
                 if not isinstance(tu, self.LocalGraph):
-                    raise TypeError(
+                    raise TypeError(  # pragma: no cover
                         "Method graphs should return a list of LocalGraph.")
             self.fLOG("[BenchMark.run] graph {0} done".format(self.Name))
             self.fLOG("[BenchMark.run] Received {0} graphs.".format(
                 len(self._graphs)))
             self.fLOG("[BenchMark.run] end {0} do".format(self.Name))
             self.end()
             self.fLOG("[BenchMark.run] end {0} done".format(self.Name))
@@ -427,33 +437,36 @@
 
     @property
     def Metrics(self):
         """
         Returns the metrics.
         """
         if not hasattr(self, "_metrics"):
-            raise KeyError("Method run was not run, no metrics was found.")
+            raise KeyError(  # pragma: no cover
+                "Method run was not run, no metrics was found.")
         return self._metrics
 
     @property
     def Metadata(self):
         """
         Returns the metrics.
         """
         if not hasattr(self, "_metadata"):
-            raise KeyError("Method run was not run, no metadata was found.")
+            raise KeyError(  # pragma: no cover
+                "Method run was not run, no metadata was found.")
         return self._metadata
 
     @property
     def Appendix(self):
         """
         Returns the metrics.
         """
         if not hasattr(self, "_appendix"):
-            raise KeyError("Method run was not run, no metadata was found.")
+            raise KeyError(  # pragma: no cover
+                "Method run was not run, no metadata was found.")
         return self._appendix
 
     def to_df(self, convert=False, add_link=False, format="html"):
         """
         Converts the metrics into a dataframe.
 
         @param          convert         if True, calls method *_convert* on each cell
@@ -622,15 +635,15 @@
 
     @property
     def Graphs(self):
         """
         Returns images of graphs.
         """
         if not hasattr(self, "_graphs"):
-            raise KeyError("unable to find _graphs")
+            raise KeyError("unable to find _graphs")  # pragma: no cover
         return self._graphs
 
     default_css = """
                 .datagrid table { border-collapse: collapse; border-spacing: 0; width: 100%;
                         table-layout: fixed; font-family: Verdana; font-size: 12px;
                         word-wrap: break-word; }
```

## pyquickhelper/benchhelper/grid_benchmark.py

```diff
@@ -42,30 +42,30 @@
         """
         BenchMark.__init__(self, name=name, datasets=datasets, clog=clog,
                            fLOG=fLOG, path_to_images=path_to_images,
                            cache_file=cache_file, progressbar=progressbar,
                            **params)
 
         if not isinstance(datasets, list):
-            raise TypeError("datasets must be a list")
+            raise TypeError("datasets must be a list")  # pragma: no cover
         for i, df in enumerate(datasets):
             if not isinstance(df, dict):
-                raise TypeError(
+                raise TypeError(  # pragma: no cover
                     "Every dataset must be a dictionary, {0}th is not.".format(i))
             if "X" not in df:
-                raise KeyError(
+                raise KeyError(  # pragma: no cover
                     "Dictionary {0} should contain key 'X'.".format(i))
             if "di" in df:
-                raise KeyError(
+                raise KeyError(  # pragma: no cover
                     "Dictionary {0} should not contain key 'di'.".format(i))
             if "name" not in df:
-                raise KeyError(
+                raise KeyError(  # pragma: no cover
                     "Dictionary {0} should not contain key 'name'.".format(i))
             if "shortname" not in df:
-                raise KeyError(
+                raise KeyError(  # pragma: no cover
                     "Dictionary {0} should not contain key 'shortname'.".format(i))
         self._datasets = datasets
         self._repetition = repetition
 
     def init_main(self):
         """
         initialisation
@@ -104,24 +104,25 @@
                   len(self._datasets))
         self.fLOG("[MlGridBenchmark.bench] number of experiments",
                   len(params_list))
 
         unique = set()
         for i, pars in enumerate(params_list):
             if "name" not in pars:
-                raise KeyError(
+                raise KeyError(  # pragma: no cover
                     "Dictionary {0} must contain key 'name'.".format(i))
             if "shortname" not in pars:
-                raise KeyError(
+                raise KeyError(  # pragma: no cover
                     "Dictionary {0} must contain key 'shortname'.".format(i))
             if pars["name"] in unique:
-                raise ValueError("'{0}' is duplicated.".format(pars["name"]))
+                raise ValueError(  # pragma: no cover
+                    "'{0}' is duplicated.".format(pars["name"]))
             unique.add(pars["name"])
             if pars["shortname"] in unique:
-                raise ValueError(
+                raise ValueError(  # pragma: no cover
                     "'{0}' is duplicated.".format(pars["shortname"]))
             unique.add(pars["shortname"])
 
         # Multiplies the experiments.
         full_list = []
         for i in range(len(self._datasets)):
             for pars in params_list:
@@ -137,15 +138,16 @@
 
     def bench(self, **params):
         """
         run an experiment multiple times,
         parameter *di* is the dataset to use
         """
         if "di" not in params:
-            raise KeyError("key 'di' is missing from params")
+            raise KeyError(
+                "key 'di' is missing from params")  # pragma: no cover
         results = []
 
         for iexp in range(self._repetition):
 
             di = params["di"]
             shortname_model = params["shortname"]
             name_model = params["name"]
@@ -201,19 +203,19 @@
         """
         function to overload
 
         @param      info        dictionary with at least key ``'X'``
         @param      params      additional parameters
         @return                 output of the experiment
         """
-        raise NotImplementedError()
+        raise NotImplementedError()  # pragma: no cover
 
     def predict_score_experiment(self, info, output, **params):
         """
         function to overload
 
         @param      info        dictionary with at least key ``'X'``
         @param      output      output of the benchmar
         @param      params      additional parameters
         @return                 output of the experiment, tuple of dictionaries
         """
-        raise NotImplementedError()
+        raise NotImplementedError()  # pragma: no cover
```

## pyquickhelper/cli/cli_helper.py

```diff
@@ -291,16 +291,15 @@
     @return             module name
     """
     mod = fct.__module__
     spl = mod.split('.')
     name = spl[0]
     if name == 'src':
         return spl[1]
-    else:
-        return spl[0]
+    return spl[0]
 
 
 def cli_main_helper(dfct, args, fLOG=print):
     """
     Implements the main commmand line for a module.
 
     @param      dfct        dictionary ``{ key: fct }``
```

## pyquickhelper/cli/encryption_cli.py

```diff
@@ -65,18 +65,18 @@
     @param      encrypt     boolean, True to encrypt
     @param      crypt_file  encrypted file
     @param      crypt_map   @see cl EncryptedBackup
     @param      regex       regular expression to filter in files to retrieve
     @param      fLOG        logging function
     """
     if not os.path.exists(source):
-        raise FileNotFoundError(source)
+        raise FileNotFoundError(source)  # pragma: no cover
     try:
         from pyquickhelper.filehelper import EncryptedBackup, TransferAPIFile, FileTreeNode
-    except ImportError:
+    except ImportError:  # pragma: no cover
         folder = os.path.normpath(os.path.join(
             os.path.abspath(os.path.dirname(__file__)), "..", ".."))
         sys.path.append(folder)
         from pyquickhelper.filehelper import EncryptedBackup, TransferAPIFile, FileTreeNode
 
     if isinstance(password, str):
         password = bytes(password, encoding="ascii")
@@ -127,15 +127,15 @@
     """
     parser = get_parser(True)
     if args is not None and args == ['--help']:
         fLOG(parser.format_help())
     else:
         try:
             args = parser.parse_args(args=args)
-        except SystemExit:
+        except SystemExit:  # pragma: no cover
             if fLOG:
                 fLOG(parser.format_usage())
             args = None
 
         if args is not None:
             do_main(source=args.source, dest=args.dest, password=args.password,
                     encrypt=True, crypt_file=args.status, crypt_map=args.map, fLOG=fLOG)
@@ -159,21 +159,21 @@
     """
     parser = get_parser(False)
     if args is not None and args == ['--help']:
         fLOG(parser.format_help())
     else:
         try:
             args = parser.parse_args(args=args)
-        except SystemExit:
+        except SystemExit:  # pragma: no cover
             if fLOG:
                 fLOG(parser.format_usage())
             args = None
 
         if args is not None:
             do_main(source=args.dest, dest=args.source, password=args.password,
                     encrypt=False, crypt_file=None, crypt_map=None,
                     regex=args.regex if args.regex else None,
                     fLOG=fLOG)
 
 
 if __name__ == "__main__":
-    decrypt()
+    decrypt()  # pragma: no cover
```

## pyquickhelper/cli/encryption_file_cli.py

```diff
@@ -39,18 +39,18 @@
     @param      source      source of files to encrypt or decrypt
     @param      dest        destination
     @param      password    password
     @param      encrypt     boolean, True to encrypt
     @param      fLOG        logging function
     """
     if not os.path.exists(source):
-        raise FileNotFoundError(source)
+        raise FileNotFoundError(source)  # pragma: no cover
     try:
         from pyquickhelper.filehelper import encrypt_stream, decrypt_stream
-    except ImportError:
+    except ImportError:  # pragma: no cover
         folder = os.path.normpath(os.path.join(
             os.path.abspath(os.path.dirname(__file__)), "..", ".."))
         sys.path.append(folder)
         from pyquickhelper.filehelper import encrypt_stream, decrypt_stream
 
     if isinstance(password, str):
         password = bytes(password, encoding="ascii")
@@ -82,15 +82,15 @@
     """
     parser = get_parser(True)
     if args is not None and args == ['--help']:
         fLOG(parser.format_help())
     else:
         try:
             args = parser.parse_args()
-        except SystemExit:
+        except SystemExit:  # pragma: no cover
             if fLOG:
                 fLOG(parser.format_usage())
             args = None
 
         if args is not None:
             do_main(source=args.source, dest=args.dest,
                     password=args.password, encrypt=True,
@@ -112,20 +112,20 @@
     """
     parser = get_parser(False)
     if args is not None and args == ['--help']:
         fLOG(parser.format_help())
     else:
         try:
             args = parser.parse_args()
-        except SystemExit:
+        except SystemExit:  # pragma: no cover
             if fLOG:
                 fLOG(parser.format_usage())
             args = None
 
         if args is not None:
             do_main(source=args.source, dest=args.dest,
                     password=args.password, encrypt=False,
                     fLOG=fLOG)
 
 
 if __name__ == "__main__":
-    decrypt_file()
+    decrypt_file()  # pragma: no cover
```

## pyquickhelper/cli/ftp_cli.py

```diff
@@ -1,14 +1,13 @@
 """
 @file
 @brief Command line about transfering files.
 """
 import os
 import glob
-from ..filehelper import TransferFTP
 
 
 def ftp_upload(files, dest, host, user, pwd, ftps=False, fLOG=print):
     """
     Pushes a file to a server using :epkg:`FTP` or :epkg:`SFTP`.
 
     :param files: local files to move, comma separated or
@@ -30,14 +29,16 @@
         protocol.
 
     The user and the password can be prefix by
     `keyring,`. The module :epkg:`keyring` is then used
     to retrieve the values. Example:
     ``--user=keyring,user,site``.
     """
+    from ..filehelper import TransferFTP
+
     if isinstance(files, str):
         files = [files]
     new_files = []
     for name in files:
         if ',' in name:
             new_files.extend(name.split(','))
         else:
```

## pyquickhelper/cli/notebook.py

```diff
@@ -86,24 +86,27 @@
 
         The command line converts notebook into HTML, RST, PDF, slides...
         It calls :epkg:`nbconvert` but adds some preprocessing before calling
         it.
     """
     from ..helpgen.process_notebooks import process_notebooks
     if not os.path.exists(filename):
-        raise FileNotFoundError("Unable to find '{}'.".format(filename))
+        raise FileNotFoundError(  # pragma: no cover
+            "Unable to find '{}'.".format(filename))
     if outfold in ('.', '', None):
         outfold = os.path.abspath(os.path.dirname(filename))
     if not os.path.exists(outfold):
-        raise FileNotFoundError("Unable to find '{}'.".format(outfold))
+        raise FileNotFoundError(  # pragma: no cover
+            "Unable to find '{}'.".format(outfold))
     if build in ('.', '', None):
         build = os.path.join(outfold, "_convertnb")
         if not os.path.exists(build):
             os.mkdir(build)
     if not os.path.exists(build):
-        raise FileNotFoundError("Unable to find '{}'.".format(build))
+        raise FileNotFoundError(  # pragma: no cover
+            "Unable to find '{}'.".format(build))
     return process_notebooks(
         notebooks=filename, outfold=outfold, build=build,
         latex_path=latex_path, pandoc_path=pandoc_path,
         formats=formats, exc=exc, nblinks=nblinks,
         remove_unicode_latex=remove_unicode_latex,
         fLOG=fLOG)
```

## pyquickhelper/cli/pyq_sync_cli.py

```diff
@@ -22,20 +22,20 @@
         Synchronizes two folders from the command line.
     """
     with warnings.catch_warnings():
         warnings.simplefilter("ignore", ImportWarning)
         try:
             from pyquickhelper.filehelper.synchelper import synchronize_folder
             from pyquickhelper.cli.cli_helper import call_cli_function
-        except ImportError:
+        except ImportError:  # pragma: no cover
             folder = os.path.normpath(os.path.join(
                 os.path.abspath(os.path.dirname(__file__)), "..", ".."))
             sys.path.append(folder)
             from pyquickhelper.filehelper.synchelper import synchronize_folder
             from pyquickhelper.cli.cli_helper import call_cli_function
 
     call_cli_function(synchronize_folder, args=args, fLOG=fLOG,
                       skip_parameters=('fLOG', 'operations', 'log1'))
 
 
 if __name__ == "__main__":
-    pyq_sync()
+    pyq_sync()  # pragma: no cover
```

## pyquickhelper/cli/simplified_fct.py

```diff
@@ -103,15 +103,16 @@
     if len(input) <= 5000 and \
         (input.startswith('http') or
          os.path.exists(input)):
         content = read_content_ufs(input)
     else:
         content = input
     if directives:
-        raise NotImplementedError("Cannot specify directives yet.")
+        raise NotImplementedError(
+            "Cannot specify directives yet.")  # pragma: no cover
 
     preamble = _preamble + _custom_preamble
     epkg_dictionary = get_epkg_dictionary()
 
     ht = rst2html(content, writer=writer, keep_warnings=keep_warnings,
                   language=language, layout=layout,
                   document_name=output, imgmath_latex_preamble=preamble,
```

## pyquickhelper/helpgen/default_conf.py

```diff
@@ -718,29 +718,23 @@
                 'github_user': github_user,
                 'github_repo': github_repo,
             }
         pygments_style = 'monokai'
 
     # mapping
 
-    intersphinx_mapping = {'python': (
-        'https://docs.python.org/{0}.{1}'.format(*(sys.version_info[:2])), None)}
-    intersphinx_mapping['matplotlib'] = ('http://matplotlib.org/', None)
-    try:
-        import numpy
-        intersphinx_mapping['numpy'] = (
-            'http://www.numpy.org/{0}'.format(numpy.__version__), None)
-    except ImportError:  # pragma: no cover
-        pass
-    try:
-        import pandas
-        intersphinx_mapping['pandas'] = (
-            'http://pandas.pydata.org/pandas-docs/version/{0}'.format(pandas.__version__), None)
-    except ImportError:  # pragma: no cover
-        pass
+    intersphinx_mapping = {
+        'python': ('https://docs.python.org/{.major}'.format(
+            sys.version_info), None),
+        'numpy': ('https://docs.scipy.org/doc/numpy/', None),
+        'scipy': ('https://docs.scipy.org/doc/scipy/reference', None),
+        'matplotlib': ('https://matplotlib.org/', None),
+        'pandas': ('https://pandas.pydata.org/pandas-docs/stable/', None),
+        'joblib': ('https://joblib.readthedocs.io/en/latest/', None),
+    }
 
     # information about code
     def linkcode_resolve_function(domain, info):
         if link_resolve is None:
             return None
         if domain != 'py':
             return None
```

## pyquickhelper/helpgen/sphinxm_convert_doc_sphinx_helper.py

```diff
@@ -630,15 +630,15 @@
         newtmpl = self.app.emit_firstresult('html-page-context', pagename,
                                             templatename, ctx, event_arg)
         if newtmpl:
             templatename = newtmpl
 
         try:
             output = self.templates.render(templatename, ctx)
-        except UnicodeError:
+        except UnicodeError:  # pragma: no cover
             logger = getLogger("MockSphinxApp")
             logger.warning("[_CustomSphinx] A unicode error occurred when rendering the page %s. "
                            "Please make sure all config values that contain "
                            "non-ASCII content are Unicode strings.", pagename)
             return
 
         if not outfilename:
@@ -880,25 +880,30 @@
         if hasattr(self, "doctree_") and docname in self.doctree_:
             from sphinx.util.docutils import WarningStream
             doctree = self.doctree_[docname]
             doctree.settings.env = self
             doctree.reporter = Reporter(self.doc2path(
                 docname), 2, 5, stream=WarningStream())
             return doctree
-        else:
-            if hasattr(self, "self.doctree_"):
-                available = list(sorted(self.doctree_))
-                if len(available) > 10:
-                    available = available[10:]
-            else:
-                available = []
 
-            raise KeyError("Unable to find doctree for '{0}'\nFirst documents:\n{1}.".format(
-                docname, "\n".join(available)))
-            # return BuildEnvironment.get_doctree(self, docname)
+        if hasattr(self, "doctree_"):
+            available = list(sorted(self.doctree_))
+            if len(available) > 10:
+                available = available[10:]
+            raise KeyError(
+                "Unable to find entry '{}' (has doctree: {})\nFirst documents:\n{}"
+                "".format(
+                    docname, hasattr(self, "doctree_"),
+                    "\n".join(available)))
+
+        raise KeyError(  # pragma: no cover
+            "Doctree empty or not found for '{}' (has doctree: {})"
+            "".format(
+                docname, hasattr(self, "doctree_")))
+        # return BuildEnvironment.get_doctree(self, docname)
 
     def apply_post_transforms(self, doctree, docname):
         """Apply all post-transforms."""
         # set env.docname during applying post-transforms
         self.temp_data['docname'] = docname
 
         transformer = SphinxTransformer(doctree)
@@ -1037,28 +1042,28 @@
         # status code for command-line application
         self.statuscode = 0
 
         # delayed import to speed up time
         from sphinx.application import builtin_extensions
         try:
             from sphinx.application import CONFIG_FILENAME, Config, Tags
-            sphinx_version = 2
+            sphinx_version = 2  # pragma: no cover
         except ImportError:
             # Sphinx 3.0.0
             from sphinx.config import CONFIG_FILENAME, Config, Tags
             sphinx_version = 3
 
         # read config
         self.tags = Tags(tags)
         with warnings.catch_warnings():
             warnings.simplefilter(
                 "ignore", (DeprecationWarning, PendingDeprecationWarning))
             if self.confdir is None:
                 self.config = Config({}, confoverrides or {})
-            else:
+            else:  # pragma: no cover
                 try:
                     self.config = Config.read(
                         self.confdir, confoverrides or {}, self.tags)
                 except AttributeError:
                     try:
                         self.config = Config(  # pylint: disable=E1121
                             confdir, confoverrides or {}, self.tags)
@@ -1068,26 +1073,27 @@
                                                  confoverrides or {}, self.tags)
                         except TypeError:
                             # Sphinx==3.0.0
                             self.config = Config({}, confoverrides or {})
         self.sphinx__display_version__ = __display_version__
 
         # create the environment
-        if sphinx_version == 2:
+        if sphinx_version == 2:  # pragma: no cover
             with warnings.catch_warnings():
                 warnings.simplefilter(
                     "ignore", (DeprecationWarning, PendingDeprecationWarning, ImportWarning))
                 self.config.check_unicode()
         self.config.pre_init_values()
 
         # set up translation infrastructure
         self._init_i18n()
 
         # check the Sphinx version if requested
-        if self.config.needs_sphinx and self.config.needs_sphinx > __display_version__:
+        if (self.config.needs_sphinx and self.config.needs_sphinx >
+                __display_version__):  # pragma: no cover
             from sphinx.locale import _
             from sphinx.application import VersionRequirementError
             raise VersionRequirementError(
                 _('This project needs at least Sphinx v%s and therefore cannot '
                   'be built with this version.') % self.config.needs_sphinx)
 
         # set confdir to srcdir if -C given (!= no confdir); a few pieces
@@ -1098,15 +1104,15 @@
         # load all built-in extension modules
         for extension in builtin_extensions:
             try:
                 with warnings.catch_warnings():
                     warnings.filterwarnings(
                         "ignore", category=DeprecationWarning)
                     self.setup_extension(extension)
-            except Exception as e:
+            except Exception as e:  # pragma: no cover
                 if 'sphinx.builders.applehelp' not in str(e):  # pragma: no cover
                     mes = "Unable to run setup_extension '{0}'\nWHOLE LIST\n{1}".format(
                         extension, "\n".join(builtin_extensions))
                     raise ExtensionError(mes) from e
 
         # load all user-given extension modules
         for extension in self.config.extensions:
@@ -1147,15 +1153,15 @@
         # the config file itself can be an extension
         if self.config.setup:
             prefix = 'while setting up extension %s:' % "conf.py"
             if prefixed_warnings is not None:
                 with prefixed_warnings(prefix):
                     if callable(self.config.setup):
                         self.config.setup(self)
-                    else:
+                    else:  # pragma: no cover
                         from sphinx.locale import _
                         from sphinx.application import ConfigError
                         raise ConfigError(
                             _("'setup' as currently defined in conf.py isn't a Python callable. "
                               "Please modify its definition to make it a callable function. This is "
                               "needed for conf.py to behave as a Sphinx extension.")
                         )
@@ -1219,15 +1225,15 @@
 
     def _init_env(self, freshenv):
         if freshenv:
             self.env = _CustomBuildEnvironment(self)
             self.env.setup(self)
             if self.srcdir is not None and self.srcdir != "IMPOSSIBLE:TOFIND":
                 self.env.find_files(self.config, self.builder)
-        elif "IMPOSSIBLE:TOFIND" not in self.doctreedir:
+        elif "IMPOSSIBLE:TOFIND" not in self.doctreedir:  # pragma: no cover
             from sphinx.application import ENV_PICKLE_FILENAME
             filename = os.path.join(self.doctreedir, ENV_PICKLE_FILENAME)
             try:
                 self.info('loading pickled environment... ', nonl=True)
                 with open(filename, 'rb') as f:
                     self.env = pickle.load(f)
                     self.env.setup(self)
@@ -1236,22 +1242,24 @@
                 self.info('failed: %s' % err)
                 self._init_env(freshenv=True)
         elif self.env is None:
             self.env = _CustomBuildEnvironment(self)
             if hasattr(self.env, 'setup'):
                 self.env.setup(self)
         if not hasattr(self.env, 'project') or self.env.project is None:
-            raise AttributeError("self.env.project is not initialized.")
+            raise AttributeError(  # pragma: no cover
+                "self.env.project is not initialized.")
 
     def create_builder(self, name):
         """
         Creates a builder, raises an exception if name is None.
         """
         if name is None:
-            raise ValueError("Builder name cannot be None")
+            raise ValueError(  # pragma: no cover
+                "Builder name cannot be None")
 
         return self.registry.create_builder(self, name)
 
     def _extended_init_(self):
         """
         Additional initialization steps.
         """
@@ -1273,15 +1281,15 @@
             if ('section' not in stype and 'title' not in stype and
                     'reference' not in stype):
                 continue
             try:
                 node['ids'][0]
             except IndexError:
                 node['ids'] = ['missing%d' % i]
-            except TypeError:
+            except TypeError:  # pragma: no cover
                 pass
 
     def finalize(self, doctree, external_docnames=None):
         """
         Finalizes the documentation after it was parsed.
 
         @param      doctree             doctree (or pub.document), available after publication
@@ -1291,16 +1299,17 @@
         for img in imgs:
             img['save_uri'] = img['uri']
 
         if not isinstance(self.env, _CustomBuildEnvironment):
             raise TypeError(  # pragma: no cover
                 "self.env is not _CustomBuildEnvironment: '{0}'".format(type(self.env)))
         if not isinstance(self.builder.env, _CustomBuildEnvironment):
-            raise TypeError("self.builder.env is not _CustomBuildEnvironment: '{0}'".format(
-                type(self.builder.env)))
+            raise TypeError(  # pragma: no cover
+                "self.builder.env is not _CustomBuildEnvironment: '{0}'".format(
+                    type(self.builder.env)))
         self.doctree_ = doctree
         self.builder.doctree_ = doctree
         self.env.doctree_[self.config.master_doc] = doctree
         self.env.all_docs = {self.config.master_doc: self.config.master_doc}
 
         if external_docnames:
             for doc in external_docnames:
@@ -1379,15 +1388,15 @@
                 logger.info(
                     '[MockSphinxApp] PlotDirective: {}'.format(self.content))
                 try:
                     res = old_run(self)
                     logger.info(
                         '[MockSphinxApp] PlotDirective ok')
                     return res
-                except OSError as e:
+                except OSError as e:  # pragma: no cover
                     logger = getLogger("MockSphinxApp")
                     logger.info(
                         '[MockSphinxApp] PlotDirective failed: {}'.format(e))
                 return []
 
             obj.run = run
 
@@ -1449,15 +1458,15 @@
     def add_node(self, node, override=True, **kwds):
         self._added_objects.append(('node', node))
         self.debug('[_CustomSphinx]  adding node: %r', (node, kwds))
         nodes._add_node_class_names([node.__name__])
         for key, val in kwds.items():
             try:
                 visit, depart = val
-            except ValueError:
+            except ValueError:  # pragma: no cover
                 raise ExtensionError(("Value for key '%r' must be a "
                                       "(visit, depart) function tuple") % key)
             translator = self.registry.translators.get(key)
             translators = []
             if translator is not None:
                 translators.append(translator)
             elif key == 'html':
@@ -1496,15 +1505,15 @@
     def add_directive_to_domain(self, domain, name, obj, has_content=None,  # pylint: disable=W0221
                                 argument_spec=None, override=False, **option_spec):
         self._added_objects.append(('directive_to_domain', domain, name))
         try:
             Sphinx.add_directive_to_domain(self, domain, name, obj,  # pylint: disable=E1123
                                            has_content=has_content, argument_spec=argument_spec,
                                            override=override, **option_spec)
-        except TypeError:
+        except TypeError:  # pragma: no cover
             # Sphinx==3.0.0
             Sphinx.add_directive_to_domain(self, domain, name, obj,
                                            override=override, **option_spec)
 
     def add_role_to_domain(self, domain, name, role, override=False):
         self._added_objects.append(('roles_to_domain', domain, name))
         Sphinx.add_role_to_domain(self, domain, name, role, override=override)
@@ -1531,17 +1540,19 @@
         try:
             # Sphinx >= 1.8
             Sphinx.add_css_file(self, filename, **kwargs)
         except AttributeError:  # pragma: no cover
             # Sphinx < 1.8
             Sphinx.add_stylesheet(self, filename, **kwargs)
 
-    def add_latex_package(self, packagename, options=None):
+    def add_latex_package(self, packagename, options=None, after_hyperref=False):
         self._added_objects.append(('latex', packagename))
-        Sphinx.add_latex_package(self, packagename)
+        Sphinx.add_latex_package(
+            self, packagename=packagename, options=options,
+            after_hyperref=after_hyperref)
 
     def add_object_type(self, directivename, rolename, indextemplate='',
                         parse_node=None, ref_nodeclass=None, objname='',
                         doc_field_types=None, override=False):
         if doc_field_types is None:
             doc_field_types = []
         self._added_objects.append(('object', directivename, rolename))
@@ -1574,13 +1585,16 @@
             if clname == co.__class__.__name__:
                 found = co
                 foundi = i
                 break
         if found is not None and not exc:
             return None
         if found is None:
-            raise ValueError("Unable to find a collector '{0}' in \n{1}".format(
-                clname, "\n".join(map(lambda x: x.__class__.__name__, self._added_collectors))))
+            raise ValueError(  # pragma: no cover
+                "Unable to find a collector '{0}' in \n{1}".format(
+                    clname, "\n".join(
+                        map(lambda x: x.__class__.__name__,
+                            self._added_collectors))))
         for v in found.listener_ids.values():
             self.disconnect(v)
         del self._added_collectors[foundi]
         return found
```

## pyquickhelper/imghelper/img_export.py

```diff
@@ -27,25 +27,25 @@
 
     if isinstance(images, str):
         if ',' in images:
             images = images.split(',')
         else:
             images = [images]
     elif not isinstance(images, list):
-        raise TypeError("Images must be a list.")
+        raise TypeError("Images must be a list.")  # pragma: no cover
 
     all_images = []
     for img in images:
         if "*" in img:
             names = glob.glob(img)
             all_images.extend(names)
         else:
             all_images.append(img)
 
-    if fLOG is not None:
+    if fLOG is not None:  # pragma: no cover
         for i, img in enumerate(all_images):
             fLOG("[images2pdf] {}/{} '{}'".format(i + 1, len(all_images), img))
 
     if isinstance(output, str):
         st = open(output, 'wb')
         close = True
     else:
```

## pyquickhelper/imghelper/img_helper.py

```diff
@@ -30,23 +30,23 @@
                     i = zoom_img(im, factor=factor, max_dim=max_dim, fLOG=fLOG)
                 else:
                     of = out_file.format(os.path.split(im)[-1])
                     i = zoom_img(im, factor=factor, max_dim=max_dim,
                                  out_file=of, fLOG=fLOG)
                 res.append(i)
             if len(res) == 0:
-                raise FileNotFoundError(
+                raise FileNotFoundError(  # pragma: no cover
                     "Unable to find anything in '{}'.".format(img))
             return res
         from PIL import Image
         obj = Image.open(img)
     elif hasattr(obj, 'size'):
         obj = img
     else:
-        raise TypeError(
+        raise TypeError(  # pragma: no cover
             "Image should be a string or an image not {}.".format(type(img)))
     dx, dy = obj.size
     if max_dim is not None:
         if not isinstance(max_dim, int):
             max_dim = int(max_dim)
         facx = max_dim * 1. / max(dx, 1)
         facy = max_dim * 1. / max(dy, 1)
```

## pyquickhelper/imghelper/js_helper.py

```diff
@@ -80,25 +80,27 @@
         cmds = ['npm install ' + ' '.join(module_list)]
         errs = []
         for cmd in cmds:
             fLOG("[install_node_js_modules] run ", cmd)
             err = run_cmd(cmd, wait=True, change_path=dir_name, fLOG=fLOG)[1]
             errs.append(err)
     if not os.path.exists(node_modules):
-        raise Exception("Unable to run from '{0}' commands line:\n{1}\n--due to--\n{2}".format(
-                        dir_name, "\n".join(cmds), "\n".join(errs)))
+        raise RuntimeError(  # pragma: no cover
+            "Unable to run from '{0}' commands line:\n{1}\n--due to--\n{2}".format(
+                dir_name, "\n".join(cmds), "\n".join(errs)))
 
 
 def nodejs_version():
     """
     Returns :epkg:`node.js` version.
     """
     out, err = run_cmd('node -v', wait=True)
     if len(err) > 0:
-        raise NodeJsException("Unable to find node\n{0}".format(err))
+        raise NodeJsException(  # pragma: no cover
+            "Unable to find node\n{0}".format(err))
     return out
 
 
 def run_js_with_nodejs(script, path_dependencies=None, fLOG=noLOG):
     """
     Runs a :epkg:`javascript` script with :epkg:`node.js`.
 
@@ -108,21 +110,22 @@
     @return                         output of the script
     """
     script_clean = script.replace("\"", "\\\"").replace("\n", " ")
     cmd = 'node -e "{0}"'.format(script_clean)
     out, err = run_cmd(cmd, change_path=path_dependencies,
                        fLOG=fLOG, wait=True)
     if len(err) > 0:
-        filtered = "\n".join(_ for _ in err.split(
-            '\n') if not _.startswith("[BABEL] Note:"))
+        filtered = "\n".join(_ for _ in err.split('\n')
+                             if not _.startswith("[BABEL] Note:"))
     else:
         filtered = err
     if len(filtered) > 0:
-        raise NodeJsException(
-            "Execution of node.js failed.\n--CMD--\n{0}\n--ERR--\n{1}\n--OUT--\n{2}\n--SCRIPT--\n{3}".format(cmd, err, out, script))
+        raise NodeJsException(  # pragma: no cover
+            "Execution of node.js failed.\n--CMD--\n{0}\n--ERR--\n{1}\n--OUT--\n{2}\n"
+            "--SCRIPT--\n{3}".format(cmd, err, out, script))
     return out
 
 
 _require_cache = {}
 
 
 def require(module_name, cache_folder='.', suffix='_pyq', update=False, fLOG=noLOG):
@@ -136,15 +139,16 @@
     @param      update          update the converted script
     @param      fLOG            logging function
     @return                     outcome of the javascript script
 
     The function is not fully tested.
     """
     if module_name.endswith('.js'):
-        raise ValueError("module_name must the name without extension .js")
+        raise ValueError(  # pragma: no cover
+            "module_name must the name without extension .js")
     global _require_cache
     if module_name in _require_cache and not update:
         py_code = _require_cache[module_name]
     else:
         from js2py.node_import import ADD_TO_GLOBALS_FUNC, GET_FROM_GLOBALS_FUNC
         from js2py import translate_js
```

## pyquickhelper/imghelper/svg_helper.py

```diff
@@ -1,20 +1,15 @@
 """
 @file
 @brief Helpers around images and :epkg:`SVG`.
 
 .. versionadded:: 1.7
 """
 import xml.etree.ElementTree as ET
-try:
-    from io import BytesIO
-except ImportError:
-    # Python 2.7
-    from StringIO import StringIO as BytesIO
-
+from io import BytesIO
 from .excs import PYQImageException
 
 
 def guess_svg_size(svg):
     """
     Guesses the dimension of a :epkg:`SVG` image.
 
@@ -63,13 +58,13 @@
     except OSError as e:
         if svg.startswith('<svg>'):
             size = guess_svg_size(svg)
             head = '<svg width="{}" height="{}">'.format(*size)
             svg = head + svg[5:]
             return svg2img(svg, dpi=dpi, scale=scale, **kwargs)
         else:
-            raise PYQImageException(
+            raise PYQImageException(  # pragma: no cover
                 "width and height must be specified. This might be the error.") from e
     png = img.getvalue()
     st = BytesIO(png)
     from PIL import Image
     return Image.open(st)
```

## pyquickhelper/loghelper/flog.py

```diff
@@ -84,15 +84,15 @@
     flog_static.store_log_values["__log_file_name"] = filename
 
     if create:
         if not os.path.exists(flog_static.store_log_values["__log_path"]):
             os.makedirs(flog_static.store_log_values["__log_path"])
     else:
         if not os.path.exists(flog_static.store_log_values["__log_path"]):
-            raise PQHException(
+            raise PQHException(  # pragma: no cover
                 "unable to find path " + flog_static.store_log_values["__log_path"])
 
 
 def GetSepLine():
     """
     return always ``\\n``
     """
@@ -267,15 +267,15 @@
                 return s
             if isinstance(s, bytes):
                 return s.decode("utf8")
             try:
                 if upp:
                     return pprint.pformat(s)
                 return typstr(s)
-            except Exception as e:
+            except Exception as e:  # pragma: no cover
                 raise Exception(  # pragma: no cover
                     "unable to convert s into string: type(s)=" + str(type(s))) from e
 
         message = str(dt).split(
             ".")[0] + " " + " ".join([_str_process(s) for s in args]) + sep
         st = "                    "
     else:
@@ -292,15 +292,15 @@
     return sep.join(messages)
 
 
 def _this_fLOG(*args, **kwargs):
     """
     Other name private to this module.
     """
-    fLOG(*args, **kwargs)
+    fLOG(*args, **kwargs)  # pragma: no cover
 
 
 def get_relative_path(folder, file, exists=True, absolute=True):
     """
     private function, return the relative path or absolute between a folder and a file,
     use `relpath <https://docs.python.org/3/library/os.path.html#os.path.relpath>`_
 
@@ -309,17 +309,17 @@
     @param      exists      check existence
     @param      absolute    if True return a path which starts from the root
     @return                 relative path
     @rtype                  str
     """
     if exists:
         if not os.path.exists(folder):
-            raise PQHException(folder + " does not exist.")
+            raise PQHException(folder + " does not exist.")  # pragma: no cover
         if not os.path.exists(file):
-            raise PQHException(file + " does not exist.")
+            raise PQHException(file + " does not exist.")  # pragma: no cover
     sd = os.path.normpath(folder).replace("\\", "/").split("/")
     sf = os.path.normpath(file).replace("\\", "/").split("/")
     i = 0
     while i < len(sd):
         if i >= len(sf):
             break
         if sf[i] != sd[i]:
@@ -674,15 +674,15 @@
         if os.path.exists(dest) and not os.path.exists(nyet):
             try:
                 fLOG("[loghelper.flog] trying to connect", url)
                 f1 = urllib_request.urlopen(url)
                 down = _first_more_recent(f1, dest)
                 newdate = down
                 f1.close()
-            except IOError:
+            except IOError:  # pragma: no cover
                 fLOG(
                     "unable to connect Internet, working offline for url", url)
                 down = False
         else:
             down = True
             newdate = False
 
@@ -796,15 +796,15 @@
     the command line
     """
     if use_command_line:
         if sys.platform.startswith("win"):  # pragma: no cover
             out, err = run_cmd("rmdir /s /q " + folder, wait=True)
         else:
             out, err = run_cmd("rm -Rf " + folder, wait=True)
-        if len(err) > 0:
+        if len(err) > 0:  # pragma: no cover
             raise Exception("Unable to remove '{0}'\n{1}".format(folder, err))
         return out
     else:
         file, rep = [], []
         for r, d, f in os.walk(folder):
             for a in d:
                 rep.append(os.path.join(r, a))
@@ -921,15 +921,16 @@
     @return                 type, length (order of preference (int, float, str))
                             the parameter length has a meaning only for str result
     """
     defa = None if none else str
     length = 0
     typstr = str
     if args in [typstr, float, int, None, decimal.Decimal]:
-        raise PQHException("this case is unexpected %s" % typstr(args))
+        raise PQHException("this case is unexpected %s" %
+                           typstr(args))  # pragma: no cover
 
     if len(args) == 0:
         res = defa
 
     elif len(args) == 1:
         res = guess_type_value(args[0], none)
         if res == typstr:
@@ -965,18 +966,18 @@
             olength = length
 
     return res, olength
 
 
 def guess_machine_parameter():
     """
-    determine many parameters on this machine
-        - machine name
-        - user name
-        - domain...
+    Determines many parameters on this machine:
+    - machine name
+    - user name
+    - domain...
     @return         dictionary { name : value }
     """
     val = ["COMPUTERNAME", "NUMBER_OF_PROCESSORS", "OS",
            "PATH", "USERDOMAIN", "USERNAME", "USERPROFILE",
            "windir", "TEMP", "USER"]
     res = {}
     sep = ";" if sys.platform.startswith("win") else ":"
@@ -993,15 +994,15 @@
             res["TEMP"] = "/tmp"
 
     return res
 
 
 def IsEmptyString(s):
     """
-    empty string or not?
+    Empty string or not?
 
     :param s: any string (str, None)
     :return: is it empty or not?
     :rtype: bool
     :raises PQHException: when a type is unexpected
     """
     if s is None:
@@ -1010,20 +1011,20 @@
         return len(s) == 0
     raise PQHException(  # pragma: no cover
         "the type is unexpected {0}".format(type(s)))
 
 
 def load_content_file_with_encoding(filename):
     """
-    try different encoding to load a file, tries utf8, latin1 and None
+    Tries different encoding to load a file, tries utf8, latin1 and None.
     @param      filename    filename
     @return                 couple  (content, encoding)
     """
     error = None
     for enc in ["utf8", "latin1", None]:
         try:
             with open(filename, "r", encoding=enc) as f:
                 content = f.read()
             return content, enc
         except Exception as e:  # pragma: no cover
             error = e
-    raise error
+    raise error  # pragma: no cover
```

## pyquickhelper/pandashelper/tblformat.py

```diff
@@ -132,15 +132,15 @@
         gdf = df.groupby(split_row)
         rows = []
         for key, g in gdf:
             key = str(key).strip('()')
             if ':ref:' in key:
                 try:
                     key = key.split("`")[1].split("<")[0].strip()
-                except IndexError:
+                except IndexError:  # pragma: no cover
                     pass
             if label_pattern is not None:
                 lab = label_pattern.format(section=key.replace(".", "D"))
                 rows.append("")
                 rows.append(lab)
             rows.append("")
             rows.append(key)
@@ -221,42 +221,40 @@
     if index:
         df = df.reset_index(drop=False).copy()
         ind = df.columns[0]
 
         def boldify(x):
             try:
                 return "**{0}**".format(x)
-            except Exception as e:
+            except Exception as e:  # pragma: no cover
                 raise Exception(
                     "Unable to boldify type {0}".format(type(x))) from e
 
         try:
             values = df[ind].apply(boldify)
-        except Exception:
+        except Exception:  # pragma: no cover
             warnings.warn("Unable to boldify the index (1).", SyntaxWarning)
 
         try:
             df[ind] = values
-        except Exception:
+        except Exception:  # pragma: no cover
             warnings.warn("Unable to boldify the index (2).", SyntaxWarning)
 
     def align_string(s, align, length):
         if len(s) < length:
             if align == "l":
                 return s + " " * (length - len(s))
-            elif align == "r":
+            if align == "r":
                 return " " * (length - len(s)) + s
-            elif align == "c":
+            if align == "c":
                 m = (length - len(s)) // 2
                 return " " * m + s + " " * (length - m - len(s))
-            else:
-                raise ValueError(
-                    "align should be 'l', 'r', 'c' not '{0}'".format(align))
-        else:
-            return s
+            raise ValueError(  # pragma: no cover
+                "align should be 'l', 'r', 'c' not '{0}'".format(align))
+        return s
 
     def complete(cool):
         if list_table:
             i, s = cool
             if s is None:
                 s = ""
             if isinstance(s, float) and numpy.isnan(s):
@@ -307,29 +305,30 @@
         length = [(len(_) if isinstance(_, typstr) else 5) for _ in df.columns]
         for row in df.values:
             for i, v in enumerate(row):
                 length[i] = max(length[i], len(typstr(v).strip()))
         if column_size is not None:
             if isinstance(column_size, list):
                 if len(length) != len(column_size):
-                    raise ValueError("length and column_size should have the same size {0} != {1}".format(
-                        len(length), len(column_size)))
+                    raise ValueError(  # pragma: no cover
+                        "length and column_size should have the same size {0} != {1}".format(
+                            len(length), len(column_size)))
                 for i in range(len(length)):
                     if not isinstance(column_size[i], int):
-                        raise TypeError(
+                        raise TypeError(  # pragma: no cover
                             "column_size[{0}] is not an integer".format(i))
                     length[i] *= column_size[i]
             elif isinstance(column_size, dict):
                 for i, c in enumerate(df.columns):
                     if c in column_size:
                         length[i] = column_size[c]
                     elif i in column_size:
                         length[i] = column_size[i]
             else:
-                raise TypeError(
+                raise TypeError(  # pragma: no cover
                     "column_size must be a list or a dictionary not {}".format(
                         type(column_size)))
 
         ic = 2
         length = [_ + ic for _ in length]
         line = ["-" * lc for lc in length]
         lineb = ["=" * lc for lc in length]
@@ -373,17 +372,16 @@
     septd = "</td><td%s>" % cltd
     strtd = "<tr%s><td%s>" % (cltr, cltd)
 
     typstr = str
 
     def conv(s):
         if s is None:
-            return ""
-        else:
-            return typstr(s)
+            return ""  # pragma: no cover
+        return typstr(s)
 
     for row in self.values:
         s = septd.join(conv(_) for _ in row)
         rows.append(strtd + s + "</td></tr>")
     rows.append("</table>")
     rows.append("")
     return "\n".join(rows)
```

## pyquickhelper/pandashelper/tblfunction.py

```diff
@@ -34,10 +34,9 @@
     @raise      TypeError   if ``s`` is not a ``float``
 
     The function imports :epkg:`numpy` (delayed import).
     """
     if isinstance(s, float):
         import numpy
         return numpy.isnan(s)
-    else:
-        raise TypeError(
-            "wrong type before calling numpy.isnan: {0}".format(type(s)))
+    raise TypeError(  # pragma: no cover
+        "wrong type before calling numpy.isnan: {0}".format(type(s)))
```

## pyquickhelper/pycode/_pylint_common.py

```diff
@@ -62,14 +62,15 @@
                      "Unused import sphinx.builders.latex.transforms",
                      "Unable to import 'pyquickhelper.helpgen.sphinxm_mock_app'",
                      "No name 'sphinxm_mock_app' in module 'pyquickhelper.helpgen'",
                      "W0641: Possibly unused variable",
                      "[E731] do not assign a lambda expression, use a def",
                      "cli_helper.py:196",
                      "magic_parser.py:154: C0123: Using type() instead of isinstance()",
+                     "sphinxm_convert_doc_sphinx_helper.py:1595: [E128]",
                      ])
 
 
 def _private_test_style_test(fLOG, run_lint, verbose=False, pattern=".*[.]py$"):
     thi = os.path.abspath(os.path.dirname(__file__))
     test_ = os.path.normpath(os.path.join(thi, "..", "..", '..', '_unittests'))
     check_pep8(test_, fLOG=fLOG, neg_pattern="((temp[0-9]?_.*)|(.*((_venv)|(sphinxdoc)|([.]git)|(__pycache__)).*))",
```

## pyquickhelper/pycode/pytest_helper.py

```diff
@@ -40,14 +40,30 @@
     Runs test functions from *module*.
 
     :param module: module (string or module)
     :param pattern: function pattern
     :param stop_first: stops at the first error or run all of them
     :param verbose: prints out the name of the functions
     :param fLOG: logging function
+
+    The following piece of code could also be used to
+    run all tests not using any parameter.
+
+    ::
+
+        fcts = [v for k, v in locals().items() if k.startswith('test_')]
+        for fct in fcts:
+            print("run", fct.__name__)
+            try:
+                fct()
+            except Exception as e:
+                if 'missing' in str(e):
+                    print(e)
+                    continue
+                raise e
     """
     if isinstance(module, str):
         module_path = module
         module = os.path.splitext(module)[0]
         _, module_name = os.path.split(os.path.splitext(module)[0])
         with warnings.catch_warnings(record=False):
             spec = importlib.util.spec_from_file_location(
```

## pyquickhelper/pycode/setup_helper.py

```diff
@@ -26,16 +26,15 @@
     return commands
 
 
 def get_available_build_commands():
     """
     Returns commands which build the package.
     """
-    return {"bdist_msi", "sdist",
-            "bdist_wheel", "publish", "publish_doc", "register",
+    return {"sdist", "bdist_wheel", "publish", "publish_doc", "register",
             "upload_docs", "bdist_wininst", "build_ext"}
 
 
 def available_commands_list(argv):
     """
     Checks that on command handled by pyquickhelper is part of the arguments.
 
@@ -160,18 +159,18 @@
     Parameter *covtoken* was added to post the coverage report to :epkg:`codecov`.
     Option ``-e`` and ``-g`` were added to
     filter file by regular expressions (in with *e*, out with *g*).
 
     .. versionchanged:: 1.8
         Parameters *coverage_root*, *direct_call* were added.
     """
-    if fLOG is None:
+    if fLOG is None:  # pragma: no cover
         from ..loghelper.flog import noLOG
         fLOG = noLOG
-    if skip_function is None:
+    if skip_function is None:  # pragma: no cover
         from .utils_tests_private import default_skip_function
         skip_function = default_skip_function
     if pattern_copy is None:
         # delayed import
         from .default_regular_expression import _setup_pattern_copy
         pattern_copy = _setup_pattern_copy
 
@@ -209,24 +208,24 @@
             f = argv[lf + 1]
         else:
             f = None
 
         if "-e" in argv:
             le = argv.index("-e")
             if le >= len(argv) - 1:
-                raise ValueError(
+                raise ValueError(  # pragma: no cover
                     "Option -e should be follow by a regular expression.")
             e = re.compile(argv[le + 1])
         else:
             e = None
 
         if "-g" in argv:
             lg = argv.index("-g")
             if lg >= len(argv) - 1:
-                raise ValueError(
+                raise ValueError(  # pragma: no cover
                     "Option -g should be follow by a regular expression.")
             g = re.compile(argv[lg + 1])
         else:
             g = None
 
         if f is None and d is None and e is None and g is None:
             return skip_function
@@ -260,15 +259,15 @@
         file_or_folder) else os.path.dirname(file_or_folder)
     unit_test_folder = os.path.join(folder, "_unittests")
     fLOG("unittest_modules={0}".format(unittest_modules))
 
     if unittest_modules is None:
         unittest_modules_py3to2 = None
         unittest_modules_script = None
-    else:
+    else:  # pragma: no cover
         unittest_modules_py3to2 = []
         unittest_modules_script = []
         for mod in unittest_modules:
             if isinstance(mod, tuple):
                 unittest_modules_py3to2.append(mod[0])
                 unittest_modules_script.append(mod[1])
             else:
@@ -285,15 +284,15 @@
         else:
             sub = os.path.split(full_path)[0]
             sub = os.path.split(sub)[0]
             return sub
 
     # starts interpreting the commands
 
-    if "clean_space" in argv:
+    if "clean_space" in argv:  # pragma: no cover
         rem = clean_space_for_setup(
             file_or_folder, file_filter=file_filter_pep8)
         print("[clean_space] number of impacted files (pep8 + rst):", len(rem))
         rem = clean_notebooks_for_numbers(file_or_folder)
         print("[clean_space] number of impacted notebooks:", len(rem))
         return True
 
@@ -315,15 +314,15 @@
                              verbose=verbose, pylint_ignore=ignores)
         print("[run_pylint] run_pylint for unittest")
         run_pylint_for_setup(os.path.join(folder, "_unittests"),
                              fLOG=print, pattern=pattern, verbose=verbose,
                              pylint_ignore=ignores)
         return True
 
-    elif 'history' in argv:
+    elif 'history' in argv:  # pragma: no cover
         dest = ' '.join(argv).split('history')[-1].strip()
         if not dest:
             dest = os.path.join(folder, 'HISTORY.rst')
         if existing_history is None:
             hfold = get_folder(file_or_folder)
             histo = os.path.join(hfold, 'HISTORY.rst')
             if os.path.exists(histo):
@@ -352,15 +351,15 @@
         if setup_params is None:
             setup_params = {}
         out, err = call_setup_hook(folder,
                                    project_var_name if module_name is None else module_name,
                                    fLOG=fLOG,
                                    **setup_params)
         if len(err) > 0 and err != "no _setup_hook":
-            raise Exception(
+            raise Exception(  # pragma: no cover
                 "unable to run _setup_hook\nOUT:\n{0}\n[setuperror]\n{1}".format(out, err))
 
         if func_sphinx_begin is not None:
             func_sphinx_begin(argv=argv, file_or_folder=file_or_folder, project_var_name=project_var_name,
                               module_name=module_name, unittest_modules=unittest_modules, pattern_copy=pattern_copy,
                               requirements=requirements, port=port, blog_list=blog_list, default_engine_paths=default_engine_paths,
                               extra_ext=extra_ext, add_htmlhelp=add_htmlhelp, setup_params=setup_params, coverage_options=coverage_options,
@@ -515,25 +514,25 @@
         root = os.path.abspath(os.path.dirname(file_or_folder))
         root = os.path.normpath(root)
         dest = os.path.join(root, "dist_module27")
         py3to2_convert_tree(
             root, dest, unittest_modules=unittest_modules_py3to2, pattern_copy=pattern_copy)
         return True
 
-    elif "test_local_pypi" in argv:
+    elif "test_local_pypi" in argv:  # pragma: no cover
         # delayed import
         from ..filehelper import get_url_content_timeout
         url = "http://localhost:{0}/".format(port)
         content = get_url_content_timeout(url, timeout=5)
         if content is None or len(content) == 0:
             raise Exception("test failed for url: " + url)
         print(content)
         return True
 
-    elif 'local_jenkins' in argv:
+    elif 'local_jenkins' in argv:  # pragma: no cover
         pos = argv.index("local_jenkins")
         user = argv[pos + 1]
         password = argv[pos + 2]
         if len(argv) > pos + 3:
             location = argv[pos + 3]
         else:
             if sys.platform.startswith("win"):  # pragma: no cover
@@ -604,15 +603,16 @@
     try:
         version = src.version(ffolder)
     except Exception as e:  # pragma: no cover
         if exc:
             raise e
         return None
     if version in ["0", 0, None]:
-        raise Exception("issue with version {0}".format(version))
+        raise Exception(  # pragma: no cover
+            "issue with version {0}".format(version))
 
     # write version number
     if version is not None:
         with open(os.path.join(ffolder, "version.txt"), "w") as f:
             f.write(str(version) + "\n")
 
     modifies_init_file(ffolder, version, module_name=module_name)
@@ -692,18 +692,18 @@
     @param      fLOG                logging function
 
     The function outputs some information through function @see fn fLOG.
 
     A page will be added for each extra file extension mentioned in *extra_ext* if
     some of these were found.
     """
-    if fLOG is None:
+    if fLOG is None:  # pragma: no cover
         from ..loghelper.flog import noLOG
         fLOG = noLOG
-    if "--help" in argv:
+    if "--help" in argv:  # pragma: no cover
         from ..helpgen.help_usage import get_help_usage
         print(get_help_usage())
     else:
         from ..helpgen.sphinx_main import generate_help_sphinx
 
         if layout is None:
             layout = ["html", "pdf"]
@@ -772,21 +772,22 @@
     """
     # delayed import
     from .tkinter_helper import fix_tkinter_issues_virtualenv
     from .utils_tests import main_wrapper_tests
     ffolder = get_folder(file_or_folder)
     funit = os.path.join(ffolder, "_unittests")
     if not os.path.exists(funit):
-        raise FileNotFoundError(
-            "You must get the whole source to run the unittests,\nfolder {0} should exist".format(funit))
+        raise FileNotFoundError(  # pragma: no cover
+            "You must get the whole source to run the unittests,"
+            "\nfolder {0} should exist".format(funit))
 
-    if skip_function is None:
+    if skip_function is None:  # pragma: no cover
         from .utils_tests_private import default_skip_function
         skip_function = default_skip_function
-    if fLOG is None:
+    if fLOG is None:  # pragma: no cover
         from ..loghelper.flog import noLOG
         fLOG = noLOG
 
     fix_tkinter_issues_virtualenv(fLOG=fLOG)
 
     cov = True
     if coverage_options:
@@ -842,27 +843,27 @@
 
     def filter(name):
         if os.path.splitext(name)[-1] != ".py":
             return False
         if "temp_" in name:
             return False
         if "temp2_" in name:
-            return False
+            return False  # pragma: no cover
         for a in avoid:
             if name.startswith(a + "\\"):
-                return False
+                return False  # pragma: no cover
             if name.startswith(a + "/"):
                 return False
         return True
 
     root = get_folder(file_or_folder)
     root = os.path.normpath(root)
     name = os.path.split(root)[-1]
     if location is None:
-        dest = os.path.join(root, "ptvs_project.pyproj")
+        dest = os.path.join(root, "ptvs_project.pyproj")  # pragma: no cover
     else:
         dest = os.path.join(location, "ptvs_project.pyproj")
     all_files = [os.path.relpath(_, root)
                  for _ in explore_folder_iterfile(root)]
     all_files = [_ for _ in all_files if filter(_)]
     pyproj = get_pyproj_project(name, all_files)
     with open(dest, "w", encoding="utf8") as f:
@@ -1015,15 +1016,15 @@
     @param      argv        argument on the command line
     @return                 location of the dump
 
     The result is None for remote continuous integration.
     """
     from . import is_travis_or_appveyor
     if is_travis_or_appveyor():
-        return None
+        return None  # pragma: no cover
     hash = hash_list(argv)
     setup = os.path.join(location, "setup.py")
     if not os.path.exists(setup):
         raise FileNotFoundError(setup)  # pragma: no cover
     fold = os.path.join(location, "..", "_coverage_dumps")
     if not os.path.exists(fold):
         os.mkdir(fold)
@@ -1046,16 +1047,15 @@
     """
     st = "--".join(map(str, argv))
     hash = hashlib.md5()
     hash.update(st.encode("utf-8"))
     res = hash.hexdigest()
     if len(res) > 8:
         return res[:8]
-    else:
-        return res
+    return res  # pragma: no cover
 
 
 def build_history_from_setup(dest, owner, module, existing_history=None,
                              skip_issues=None, fLOG=None):
     """
     Builds the history from :epkg:`github` and :epkg:`pypi`.
 
@@ -1068,15 +1068,15 @@
     @param      fLOG                logging function
     @return                         history
     """
     # delayed import
     from ..loghelper.history_helper import build_history, compile_history
     if owner is None:
         raise ValueError("owner must be specified")
-    if fLOG is None:
+    if fLOG is None:  # pragma: no cover
         from ..loghelper.flog import noLOG
         fLOG = noLOG
     repo = module
     hist = build_history(owner, repo, unpublished=True,
                          existing_history=existing_history,
                          skip_issues=skip_issues, fLOG=fLOG)
     output = compile_history(hist)
@@ -1096,15 +1096,15 @@
     @param      neg_pattern     negative pattern
     @parm       pylint_ignore   ignore these :epkg:`pylint` warnings or errors
     @param      verbose         verbose
     @param      fLOG            logging function
     """
     # delayed import
     from .utils_tests_helper import check_pep8
-    if fLOG is None:
+    if fLOG is None:  # pragma: no cover
         from ..loghelper.flog import noLOG
         fLOG = noLOG
     check_pep8(folder, pattern=pattern, neg_pattern=neg_pattern,
                pylint_ignore=pylint_ignore, verbose=verbose, fLOG=fLOG)
 
 
 def modifies_init_file(folder, version, module_name=None):
@@ -1119,48 +1119,48 @@
         vs = v.split('.')
         if len(vs) <= 2:
             return '.'.join(list(vs) + [nv])
         if len(vs) >= 3:
             vs = list(vs)
             vs[-1] = nv
             return '.'.join(vs)
-        raise ValueError(
+        raise ValueError(  # pragma: no cover
             "Unable to process '{}' with new version '{}'.".format(v, nv))
 
     filename = None
     if os.path.exists(folder):
         if os.path.isdir(folder):
             src = os.path.join(folder, 'src')
             if module_name is None:
                 setu = os.path.join(folder, 'setup.py')
                 if not os.path.exists(setu):
-                    raise FileNotFoundError(
+                    raise FileNotFoundError(  # pragma: no cover
                         "Unable to find 'setup.py' in '{}' and module_name is "
                         "None.".format(folder))
                 reg = re.compile(
                     "(project_var_name = ['\\\"]([a-zA-Z][a-zA-Z_0-9]+)['\\\"])")
                 with open(setu, 'r', encoding='utf-8') as f:
                     cst = f.read()
                 find = reg.findall(cst)
                 if len(find) == 0:
-                    raise FileNotFoundError(
+                    raise FileNotFoundError(  # pragma: no cover
                         "Unable to find 'project_var_name' in 'setup.py' in '{}' "
                         "and module_name is None.".format(folder))
                 module_name = find[0][1]
             if os.path.exists(src) and module_name is not None:
                 filename = os.path.join(src, module_name, '__init__.py')
             elif os.path.exists(src) and module_name is not None:
                 filename = os.path.join(src, module_name, '__init__.py')
             elif module_name is not None:
                 filename = os.path.join(folder, module_name, '__init__.py')
             else:
-                raise FileNotFoundError(
+                raise FileNotFoundError(  # pragma: no cover
                     "Unable to find '__init__.py' in '{}' (module_name is None).".format(folder))
         if not os.path.exists(filename):
-            raise FileNotFoundError(
+            raise FileNotFoundError(  # pragma: no cover
                 "Unable to find '__init__.py' in '{}' (got '{}').".format(folder, filename))
         with open(filename, 'r', encoding='utf-8') as f:
             content = f.read()
     elif '__version__' in folder:
         content = folder
     else:
         raise ValueError("Unable to process '{}'.".format(folder))
@@ -1169,25 +1169,25 @@
     lines = content.split('\n')
     modif = []
     rep = []
     for line in lines:
         if line.startswith("__version__"):
             find = reg.findall(line)
             if len(find) != 1:
-                raise ValueError(
+                raise ValueError(  # pragma: no cover
                     "Unable to find __version__ in '{}'".format(line))
             v = find[0][1]
             nv = _update_version(v, str(version))
             newline = line.replace(v, nv)
             modif.append(newline)
             rep.append((line, newline))
         else:
             modif.append(line)
     if len(rep) == 0:
-        raise ValueError(
+        raise ValueError(  # pragma: no cover
             "Unable to find '__version__' in \n{}".format(content))
 
     content = '\n'.join(modif)
     if filename is not None:
         with open(filename, 'w', encoding='utf-8') as f:
             f.write(content)
     return content
```

## pyquickhelper/pycode/utils_tests_private.py

```diff
@@ -33,15 +33,15 @@
     else:
         expected = {"_nrt", "_unittest", "_unittests"}
         if folder is None:
             path = os.path.split(__file__)[0]
             dirs = [os.path.join(path, "..", "..", d) for d in expected]
         elif isinstance(folder, str):
             if not os.path.exists(folder):
-                raise FileNotFoundError(folder)
+                raise FileNotFoundError(folder)  # pragma: no cover
             last = os.path.split(folder)[-1]
             if last in expected:
                 dirs = [folder]
             else:
                 dirs = [os.path.join(folder, d) for d in expected]
         else:
             dirs = folder
@@ -61,16 +61,15 @@
             sys.path.append(fold)
         content = glob.glob(fold + "/" + filter)
         if filter != "temp_*":
             if root is not None:
                 def remove_root(p):
                     if p.startswith(root):
                         return p[len(root):]
-                    else:
-                        return p
+                    return p
                 couples = [(remove_root(il), il) for il in content]
             else:
                 couples = [(il, il) for il in content]
 
             content = []
             for il, fu in couples:
                 if "test_" in il and ".py" in il and ".py.err" not in il and \
@@ -106,29 +105,29 @@
     @param      file        filename
     @return                 int
     """
     try:
         f = open(file, "r", errors="ignore")
         li = f.readlines()
         f.close()
-    except Exception as e:
+    except Exception as e:  # pragma: no cover
         warnings.warn("Issue with '{0}'\n{1}\n{2}".format(
             file, type(e), e), UserWarning)
         return 10
     try:
         s = ''.join(li)
-    except Exception as e:
+    except Exception as e:  # pragma: no cover
         warnings.warn(
-            "Probably an enconding issue for file '{0}'\n{1}\n{2}".format(file, type(e), e), UserWarning)
+            "Probably an enconding issue for file '{0}'\n{1}\n{2}".format(
+                file, type(e), e), UserWarning)
         return 10
     c = re.compile("[(]time=([0-9]+)s[)]").search(s)
     if c is None:
         return 0
-    else:
-        return int(c.groups()[0])
+    return int(c.groups()[0])
 
 
 def import_files(li, additional_ut_path=None, fLOG=noLOG):
     """
     Runs all tests in file list ``li``.
 
     @param      li                      list of files (python scripts)
@@ -154,15 +153,15 @@
                 else:
                     sys.path.append(p)
         tl = os.path.split(le)[1]
         fi = tl.replace(".py", "")
 
         try:
             mo = __import__(fi)
-        except Exception as e:
+        except Exception as e:  # pragma: no cover
             raise ImportError("Unable to import '{}' due to {}.\nsys.path=\n{}".format(
                 fi, e, "\n".join(sys.path)))
 
         # some tests can mess up with the import path
         sys.path = copypath
 
         cl = dir(mo)
@@ -173,26 +172,26 @@
             testsuite = unittest.TestSuite()
             loc = locals()
             exec(
                 compile("di = dir (mo." + c + ")", "", "exec"), globals(), loc)
             di = loc["di"]
             for d in di:
                 if len(d) >= 6 and d[:5] == "_test":
-                    raise RuntimeError(
+                    raise RuntimeError(  # pragma: no cover
                         "a function _test is still deactivated %s in %s" % (d, c))
                 if len(d) < 5 or d[:4] != "test":
                     continue
                 # method d.c
                 loc = locals()
                 code = "t = mo." + c + "(\"" + d + "\")"
                 cp = compile(code, "", "exec")
                 try:
                     exec(cp, globals(), loc)
                 except Exception as e:
-                    raise Exception(
+                    raise Exception(  # pragma: no cover
                         "Unable to execute code '{0}'".format(code)) from e
                 t = loc["t"]
                 testsuite.addTest(t)
 
             allsuite.append((testsuite, le))
 
     return allsuite
@@ -209,31 +208,31 @@
     for log_file in ["temp_hal_log.txt", "temp_hal_log2.txt",
                      "temp_hal_log_.txt", "temp_log.txt", "temp_log2.txt", ]:
         li = get_test_file(log_file, folder=folder)
         for el in li:
             try:
                 if os.path.isfile(el):
                     os.remove(el)
-            except Exception as e:
+            except Exception as e:  # pragma: no cover
                 fLOG("[clean] unable to remove file '{}' due to {}".format(
                     el, str(e).replace("\n", " ")))
 
     li = get_test_file("temp_*")
     for el in li:
         try:
             if os.path.isfile(el):
                 os.remove(el)
-        except Exception as e:
+        except Exception as e:  # pragma: no cover
             fLOG("[clean] unable to remove file '{}' due to {}".format(
                 el, str(e).replace("\n", " ")))
     for el in li:
         try:
             if os.path.isdir(el):
                 remove_folder(el)
-        except Exception as e:
+        except Exception as e:  # pragma: no cover
             fLOG("[clean] unable to remove dir '{}' due to {}".format(
                 el, str(e).replace("\n", " ")))
 
 
 def main_run_test(runner, path_test=None, limit_max=1e9, log=False, skip=-1, skip_list=None,
                   on_stderr=False, processes=False, skip_function=None,
                   additional_ut_path=None, stdout=None, stderr=None, filter_warning=None,
@@ -276,15 +275,15 @@
 
     # checking that the module does not belong to the installed modules
     if path_test is not None:
         path_module = os.path.join(sys.executable, "Lib", "site-packages")
         paths = [os.path.join(path_module, "src"), ]
         for path in paths:
             if os.path.exists(path):
-                raise FileExistsError(
+                raise FileExistsError(  # pragma: no cover
                     "This path should not exist '{}'.".format(path))
 
     def short_name(el):
         cut = os.path.split(el)
         cut = os.path.split(cut[0])[-1] + "/" + cut[-1]
         return cut
 
@@ -301,37 +300,37 @@
     done = {}
     duplicate = []
     for _, cut, lc in co:
         if cut in done:
             duplicate.append((cut, lc))
         done[cut] = True
 
-    if len(duplicate) > 0:
+    if len(duplicate) > 0:  # pragma: no cover
         s = list(set(duplicate))
         s.sort()
         mes = "\n".join(str(_) for _ in s)
         raise Exception("duplicated test file were detected:\n" + mes)
 
     # check existing
     if len(co) == 0:
-        raise FileNotFoundError(
+        raise FileNotFoundError(  # pragma: no cover
             "unable to find any test files in {0}".format(path_test))
 
     if skip != -1:
         fLOG("[main_run_test] found ", len(co), " test files skipping", skip)
     else:
         fLOG("[main_run_test] found ", len(co), " test files")
 
     # extract the test classes
     cco = []
     duration = {}
     index = 0
     for e, cut, l in co:
         if e > limit_max:
-            continue
+            continue  # pragma: no cover
         cco.append((e, l))
         cut = os.path.split(l)
         cut = os.path.split(cut[0])[-1] + "/" + cut[-1]
         duration[cut] = e
         index += 1
 
     exp = re.compile("Ran ([0-9]+) tests? in ([.0-9]+)s")
@@ -357,17 +356,17 @@
     memout.write("[main_run_test] ---- JENKINS BEGIN UNIT TESTS ----")
     memout.write(
         "[main_run_test] ---- BEGIN UNIT TEST for {0}\n".format(path_test))
 
     # display all tests
     for i, s in enumerate(suite):
         if skip >= 0 and i < skip:
-            continue
+            continue  # pragma: no cover
         if i + 1 in skip_list:
-            continue
+            continue  # pragma: no cover
         cut = os.path.split(s[1])
         cut = os.path.split(cut[0])[-1] + "/" + cut[-1]
         if skip_function is not None:
             with open(s[1], "r") as f:
                 content = f.read()
             if skip_function(s[1], content, duration.get(cut, None)):
                 continue
@@ -386,17 +385,17 @@
         runner.stream.stream, StringIOAndFile) else None
 
     # run all tests
     last_s = None
     for i, s in enumerate(suite):
         last_s = s
         if skip >= 0 and i < skip:
-            continue
+            continue  # pragma: no cover
         if i + 1 in skip_list:
-            continue
+            continue  # pragma: no cover
         cut = os.path.split(s[1])
         cut = os.path.split(cut[0])[-1] + "/" + cut[-1]
         if skip_function is not None:
             with open(s[1], "r") as f:
                 content = f.read()
             if skip_function(s[1], content, duration.get(cut, None)):
                 continue
@@ -555,20 +554,20 @@
             for i, (w, s) in enumerate(lw):
                 sw = str(w)
                 if sw in wdone:
                     continue
                 wdone[sw] = w
                 try:
                     sw = "  w{0}: {1}\n".format(i, w)
-                except UnicodeEncodeError:
+                except UnicodeEncodeError:  # pragma: no cover
                     sw = "  w{0}: Unable to convert a warnings of type {1} into a string (1)".format(
                         i, type(w))
                 try:
                     memout.write(sw)
-                except UnicodeEncodeError:
+                except UnicodeEncodeError:  # pragma: no cover
                     sw = "  w{0}: Unable to convert a warnings of type {1} into a string (2)".format(
                         i, type(w))
                     memout.write(sw)
 
     fLOG("[main_run_test] END of unit tests")
     memout.write("[main_run_test] END of unit tests\n")
```

## pyquickhelper/serverdoc/documentation_server.py

```diff
@@ -6,20 +6,20 @@
 import sys
 import os
 import subprocess
 import copy
 import datetime
 try:
     from urllib.parse import urlparse, parse_qs
-except ImportError:
+except ImportError:  # pragma: no cover
     from urlparse import urlparse, parse_qs
 from threading import Thread
 try:
     from http.server import BaseHTTPRequestHandler, HTTPServer
-except ImportError:
+except ImportError:  # pragma: no cover
     from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
 
 if __name__ == "__main__":  # pragma: no cover
     path_ = os.path.normpath(os.path.abspath(
         os.path.join(os.path.split(__file__)[0], "..", "..", "..", "src")))
     if path_ not in sys.path:
         sys.path.append(path_)
@@ -68,27 +68,27 @@
         logging function
         """
         fLOG(*args, **kwargs)
 
     @staticmethod
     def add_mapping(key, value):
         """
-        adds a mapping associated to a local path to watch
+        Adds a mapping associated to a local path to watch.
 
         @param      key         key in ``http://locahost:8008/key/``
         @param      value       local path
 
-        Python documentation says list are protected against multithreading (concurrent accesses).
-
+        Python documentation says list are protected against
+        multithreading (concurrent accesses).
         If you run the server multiple times, the mappings stays because it
         is a static variable.
         """
         value = os.path.normpath(value)
         if not os.path.exists(value):
-            raise FileNotFoundError(value)
+            raise FileNotFoundError(value)  # pragma: no cover
         DocumentationHandler.mappings[key] = value
 
     @staticmethod
     def get_mappings():
         """
         Returns a copy of the mappings.
 
@@ -324,23 +324,24 @@
         if isinstance(anys, bytes):
             if script_python:
                 raise SystemError("** w,unable to execute script from bytes")
             self.wfile.write(anys)
         else:
             if script_python:
                 #any = self.process_scripts(any, params)
-                raise NotImplementedError("unable to execute a python script")
+                raise NotImplementedError(  # pragma: no cover
+                    "unable to execute a python script")
             text = anys.encode("utf-8")
             self.wfile.write(text)
 
     def shutdown(self):
         """
         Shuts down the service.
         """
-        raise NotImplementedError()
+        raise NotImplementedError()  # pragma: no cover
 
     def serve_content(self, cpath, method="GET"):
         """
         Tells what to do based on the path. The function intercepts the
         path /localfile/, otherwise it calls ``serve_content_web``.
 
         If you type ``http://localhost:8080/root/file``,
@@ -569,21 +570,22 @@
         DocumentationHandler.add_mapping(k, v)
 
     if server is None:
         server = HTTPServer(('localhost', port), DocumentationHandler)
     elif isinstance(server, str):
         server = HTTPServer((server, port), DocumentationHandler)
     elif not isinstance(server, HTTPServer):
-        raise TypeError("unexpected type for server: " + str(type(server)))
+        raise TypeError(  # pragma: no cover
+            "unexpected type for server: " + str(type(server)))
 
     if thread:
         th = DocumentationThreadServer(server)
         th.start()
         return th
-    else:
+    else:  # pragma: no cover
         server.serve_forever()
         return server
 
 
 if __name__ == '__main__':  # pragma: no cover
 
     run_server = True
```

## pyquickhelper/sphinxext/_sphinx_common_builder.py

```diff
@@ -80,16 +80,17 @@
                 if builder.current_docname and builder.current_docname != "<<string>>":
                     if srcdir is None:
                         current = os.path.dirname(builder.current_docname)
                     else:
                         current = os.path.dirname(os.path.join(
                             srcdir, builder.current_docname))
                     if current is None or not os.path.exists(current):
-                        raise FileNotFoundError(
-                            "Unable to find document '{0}' current_docname='{1}'".format(current, builder.current_docname))
+                        raise FileNotFoundError(  # pragma: no cover
+                            "Unable to find document '{0}' current_docname='{1}'"
+                            "".format(current, builder.current_docname))
                     dest = os.path.dirname(os.path.join(
                         outdir, builder.current_docname))
                     fold = outdir
                 else:
                     # current_docname is None which means
                     # no file should be created
                     fold = None
@@ -127,18 +128,19 @@
                     if remote:
                         if atts.get('download', False):
                             # Downloads the image
                             try:
                                 get_url_content_timeout(
                                     atts['src'], output=dest, encoding=None, timeout=20)
                                 full = atts['src']
-                            except InternetException as e:
+                            except InternetException as e:  # pragma: no cover
                                 logger = logging.getLogger("image")
                                 logger.warning(
-                                    "[image] unable to get content for url '{0}' due to '{1}'".format(atts['src'], e))
+                                    "[image] unable to get content for url '{0}' due to '{1}'"
+                                    "".format(atts['src'], e))
                                 this = os.path.abspath(
                                     os.path.dirname(__file__))
                                 full = os.path.join(
                                     this, "sphinximages", "sphinxtrib", "missing.png")
                                 shutil.copy(full, dest)
                         else:
                             name = atts['src']
@@ -149,30 +151,31 @@
                             dest = dest[:2] + dest[2:].replace(':', '_')
                             ext = os.path.splitext(dest)[-1]
                             if ext not in ('.png', '.jpg'):
                                 dest += '.png'
                         try:
                             shutil.copy(full, dest)
                         except FileNotFoundError as e:
-                            raise FileNotFoundError(
+                            raise FileNotFoundError(  # pragma: no cover
                                 "Unable to copy from '{0}' to '{1}'.".format(full, dest)) from e
                         full = dest
                 else:
                     full = dest
             else:
                 name = atts['src']
                 full = name
                 dest = name
 
             atts['src'] = name
             atts['full'] = full
             atts['dest'] = dest
         else:
-            raise ValueError("No image was found in node (class='{1}')\n{0}".format(
-                node, self.__class__.__name__))
+            raise ValueError(  # pragma: no cover
+                "No image was found in node (class='{1}')\n{0}".format(
+                    node, self.__class__.__name__))
 
         # image size
         if 'width' in node:
             atts['width'] = node['width']
         if 'height' in node:
             atts['height'] = node['height']
         if 'download' in node:
@@ -180,15 +183,15 @@
         if 'scale' in node:
             import PIL
             if 'width' not in node or 'height' not in node:
                 imagepath = urllib.request.url2pathname(uri)
                 try:
                     img = PIL.Image.open(
                         imagepath.encode(sys.getfilesystemencoding()))
-                except (IOError, UnicodeEncodeError):
+                except (IOError, UnicodeEncodeError):  # pragma: no cover
                     pass  # TODO: warn?
                 else:
                     self.settings.record_dependencies.add(  # pylint: disable=E1101
                         imagepath.replace('\\', '/'))
                     if 'width' not in atts:
                         atts['width'] = '%dpx' % img.size[0]
                     if 'height' not in atts:
```

## pyquickhelper/sphinxext/sphinx_autosignature.py

```diff
@@ -144,15 +144,15 @@
                 keep_logged.append(" ".join(str(_) for _ in els))
             logging_function = keep_logging
         else:
             logging_function = None
 
         try:
             source, lineno = self.reporter.get_source_and_line(self.lineno)
-        except AttributeError:
+        except AttributeError:  # pragma: no cover
             source = lineno = None
 
         # object name
         object_name = " ".join(_.strip("\n\r\t ") for _ in self.content)
         if opt_syspath:
             syslength = len(sys.path)
             sys.path.extend(opt_syspath.split(';'))
@@ -161,27 +161,28 @@
                 object_name, use_init=False, fLOG=logging_function)
         except ImportError as e:
             mes = "[autosignature] unable to import '{0}' due to '{1}'".format(
                 object_name, e)
             logger = logging.getLogger("autosignature")
             logger.warning(mes)
             if logging_function:
-                logging_function(mes)
+                logging_function(mes)  # pragma: no cover
             if lineno is not None:
                 logger.warning(
                     '   File "{0}", line {1}'.format(source, lineno))
             obj = None
             kind = None
         if opt_syspath:
             del sys.path[syslength:]
 
-        if opt_members is not None and kind != "class":
+        if opt_members is not None and kind != "class":  # pragma: no cover
             logger = logging.getLogger("autosignature")
             logger.warning(
-                "[autosignature] option members is specified but '{0}' is not a class (kind='{1}').".format(object_name, kind))
+                "[autosignature] option members is specified but '{0}' "
+                "is not a class (kind='{1}').".format(object_name, kind))
             obj = None
 
         # build node
         node = self.__class__.autosignature_class(rawsource=object_name,
                                                   source=source, lineno=lineno,
                                                   objectname=object_name)
 
@@ -199,40 +200,41 @@
                 pimp = import_path(
                     obj, err_msg="object name: '{0}'".format(object_name))
                 anchor = '{0}.{1}'.format(pimp, object_name.split(".")[-1])
         elif opt_path == 'full':
             anchor = object_name
         elif opt_path == 'name':
             anchor = object_name.split(".")[-1]
-        else:
+        else:  # pragma: no cover
             logger = logging.getLogger("autosignature")
             logger.warning(
-                "[autosignature] options path is '{0}', it should be in (import, name, full) for object '{1}'.".format(opt_path, object_name))
+                "[autosignature] options path is '{0}', it should be in "
+                "(import, name, full) for object '{1}'.".format(opt_path, object_name))
             anchor = object_name
 
         if obj is None:
             if opt_link:
                 text = "\n:py:func:`{0} <{1}>`\n\n".format(anchor, object_name)
             else:
                 text = "\n``{0}``\n\n".format(anchor)
         else:
             obj_sig = obj.__init__ if kind == "class" else obj
             try:
                 signature = inspect.signature(obj_sig)
                 parameters = signature.parameters
-            except TypeError as e:
+            except TypeError as e:  # pragma: no cover
                 mes = "[autosignature](1) unable to get signature of '{0}' - {1}.".format(
                     object_name, str(e).replace("\n", "\\n"))
                 logger = logging.getLogger("autosignature")
                 logger.warning(mes)
                 if logging_function:
                     logging_function(mes)
                 signature = None
                 parameters = None
-            except ValueError as e:
+            except ValueError as e:  # pragma: no cover
                 # Backup plan, no __text_signature__, this happen
                 # when a function was created with pybind11.
                 doc = obj_sig.__doc__
                 sigs = set(enumerate_cleaned_signature(doc))
                 if len(sigs) == 0:
                     mes = "[autosignature](2) unable to get signature of '{0}' - {1}.".format(
                         object_name, str(e).replace("\n", "\\n"))
@@ -280,24 +282,25 @@
                     parameters, opt_annotation)
                 text = "\n:py:{3}:`{0} <{1}>` ({2})\n\n".format(
                     anchor, object_name, signature, domkind)
 
         if obj is not None and opt_summary:
             # Documentation.
             doc = obj.__doc__  # if kind != "class" else obj.__class__.__doc__
-            if doc is None:
+            if doc is None:  # pragma: no cover
                 mes = "[autosignature] docstring empty for '{0}'.".format(
                     object_name)
                 logger = logging.getLogger("autosignature")
                 logger.warning(mes)
                 if logging_function:
                     logging_function(mes)
             else:
                 if "type(object_or_name, bases, dict)" in doc:
-                    raise Exception("issue with {0}\n{1}".format(obj, doc))
+                    raise TypeError(  # pragma: no cover
+                        "issue with {0}\n{1}".format(obj, doc))
                 docstring = self.build_summary(doc)
                 text += docstring + "\n\n"
 
         if opt_members is not None and kind == "class":
             docstring = self.build_members(obj, opt_members, object_name,
                                            opt_annotation, opt_summary)
             docstring = "\n".join(
@@ -328,20 +331,21 @@
             if name[0] == "_" or (members is not None and name not in members):
                 continue
             if name not in cl.__dict__:
                 # Not a method of this class.
                 continue
             try:
                 signature = inspect.signature(value)
-            except TypeError as e:
+            except TypeError as e:  # pragma: no cover
                 logger = logging.getLogger("autosignature")
                 logger.warning(
-                    "[autosignature](2) unable to get signature of '{0}.{1} - {2}'.".format(object_name, name, str(e).replace("\n", "\\n")))
+                    "[autosignature](2) unable to get signature of "
+                    "'{0}.{1} - {2}'.".format(object_name, name, str(e).replace("\n", "\\n")))
                 signature = None
-            except ValueError:
+            except ValueError:  # pragma: no cover
                 signature = None
 
             if signature is not None:
                 parameters = signature.parameters
             else:
                 parameters = []
 
@@ -350,15 +354,15 @@
 
             signature = self.build_parameters_list(parameters, annotation)
             text = "\n:py:meth:`{0} <{1}.{0}>` ({2})\n\n".format(
                 name, object_name, signature)
 
             if value is not None and summary:
                 doc = value.__doc__
-                if doc is None:
+                if doc is None:  # pragma: no cover
                     logger = logging.getLogger("autosignature")
                     logger.warning(
                         "[autosignature] docstring empty for '{0}.{1}'.".format(object_name, name))
                 else:
                     docstring = self.build_summary(doc)
                     lines = "\n".join(
                         map(lambda s: "    " + s, docstring.split("\n")))
```

## pyquickhelper/sphinxext/sphinx_blocref_extension.py

```diff
@@ -154,25 +154,25 @@
             self.state.nested_parse(content, self.content_offset, container)
         else:
             container = None
 
         # mid
         breftag = self.options.get('tag', '').strip()
         if len(breftag) == 0:
-            raise ValueError("tag is empty")
+            raise ValueError("tag is empty")  # pragma: no cover
         if env is not None:
             mid = int(env.new_serialno('index%s-%s' %
                                        (name_desc, breftag))) + 1
         else:
             mid = -1
 
         # title
         titleo = self.options.get('title', "").strip()
         if len(titleo) == 0:
-            raise ValueError("title is empty")
+            raise ValueError("title is empty")  # pragma: no cover
         title = self._update_title(titleo, breftag, mid)
 
         # main node
         ttitle = title
         title = nodes.title(text=_(title))
         if container is not None:
             blocref.insert(0, title)
@@ -197,15 +197,15 @@
                                          env.new_serialno('index%s%s' % (name_desc, breftag)))
             blocref["breftargetid"] = targetid
             ids = [targetid]
             targetnode = nodes.target(legend, '', ids=ids)
             set_source_info(self, targetnode)
             try:
                 self.state.add_target(targetid, '', targetnode, lineno)
-            except Exception as e:
+            except Exception as e:  # pragma: no cover
                 mes = "Issue in \n  File '{0}', line {1}\ntitle={2}\ntag={3}\ntargetid={4}"
                 raise Exception(mes.format(docname, lineno,
                                            title, breftag, targetid)) from e
 
             # index node
             index = self.options.get('index', None)
             if index is not None:
@@ -220,16 +220,15 @@
         else:
             targetnode = None
             indexnode = None
 
         res = [a for a in [indexnode, targetnode, blocref] if a is not None]
         if add_container:
             return res, ret_container
-        else:
-            return res
+        return res
 
 
 def process_blocrefs(app, doctree):
     """
     collect all blocrefs in the environment
     this is not done in the directive itself because it some transformations
     must have already been run, e.g. substitutions
@@ -249,16 +248,16 @@
     if not hasattr(env, attr):
         setattr(env, attr, [])
     attr_list = getattr(env, attr)
     for node in doctree.traverse(class_node):
         try:
             targetnode = node.parent[node.parent.index(node) - 1]
             if not isinstance(targetnode, nodes.target):
-                raise IndexError
-        except IndexError:
+                raise IndexError  # pragma: no cover
+        except IndexError:  # pragma: no cover
             targetnode = None
         newnode = node.deepcopy()
         breftag = newnode['breftag']
         breftitle = newnode['breftitle']
         brefmid = newnode['brefmid']
         brefline = newnode['brefline']
         breffile = newnode['breffile']
@@ -448,21 +447,21 @@
             # Create a reference
             newnode = nodes.reference('', '', internal=True)
             newnode['name'] = _(orig_entry)
             try:
                 newnode['refuri'] = app.builder.get_relative_uri(
                     fromdocname, blocref_info['docname'])
                 if blocref_info['target'] is None:
-                    raise NoUri
+                    raise NoUri  # pragma: no cover
                 try:
                     newnode['refuri'] += '#' + blocref_info['target']['refid']
-                except Exception as e:
+                except Exception as e:  # pragma: no cover
                     raise KeyError("refid in not present in '{0}'".format(
                         blocref_info['target'])) from e
-            except NoUri:
+            except NoUri:  # pragma: no cover
                 # ignore if no URI can be determined, e.g. for LaTeX output
                 pass
 
             newnode.append(nodes.Text(newnode['name']))
 
             # para is duplicate of the content of the bloc
             para += newnode
@@ -479,15 +478,15 @@
                 p = nodes.paragraph()
                 item += p
                 newnode = nodes.reference('', title, internal=True)
                 try:
                     newnode['refuri'] = app.builder.get_relative_uri(
                         fromdocname, brefdocname)
                     newnode['refuri'] += '#' + idss[0]
-                except NoUri:
+                except NoUri:  # pragma: no cover
                     # ignore if no URI can be determined, e.g. for LaTeX output
                     pass
                 p += newnode
                 bullets += item
 
             # Adds the content.
             blocref_entry["ids"] = idss
```

## pyquickhelper/sphinxext/sphinx_cmdref_extension.py

```diff
@@ -81,15 +81,15 @@
         res, cont = BlocRef.private_run(self, add_container=True)
         name = self.options.get("cmd", None)
 
         if name is not None and len(name) > 0:
             self.reporter = self.state.document.reporter
             try:
                 source, lineno = self.reporter.get_source_and_line(self.lineno)
-            except AttributeError:
+            except AttributeError:  # pragma: no cover
                 source = lineno = None
 
             # object name
             if name.startswith("-m"):
                 # example: -m pyquickhelper clean_files --help
                 out, err = run_script(
                     name, fLOG=noLOG, wait=True, change_path=path)
@@ -148,15 +148,15 @@
                 name_fct = name_fct.strip()
                 fullname = fullname.strip()
                 name_cmd = name_cmd.strip()
 
                 fullname = "{0}.{1}".format(fullname, name_fct)
                 try:
                     obj, name = import_object(fullname, kind="function")
-                except ImportError:
+                except ImportError:  # pragma: no cover
                     logger = logging.getLogger("CmdRef")
                     logger.warning(
                         "[CmdRef] unable to import '{0}'".format(fullname))
                     if lineno is not None:
                         logger.warning(
                             '   File "{0}", line {1}'.format(source, lineno))
                     obj = None
```

## pyquickhelper/sphinxext/sphinx_docassert_extension.py

```diff
@@ -7,24 +7,16 @@
 from docutils import nodes
 import sphinx
 from sphinx.util import logging
 from sphinx.util.docfields import DocFieldTransformer, _is_single_paragraph
 from .import_object_helper import import_any_object
 
 
-def check_typed_make_field(self,
-                           types,
-                           domain,
-                           items,
-                           env=None,
-                           parameters=None,
-                           function_name=None,
-                           docname=None,
-                           kind=None
-                           ):
+def check_typed_make_field(self, types, domain, items, env=None, parameters=None,
+                           function_name=None, docname=None, kind=None):
     """
     Overwrites function
     `make_field <https://github.com/sphinx-doc/sphinx/blob/master/sphinx/util/docfields.py#L197>`_.
     Processes one argument of a function.
 
     @param      self            from original function
     @param      types           from original function
@@ -101,22 +93,26 @@
         @param      replaced        should be *DocFieldTransformer.transform*
         """
         self.replaced = replaced
 
     def override_transform(self, other_self, node):
         """
         Transform a single field list *node*.
-        Overwrite function `transform <https://github.com/sphinx-doc/sphinx/blob/master/sphinx/util/docfields.py#L271>`_.
-        It only adds extra verification and returns results from the replaced function.
+        Overwrite function `transform
+        <https://github.com/sphinx-doc/sphinx/blob/
+        master/sphinx/util/docfields.py#L271>`_.
+        It only adds extra verification and returns results from
+        the replaced function.
 
         @param      other_self      the builder
         @param      node            node the replaced function changes or replace
 
-        The function parses the original function and checks that the list of arguments declared
-        by the function is the same the list of documented arguments.
+        The function parses the original function and checks that the list
+        of arguments declared by the function is the same the list of
+        documented arguments.
         """
         typemap = other_self.typemap
         entries = []
         groupindices = {}
         types = {}
 
         # step 1: traverse all fields and collect field types and content
@@ -124,33 +120,48 @@
             fieldname, fieldbody = field
             try:
                 # split into field type and argument
                 fieldtype, fieldarg = fieldname.astext().split(None, 1)
             except ValueError:
                 # maybe an argument-less field type?
                 fieldtype, fieldarg = fieldname.astext(), ''
-            if fieldtype != "param":
+            if fieldtype == "Parameters":
+                # numpydoc style
+                keyfieldtype = 'parameter'
+            elif fieldtype == "param":
+                keyfieldtype = 'param'
+            else:
                 continue
-            typedesc, is_typefield = typemap.get(fieldtype, (None, None))
+            typedesc, is_typefield = typemap.get(keyfieldtype, (None, None))
 
             # sort out unknown fields
-            if typedesc is None or typedesc.has_arg != bool(fieldarg):
+            extracted = []
+            if keyfieldtype == 'parameter':
+                # numpydoc
+
+                for child in fieldbody.children:
+                    if isinstance(child, nodes.definition_list):
+                        for child2 in child.children:
+                            extracted.append(child2)
+            elif typedesc is None or typedesc.has_arg != bool(fieldarg):
                 # either the field name is unknown, or the argument doesn't
                 # match the spec; capitalize field name and be done with it
                 new_fieldname = fieldtype[0:1].upper() + fieldtype[1:]
                 if fieldarg:
                     new_fieldname += ' ' + fieldarg
                 fieldname[0] = nodes.Text(new_fieldname)
                 entries.append(field)
                 continue
 
             typename = typedesc.name
 
             # collect the content, trying not to keep unnecessary paragraphs
-            if _is_single_paragraph(fieldbody):
+            if extracted:
+                content = extracted
+            elif _is_single_paragraph(fieldbody):
                 content = fieldbody.children[0].children
             else:
                 content = fieldbody.children
 
             # if the field specifies a type, put it in the types collection
             if is_typefield:
                 # filter out only inline nodes; others will result in invalid
@@ -213,15 +224,22 @@
                     logger.warning(
                         "[docassert] unable to get signature of '{0}'.".format(docs))
                     signature = None
                     parameters = None
 
             # grouped entries need to be collected in one entry, while others
             # get one entry per field
-            if typedesc.is_grouped:
+            if extracted:
+                # numpydoc
+                group_entries = []
+                for ext in extracted:
+                    name = ext.astext().split('\n')[0].split()[0]
+                    group_entries.append((name, ext))
+                entries.append([typedesc, group_entries])
+            elif typedesc.is_grouped:
                 if typename in groupindices:
                     group = entries[groupindices[typename]]
                 else:
                     groupindices[typename] = len(entries)
                     group = [typedesc, []]
                     entries.append(group)
                 entry = typedesc.make_entry(fieldarg, [translatable_content])
@@ -238,18 +256,17 @@
             logger.warning("[docassert] {0}".format(e))
             env = None
 
         docname = fieldbody.parent.source.split(':docstring')[0]
 
         for entry in entries:
             if isinstance(entry, nodes.field):
-                # raise NotImplementedError()
                 logger = logging.getLogger("docassert")
                 logger.warning(
-                    "[docassert] unable to checl [nodes.field] {0}".format(entry))
+                    "[docassert] unable to check [nodes.field] {0}".format(entry))
             else:
                 fieldtype, content = entry
                 fieldtypes = types.get(fieldtype.name, {})
                 check_typed_make_field(other_self, fieldtypes, other_self.directive.domain,
                                        content, env=env, parameters=parameters,
                                        function_name=function_name, docname=docname,
                                        kind=funckind)
@@ -275,9 +292,9 @@
         return inst.override_transform(me, node)
 
     DocFieldTransformer.transform = local_transform
     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}
 
 
 def setup(app):
-    "see @see fn setup_docassert"
+    "setup for docassert"
     return setup_docassert(app)
```

## pyquickhelper/sphinxext/sphinx_doctree_builder.py

```diff
@@ -20,15 +20,15 @@
 class DocTreeTranslator(nodes.NodeVisitor, CommonSphinxWriterHelpers):
     """
     Defines a translator for doctree
     """
 
     def __init__(self, builder, document):
         if not hasattr(builder, 'config'):
-            raise TypeError(
+            raise TypeError(  # pragma: no cover
                 "Unexpected type for builder {0}".format(type(builder)))
         nodes.NodeVisitor.__init__(self, document)
         self.builder = builder
 
         newlines = builder.config.text_newlines
         if newlines == 'windows':
             self.nl = '\r\n'
```

## pyquickhelper/sphinxext/sphinx_epkg_extension.py

```diff
@@ -95,24 +95,26 @@
 
     # Configuration.
     env = inliner.document.settings.env
     app = env.app
     config = app.config
     try:
         epkg_dictionary = config.epkg_dictionary
-    except AttributeError as e:
+    except AttributeError as e:  # pragma: no cover
         ma = "\n".join(sorted(str(_) for _ in app.config))
         raise AttributeError(
-            "unable to find 'epkg_dictionary' in configuration. Available:\n{0}".format(ma)) from e
+            "unable to find 'epkg_dictionary' in configuration. Available:\n{0}"
+            "".format(ma)) from e
 
     # Supported module?
     modname = spl[0]
     if modname not in epkg_dictionary:
-        msg = inliner.reporter.error("Unable to find module '{0}' in epkg_dictionary, existing={1}".format(
-                                     modname, ", ".join(sorted(epkg_dictionary.keys())), line=lineno))
+        msg = inliner.reporter.error(
+            "Unable to find module '{0}' in epkg_dictionary, existing={1}".format(
+                modname, ", ".join(sorted(epkg_dictionary.keys())), line=lineno))
         prb = inliner.problematic(rawtext, rawtext, msg)
         return [prb], [msg]
 
     if len(spl) == 1:
         value = epkg_dictionary[modname]
         if isinstance(value, tuple):
             if len(value) == 0:
@@ -140,27 +142,29 @@
                     found = import_any_object(namef)[0]
                 else:
                     # Defined in the configuration.
                     found = getattr(config, namef)
 
         if found is None:
             msg = inliner.reporter.error(
-                "Unable to find a tuple with '{0}' parameters in epkg_dictionary['{1}']".format(expected, modname))
+                "Unable to find a tuple with '{0}' parameters in epkg_dictionary['{1}']"
+                "".format(expected, modname))
             prb = inliner.problematic(rawtext, rawtext, msg)
             return [prb], [msg]
 
         if callable(found):
             try:
                 anchor, url = found(text)
             except TypeError:
                 try:
                     anchor, url = found()(text)
-                except Exception as e:
+                except Exception as e:  # pragma: no cover
                     raise ValueError(
-                        "epkg accepts function or classes with __call__ overloaded. Found '{0}'".format(found)) from e
+                        "epkg accepts function or classes with __call__ overloaded. "
+                        "Found '{0}'".format(found)) from e
         else:
             url = found.format(*tuple(spl[1:]))
             if spl[0].startswith("*"):
                 anchor = ".".join(spl[1:])
             else:
                 anchor = ".".join(spl)
```

## pyquickhelper/sphinxext/sphinx_md_builder.py

```diff
@@ -54,15 +54,16 @@
 class MdTranslator(TextTranslator, CommonSphinxWriterHelpers):
     """
     Defines a :epkg:`MD` translator.
     """
 
     def __init__(self, builder, document):
         if not hasattr(builder, "config"):
-            raise TypeError("Builder has no config: {}".format(type(builder)))
+            raise TypeError(  # pragma: no cover
+                "Builder has no config: {}".format(type(builder)))
         TextTranslator.__init__(self, document, builder)
 
         newlines = builder.config.text_newlines
         if newlines == 'windows':
             self.nl = '\r\n'
         elif newlines == 'native':
             self.nl = os.linesep
@@ -434,16 +435,16 @@
         self._table.append([])
 
     def depart_row(self, node):
         pass
 
     def visit_entry(self, node):
         if hasattr(node, 'morerows') or hasattr(node, 'morecols'):
-            raise NotImplementedError('Column or row spanning cells are '
-                                      'not implemented.')
+            raise NotImplementedError(  # pragma: no cover
+                'Column or row spanning cells are not implemented.')
         self.new_state(0)
 
     def depart_entry(self, node):
         text = self.nl.join(self.nl.join(x[1]) for x in self.states.pop())
         self.stateindent.pop()
         self._table[-1].append(text)
 
@@ -918,18 +919,18 @@
 
     def eval_expr(self, expr):
         md = True
         rst = False
         html = False
         latex = False
         if not(rst or html or latex or md):
-            raise ValueError("One of them should be True")
+            raise ValueError("One of them should be True")  # pragma: no cover
         try:
             ev = eval(expr)
-        except Exception as e:
+        except Exception as e:  # pragma: no cover
             raise ValueError(
                 "Unable to interpret expression '{0}'".format(expr))
         return ev
 
     def visit_only(self, node):
         ev = self.eval_expr(node.attributes['expr'])
         if ev:
```

## pyquickhelper/texthelper/templating.py

```diff
@@ -58,9 +58,9 @@
             res = template.render(**context)
         except UndefinedError as ee:
             raise CustomTemplateException(
                 "Some parameters are missing or mispelled\n{}"
                 "".format(pformat(context))) from ee
         return res
     else:
-        raise ValueError(
+        raise ValueError(  # pragma: no cover
             "engine should be 'mako' or 'jinja2', not '{0}'".format(engine))
```

## Comparing `pyquickhelper-1.9.3396.dist-info/LICENSE.txt` & `pyquickhelper-1.9.3418.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `pyquickhelper-1.9.3396.dist-info/METADATA` & `pyquickhelper-1.9.3418.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pyquickhelper
-Version: 1.9.3396
+Version: 1.9.3418
 Summary: Various functionalities: folder synchronization, simple logging function, helpers to generate documentation with sphinx, sphinx extension, to run a command line, to run a notebook...
 Home-page: http://www.xavierdupre.fr/app/pyquickhelper/helpsphinx/index.html
 Author: Xavier Dupré
 Author-email: xavier.dupre@gmail.com
 License: MIT
 Download-URL: https://github.com/sdpython/pyquickhelper
 Keywords: pyquickhelper,synchronization,files,documentation,Xavier Dupré,sphinx,extension,notebooks,rst,builder,cli,setup,unit tests
@@ -32,14 +32,15 @@
 Requires-Dist: jyquickhelper ; extra == 'all'
 Requires-Dist: matplotlib ; extra == 'all'
 Requires-Dist: metakernel ; extra == 'all'
 Requires-Dist: multi-key-dict ; extra == 'all'
 Requires-Dist: nbconvert (>=5.6.1) ; extra == 'all'
 Requires-Dist: notebook (>=4.2.0) ; extra == 'all'
 Requires-Dist: numpy (>=1.16.0) ; extra == 'all'
+Requires-Dist: numpydoc ; extra == 'all'
 Requires-Dist: pandas (>=1.0.0) ; extra == 'all'
 Requires-Dist: psutil ; extra == 'all'
 Requires-Dist: pylint ; extra == 'all'
 Requires-Dist: python-jenkins (>=1.0.0) ; extra == 'all'
 Requires-Dist: pyyaml ; extra == 'all'
 Requires-Dist: pylzma ; extra == 'all'
 Requires-Dist: pysftp ; extra == 'all'
@@ -120,14 +121,18 @@
     :target: https://github.com/sdpython/pyquickhelper/
     :alt: Forks
 
 .. image:: https://img.shields.io/github/stars/sdpython/pyquickhelper.svg
     :target: https://github.com/sdpython/pyquickhelper/
     :alt: Stars
 
+.. image:: https://img.shields.io/github/repo-size/sdpython/pyquickhelper
+    :target: https://github.com/sdpython/pyquickhelper/
+    :alt: size
+
 `pyquickhelper <http://www.xavierdupre.fr/app/pyquickhelper/helpsphinx/index.html>`_
 is used to automate the release of the documentation such as automating *Jenkins*,
 converting notebooks into many formats, extending *Sphinx* with custom
 extensions... It assumes the project is organized on the same template
 as this one.
 
 Functionalities
@@ -221,17 +226,24 @@
 
 .. _l-HISTORY:
 
 =======
 History
 =======
 
-current - 2020-06-08 - 0.00Mb
+current - 2020-07-09 - 0.00Mb
 =============================
 
+* `307`: Add a function to plot a graph on a matplotlib (2020-07-07)
+* `306`: Remove numpydoc added by default, it fails with other extensions (2020-06-28)
+* `305`: docassert does not work on numpydoc (2020-06-23)
+
+1.9.3396 - 2020-06-08 - 2.06Mb
+==============================
+
 * `304`: Implements a simpler version of ignore_warnings (2020-06-07)
 
 1.9.3393 - 2020-06-03 - 2.06Mb
 ==============================
 
 * `303`: Add parameter squeeze to assertEqualArray (2020-06-03)
 * `302`: Implements method assertLogging in ExtTestCase (2020-05-10)
```

## Comparing `pyquickhelper-1.9.3396.dist-info/RECORD` & `pyquickhelper-1.9.3418.dist-info/RECORD`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-pyquickhelper/__init__.py,sha256=sZ-CNz956q3M4q3fMH3FRJdggGFeMvcnutZJ0mrZn70,2798
+pyquickhelper/__init__.py,sha256=qzCfqZBVk8sFwK1dfWI6wShdQDky2eGtVa_Fz_uR5sE,2818
 pyquickhelper/__main__.py,sha256=5mkma38oKQGSOqw715-sLMyFJrV9a3bAMhtaIgAT8Ls,2852
 pyquickhelper/benchhelper/__init__.py,sha256=g2txWUvRjFRdZKgq-yCNgHzfvdFRGQlGAyCEgeVgpeA,129
-pyquickhelper/benchhelper/benchmark.py,sha256=X5FJs-hLHaVi0-b2tiQJy0ePRFLZqkLdf2ckPRxkq7g,30626
-pyquickhelper/benchhelper/grid_benchmark.py,sha256=DDVxRHXYTMUCXuPe_6Kytj52LZ_2QJkCEcLlfbxJCsU,7912
+pyquickhelper/benchhelper/benchmark.py,sha256=ljT2BiUXCJuZhmdbaii7ZNW15j5_18drmxa8B8Te2ic,31360
+pyquickhelper/benchhelper/grid_benchmark.py,sha256=CODkhd2W1uFtvJ5Vx6lvxcMiTF-Mbw10BVx0JpSqnnw,8212
 pyquickhelper/cli/__init__.py,sha256=YTQgKVtFoRA5TJBCYv50Qe-UtwfYrh-eOl-ehS7825Q,124
-pyquickhelper/cli/cli_helper.py,sha256=2HfPBU3kwt_Z2nfB2DYV8YrmHhXeQiBxoia53HOFW_A,16975
-pyquickhelper/cli/encryption_cli.py,sha256=C7kVhejIYCAP9b-kJVfVEYeW1UCAbb70cOC7_-V8EMk,6491
-pyquickhelper/cli/encryption_file_cli.py,sha256=IwtNP5eS9QhlQDCSZn9nCAOuAyzW8Irbb_vKQ-h-2YE,4011
-pyquickhelper/cli/ftp_cli.py,sha256=dtvdkEfpYungNKKLLfY3n7KwpzoHZCjsowxC6RzUDH0,2808
-pyquickhelper/cli/notebook.py,sha256=bhcqPnyKWhguZiV-q1rDL3AdovE8tI0lqbZwEHAjKSA,4752
-pyquickhelper/cli/pyq_sync_cli.py,sha256=yGiciTa4u-0kqE9oPfr4CKLU2F17bcyN_oo-_-zdS-8,1366
+pyquickhelper/cli/cli_helper.py,sha256=b-0SMGLG2CxKTqZ2tnktCuzb6kmSXoABu9SPHW7Qrsg,16960
+pyquickhelper/cli/encryption_cli.py,sha256=aeBwGgpMvPHqvcMnxQVgxNsuL0C8ccnwmPXCvHhCAy0,6591
+pyquickhelper/cli/encryption_file_cli.py,sha256=xIzROhifgVR2uT55KCXeZBtTEeFPtwkXU_M7hkZsoNE,4111
+pyquickhelper/cli/ftp_cli.py,sha256=3tiY4zJMGlKScqPcvDAn8BwaNyCCdokMtm8z8TTXlVk,2814
+pyquickhelper/cli/notebook.py,sha256=xDZ5kQF1eYvLpBsDJGVdX_9B4OExbkVFLhy8-YU2unI,4854
+pyquickhelper/cli/pyq_sync_cli.py,sha256=TYVVRjQMOz3kIF7W91BIZ6BenEQ9wKwj0kHGr1OoVqw,1406
 pyquickhelper/cli/script_exec.py,sha256=Pkk1giIy4MIl39huE4ZFMQDEBYSLDterkMgJQAjocLE,1528
-pyquickhelper/cli/simplified_fct.py,sha256=arbhTdvNOVp_EuMYyMbNmzw0VcicWFLWU9D1dMcJIxU,4828
+pyquickhelper/cli/simplified_fct.py,sha256=lNy-wy71LWaoJGAkbW1wTB7KAqnYniySa7l5Y1tlu0I,4862
 pyquickhelper/filehelper/__init__.py,sha256=k-O7TjZd-Lh8Ouy1NWzpgLdqKyAguLuz3tgp9CYdQyw,1507
 pyquickhelper/filehelper/anyfhelper.py,sha256=eZWxQeJPsNcI8C08-nD15KYuv0nbQ2I3MW-TyFEQRl8,8485
 pyquickhelper/filehelper/compression_helper.py,sha256=-OXjcqI8NZujSVZU4mYWCbtHRbdOlB6O0GSWd9aRqYg,23998
 pyquickhelper/filehelper/difflib.js,sha256=nfSMh4ay-sBY0lOqdj14PuVIh3nTBNT2zmL8GaBcDUk,11721
 pyquickhelper/filehelper/diffview.css,sha256=2YTUkjlT3xBSJ6sFQitR1SMv4_HsmSwOmhd4IoIES4Y,2694
 pyquickhelper/filehelper/diffview.js,sha256=Q73YqLxC9SWuFikrl3TVGar81PmSpWuXkIMP9Jro6ow,8185
 pyquickhelper/filehelper/download_helper.py,sha256=-Lg6Uc8qBD0nApmtiuzvGtHshKEruOL0cmq97V9uUIE,6773
@@ -39,15 +39,16 @@
 pyquickhelper/helpgen/__init__.py,sha256=kNjdzjCod4DtUB9MAq-oBaRaSpg0yYBQ3zDY7eFi73g,721
 pyquickhelper/helpgen/_fake_function_to_documentation.py,sha256=AwmZDQ_rHXumsLAAEDSdFO3yOXb2eOa5-YgKsQhrzBU,1096
 pyquickhelper/helpgen/_my_doxypy.py,sha256=4YtnyPY545TZzG7PJLxWse-T2FmY9uAMbjlXQFL3jR8,21783
 pyquickhelper/helpgen/_nbconvert_config.py,sha256=U9f80XDLZ4JShL5nnwrvq0xjUUVOuqkwH7C1w9nySPw,501
 pyquickhelper/helpgen/_nbconvert_preprocessor.py,sha256=2pK8Leye4txrgvKiwmbW978tUIunbtSzQMpTel3lxUQ,1099
 pyquickhelper/helpgen/_single_file_html_builder.py,sha256=fjDvbFw8nOyBxG-1ZdwC-iWBEr2pNzuZdQ0TQdCoTLo,7560
 pyquickhelper/helpgen/conf_path_tools.py,sha256=qPBfg08rGzIpRaMD0qA99ZmKwBu05_me2RdDoOj0yXk,6868
-pyquickhelper/helpgen/default_conf.py,sha256=i07KExkOeMZNHRzDaVc8UFn52GiW5tXfS_dcJebntAQ,44777
+pyquickhelper/helpgen/default_conf.py,sha256=FyWYssDD91rqzr8IRQ6jUy9QMZiJUOgeNz5Uq2-RWLs,44619
+pyquickhelper/helpgen/graphviz_helper.py,sha256=blZApuTXWZ8PpPPD9g_AxyKeYlq-4C5oHn-nKs69lig,1809
 pyquickhelper/helpgen/help_usage.py,sha256=xHaIgK-7X-INlmH9Dz4RepPWSI_Giahfamm44DvfcLE,516
 pyquickhelper/helpgen/helpgen_exceptions.py,sha256=tBpGAz1JUF-k27plQ1dccCqpxz_zRy9MfOiiRLITGVw,986
 pyquickhelper/helpgen/install_custom.py,sha256=LEfcbTGxwD6m4zB063zZONWMwYAtQNvlp5CODAhAoUo,5203
 pyquickhelper/helpgen/install_js_dep.py,sha256=jGs1S-HfdqjaxVROicwXwof6ZfzRfo6sVoXOiRQRNQ0,1814
 pyquickhelper/helpgen/markdown_helper.py,sha256=iy9z3CmQXm5hTDwg6dQ969uePG_Wff_MRl52IMNYpe4,1971
 pyquickhelper/helpgen/notebook_exporter.py,sha256=URz8BWv6-XrwwCtTY_pcudEluDkugwohUVCMExYrOfQ,4441
 pyquickhelper/helpgen/pandoc_helper.py,sha256=x1bD-PrvX79_57HDmYVlFUjlRaJAid3tUUS_qoHkHK8,1932
@@ -61,29 +62,29 @@
 pyquickhelper/helpgen/rst_converters.py,sha256=6onaro61ajFLiqsZnZ9P4G4djhw2G28jAs0n2lvVSCQ,24659
 pyquickhelper/helpgen/rst_modified.tpl,sha256=-vaa6TcZjZlJMdm3a9gL2jQDrOwtL4MQSVKHAzNanY8,393
 pyquickhelper/helpgen/sphinx_helper.py,sha256=ZPwKK_hkD3_UMWF1xOLP_u-iU_-JHrbIfKz4LvxhepA,2761
 pyquickhelper/helpgen/sphinx_main.py,sha256=3xAku3RHmA2B2WJhZkGO7gBdf7xapzk9gRU6S8fQ1kg,61383
 pyquickhelper/helpgen/sphinx_main_helper.py,sha256=bFVtzIPgGM5ex5YxPyp0zKPW8putZngLA3EMa3Hn4iw,20014
 pyquickhelper/helpgen/sphinx_main_missing_html_files.py,sha256=ctXdjMNIi4s_8Gq86p5dRaXZj7onDx3_EgxV2FloX40,8722
 pyquickhelper/helpgen/sphinx_main_verification.py,sha256=Lieq08nm0c8xGPQI4jagYC5iPqD4sMEMU3J4nZySh_M,4291
-pyquickhelper/helpgen/sphinxm_convert_doc_sphinx_helper.py,sha256=CKwGayYG1Mla_zYNduZl-k-SStEueka9URTu0fTEmBc,63272
+pyquickhelper/helpgen/sphinxm_convert_doc_sphinx_helper.py,sha256=OL3VzrHnYvKIG7VYHTEO1m-_xcQv1frsWEi4M5FnDUo,64057
 pyquickhelper/helpgen/sphinxm_custom_app.py,sha256=z1E8NtJqaHeBgvzUydoz-2t-0W3lvy1KyHU3kYSTO4U,5848
 pyquickhelper/helpgen/sphinxm_mock_app.py,sha256=T7FFMQ48F4F1t355gzhkRtyfTNlg8_1-5z9_B2WOjCQ,17252
 pyquickhelper/helpgen/stat_helper.py,sha256=XLAmV_Wb9hbCPSm7lJyAgGUyhQEzk0nyM2umMQGaD_Y,3677
 pyquickhelper/helpgen/style_css_template.py,sha256=eaH_cBUeNn7HARIDqQtkPVxog7hJRy8eipX2w08ZlsE,2272
 pyquickhelper/helpgen/utils_pywin32.py,sha256=Lpn9cxCTDtonioBGB8LQMUONOh8AebglUJZQOuiZpNk,2247
 pyquickhelper/helpgen/utils_sphinx_config.py,sha256=Y4IH3MGPM5zM2Jj7MpZY6TooaNUdKE5_DO6NRvyOlBU,4895
 pyquickhelper/helpgen/utils_sphinx_doc.py,sha256=1iFkFCQuwhHEuIneLH8qxNYKzREsPpv9sF75_7cbkFQ,76539
 pyquickhelper/helpgen/utils_sphinx_doc_helpers.py,sha256=QBR76AaoEAcJCxrEOtpzZkPSboh6aqyYZxhatYKhf-A,37584
 pyquickhelper/imghelper/__init__.py,sha256=VDhAAxT_3oKa3lxsFKycHam0-OCB1bd_CR_cuHUTXtA,110
 pyquickhelper/imghelper/excs.py,sha256=-B9PvXuhzfo57WUMJmajnAUYpFGG_JFMPgT5j-NGxKI,166
-pyquickhelper/imghelper/img_export.py,sha256=gpeay4RAtzouKrYJEEpDcHgrKUYuaQb1g_5fXVPQjCU,1552
-pyquickhelper/imghelper/img_helper.py,sha256=35SzpFRIkI99BDaxyKvgJ3nNWsokUE-KRX8U7KoZMhc,2928
-pyquickhelper/imghelper/js_helper.py,sha256=HtVxUuJ7XMGtc_77xWJ7X7Drs2xNUpJOKMvwNCkaXkQ,7269
-pyquickhelper/imghelper/svg_helper.py,sha256=uCQJCT8XFcnwPrHerMfCGaIamkPTC4Nd5d8jlfBKx2s,2053
+pyquickhelper/imghelper/img_export.py,sha256=0msvXX--Yl32JQPgFBJHlEWWX1qoDOaNNZzjT_fdOys,1592
+pyquickhelper/imghelper/img_helper.py,sha256=-xD2l8jpZZhDDyTXMz1MjHWHsAZERuTsQZEbtvF1YxI,2968
+pyquickhelper/imghelper/js_helper.py,sha256=GFUPh1nsCGhuQoMlqOTH1Kf0y0tJecLEvLt7emgzZdA,7418
+pyquickhelper/imghelper/svg_helper.py,sha256=W86DBcG4d4ed5BXwEX1cHuQxQdTLFECdJn_ATbWQY6w,1976
 pyquickhelper/ipythonhelper/__init__.py,sha256=57hFDaiu9z6SWzdMVvet2GA8eEmsqSUwoMfPwZph0Aw,1199
 pyquickhelper/ipythonhelper/html_forms.py,sha256=V630vbXrcGkjI0GGP4ytc8A9hvaX2lQKoiMnJR6Ut1I,4773
 pyquickhelper/ipythonhelper/interact.py,sha256=TD3pEsWjf1A359QXsCME5SKTXerDxAjHGRGpXqA41GM,7467
 pyquickhelper/ipythonhelper/kindofcompletion.py,sha256=r-FJ8xSbFSpivFMggEUi2zBOk53BRpMj37f6Q7DG1Ic,4433
 pyquickhelper/ipythonhelper/magic_class.py,sha256=gJN1hyF8TJkBBNAzKlPWuTOmM2Tep7D76M4WBrO2dpg,3174
 pyquickhelper/ipythonhelper/magic_class_compress.py,sha256=pudp8y6eeCNbF_LfFFwRnlodqvhqXsExioa8V3ELz1w,2712
 pyquickhelper/ipythonhelper/magic_class_crypt.py,sha256=J2nWsOX7faQx3uEp5pGBZRoUOqh00roemAmAj4IHLPE,4575
@@ -104,15 +105,15 @@
 pyquickhelper/jenkinshelper/jenkins_server_template.py,sha256=Bgoed_Y0Bod7AOhsHjou5NOpKjKSgE1A3FXvvHwaIM0,4917
 pyquickhelper/jenkinshelper/yaml_helper.py,sha256=qbv_O1thOP5qgZ21uYVBeiQjPgN0czJY1PiZzR93apI,27865
 pyquickhelper/jenkinshelper/yaml_helper_yaml.py,sha256=sOcmhcicIhXMoS-1pxlk2gFZfPpC9ybpnoCDkTIuJFo,481
 pyquickhelper/loghelper/__init__.py,sha256=1dDyfObCg40BekNctaK4MQLLewSJHuEINUI_OAO8hek,806
 pyquickhelper/loghelper/buffered_flog.py,sha256=izfMteetGliEizcnBeOrV05od5PTh31ZfqfLIHoyPfo,883
 pyquickhelper/loghelper/convert_helper.py,sha256=fKD02IRYMdejVpJzAfo3dZUU0FHJWpheSnoOVsx6Hco,1737
 pyquickhelper/loghelper/custom_log.py,sha256=TL0CjgmooSp_MbXbc__JeKZSw8XknqX0-EXdCAhlZGQ,3833
-pyquickhelper/loghelper/flog.py,sha256=sVeoB-VbfQirnfVotZM0TWcU2o797Pl0PirRUn3tjt4,36641
+pyquickhelper/loghelper/flog.py,sha256=1yp0v9g3yJjUDEQTpR83nqwZ7N4SMa0mcLEybCwQen8,36842
 pyquickhelper/loghelper/flog_fake_classes.py,sha256=FZGhylGBrIcLi647ENfeCcoKnRdmt-__tmMWVxayUZ8,2294
 pyquickhelper/loghelper/github_api.py,sha256=xDtMcYCa3lS9p3Wmxo70dqtoF_VyyKOD4UYQYI5hebQ,1840
 pyquickhelper/loghelper/history_helper.py,sha256=qvc9Ibsdo-tmzTHQn6hLpzgoTfPV5NsSHG2XQ5d1F5g,10534
 pyquickhelper/loghelper/os_helper.py,sha256=Qr_1dZKUMvLWE_16ji7SrCJCdo2NigNJvppo4V2zoWc,1218
 pyquickhelper/loghelper/pqh_exception.py,sha256=jhVdqFVbvtw9lDowk27oBKvLfBMmRw7Cia9H8P1gyIs,707
 pyquickhelper/loghelper/process_helper.py,sha256=34aTLx2fwXlLr-SlOjVlL_wskwrLQjl0PmEEVtA6VlU,1555
 pyquickhelper/loghelper/process_script.py,sha256=D_RUttu7gby8QiVtiSysMzXCIAEoBDAPJYFsyMFEOqU,5498
@@ -124,18 +125,18 @@
 pyquickhelper/loghelper/url_helper.py,sha256=pBHKjJrVU5LLxs3catyC1h6TLBvHFG_N1oUHSs6wamU,1504
 pyquickhelper/loghelper/repositories/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pyquickhelper/loghelper/repositories/gitlab_helper.py,sha256=Az_fYb8Yq05Ot_Jra7o_O9FvGyH2xaC9b2Icge84CD0,3014
 pyquickhelper/loghelper/repositories/pygit_helper.py,sha256=evlj9YTv2QAafD-p1ak7QndUCAvBLBC5ZMIdnoNfVL8,31656
 pyquickhelper/loghelper/repositories/pysvn_helper.py,sha256=f2-wZCO-2Id6Cv0-nr052MyyXScAxzTxIEsx--neyVA,13085
 pyquickhelper/pandashelper/__init__.py,sha256=8rSHBLDgWeUl6sX7q4Sf28N_EQSDCHNODIxEwVTJA70,161
 pyquickhelper/pandashelper/readh.py,sha256=Xl6wVmnXFqpXdm9To_VbkyorPsrALIj7Gm1PZOMPRNo,2879
-pyquickhelper/pandashelper/tblformat.py,sha256=ga7l9qUpNSVeV_QQ7XokPDpkIbQojDIwAVuJHQBQFyw,14618
-pyquickhelper/pandashelper/tblfunction.py,sha256=QJoZN1yKAz8Ed28_7ZmN_bPEdmsdXyYpv9FtxODHmcs,982
+pyquickhelper/pandashelper/tblformat.py,sha256=onHBw89EI1M-BD38sOLLY8Pyx8WXIoHnm5P7A8xZjeQ,14759
+pyquickhelper/pandashelper/tblfunction.py,sha256=l8YsOhpHMM52mR6Pu2oHKQVK68etkj-HtRwsMMJChdk,983
 pyquickhelper/pycode/__init__.py,sha256=mmW6vuIXFLIaeppg_k1ulGblEdi65BnKVh7odU-kXHg,1309
-pyquickhelper/pycode/_pylint_common.py,sha256=QXpvPkUpGzgSbqX9oEYBgx046pFKhSyT9kcE1_Fdc78,6266
+pyquickhelper/pycode/_pylint_common.py,sha256=TNUchCovYC7uqCE1RQ76rE7NeJ4wqFQCVjfVcofJiv8,6341
 pyquickhelper/pycode/blog_helper.py,sha256=vf6j5XamsQXPEtKUX7K5o6i8G5P6qGxQFtG4gp0QAsU,2095
 pyquickhelper/pycode/build_helper.py,sha256=h5kgo89-IYneH0xrHVGycX_iGewxSxSYOmCgwLPQiqI,23989
 pyquickhelper/pycode/call_setup_hook.py,sha256=cjzjSPAFAQkYq0kMEIqJDRqWmCZs6qbBp4K8Y7FkiEc,6324
 pyquickhelper/pycode/ci_helper.py,sha256=UYXEYRI1TnV0AWjOaPyB4VHtFDIuEzLISSFm5jjnNVA,1163
 pyquickhelper/pycode/clean_helper.py,sha256=40Aw-2GvU5EEh83BKN5tnCZKmb-Ek4ocmgHytSFLAfs,3454
 pyquickhelper/pycode/code_exceptions.py,sha256=OpqN1jiHYQs6N-u6GBwKSSvFfe2M97uU1F8hZk63HEM,311
 pyquickhelper/pycode/code_helper.py,sha256=K_VcxscJLUmMJB06MAq0Jdwcxd24kqv2COgr8StUKmg,9335
@@ -144,58 +145,58 @@
 pyquickhelper/pycode/default_regular_expression.py,sha256=vIrpkNc1J-O8ZQE1YuCDt0A0aBYCwRhjiRtwihBaFjs,421
 pyquickhelper/pycode/insetup_helper.py,sha256=vgx1ZNWNzNJUa1Yd1kzPTAe9FR2Qo7MSF8_cvGUGGic,2459
 pyquickhelper/pycode/linux_scripts.py,sha256=DYKFNPNBBNEe9BF-p-uWjnLs9obJpXWYerqH2FuQ0HA,1154
 pyquickhelper/pycode/open_script_file.py,sha256=96E0Gd039Ok2RPgxIxzMlpuyC81yQHlxVzt6h8hfeBI,1044
 pyquickhelper/pycode/pip_helper.py,sha256=prE-vo4rbxDcAdU4Nkm0HOKTZfmFjRdaNlEFpp4GRVQ,2850
 pyquickhelper/pycode/profiling.py,sha256=egPxExO0WQhumRB-Lf6T_j9KLRaEBqsRs69AoxH0D4Y,6066
 pyquickhelper/pycode/py3to2.py,sha256=64yKfm_dje_WEbGJJaQV5YDJtxm3xbc_buPOPZSbWO8,10559
-pyquickhelper/pycode/pytest_helper.py,sha256=T0UguN1gRXrQuueCGztsvuKxFTf7xewd0IQxwNXHGqg,3385
+pyquickhelper/pycode/pytest_helper.py,sha256=WpidAJabKL0ZRrqkCc_DuHe4fZtvjCzsGR8PJOAsh1A,3841
 pyquickhelper/pycode/readme_helper.py,sha256=5l7ByIj9wpC8hkEyEnp9XokKsWQFQAVSrmc8FduApIc,1391
-pyquickhelper/pycode/setup_helper.py,sha256=YLqmj23G8-UzcL6h_hSVZUb1s4rPh17x2MAmRbY2JF0,55256
+pyquickhelper/pycode/setup_helper.py,sha256=29EFw-yn2xZZJJk20Ay3WMwh6vO-be41qxPMRX8iRks,55845
 pyquickhelper/pycode/tkinter_helper.py,sha256=ut653z4EB5XxhKRxwxRCNLIGuJMlrVQ66HKosc2MXCA,5565
 pyquickhelper/pycode/trace_execution.py,sha256=BD-L5-J3ud6095XjNGHmJ_hLo_qac1OKwl6FovArBD4,460
 pyquickhelper/pycode/unittestclass.py,sha256=aXvdR6Z3SoqUIZ7hm_VuFogJkxRMaK1Tx7Ytd1JFcbM,22964
 pyquickhelper/pycode/utils_tests.py,sha256=rXhmWbaI3I0YE-i1BtNRs6AlyFqRvuPUpRYml95uPnc,24505
 pyquickhelper/pycode/utils_tests_helper.py,sha256=En7szAnnLKrVs6dwHG6TE55hZ_oI1w1sC7MgByPWRJ4,20796
-pyquickhelper/pycode/utils_tests_private.py,sha256=aM8ybDF0fxoM-eklvdZS84STr9SbbHO5CRvJei5brsg,23090
+pyquickhelper/pycode/utils_tests_private.py,sha256=ea7Ectw91ItOaf8SCb0jd2Ya537SsTg_MD1BLbj3iHE,23442
 pyquickhelper/pycode/utils_tests_stringio.py,sha256=dsKs_-qbRX2lH3WZxwoBhx4wAuvI0U56n-33H6A2jvg,2386
 pyquickhelper/pycode/venv_helper.py,sha256=gazI70oNXbas3hhJMx6BiLjOL_LhX_B1_0etDAcQhAg,17981
 pyquickhelper/pycode/windows_scripts.py,sha256=wlhMRci6z16Y_iAH5JlqhP9tHFfe65fovyjoIQYQU0M,26868
 pyquickhelper/serverdoc/__init__.py,sha256=TI05-ozJUEp6xKkpZmbptFo4AxrXHiLjPkiVSEfqQ3s,147
-pyquickhelper/serverdoc/documentation_server.py,sha256=uipN1WzGDegmRJVXK_OVJYayHQijTasSQ3D2_DPmSNk,21812
+pyquickhelper/serverdoc/documentation_server.py,sha256=W8MdYdaE6MUOGHPaT8qbN-jJJJ54Az-X3SIYEN-3ubw,21996
 pyquickhelper/serverdoc/server_helper.py,sha256=GDasw2x1-Yli2QYkVNpKE14gY6pczUEulrpMbFGX8yw,1759
 pyquickhelper/sphinxext/__init__.py,sha256=YgFqCK9m8Y0gVirhs3YuPaBxDpsND7CZKTTzMtFyNXs,7977
 pyquickhelper/sphinxext/_private_for_unittest.py,sha256=E50igmWMMrmhDxklen6xDf_bDqhfZO40kuf0SK5x2Y0,139
-pyquickhelper/sphinxext/_sphinx_common_builder.py,sha256=E8K6n_yqnpb_K9CjWI1sXYUH_1zCIivNGRkjTueeEME,8935
+pyquickhelper/sphinxext/_sphinx_common_builder.py,sha256=E_JzHpZbjwG_bPvIlBXwDZlWGdS7_qJflT_S1ZnHhkk,9129
 pyquickhelper/sphinxext/blog_post.py,sha256=5FnG0ezb50u_92teWflvuC363Zxcq2WtIVFhg9zqAqY,11818
 pyquickhelper/sphinxext/blog_post_list.py,sha256=0ioqbpbTqwHFuTGVTnFMpjRBBBTkBuy6ZaqRfMMcRf0,26101
 pyquickhelper/sphinxext/build_rss.py,sha256=pYzaEXjIZcw9XlcqvDQhkc3ejEukg3Z-HtCZfVP51A4,3005
 pyquickhelper/sphinxext/documentation_link.py,sha256=d9vNXEtDUUwgkz0FSJ0HRweOMlUdQQSWnag3RVijQUI,975
 pyquickhelper/sphinxext/feed-icon-16x16.png,sha256=yTe0_S1BqmkdeYuRKxoQsGhQ0q_mg09BcK5YiWkwyFc,764
 pyquickhelper/sphinxext/import_object_helper.py,sha256=teCtmx4QW7blH-CX1MUTN4KbXFFa0Kuqd73wT6Lvodw,9633
-pyquickhelper/sphinxext/sphinx_autosignature.py,sha256=rleOdoLuJLeTfVRzSBR6kgepPxyB4IDAv2z8VSrXwYs,20132
+pyquickhelper/sphinxext/sphinx_autosignature.py,sha256=c0OJmKeW4Lu07tZbLKkYTw-t7P3y001Q_n1ris_Ls4I,20442
 pyquickhelper/sphinxext/sphinx_bigger_extension.py,sha256=MwGYe_eNQ4igN97GCLyPNpWGOIYPsbSKfmLELVsyh_4,3995
-pyquickhelper/sphinxext/sphinx_blocref_extension.py,sha256=j8hHuDeUZqh4gvxX0FT3dbgiT41OeqOEAfC66UiwSaI,20832
+pyquickhelper/sphinxext/sphinx_blocref_extension.py,sha256=A2TKuf8H4VDhy47XqSJ3Z6LLvkFsTvtDdwE9ULX47LE,20993
 pyquickhelper/sphinxext/sphinx_blog_extension.py,sha256=2SIne7ae60RzNXHkiwV4LZNe5Vio8sqB_1cRCNIvtcw,17333
-pyquickhelper/sphinxext/sphinx_cmdref_extension.py,sha256=J8-Jog5WqmedufvK_l6In62bQc6-yx-x5dBYRwE2oD0,12460
+pyquickhelper/sphinxext/sphinx_cmdref_extension.py,sha256=CQan5lg6zPSG11rt_pkeNIONWaeDnx9i67lp4MsAKSo,12500
 pyquickhelper/sphinxext/sphinx_collapse_extension.py,sha256=8KuGK5cjC_72KeZPDSJk_pAQ6wZ5vjNi1Mw3iCsLBjc,5384
-pyquickhelper/sphinxext/sphinx_docassert_extension.py,sha256=AFFa1V2diUjwomoagEkLnK5GcY_q1fWuEVN9s_Citoc,11499
-pyquickhelper/sphinxext/sphinx_doctree_builder.py,sha256=s7c1NJj9XZ-9IAyRshta-HE5MO9GJR0fB0W6T88cSv4,9751
+pyquickhelper/sphinxext/sphinx_docassert_extension.py,sha256=gxJfxJK8RiB9LhbMAWH1q3RSb2G6_IPl_vwlrc1VzFc,12150
+pyquickhelper/sphinxext/sphinx_doctree_builder.py,sha256=wOCg_pAZiM3EKZsKqymL9zKywU3pQVvpHcI6io19B08,9771
 pyquickhelper/sphinxext/sphinx_downloadlink_extension.py,sha256=2cH8-qNpiIODUhOZdfi8NL4uZpa5m_xjWpjQK4gXfeA,11139
-pyquickhelper/sphinxext/sphinx_epkg_extension.py,sha256=qTEOwuBmrQMJgHl8m6AOZo0yoSQZ4TzlKtoUHZFN-cI,7928
+pyquickhelper/sphinxext/sphinx_epkg_extension.py,sha256=tEhjRmlgsBHA3xtYW4501YUQiCPDmMJzA6PGkV3YrfI,8025
 pyquickhelper/sphinxext/sphinx_exref_extension.py,sha256=rfRdY3euFxcRbyTjKweqGa9f7nsC6LvbfbDhjqiWf3M,6426
 pyquickhelper/sphinxext/sphinx_ext_helper.py,sha256=TGts9lG6MyqYl04f6akRfql2UiIWYagCT34eC6j41QE,3653
 pyquickhelper/sphinxext/sphinx_faqref_extension.py,sha256=KDnKrvi8aD_JgHG7BCaS1MQ_VgYBfq8l28l8LDt7dZI,6428
 pyquickhelper/sphinxext/sphinx_gdot_extension.py,sha256=jYCsXYmrGhpuf4_j2mhtlFk9JrMuPqpFS_8UHoCKego,10390
 pyquickhelper/sphinxext/sphinx_githublink_extension.py,sha256=jTU-seGTBmGp17InZGoYpfnOp_4ZQTVnaZ5vc6x3ToE,7943
 pyquickhelper/sphinxext/sphinx_gitlog_extension.py,sha256=dd6mNn8QWJZdrk0FNt5PwOpRwaHT-0Nt861Y6oD_Vpw,4370
 pyquickhelper/sphinxext/sphinx_image_extension.py,sha256=gLuDb-jgSzkjV5QxVK3klT5pwthb2biuacDM5EE3kQw,13437
 pyquickhelper/sphinxext/sphinx_latex_builder.py,sha256=DBgPBue90KBcwX7z9lYS_SsW0Oa7GAe0vKbI5BTxMzc,10578
 pyquickhelper/sphinxext/sphinx_mathdef_extension.py,sha256=pRNNCZMSP_cv2NInuJFmN7DzlfXPCgLm9ADUUywc7p0,17121
-pyquickhelper/sphinxext/sphinx_md_builder.py,sha256=59ePVkMm5z-GAFj2HZj105rwfnpiTnPgr8084uCoIiM,34253
+pyquickhelper/sphinxext/sphinx_md_builder.py,sha256=Z-Pi5ul6rV_b9f3ZpXo3a_k9H2i0YwPxH4UGuj_WgAA,34327
 pyquickhelper/sphinxext/sphinx_nbref_extension.py,sha256=TCIOc--9cFwz8xJJxxpX_urtIKre9fV_bowI9ohKj3E,6266
 pyquickhelper/sphinxext/sphinx_postcontents_extension.py,sha256=vYDulWanBAx1_Bo_FIv1encOkQ4xFwxSyG8SyCLZhCM,8552
 pyquickhelper/sphinxext/sphinx_quote_extension.py,sha256=4z5YUC2InVlCgTgtT7dMsc3CjwR0N2Xi8_VxJ074NMA,6694
 pyquickhelper/sphinxext/sphinx_rst_builder.py,sha256=MNM_IyGt_a302LBML7BZ4zAbPhcB7YOmKCMgZLKTxe8,39270
 pyquickhelper/sphinxext/sphinx_runpython_extension.py,sha256=cB2t0szsN8cpDu0O95F4mp_l8OgpE8EZ-XyDT3o9t3c,31317
 pyquickhelper/sphinxext/sphinx_sharenet_extension.py,sha256=0xdPrvEj66zAzGx_r2fCeIhLRDHvtVbRp9PPE7NhQhM,9545
 pyquickhelper/sphinxext/sphinx_template_extension.py,sha256=Nn0UdgJuPxhkQWXamUS9TbKxbPoIBo8DkbbpBAI7OlI,5166
@@ -313,16 +314,16 @@
 pyquickhelper/sphinxext/sphinximages/sphinxtrib/missing.png,sha256=NAzhNFgWAixKVaf2HTJUdW57KG3OaQmzv1GBoS13JbY,4096
 pyquickhelper/sphinxext/templates/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pyquickhelper/sphinxext/templates/tabular.tex_t.txt,sha256=3UcIVaNjiNchg2Q2IRKW-Ojpt40uuS3HD6fEYFP_bQE,644
 pyquickhelper/texthelper/__init__.py,sha256=URaAAIYWE6lGfK3OokikJ_bFycyEglKluk7uVES9eC8,265
 pyquickhelper/texthelper/code_helper.py,sha256=6QepT6zz8n5gupxXc0IhsGJjcMtQTZ_TlO_NBCocTeE,1923
 pyquickhelper/texthelper/diacritic_helper.py,sha256=VMPEa3amIbdwrNNQaabEYdaAzp1KOEpsERVKD003OOw,488
 pyquickhelper/texthelper/html_helper.py,sha256=kxGhsaLlFMrtjSB4BTXxvNJudlR06z-6QNMJD0gmwKM,568
-pyquickhelper/texthelper/templating.py,sha256=Qd14p503U1UszL7lULjJ5jACnMOMsZFs8ol1zMAs31M,2355
+pyquickhelper/texthelper/templating.py,sha256=cNrCK1hGTcDO2K-BYHDIe3_52x0HxSJ108CyyjFSlSA,2375
 pyquickhelper/texthelper/texts_language.py,sha256=NQHywFeJtM39rc9H2G8D3TYfbDVSS6Rb3a1a1EperZc,3323
 pyquickhelper/texthelper/version_helper.py,sha256=0szxUS_eImc4VOGDqIQ0fwpsCSdtzTfKfSVbkguwmw0,1916
-pyquickhelper-1.9.3396.dist-info/LICENSE.txt,sha256=ebX2AZDkAVbuoSyYNYhZfLedTrnPksAMCtVaQrBLb18,1083
-pyquickhelper-1.9.3396.dist-info/METADATA,sha256=EG9AuK7BoX_sluG0YT48uylp7nzZIs1-U3-C0tEYQ8Q,24062
-pyquickhelper-1.9.3396.dist-info/WHEEL,sha256=qB97nP5e4MrOsXW5bIU5cUn_KSVr10EV0l-GCHG9qNs,97
-pyquickhelper-1.9.3396.dist-info/entry_points.txt,sha256=5Pfd5cFMWrGBXnRG-1IDZV2kszTPoZI-rb1VOp2AP2U,304
-pyquickhelper-1.9.3396.dist-info/top_level.txt,sha256=N1OrpC1l0DxPwJs6tAdFLNhqA0HQmT9Kud_5U2_YKTo,14
-pyquickhelper-1.9.3396.dist-info/RECORD,,
+pyquickhelper-1.9.3418.dist-info/LICENSE.txt,sha256=ebX2AZDkAVbuoSyYNYhZfLedTrnPksAMCtVaQrBLb18,1083
+pyquickhelper-1.9.3418.dist-info/METADATA,sha256=A38hEXqFb-qlSANY0LI4mGt822Rg3JH3YMy7-lwhHx8,24527
+pyquickhelper-1.9.3418.dist-info/WHEEL,sha256=qB97nP5e4MrOsXW5bIU5cUn_KSVr10EV0l-GCHG9qNs,97
+pyquickhelper-1.9.3418.dist-info/entry_points.txt,sha256=5Pfd5cFMWrGBXnRG-1IDZV2kszTPoZI-rb1VOp2AP2U,304
+pyquickhelper-1.9.3418.dist-info/top_level.txt,sha256=N1OrpC1l0DxPwJs6tAdFLNhqA0HQmT9Kud_5U2_YKTo,14
+pyquickhelper-1.9.3418.dist-info/RECORD,,
```

